<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>U</title>
    <url>/16406/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>增加Docker-CE安装源并安装20.10.17版本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
add-apt-repository <span class="token parameter variable">-y</span> <span class="token string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="token variable"><span class="token variable">$(</span>lsb_release <span class="token parameter variable">-cs</span><span class="token variable">)</span></span> stable"</span>
<span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce<span class="token operator">=</span><span class="token number">5</span>:20.10.17~3-0~ubuntu-jammy docker-ce-cli<span class="token operator">=</span><span class="token number">5</span>:20.10.17~3-0~ubuntu-jammy containerd.io <span class="token function">docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>新建docker配置文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/docker/ <span class="token punctuation">;</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
&#123;
  "exec-opts": [
      "native.cgroupdriver=systemd"
      ],
  "log-driver": "json-file",
  "log-opts": &#123;
    "max-size": "10m",
    "max-file": "3"
  &#125;,
  "registry-mirrors": [
      "http://192.168.2.253:10007",
      "http://f1361db2.m.daocloud.io",
      "https://m9f30s9x.mirror.aliyuncs.com"
      ],
  "insecure-registries": [
      "192.168.2.253:10007",
      "192.168.2.253:10008"
      ]
&#125;
EOF</span>
systemctl daemon-reload
systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> <span class="token function">docker</span>
<span class="token function">docker-compose</span> <span class="token parameter variable">-v</span>
<span class="token function">docker</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>local</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img data-src="../../images/2b2eef0cdf47e13e.jpg"></p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites-Generate-static-files-Generate-static-files"><a href="#Deploy-to-remote-sites-Generate-static-files-Generate-static-files" class="headerlink" title="Deploy to remote sites Generate static files Generate static files"></a>Deploy to remote sites Generate static files Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>local</category>
      </categories>
  </entry>
  <entry>
    <title>NFS</title>
    <url>/19048/</url>
    <content><![CDATA[<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><p>线上服务器无需要手动安装系统,只需要配置好硬盘分区,选择镜像CentOS 7.9.2009.,一分钟即可完成安装.</p>
<h2 id="更换系统"><a href="#更换系统" class="headerlink" title="更换系统"></a>更换系统</h2><p>更换系统或重装系统步骤如下:</p>
<ul>
<li>在实例详情页面选择停止,来停止实例.</li>
<li>在实例详情页面点击更换操作系统,</li>
<li>在更换操作系统页面,镜像类别选择CentOS,版本为7.9 64位.选择自定义root密码,输入登录密码.</li>
<li>勾选同一服务协议,点击确认订单,等待安装完成.</li>
</ul>
<h2 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h2><p>安装完毕的系统,无法通过ssh直接连接.需要修改ssh端口和用于跳板机登录的账号.</p>
<p>点击远程连接,选择发送命令,在下面命令内容中执行脚本添加用户nanruan并设置密码,密码是&#x2F;etc&#x2F;shadow中哈希值:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">useradd</span> <span class="token parameter variable">-p</span> <span class="token punctuation">\</span><span class="token variable">$6</span><span class="token punctuation">\</span><span class="token variable">$YVLnCcQL</span><span class="token punctuation">\</span><span class="token variable">$NlbdFMzHHzw9Byk2EFjl4BNCm0riq22HnJKTVcccZv</span>/FQ/Y2HgvSeavPCUbdgzTmA3T3ksn7SYkq96An12oBW0 nanruan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>修改默认端口由22改为2222,重启sshd服务便可以通过堡垒机来访问登录了:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/#Port 22/Port 2222/g"</span> /etc/ssh/sshd_config
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/PasswordAuthentication no/PasswordAuthentication yes/g"</span> /etc/ssh/sshd_config
systemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过脚本的方式修改密码:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token string">"qv4YB7#x9WhPj?i4E1DRgu1dlOWR"</span> <span class="token operator">|</span> <span class="token function">passwd</span> root <span class="token parameter variable">--stdin</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="安全组配置"><a href="#安全组配置" class="headerlink" title="安全组配置"></a>安全组配置</h2><p>登录阿里云控制台,在云服务器ECS的安全组中,将服务器加入到安全组线上服务器k8s(安全组ID:sg-uf64fg98yuqdtdjfjt5z).</p>
<p>再从其他安全组中剔除服务器.</p>
<h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><p>需要对系统做一些初始化配置工作.</p>
<h2 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h2><p>安装5.4版本内核:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># yum --disablerepo="*" --enablerepo="elrepo-kernel" list available</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y kernel-lt-5.4.236-1.el7.elrepo --enablerepo=elrepo-kernel</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>设置内核启动顺序并重新生成引导文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># grub2-set-default 0</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="内核调整"><a href="#内核调整" class="headerlink" title="内核调整"></a>内核调整</h2><p>需要修改内核参数,否则安装运行K8s会失败:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># ulimit -SHn 65536</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># modprobe br_netfilter</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_nonlocal_bind = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_local_port_range = 1024 65535" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "net.bridge.bridge-nf-call-ip6tables = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "net.bridge.bridge-nf-call-iptables = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "10000 65535" > /proc/sys/net/ipv4/ip_local_port_range</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "* soft nofile 655350" >> /etc/security/limits.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "* hard nofile 655350" >> /etc/security/limits.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "vm.max_map_count = 524288" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "fs.file-max = 6553560" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># echo "fs.inotify.max_user_instances=8192" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># sysctl --system</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="登录限制"><a href="#登录限制" class="headerlink" title="登录限制"></a>登录限制</h2><p>服务器ssh连接方式为,先直连nanruan@k8s-m1-pro节点,然后再跳转连接到其他服务器.</p>
<h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p>主节点k8s-m1-pro连接端口是2222,修改sshd配置,禁止root用户登录.只能通过nanruan用户登录:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/PermitRootLogin yes/PermitRootLogin no/g" /etc/ssh/sshd_config</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>安装Fail2ban来阻止恶意登录:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># yum install fail2ban</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>修改配置启用通过iptables防护非法sshd登录.规则为在300秒内输错5次密码,IP被禁止连接2222端口1个小时:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/fail2ban/jail.conf</span>
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>sshd<span class="token punctuation">]</span>

<span class="token comment"># To use more aggressive sshd modes set filter parameter "mode" in jail.local:</span>
<span class="token comment"># normal (default), ddos, extra or aggressive (combines all).</span>
<span class="token comment"># See "tests/files/logs/sshd" or "filter.d/sshd.conf" for usage example and details.</span>
<span class="token comment">#mode   = normal</span>
enabled <span class="token operator">=</span> <span class="token boolean">true</span>
filter <span class="token operator">=</span> sshd
port    <span class="token operator">=</span> <span class="token number">2222</span>
action <span class="token operator">=</span> iptables<span class="token punctuation">[</span>name<span class="token operator">=</span>SSH, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">2222</span>, <span class="token assign-left variable">protocol</span><span class="token operator">=</span>tcp<span class="token punctuation">]</span>
logpath <span class="token operator">=</span> %<span class="token punctuation">(</span>sshd_log<span class="token punctuation">)</span>s
backend <span class="token operator">=</span> %<span class="token punctuation">(</span>sshd_backend<span class="token punctuation">)</span>s
bantime <span class="token operator">=</span> <span class="token number">3600</span>
findtime <span class="token operator">=</span> <span class="token number">300</span>
maxretry <span class="token operator">=</span> <span class="token number">5</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>启动服务:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now fail2ban</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果需要限制Nginx访问可以参考: <a href="https://zhuanlan.zhihu.com/p/71911717/">https://zhuanlan.zhihu.com/p/71911717/</a></p>
<h3 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h3><p>除了k8s-m1-pro节点外,修改系统&#x2F;etc&#x2F;hosts.deny和&#x2F;etc&#x2F;hosts.allow文件,只允许通过内网ssh连接,其他拒绝地址:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "sshd:ALL:deny" >> /etc/hosts.deny</span>
<span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "sshd:172.16.0.0/255.255.0.0:allow" >> /etc/hosts.allow</span>
<span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="查询异常登录"><a href="#查询异常登录" class="headerlink" title="查询异常登录"></a>查询异常登录</h3><p>&#x2F;var&#x2F;log&#x2F;secure文件记录有异常登录信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># tail -n 30 /var/log/secure</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在主节点上可以通过fail2ban-client命令查看被ban列表:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client status</span>
<span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client status sshd</span>
<span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>解除被ban的IP地址:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client set sshd unbanip 47.101.138.100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><p>一些系统设置.</p>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>修改主机名,并加入到hosts域名解析:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># hostnamectl set-hostname k8s-m1-pro</span>
<span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "127.0.0.1   $(hostname)" >> /etc/hosts</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="限制日志大小"><a href="#限制日志大小" class="headerlink" title="限制日志大小"></a>限制日志大小</h3><p>限制系统journal日志保留时常为1周:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># journalctl --vacuum-time=1w</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>安装基本工具:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># yum install -y git wget net-tools bind-utils vim bash-completion nfs-utils jq nc telnet lvm2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><p>修改&#x2F;etc&#x2F;profile文件,添加一些常用变量:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "export HISTTIMEFORMAT='`whoami` : %F %T :'" >> /etc/profile</span>
<span class="token punctuation">[</span>root@k8s-m2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "export NFS_SERVER_NANRUAN=172.16.17.100" >> /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>在主节点上设置免密登录目标服务器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># ssh-keygen</span>
<span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># ssh-copy-id -p 2222 root@172.16.17.97</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>最后重启目标服务器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-w3-pro ~<span class="token punctuation">]</span><span class="token comment"># reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>重启后检查主机名和内核版本.</p>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p>对k8s-m1-pro,k8s-m2-pro和k8s-m3-pro节点上储存专用云盘进行初始化.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用fdisk来操作:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># fdisk /dev/vdb</span>
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: p
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-4, default <span class="token number">1</span><span class="token punctuation">)</span>: 
First sector <span class="token punctuation">(</span><span class="token number">2048</span>-1953525167, default <span class="token number">2048</span><span class="token punctuation">)</span>: 
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">2048</span>-1953525167, default <span class="token number">1953525167</span><span class="token punctuation">)</span>: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改分区system ID为lvm并退出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: t
Selected partition <span class="token number">1</span>
Hex code <span class="token punctuation">(</span>type L to list all codes<span class="token punctuation">)</span>: 8e
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># partprobe</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="创建卷"><a href="#创建卷" class="headerlink" title="创建卷"></a>创建卷</h2><p>依次创建PV,VG和LV:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># export DIR=ssd</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># pvcreate /dev/vdb1</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># vgcreate $&#123;DIR&#125; /dev/vdb1</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># lvcreate -l +100%FREE -n $&#123;DIR&#125; $&#123;DIR&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>格式化成xfs并挂载到指定目录下面:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># mkfs.xfs /dev/$&#123;DIR&#125;/$&#123;DIR&#125;</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /$&#123;DIR&#125;; mount /dev/$&#123;DIR&#125;/$&#123;DIR&#125; /$&#123;DIR&#125;/</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># echo "/dev/mapper/$&#123;DIR&#125;-$&#123;DIR&#125; /$&#123;DIR&#125; xfs defaults 0 0" >> /etc/fstab</span>
<span class="token punctuation">[</span>root@pro-k8s-storage1 ~<span class="token punctuation">]</span><span class="token comment"># df -hT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>local</category>
      </categories>
  </entry>
  <entry>
    <title>基础概念</title>
    <url>/19629/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>虚拟化技术是计算机资源的一种管理技术,它掌控着计算机硬件资源,并将其抽象化,通过统一形式展现给应用程序.对用户来说,虚拟化只是定义了为程序隐藏真实环境的方式,真正实现虚拟化还需要具体的执行虚拟化过程的程序.</p>
<p>虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化.</p>
<ul>
<li><p>硬件虚拟化需要搭配专门的硬件平台,与普通硬件设备存在兼容问题.但有个好处是对硬件利用率高.</p>
</li>
<li><p>软件虚拟化通常在应用程序和硬件资源搭建一个Hypervisor层,应用程序在虚拟化环境中对资源的调用,是通过Hypervisor层提供的调用接口来操作.JAVA虚拟机(JVM, Java Virtual Machine)就是通过此方式实现跨平台运行.</p>
</li>
</ul>
<p>软件虚拟化从对象所在的层次,又分应用虚拟化(例如手机模拟器,Wine等)和平台虚拟化.比较常见的平台虚拟化分为以下几类:</p>
<ul>
<li><p>完全虚拟化</p>
<p>虚拟机模拟完整的底层硬件环境和特权指令的执行过程.例如VMware Workstation, VirtualBox, QEMU等</p>
</li>
<li><p>硬件辅助虚拟化</p>
<p>利用CPU辅助支持(例如Intel-VT,AMD-V)处理敏感指令来实现完全虚拟化的功能,例如VMware, Xen, KVM等.</p>
</li>
<li><p>部分虚拟化</p>
<p>只针对部分硬件资源进行虚拟化,客户操作系统需要进行修改.</p>
</li>
<li><p>超虚拟化(Paravirtualization)</p>
<p>部分硬件接口以软件的形式提供给客户机操作系统,例如早期的Xen.</p>
</li>
<li><p>操作系统级虚拟化</p>
<p>内核通过创建多个虚拟的操作系统实例来隔离不同的进程,例如容器相关技术.</p>
</li>
</ul>
<p>传统在硬件层实现的虚拟化,需要有额外的虚拟机管理应用和虚拟机操作系统层.Docker容器是在操作系统层面上实现虚拟化,直接复用本地主机的操作系统,因此叫做轻量级.</p>
<h2 id="云服务类型"><a href="#云服务类型" class="headerlink" title="云服务类型"></a>云服务类型</h2><p>提供云服务的公司总体可以归为以下几大类的一种或多种:</p>
<ul>
<li><p>IaaS</p>
<p>基础设施即服务(IaaS, Infrastructure as a service)指在云端为用户提供基础设施,如虚拟机,服务器,储存,负载均衡和网络等,代表有AWS和阿里云.</p>
</li>
<li><p>PaaS</p>
<p>平台即服务(PaaS, Platform as a service)指在云端为用户提供可执行环境,数据库,网站服务器和开发工具等,代表有OpenShift, Google App Engine, dotCloud等.</p>
</li>
<li><p>SaaS</p>
<p>软件即服务(SaaS, Software as a service)指在云端为用户提供软件,如CRM系统,邮件系统,在线办公等.代表有微软Office 365, 有道, Tower等.</p>
</li>
<li><p>CaaS</p>
<p>容器即服务(CaaS, Container as a service)是虚拟云主机的升级版,用容器替代虚拟机的服务模式.</p>
</li>
</ul>
<p>IaaS, Paas和SaaS是云计算最基本的三种服务模式,客户通过云客户端来访问上面的服务.</p>
<h2 id="Docker运行基础"><a href="#Docker运行基础" class="headerlink" title="Docker运行基础"></a>Docker运行基础</h2><p>Docker主要使用的技术有Libcontainer, Namespaces, CGroups和AUFS.</p>
<h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>内核命名空间(Namespaces)是Linux下资源隔离机制.它将进程,进程组,IPC,网络,内存等资源从内核层面分属于某个特定Namespace,不同Namespace之间资源互相透明不可见.</p>
<p>Docker使用以下6种类型的Namespace:</p>
<ul>
<li>PID Namespace: 用于进程隔离,让容器管理独立的一套PID.在宿主机可以看到容器中的进程.</li>
<li>NET Namespace: 用于虚拟网络环境,让容器拥有自己的独立网络协议栈的视图,包括网卡,IP,路由,防火墙规则和sockets等.</li>
<li>IPC Namespace: 用于隔离进程间的通信资源,让容器拥有自己的共享内存和semaphore.</li>
<li>MNT Namespace: 用于管理挂载点,让容器看上去拥有整个文件系统,类似chroot.</li>
<li>UTS Namespace: 用于隔离主机名和域名,让容器拥有独自的主机名.</li>
<li>USER Namespace: 用于隔离用户和组,让容器拥有独立于宿主机的用户和组.</li>
</ul>
<p>被隔离在Namespaces中的程序虽然无法感知命名空间以外的程序存在,但仍可以直接访问宿主机系统内核的功能和部分内核文件,只是在程序看来自己是独占系统的.</p>
<h3 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h3><p>控件群组(CGroups, Control Groups)可以限制,记录,调整进程组所使用的物理资源.例如给某进程多分配一些CPU资源或限制使用的内存上限.它能确保各个容器可以公平地分享主机物理资源,当容器内地资源使用产生压力时,不会连累到宿主机.</p>
<p>控制组提供以下功能:</p>
<ul>
<li>Resource Limiting(资源限制): 可将组设置一定的内存使用上限,超过会出现OOM.</li>
<li>Prioritization(优先级): 调配组优先级来分配CPU资源.</li>
<li>Accounting(资源审计): 统计系统资源使用情况.</li>
<li>Isolation(隔离): 为组隔离命名空间.</li>
<li>Control(控制): 执行挂起,恢复和重启等操作.</li>
</ul>
<p>cgoup对Docker组相关配置保存在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;中,下面有很多诸如cpu, memory, blkio等子目录,也叫子系统.这些都是可以被Cgroups限制的资源种类:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># ls /sys/fs/cgroup/</span>
blkio/            cpu,cpuacct/      freezer/          net_cls/          perf_event/       
cpu/              cpuset/           hugetlb/          net_cls,net_prio/ pids/             
cpuacct/          devices/          memory/           net_prio/         systemd/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>而子系统对应的资源种类下,可以看到这类资源具体可以被限制的方法:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># ls /sys/fs/cgroup/cpu/</span>
cgroup.clone_children  cpuacct.usage          cpu.rt_runtime_us      system.slice/
cgroup.event_control   cpuacct.usage_percpu   cpu.shares             tasks
cgroup.procs           cpu.cfs_period_us      cpu.stat               user.slice/
cgroup.sane_behavior   cpu.cfs_quota_us       notify_on_release      
cpuacct.stat           cpu.rt_period_us       release_agent  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在cpu子系统下面创建一个目录来测试:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /sys/fs/cgroup/cpu/mytest</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># ls /sys/fs/cgroup/cpu/mytest</span>
cgroup.clone_children  cpuacct.stat          cpu.cfs_period_us  cpu.rt_runtime_us  notify_on_release
cgroup.event_control   cpuacct.usage         cpu.cfs_quota_us   cpu.shares         tasks
cgroup.procs           cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到目录中自动生成了资源限制文件,这个目录也被称为一个控制组.</p>
<p>接着在后台执行一个会占满CPU的脚本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># while : ; do : ; done &amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">4195</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># top</span>
   PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND             
  <span class="token number">4195</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">116208</span>   <span class="token number">1260</span>    <span class="token number">152</span> R  <span class="token number">92.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:31.78 <span class="token function">bash</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时系统已经满负载,因为默认CPU quota没有任何限制,CPU period则是默认的100ms.它们组合起用来限制进程能被分配到的CPU时间:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/mytest/cpu.cfs_quota_us </span>
<span class="token parameter variable">-1</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/mytest/cpu.cfs_period_us </span>
<span class="token number">100000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>手动将cpu.cfs_quota_us中的参数改为20000(20ms),其代表在每100ms时间里,被该控制组限制的进程只能使用20ms的CPU时间,也就是20%的CPU使用率:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># echo 20000 > /sys/fs/cgroup/cpu/mytest/cpu.cfs_quota_us </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面把被限制的进程PID写入tasks文件来生效:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># echo 4195 > /sys/fs/cgroup/cpu/mytest/tasks</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># top</span>
   PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND             
  <span class="token number">4195</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">116208</span>   <span class="token number">1260</span>    <span class="token number">152</span> R  <span class="token number">20.0</span>  <span class="token number">0.0</span>   <span class="token number">9</span>:06.83 <span class="token function">bash</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时用top再次查看,进程的CPU使用率如预期般被限制住了.</p>
<p>简单而言Cgroups就是一个子系统目录加上一组资源限制文件的组合,Docker在每个子系统下为每个容器创建一个控制组(创建新目录),然后启动容器进程后,把进程PID填写到对应控制组的tasks文件中:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># ps aux | grep ubuntu</span>
root       <span class="token number">4297</span>  <span class="token number">0.0</span>  <span class="token number">0.5</span> <span class="token number">1359472</span> <span class="token number">46268</span> pts/1   Sl+  <span class="token number">14</span>:41   <span class="token number">0</span>:00 <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --cpu-period<span class="token operator">=</span><span class="token number">100000</span> --cpu-quota<span class="token operator">=</span><span class="token number">20000</span> ubuntu /bin/bash
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/cpu.cfs_period_us </span>
<span class="token number">100000</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/cpu.cfs_quota_us </span>
<span class="token number">20000</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/tasks </span>
<span class="token number">4379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h3><p>Linux容器(LXC, Linux Containers)就是基于Linux内核通过调用CGroups和Namespaces来实现容器轻量级虚拟化的技术.同时,LXC也是一组面向Linux内核容器的用户态API接口.用户通过LXC提供的功能可以创建一套完整且互相隔离的虚拟应用运行环境.</p>
<p>在LXC的实现中,运行在容器中的程序访问的是真实物理机系统,与通过虚拟机实现的虚拟化比,消除了Hypervisor层,大大提高了运行效率.</p>
<h3 id="Libcontainer"><a href="#Libcontainer" class="headerlink" title="Libcontainer"></a>Libcontainer</h3><p>Docker采用libcontainer作为默认容器,取代了之前的LXC.libcontainer的隔离性主要是内核的命名空间来实现的,具体有pid,net,ipc,mnt和uts等命名空间,它们将容器的进程,网络,消息,文件系统和主机名进行隔离.</p>
<h3 id="UFS"><a href="#UFS" class="headerlink" title="UFS"></a>UFS</h3><p>UnionFS(Union File System)是一个堆栈式的联合文件系统,是能把多个目录挂载成同一个目录的文件系统.</p>
<h2 id="Docker应用范围"><a href="#Docker应用范围" class="headerlink" title="Docker应用范围"></a>Docker应用范围</h2><p>Docker是基于Go语言实现的容器项目,由dotCloud于2013年正式开源,2015年开始大规模应用.</p>
<h3 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h3><p>现在Docker主要应用于云平台.在Docker出现以前各云平台互不兼容,Docker屏蔽了硬件层的差异,提供了统一的用户应用层,企业产品因此可以在各种云平台之前自由迁移.</p>
<h3 id="Devops"><a href="#Devops" class="headerlink" title="Devops"></a>Devops</h3><p>Docker另外一个应用领域是Devops,只要使用相同的数据镜像,就不用考虑环境问题,减少了代码运行差异,使得开发团队可以集中于产品开发,无需注重流程.</p>
<p>Docker的标准化规范,弥补了开发,业务和运维三方的需求差异,可以无缝地将产品在开发,测试和生产环境之间自由移动.</p>
<h2 id="Docker优缺点"><a href="#Docker优缺点" class="headerlink" title="Docker优缺点"></a>Docker优缺点</h2><p>总的来看Docker的缺点暂不构成问题,可以放心使用.</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用Docker的优点有:</p>
<ul>
<li><p><strong>高资源利用率</strong></p>
<p>传统虚拟机硬件资源独立不共享,Docker中所有容器共享同一个系统内核和硬件资源,对资源的利用率比虚拟机高得多.Docker容器中CPU的损耗为0%,磁盘IO的损耗小于5%,网络在使用桥接模式时损耗为15%.</p>
</li>
<li><p><strong>支持跨节点部署</strong></p>
<p>通过Docker定义的标准镜像数据格式,可以在不同操作系统和物理硬件环境中使用.</p>
</li>
<li><p><strong>版本可控,组件可复用</strong></p>
<p>Docker借助AUFS文件系统的特性,使得镜像与镜像之间可以互相借用组合,产生不同的镜像.并借助标签功能对镜像标注,为镜像提供版本控制功能.</p>
</li>
<li><p><strong>共享镜像</strong></p>
<p>Docker作为开源软件,构建出的镜像可以自由分发流传(主要通过Docker hub).</p>
</li>
<li><p><strong>轻量级,易维护</strong></p>
<p>Docker在Linux系统中表现为一个普通的进程,因此管理非常容易.</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Docker的缺点有:</p>
<ul>
<li><p><strong>宿主资源没有完全做到隔离</strong></p>
<p>虽然容器使用的系统资源互相隔离,但还有一些内核资源未被隔离开来.例如&#x2F;proc, &#x2F;sys这些目录和SELinux, syslog这些内核功能.因此容器和宿主机共用内核版本,容器内不能升级内核,对内核版本有要求的应用可能不兼容Docker.</p>
</li>
<li><p><strong>GO语言尚不成熟</strong></p>
<p>由于Docker全部采用Golang来编写,而Golang还比较年轻,难保不发生大的变动.这将对Docker产生连带影响.</p>
</li>
<li><p><strong>控制权问题</strong></p>
<p>虽然Docker现在开源,但事实上被一家公司所控制,而不像其他大的开源项目有公共基金会管理.因此后续可能变为收费闭源项目.</p>
</li>
</ul>
<h2 id="Docker构架"><a href="#Docker构架" class="headerlink" title="Docker构架"></a>Docker构架</h2><p>Docker是一个客户端&#x2F;服务器(C&#x2F;S)构架的程序.客户端只需要通过Socket向服务器或守护进程(Docker引擎)发送请求,服务器或守护进程将完成所有工作并返回结果.</p>
<p>Docker提供了一个命令行工具docker以及一套RESTful API来与守护进程交互.用户可以在一台主机上运行Docker守护进程和客户端,也可以从本地Docker客户端连接到运行在另一台主机上的远程Docker守护进程.</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>Docker服务端一般在宿主机后台运行,dockerd作为服务端接收来自客户端的请求,并通过containerd具体处理与容器相关的请求.服务端主要包括四个组件:</p>
<ul>
<li><p>dockerd</p>
<p>为客户端提供RESTful API,响应来自客户端的请求,采用模块化的构架,通过专门的Engine模块来分发管理各个来自客户端的任务.</p>
</li>
<li><p>docker-proxy</p>
<p>dockerd的子进程,配置容器端口映射功能.</p>
</li>
<li><p>containerd</p>
<p>dockerd的子进程,提供gRPC接口响应来自dockerd的请求,对下管理runC镜像和容器环境.</p>
</li>
<li><p>containerd-shim</p>
<p>containerd的子进程,为runC容器提供支持,同时作为容器内进程的根进程.</p>
</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>用户使用Docker可执行命令即为客户端程序,docker程序能将命令转为API请求再发送到服务端.客户端在命令执行结束后会立即退出.</p>
<p>可以通过-H参数显式指定服务端地址,例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker -H tcp:192.168.2.241:5999 info</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="Docker储存"><a href="#Docker储存" class="headerlink" title="Docker储存"></a>Docker储存</h2><p>Docker支持的储存文件系统如下:</p>
<ul>
<li>AUFS: 最早支持的文件系统,对Debian&#x2F;Ubuntu支持度好.</li>
<li>Btrfs: 参考zfs等特性设计的文件系统,试图用来取代Device Mapper.</li>
<li>Device Mapper: RHEL用来支持Docker开发的文件系统.</li>
<li>Overlay: 类似AUFS的层次化文件系统,性能更好.</li>
<li>Overlay 2: 原生支持128层,效率比overlay高.</li>
<li>VFS: 基于普通文件系统(ext,nfs等)的中间层抽象.</li>
<li>ZFS: 为Solaris上专用写时文件系统,在Linux上可以使用ZFS on Linux.</li>
</ul>
<p>它们都能实现分层的架构,同时又有各自的特性.Docker安装时会根据当前系统配置选择默认最适合的驱动.</p>
<h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p>AUFS原名Another UnionFS,是对UnionFS的补充.随着AUFS发展后更名为高级多层次统一文件系统(Advanced Multi Layered Unification Filesystem).简单来说就是可以将分布在不同地方的目录挂载到同一个虚拟文件系统中.</p>
<p>Docker参考Linux启动过程,首先将一个只读的bootfs(虚拟文件系统)挂载到容器文件系统中,然后将只读的rootfs(根目录文件系统)添加到bootfs之上.之后每次挂载一个readonly的FS文件层,将用户所要使用的文件内容挂载到rootfs之上.</p>
<p>这些文件层就是堆栈式文件系统中所保存的数据,在AUFS中每个文件层叫做一个分支,整个文件系统称为联合文件系统.而AUFS就是用来管理,使用这些文件层的文件系统.</p>
<p>Docker利用AUFS加载完最高层之后,会在最上面再添加一个rw权限的FS层.容器内部的应用,对当前文件系统所有写操作都会保存在这个FS层当中,当使用commit命令后,Docker会将这个FS层中的数据作为单独一个文件层保存在AUFS之中.</p>
<p>镜像(Image)可以理解为特定FS层的集合.从镜像启动容器(Container)时,Docker会依次加载BaseImage和其上image.通过镜像分隔为AUFS的文件层,使得所有容器可以共享文件层,且不会发生写冲突.</p>
<p>当使用AUFS作为储存驱动时,镜像和容器都保存在宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs目录下:</p>
<ul>
<li>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff: 镜像层数据保存目录.</li>
<li>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;layers: 镜像层的元数据文件,文件内容是记录该层之下所有镜像层名字.</li>
<li>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt: 容器运行时,容器中的文件系统挂载目录.</li>
</ul>
<h3 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h3><p>Device Mapper是Docker中支持的第二种储存驱动,存在于Redhat发行版中.特点是对块设备进行操作,而不是整个文件,在宿主机上很难发现镜像层和容器层的区别.</p>
<p>Device Mapper使用的数据块大小为64KB,在大量小数据写操作时,性能不如AUFS.</p>
<p>创建镜像的流程和AUFS有些不同:</p>
<ol>
<li>创建一个thin pool,这个pool可以创建在块设备上,也可以创建在sparse文件上.</li>
<li>创建一个按需分配的基础设备,并在该设备上创建文件系统.</li>
<li>创建镜像时,会在基础设备上做快照,每创建一个镜像层,就会做一次快照.快照创建时不占用空间,当内容变化时才会在thin pool中分配储存空间保存数据.</li>
</ol>
<p>在容器中读取数据的流程:</p>
<ol>
<li>在容器中的程序发起读请求,要访问指定地址数据块,容器层只是镜像层的一个快照,保存数据块映射表而没数据,通过指针指向镜像层中真正的数据块.</li>
<li>程序通过映射表读取对应镜像层中的数据块,并复制到容器的内存区.</li>
</ol>
<p>在容器中修改数据的流程和AUFS差不多,不同的是AUFS会复制整个文件到容器层,而Device Mapper通过定位需要修改的数据块分配新的储存区,把需要修改的数据块复制到新分配的储存区,再由程序更新.</p>
<h3 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h3><p>Docker使用Btrfs中的子卷和快照技术管理镜像和容器.Btrfs中的子卷与UNIX文件系统类似,每个子卷都有自己的目录结构.</p>
<p>Btrfs中的快照会复制整个子卷,并且快照可读写.快照保存在子卷中,也可以对快照递归地做快照.</p>
<p>Btrfs使用写时复制技术为子卷和快照分配底层储存空间,块大小一般为1GB.</p>
<p>Btrfs把镜像中的基础层作为一个子卷保存,其他镜像层和容器层都作为快照保存.</p>
<p>Brtfs中的读写操作和Device Mapper类似,但工作在文件层而不是数据块层.在修改文件时,Btrfs不会修改原文件,而是在容器层中分配新的储存空间保存修改的数据,然后修改元数据中数据指向地址.</p>
<h3 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h3><p>在Docker中使用了三种ZFS DataSet,包括文件系统,快照和克隆.其中快照只读,克隆从快照上产生,可读写.</p>
<p>镜像的基础层是一个ZFS文件系统,其他镜像层是一个ZFS克隆.启动容器后会在顶部增加一个读写层.</p>
<h3 id="Overlay-x2F-Overlay2"><a href="#Overlay-x2F-Overlay2" class="headerlink" title="Overlay&#x2F;Overlay2"></a>Overlay&#x2F;Overlay2</h3><p>OverlayFS是一种联合文件系统,与AUFS类似使用两个目录做分层,分别保存镜像层(lowerdir)和容器层(upperdir).</p>
<p>在运行容器时,Overlay会把所有镜像层对应的目录组合起来(merged&#x2F;diff),在上层添加一个容器层.而Overlay2原生支持多个lowerdir,因此保存多层镜像更有优势.</p>
<p>在Overlay中读取文件时,优先从容器层读取,容器层没有则从镜像层读取.</p>
<p>在Overlay中修改文件时,会把文件从镜像层复制到容器层,所有修改都保存在容器层.</p>
<p>在Overlay中删除文件时,会在容器层新建一个without(白障)文件,用于隐藏镜像层中的目标文件.删除文件时会在容器层新建一个opaque目录,用于隐藏镜像层中的目标目录.镜像层中文件和目录都不会被删除.</p>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>Docker的本地网络实现利用了Linux上的网络命名空间和虚拟网络设备.</p>
<p>Docker中的网络接口默认都是虚拟接口,它通过在内核中进行数据复制来实现虚拟接口之间的数据转发,发送接口的发送缓存中的数据包直接被复制到接收接口缓存中,而无须通过外部物理网络设备进行交换.</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>libnetwork中容器网络模型(CNM, Container Networking Model)十分简洁和抽象,可以让其上层使用网路功能的容器最大程度忽略底层具体实现.</p>
<p>容器网络模型包括三种元素:</p>
<ul>
<li>Sandbox(沙盒): 代表容器的网络栈,包括网卡,路由和DNS设置.Linux网络命名空间是Sandbox的标准实现.沙盒可以包含来自不同网络的接入点.</li>
<li>Endpoint(接入点): 作用是将沙盒接入网络.代表网络上可以挂载容器的接口,例如veth pair,会分配IP地址.</li>
<li>Network(网络): 可以连通多个接入点的一个子网,例如Bridge或VLAN等.</li>
</ul>
<p>对于CNM的容器管理系统来说,具体底下网络如何实现,不同子网怎么隔离都不关心.只要插件能提供网络和接入点,剩下的都是插件驱动的工作,这样就解耦了容器和网络功能.</p>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>镜像类似于虚拟机的镜像,可以将它理解为一个只读模板,保存着容器需要的环境和应用的执行代码.</p>
<p>镜像是创建Docker容器的基础,不同的镜像对应着不同的应用程序或服务.</p>
<h3 id="镜像名称"><a href="#镜像名称" class="headerlink" title="镜像名称"></a>镜像名称</h3><p>镜像名称格式像这样: <code>[命名空间|仓库地址]/镜像名:标签</code></p>
<ul>
<li><p>命名空间(Namespace)</p>
<p>用于区别构建镜像的组织或个人,一般为Docker Hub上的用户名.没有命名空间的镜像代表由官方提供,交由可靠且权威的第三方组织或机构维护的官方镜像.</p>
</li>
<li><p>仓库地址(URL)</p>
<p>如果镜像放置在第三方或私有仓库中,命名空间部分使用仓库URL路径来命名.</p>
</li>
<li><p>镜像名(Repository)</p>
<p>通常采用这个镜像中所包含的应用程务或服务名字作为镜像名.</p>
</li>
<li><p>标签(Tag)</p>
<p>习惯采用镜像包含的应用程务或服务的版本来作为镜像标签.</p>
</li>
</ul>
<h3 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h3><p>Docker的镜像是一个多层结构,每一层都在原有层基础上进行改动,这叫镜像分层框架(image-layering framework):</p>
<ul>
<li>镜像最底层为启动文件系统(bootfs)镜像.</li>
<li>往上一层根镜像(rootfs)通常是操作系统.它不包含内核,所以可做得很小.</li>
<li>用户镜像构建于根镜像之上,可以由很多层组成.</li>
<li>再往上一层是初始化(init)层,存放&#x2F;etc&#x2F;hosts和&#x2F;etc&#x2F;resolv.conf等定制化文件.</li>
<li>最后才是用户可读写的操作层.</li>
</ul>
<p>与Git原理类似,每一层镜像都可被视为一个提交,并拥有独立ID,最顶层的ID被视为镜像ID(Image ID).镜像ID用64个十六进制字符串(256比特)用来表示.当不同镜像包括相同层时,本地仅存一份相同内容.</p>
<p>上层和下层有相同的文件和配置时,上层会覆盖下层,以上层的数据为准,用户看到的是一个叠加之后的文件系统.</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>写时复制指复制某个数组或对象时,复制过程并不马上发生,而是先进行一些标记动作,只有需要对复制的数组或对象进行修改时,才真正复制出这个变量的副本.</p>
<p>Docker通过镜像运行容器时,并不马上把镜像内容复制到沙盒环境,而是直接把沙盒环境建立在镜像的基础上.容器运行的沙盒环境是镜像之上的一层临时可读写镜像层,也叫做thin类型容器层,镜像层以只读方式堆在容器层下方.</p>
<p>发生文件修改时,才会将原有镜像中需要被修改的文件复制到容器层中,修改后直接保存在容器层.AUFS中删除文件则是在容器层生成一个空白文件,用来代替镜像层对应文件,实现逻辑删除.</p>
<h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>容器是从镜像创建的应用运行实例,包含独立运行的一个或一组应用,以及运行环境.可以在容器中装入任何应用,所有应用的运行方式都一样,可以启动,开始,停止,删除等.同时可以在任何环境中运行容器,容器之间互相隔离.</p>
<p>从操作系统角度看,容器是运行在操作系统上的一个特殊进程,只不过加入了对资源的隔离和限制.在WIndows和Mac上的Docker实现基于虚拟化技术实现,和Liunx容器不同.</p>
<h3 id="容器设计"><a href="#容器设计" class="headerlink" title="容器设计"></a>容器设计</h3><p>虽然容器中能运行多个进程或多个不同的程序,但容器只会绑定一个进程.所以容器设计上应该以一个应用程序为主体,其他程序作为主体程序的支援.</p>
<p>这样容器启动时,主体程序也会被启动,Docker会监视这个程序的主进程.进程退出时,容器也会停止运行.同样通过命令停止容器运行时,Docker会发送停止信号给主体程序,让程序结束.</p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>使用docker run命令创建启动容器的流程如下:</p>
<ol>
<li>执行docker run命令后,Docker会在本地搜索所需镜像,如果没找到则从远程仓库中搜索并下载到本地,如果找到了,直接使用本地镜像.</li>
<li>Docker使用指定镜像创建一个新容器并启动.启动后在只读镜像文件层上挂载一层可读写的容器层,用来记录改变的数据.</li>
<li>Docker为容器分配一个虚拟网络接口,并通过网桥的方式将该网络接口桥接到宿主机上去.然后从网桥地址池取出一个IP地址分配给容器虚拟网络接口.</li>
<li>Docker在新容器中运行指定的命令或程序,执行完毕后被自动终止.</li>
</ol>
<h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>Docker仓库是集中存放镜像文件的场所.</p>
<p>仓库注册服务器(Registry)是存放仓库的地方,往往有多个仓库地址,用来存放不同类型的资源.</p>
<h3 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h3><p>根据所在位置,仓库可以分为本地仓库和远程仓库.</p>
<p>根据储存镜像公开分享与否,仓库可以分为公开仓库(Public)和私有仓库(Private).</p>
<h3 id="仓库组成"><a href="#仓库组成" class="headerlink" title="仓库组成"></a>仓库组成</h3><p>镜像仓库主要由两部分组成:</p>
<ul>
<li>镜像管理系统为镜像仓库提供类似代码库式的镜像存取和管理方式.</li>
<li>用户系统为镜像仓库中的镜像管理操作的授权提供支持.</li>
</ul>
<h3 id="仓库角色"><a href="#仓库角色" class="headerlink" title="仓库角色"></a>仓库角色</h3><p>一般网络上的镜像仓库包含三个角色:</p>
<ul>
<li>Index(索引): 负责维护用户账号,镜像校验及公共命名空间等信息.</li>
<li>Registry(库): 镜像和图标地仓库.</li>
<li>Client(客户端): 用户通过客户端来与仓库通信,鉴权,推送和拉取.</li>
</ul>
<h3 id="下载流程"><a href="#下载流程" class="headerlink" title="下载流程"></a>下载流程</h3><p>以Docker Hub为例下载镜像流程如下:</p>
<ol>
<li>客户端向Index发送下载某个镜像的请求.</li>
<li>Index返回三个信息:镜像位置,镜像所有层的校验信息,授权token.</li>
<li>用户使用授权token向目标Registry发出请求.</li>
<li>Registry向Index核实token是否有授权.</li>
<li>Index发返回授权验证结果,合法则通过下载请求.</li>
</ol>
<h3 id="上传流程"><a href="#上传流程" class="headerlink" title="上传流程"></a>上传流程</h3><p>以Docker Hub为例上传镜像流程如下:</p>
<ol>
<li>用户发送带证书的请求到Index,要求分配库名.</li>
<li>在成功认证以及确定命名空间和库名都能分配后,Index返回一个临时token.</li>
<li>镜像带着临时token向Registry发起推送请求.</li>
<li>Registry向Index检验该token的有效性,认证成功后开始读取客户端的数据流.</li>
<li>Index更新此次镜像的校验信息.</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>和Docker相关的网站:</p>
<ul>
<li>Docker官网: <a href="https://www.docker.com/">https://www.docker.com/</a></li>
<li>Docker官方文档: <a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com/</a></li>
<li>Docker源码: <a href="https://github.com/docker">https://github.com/docker</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>容器编排</title>
    <url>/1645/</url>
    <content><![CDATA[<h1 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h1><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose原名Fig,是Docker官方开发的用于简化多容器部署和迁移过程的容器编排(Orchestration)插件.Compose使用一个YAML格式的docker-compose.yml模板文件,来定义一组相关联的应用容器为一个服务栈.</p>
<p>Compose中有几个重要概念:</p>
<ul>
<li>任务(task): 一个容器被称为一个任务,拥有独一无二的ID,在同一个服务中的多个任务序号依次递增.</li>
<li>服务(service): 某个相同应用镜像的容器副本集合,一个服务可以横向扩展为多个容器实例.</li>
<li>服务栈(stack): 由多个服务组成,互相配合完成特定任务.一般定义在一个docker-compose.yml文件中.</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>V1版本由Python编写,安装方式如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-compose</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># curl -L https://raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># chmod +x /usr/local/bin/docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>V2版本使用Golang重构,安装方式如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># curl -L https://github.com/docker/compose/releases/download/v2.0.1/docker-compose-linux-x86_64 -o /usr/libexec/docker/cli-plugins/docker-compose</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># chmod +x /usr/libexec/docker/cli-plugins/docker-compose</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker compose version</span>
Docker Compose version v2.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>不需要时直接删掉对应二进制文件即可.</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>一个简单的样本如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">"3"</span>
services:
  redis:
    image: redis:alpine
    ports:
      - <span class="token string">"6379"</span>
    networks:
      - frontend
  db:
    image: postgres:9.4
    environment:
      ROOT_PASSWORD: example
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - backend
  vote:
    image: dockersamples/examplevotingapp_vote:before
    ports:
      - <span class="token string">"5000:80"</span>
    networks:
      - frontend
    depends_on:
      - redis
  result:
    image: dockersamples/examplevotingapp_result:before
    ports:
      - <span class="token string">"5001:80"</span>
    networks:
      - backend
    depends_on:
      - db
  worker:
    image: dockersamples/examplevotingapp_worker
    networks:
      - frontend
      - backend
  visualizer:
    image: dockersamples/visualizer:stable
    ports:
      - <span class="token string">"8080:8080"</span>
    stop_grace_period: 1m30s
    volumes:
      - <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>
      
networks:
  frontend:
  backend:

volumes:
  db-data:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上面的示例模板文件中可以看出顶级的配置项有:</p>
<ul>
<li><p>version: 定义了版本信息.</p>
</li>
<li><p>services: 定义了服务的配置信息,包含应用于为该服务启动的每个容器的配置.</p>
</li>
<li><p>networks: 定义了网络信息,提供给 services 中的具体容器使用.</p>
</li>
<li><p>volumes: 定义了卷信息,提供给services中的具体容器使用.</p>
</li>
</ul>
<h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><p>一些常见配置命令说明如下:</p>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>网络上此服务的别名(备用主机名).同一网络上的其他容器可以使用服务名称或此别名连接到其中一个服务的容器.</p>
<p>由于aliases是网络范围的,因此相同的服务可以在不同的网络上具有不同的别名.</p>
<p>网络范围的别名可以由多个容器共享,甚至可以由多个服务共享.如果是,则无法保证名称解析为的容器.</p>
<p>例如设置网络别名:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">services:
  some-service:
    networks:
      some-network:
        aliases:
          - alias1
          - alias3
      other-network:
        aliases:
          - alias2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="bulid"><a href="#bulid" class="headerlink" title="bulid"></a>bulid</h3><p>指定Dockerfile所在文件夹的路径,可以是绝对或相对路径,Compose将会利用它自动构建并使用这个镜像.例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3'</span>
services:
  webapp:
    build: ./dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>你也可以使用context指令指定Dockerfile所在文件夹的路径,同时使用dockerfile指令指定Dockerfile文件名:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3'</span>
services:
  webapp:
    build:
      context: /root/build
      dockerfile: Dockerfile-alternate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>dockerfile指令不能跟image同时使用,否则Compos不知道根据哪个指令来生成最终的服务镜像.</p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>使用command可以覆盖容器启动后默认执行的命令,可以为字符串格式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command: bundle <span class="token builtin class-name">exec</span> thin <span class="token parameter variable">-p</span> <span class="token number">3000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以为JSON数组格式 :</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command: <span class="token punctuation">[</span><span class="token string">"bundle"</span>, <span class="token string">"exec"</span>, <span class="token string">"thin"</span>, <span class="token string">"-p"</span>, <span class="token string">"3000"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称.默认将会使用”项目名称_服务名称_序号”这样的格式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">container_name: docker-web-container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>解决容器的依赖和启动先后的问题.例如先启动redis和db再启动web:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3'</span>
services:
  web:
    build: <span class="token builtin class-name">.</span>
    depends_on:
      - db
      - redis
redis:
    image: redis
db:
    image: postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>web服务不会等待redis和db完全启动之后才启动.</p>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义DNS服务器,可以是单个也可以是一个列表:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dns: <span class="token number">8.8</span>.8.8
dns:
  - <span class="token number">8.8</span>.8.8
  - <span class="token number">9.9</span>.9.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>覆盖容器中默认的入口命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">entrypoint: python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="env-file"><a href="#env-file" class="headerlink" title="env file"></a>env file</h3><p>从文件获取环境变量,可以为文件路径或列表.如果通过docker-compose -f FILE方式来指定Compose模板文件则env_file中变量的路径会基于模板文件路径.如果有变量名称与environment指令冲突,以后者为准:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">env</span> file: .env

<span class="token function">env</span> file:
  - ./cornmon.enV
  - ./apps/web.env
  - /opt/secrets.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>环境变量文件中每一行必须符合格式,支持#开头的注释行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cornmon.env : Set development environment</span>
PROG <span class="token assign-left variable">ENV</span><span class="token operator">=</span>development<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>设置环境变量.可以使用数组或字典两种格式.只给定名称的变量会自动获取运行Compose主机上对应变量的值,可以用来防止泄露不必要的数据:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">environment:
  RACK_ENV: development
  SESSION_SECRET:
environment:
  - <span class="token assign-left variable">RACK_ENV</span><span class="token operator">=</span>development
  - SESSION_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果变量名称或者值中用到true|false, yes|no等表达布尔含义的词汇,最好放到引号里,避免 YAML 自动解析某些内容为对应的布尔语义.包括: y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</p>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口,但不映射到宿主机,只被连接的服务访问.仅可以指定容器内部的端口为参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">expose:
 - <span class="token string">"3000"</span>
 - <span class="token string">"8000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>基于其他模板文件进行扩展.一般情况下,推荐在基础模板中只定义一些可以共享的镜像和环境变量,在扩展模板中具体指定应用变量,链接,数据卷等信息 .<br>例如已有一个webapp服务,定义一个基础模板文件为comman.yml:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># common.yml</span>
webapp:
  build: ./webapp
  environment:
    - <span class="token assign-left variable">DEBUG</span><span class="token operator">=</span>false
    - SEND <span class="token assign-left variable">EMAILS</span><span class="token operator">=</span>false <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再编写一个新的development.yml文件,使用common.yml中的webapp服务进行扩展:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># development.yml</span>
web:
  extends:
    file: common.yml
    service: webapp
  ports:
    - <span class="token string">"8000:8000"</span>
  links:
    - db
  environment:
    - <span class="token assign-left variable">DEBUG</span><span class="token operator">=</span>true
db:
  image: postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>后者会自动继承common.yml中的webapp服务及环境变量定义.使用 extends 需要注意以下两点：</p>
<ul>
<li>要避免出现循环依赖.例如A依赖B,B依赖C,C反过来依赖A的情况.</li>
<li>extends不会继承links和volumes_from中定义的容器和数据卷资源.</li>
</ul>
<h3 id="external-links"><a href="#external-links" class="headerlink" title="external links"></a>external links</h3><p>链接到docker-compose.yml外部的容器,甚至并非Compose管理的外部容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">external links:
  - redis_1
  - project_db_1:mysql
  - project_db_1:postgresql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra hosts"></a>extra hosts</h3><p>类似Docker中的–add-host参数,指定额外的host名称映射信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">extra_hosts:
  - <span class="token string">"googledns:8.8.8.8"</span>
  - <span class="token string">"dockerhub:52.1.157.61"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>服务容器启动后会在&#x2F;etc&#x2F;hosts文件中添加googledns和dockerhub两条内容.</p>
<h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>通过命令检查容器是否健康运行.包括检测方法(test), 间隔( interval), 超时(timeout),重试次数(retries), 启动等待时间(start_period)等:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">healthcheck:
  test: <span class="token punctuation">[</span><span class="token string">"CMD"</span>, <span class="token string">"curl"</span>, <span class="token string">"-f"</span>, <span class="token string">"http://localhost"</span><span class="token punctuation">]</span>
  interval: 1m30s
  timeout: 10s
  retries: <span class="token number">3</span>
  start_period: 30s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定为镜像名称或镜像 ID.如果镜像在本地不存在,Compose将会尝试拉取:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">image: ubuntu
image: orchardup/postgresql
image: a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果同时指定了image和build,那image不在具有单独使用它的意义,而是指定了目前要构建的镜像的名称.也就是说Compose构建的镜像则使用image中指定的名字webapp:tag命名:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">build: ./dir
image: webapp:tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h3><p>为容器添加Docker元数据(metadata)信息.例如可以为容器添加辅助说明信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">labels:
  com.startupteam.description: <span class="token string">"webapp for a startup team"</span>
  com.startupteam.department: <span class="token string">"devops department"</span>
  com.startupteam.release: <span class="token string">"rc3 for v1.0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>跟日志相关的配置,包括一系列子配置.<br>logging.driver类似于–log-driver参数,指定日志驱动类型.目前支持三种日志驱动类型: json-file, syslog, none.<br>logging.options设置日志驱动的相关参数.例如设置为syslog格式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">logging:
  driver: <span class="token string">"syslog"</span>
  options:
    syslog address: <span class="token string">"tcp://192.168.0.42:123"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者使用json-file格式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">logging:
  driver: <span class="token string">"json-file"</span>
  options:
    max-size:<span class="token string">"lOOOk"</span>
    max-file:<span class="token string">"20"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network mode"></a>network mode</h3><p>设置网络模式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">network mode: <span class="token string">"none"</span>
network mode: <span class="token string">"bridge"</span>
network mode: <span class="token string">"host"</span>
network mode: <span class="token string">"service: [service name]"</span>
network_mode: <span class="token string">"container:[name or id]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>要加入的网络,使用顶级networks定义下的条目:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">services:
  some-service:
    networks:
     - some-network
     - other-network
networks:
  some-network:
  other-network:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h3><p>跟主机系统共享进程命名空间.打开该选项的容器之间,以及和宿主机系统之间可以通过进程ID来相互访问和操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pid: <span class="token string">"host"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>暴露端口信息.使用宿主端口:容器端口(HOST:CONTAINER)格式,或者仅仅指定容器的端口(宿主将会随机选择端口)都可以:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ports:
  - <span class="token string">"3000"</span>
  - <span class="token string">"8000:8000"</span>
  - <span class="token string">"49100:22"</span>
  - <span class="token string">"127.0.0.1:8001:8001"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者指定详细设置:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ports:
  - target: <span class="token number">80</span>
    published: <span class="token number">8080</span>
    protocol: tcp
    mode: ingress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意,当使用HOST:CONTAINER格式来映射端口时,如果使用的容器端口小于60并且没放到引号里,可能会得到错误结果,因为YAML会自动解析xx:yy这种数字格式为60进制.为避免出现这种问题,建议数字串都采用引号包括起来的字符串格式.</p>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>指定重启策略,可以为no(不重启), always(总是), on-failure(失败时), unlessstopped(除非停止).例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">restart: unless-stopped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>配置容器内的内核参数.例如指定连接数为4096和开启TCP的syncookies:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctls:
  net.core.somaxconn: <span class="token number">4096</span>
  net.ipv4.tcp_syncookies: <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>指定容器的ulimits限制值.例如指定最大进程数为65535,指定文件旬柄数为20000(软限制)和40000(系统硬限制):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ulimits:
  nproc: <span class="token number">65535</span>
  nofile:
    soft: <span class="token number">20000</span>
    hard: <span class="token number">40000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>数据卷所挂载路径设置.可以设置宿主机路径(HOST:CONTAINER)或加上访问模式(HOST:CONTAINER:ro).<br>支持如ver, driver_opts, external, labels, name等子配置,该指令中路径支持相对路径:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">volumes:
  - /var/lib/mysql
  - cache/:/tmp/cache
  - ~/configs:/etc/configs/:ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>卷的bind和volume的混合使用示例:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">"3.2"</span>
services:
  web:
    image: nginx:alpine
    volumes:
      <span class="token comment"># 卷 (volume)</span>
      - type: volume
        source: mydata
        target: /data
        volume:
          nocopy: <span class="token boolean">true</span>
      <span class="token comment"># 挂载 (bind)</span>
      - type: <span class="token builtin class-name">bind</span>
        source: ./static
        target: /opt/app/static
db:
    image: postgres:latest
    volumes:
      - <span class="token string">"/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock"</span>
      - <span class="token string">"dbdata:/var/lib/postgresql/data"</span>
volumes:
  mydata:
  dbdata:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p>Compose使用docker-compose或docker compose命令来执行.常见选项有:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-f, –file FILE</td>
<td>指定使用的Compose模板文件,默认为docker-compose.yml,可多次指定.</td>
</tr>
<tr>
<td>-p, –project-name NAME</td>
<td>指定项目名称,默认将使用所在目录名称作为项目名.</td>
</tr>
<tr>
<td>-H, –host HOST</td>
<td>指定所操作的Docker服务地址.</td>
</tr>
<tr>
<td>–tls</td>
<td>启用TLS,如果指定-tlsverify则默认开启.</td>
</tr>
<tr>
<td>–tlscacert CA_PATH</td>
<td>信任的TLS CA的证书.</td>
</tr>
<tr>
<td>–tlscert CLIENT_CERT_PATH</td>
<td>客户端使用的TLS证书.</td>
</tr>
<tr>
<td>–tlskey TLS_KEY_PATH</td>
<td>TLS的私钥文件路径.</td>
</tr>
<tr>
<td>–tlsverify</td>
<td>使用TLS校验连接对方.</td>
</tr>
<tr>
<td>–project-directory PATH</td>
<td>指定工作目录,默认为Compose文件所在路径.</td>
</tr>
</tbody></table>
<h3 id="运行组合"><a href="#运行组合" class="headerlink" title="运行组合"></a>运行组合</h3><p>使用docker compose up命令,可以让Compose完成Docker Compose项目的镜像构建,容器创建,容器启动和连接容器等操作.下面使用一个最简化的wordpress项目示例:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># vi docker-compose.yml</span>
version: <span class="token string">"3"</span>
services:
  wordpress:
    image: wordpress
    depends_on:
      - db
    ports:
      - <span class="token number">8080</span>:80
    links:
      - db
  db:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: example<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认情况下docker-compose up启动的容器都在前台,终端会同时打印所有容器的输出信息,很方便调试.可以使用Ctrl+C停止前台运行的容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># docker compose up</span>
docker-db-1         <span class="token operator">|</span> <span class="token number">2021</span>-10-31 <span class="token number">22</span>:28:26 <span class="token number">0</span> <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> <span class="token string">'proxies_priv'</span> entry <span class="token string">'@% root@2b59c74426dd'</span> ignored <span class="token keyword">in</span> --skip-name-resolve mode.
docker-db-1         <span class="token operator">|</span> <span class="token number">2021</span>-10-31 <span class="token number">22</span>:28:26 <span class="token number">0</span> <span class="token punctuation">[</span>Note<span class="token punctuation">]</span> mysqld: ready <span class="token keyword">for</span> connections.
docker-db-1         <span class="token operator">|</span> Version: <span class="token string">'10.6.4-MariaDB-1:10.6.4+maria~focal'</span>  socket: <span class="token string">'/run/mysqld/mysqld.sock'</span>  port: <span class="token number">3306</span>  mariadb.org binary distribution
^CGracefully stopping<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl+C again to force<span class="token punctuation">)</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">2</span>/2
 ⠿ Container docker-wordpress-1  Stopped                                          <span class="token number">1</span>.6s
 ⠿ Container docker-db-1         Stopped                                          <span class="token number">0</span>.4s
canceled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要在后台启动并运行所有容器可以使用docker-compose up -d命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># docker compose up -d</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">2</span>/2
 ⠿ Container docker-db-1         Started                                     <span class="token number">0</span>.6s
 ⠿ Container docker-wordpress-1  Started                                     <span class="token number">1</span>.6s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果服务容器已存在,会尝试停止容器后重新创建,亦可以使用–no-recreate命令控制只启动停止状态的容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># docker compose -f docker-compose.yml up --no-recreate -d</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">3</span>/3
 ⠿ Network docker_default        Created                                       <span class="token number">0</span>.1s
 ⠿ Container docker-db-1         Started                                       <span class="token number">0</span>.7s
 ⠿ Container docker-wordpress-1  Started                                       <span class="token number">1</span>.7s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="停止组合"><a href="#停止组合" class="headerlink" title="停止组合"></a>停止组合</h3><p>通过docker compose down命令,可以让所有通过up启动的容器停止,对所创建的镜像及网络进行删除:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># docker compose -f docker-compose.yml down</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">3</span>/3
 ⠿ Container docker-wordpress-1  Removed                                   <span class="token number">1</span>.2s
 ⠿ Container docker-db-1         Removed                                   <span class="token number">0</span>.4s
 ⠿ Network docker_default        Removed                                   <span class="token number">0</span>.1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="示例样本"><a href="#示例样本" class="headerlink" title="示例样本"></a>示例样本</h2><p>下面创建一个Web服务,包含Python程序和Redis服务两个容器.</p>
<p>首先准备web.py文件,连接redis服务,并显示访问量:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p app/web</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi app/web/web.py</span>
from flask <span class="token function">import</span> Flask
from redis <span class="token function">import</span> Redis

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>

@app.route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
def hello<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    redis.incr<span class="token punctuation">(</span><span class="token string">'number'</span><span class="token punctuation">)</span>
    <span class="token builtin class-name">return</span> <span class="token string">'Hello Vi! # %s'</span> % redis.get<span class="token punctuation">(</span><span class="token string">'number'</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token builtin class-name">:</span>
    app.run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"0.0.0.0"</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">80</span>, <span class="token assign-left variable">debug</span><span class="token operator">=</span>True<span class="token punctuation">)</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编辑依赖第三方库包的名称和版本信息说明文件requirements.txt:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi app/web/requirements.txt</span>
<span class="token assign-left variable">flask</span><span class="token operator">==</span><span class="token number">0.10</span>
<span class="token assign-left variable">redis</span><span class="token operator">==</span><span class="token number">2.10</span>.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>建立Dockerfile文件用来构建Web应用镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi app/web/Dockerfile</span>
FROM python:2.7
COPY ./ /web/
WORKDIR /web
RUN pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt
CMD python web.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后配置docker-compose.yml文件,将两个服务写进去:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi app/docker-compose.yml</span>
version: <span class="token string">'3.0'</span>
services:
  redis:
    image: redis:3.2
  web:
    build:
      context: /root/app/web
    depends_on:
    - redis
    ports:
    - <span class="token number">8001</span>:80/tcp
    volumes:
    - /root/app/web:/web:rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用docker-compose up命令来启动应用:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># docker compose -f app/docker-compose.yml up</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动之后可以通过<a href="http://192.168.2.206:8001/%E6%9D%A5%E8%AE%BF%E9%97%AE">http://192.168.2.206:8001/来访问</a>.</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.高级操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker API</title>
    <url>/54519/</url>
    <content><![CDATA[<h1 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h1><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>Docker API是一套基于RESTful(Rspresentational State Transfer, 表述性状态转移)设计的HTTP,用于操作Docker服务的接口.它实现在Docker服务程序中,也由Docker服务程序向外提供.</p>
<p>RESTful设计中有几个比较关键的概念:</p>
<ul>
<li><p>Resource(资源)</p>
<p>RESTful接口操作或获取的对象就是资源,在Docker里就是容器,镜像,数据卷等实体.</p>
</li>
<li><p>Representation(表述)</p>
<p>因为资源形式各式各样,所以在RESTful设计中要求采用可读性的格式去展示资源.在Docker API中大都以JSON文本的形式表述资源.</p>
</li>
<li><p>State Transfer(状态转移)</p>
<p>对于资源的修改可以理解为资源状态发生的变化,也就是状态转移.在RESTful设计中主张用HTTP中的方法确定资源的操作方式,例如用GET获取,POST新增,PUT修改,DELETE删除等.</p>
</li>
</ul>
<h2 id="Docker-API-1"><a href="#Docker-API-1" class="headerlink" title="Docker API"></a>Docker API</h2><p>采用Docker API通信,可以免去Docker客户端安装,同时效率更高更自由.</p>
<p>为了区分不同程序提供的接口,Docker API进行了划分.例如操作Docker镜像容器等模块接口称为Docker Remote API,操作管理Docker Registry远程仓库的服务接口称为Docker Registry API,操作Docker Cloud云服务的接口称为Docker Cloud API.</p>
<h2 id="Docker-Remote-API"><a href="#Docker-Remote-API" class="headerlink" title="Docker Remote API"></a>Docker Remote API</h2><p>Docker Remote API由Docker服务程序提供,是Docker API最重要部分,它能控制Docker服务及其中镜像,容器,网络等功能的运行.</p>
<p>其中常用操作方法如下:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>列出容器</td>
<td>GET &#x2F;containers&#x2F;json</td>
</tr>
<tr>
<td>创建容器</td>
<td>POST &#x2F;containers&#x2F;create</td>
</tr>
<tr>
<td>查看容器信息</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;json</td>
</tr>
<tr>
<td>查看容器进程</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;atop</td>
</tr>
<tr>
<td>查看容器日志</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;logs</td>
</tr>
<tr>
<td>查看文件变更</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;changes</td>
</tr>
<tr>
<td>导出容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;export</td>
</tr>
<tr>
<td>启动容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;start</td>
</tr>
<tr>
<td>停止容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;stop</td>
</tr>
<tr>
<td>重启容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;restart</td>
</tr>
<tr>
<td>杀死容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;kill</td>
</tr>
<tr>
<td>附加终端</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;attach</td>
</tr>
<tr>
<td>暂停容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;pause</td>
</tr>
<tr>
<td>恢复容器</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;unpause</td>
</tr>
<tr>
<td>等待容器停止</td>
<td>GET &#x2F;containers&#x2F;(id)&#x2F;wait</td>
</tr>
<tr>
<td>删除容器</td>
<td>DELETE &#x2F;containers&#x2F;(id)</td>
</tr>
<tr>
<td>从容器复制</td>
<td>POST &#x2F;containers&#x2F;(id)&#x2F;copy</td>
</tr>
<tr>
<td>列出镜像</td>
<td>GET &#x2F;images&#x2F;json</td>
</tr>
<tr>
<td>创建镜像</td>
<td>POST &#x2F;images&#x2F;create</td>
</tr>
<tr>
<td>查看镜像信息</td>
<td>GET &#x2F;images&#x2F;(name)&#x2F;json</td>
</tr>
<tr>
<td>获取镜像历史</td>
<td>GET &#x2F;images&#x2F;(name)&#x2F;history</td>
</tr>
<tr>
<td>推送镜像</td>
<td>POST &#x2F;images&#x2F;(name)&#x2F;push</td>
</tr>
<tr>
<td>镜像贴标</td>
<td>POST &#x2F;images&#x2F;(name)&#x2F;tag</td>
</tr>
<tr>
<td>删除镜像</td>
<td>DELETE &#x2F;images&#x2F;(name)</td>
</tr>
<tr>
<td>搜索镜像</td>
<td>GET &#x2F;images&#x2F;search</td>
</tr>
</tbody></table>
<p>也可以使用curl -X发送请求来测试:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># curl --unix-socket /var/run/docker.sock http://localhost/_ping</span>
OK
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># curl -X GET http://192.168.2.234:5999/containers/json?all=1&amp;size=1</span>
<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"Id"</span><span class="token builtin class-name">:</span><span class="token string">"4608034f24faa0fde74fe3a53f89bd98af58bcc98c1d82ff51d8f19a9493ce15"</span>,<span class="token string">"Names"</span>:<span class="token punctuation">[</span><span class="token string">"/heuristic_ishizaka"</span><span class="token punctuation">]</span>,<span class="token string">"Image"</span><span class="token builtin class-name">:</span><span class="token string">"alpine"</span>,<span class="token string">"ImageID"</span><span class="token builtin class-name">:</span><span class="token string">"sha256:14119a10abf4669e8cdbdff324a9f9605d99697215a0d21c360fe8dfa8471bab"</span>,<span class="token string">"Command"</span><span class="token builtin class-name">:</span><span class="token string">"/bin/sh"</span>,<span class="token string">"Created"</span>:1635662347,<span class="token string">"Ports"</span>:<span class="token punctuation">[</span><span class="token punctuation">]</span>,<span class="token string">"Labels"</span>:<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,<span class="token string">"State"</span><span class="token builtin class-name">:</span><span class="token string">"exited"</span>,<span class="token string">"Status"</span><span class="token builtin class-name">:</span><span class="token string">"Exited (0) 2 seconds ago"</span>,<span class="token string">"HostConfig"</span>:<span class="token punctuation">&#123;</span><span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span><span class="token string">"default"</span><span class="token punctuation">&#125;</span>,<span class="token string">"NetworkSettings"</span>:<span class="token punctuation">&#123;</span><span class="token string">"Networks"</span>:<span class="token punctuation">&#123;</span><span class="token string">"bridge"</span>:<span class="token punctuation">&#123;</span><span class="token string">"IPAMConfig"</span>:null,<span class="token string">"Links"</span>:null,<span class="token string">"Aliases"</span>:null,<span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span><span class="token string">"c441e7f297764fe10f2ded3a955f4c86f263210a56e77b7a19ce36ef300f44c0"</span>,<span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"Gateway"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"IPPrefixLen"</span>:0,<span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"GlobalIPv6PrefixLen"</span>:0,<span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"DriverOpts"</span>:null<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>,<span class="token string">"Mounts"</span>:<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># curl -X POST http://192.168.2.234:5999/containers/4608034f24faa/start</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># curl -X DELETE http://192.168.2.234:5999/containers/4608034?v=1&amp;force=1</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">74386</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>详细用法可参考官网: <a href="https://docs.docker.com/engine/api/">https://docs.docker.com/engine/api/</a></p>
<h2 id="Docker-Registry-API"><a href="#Docker-Registry-API" class="headerlink" title="Docker Registry API"></a>Docker Registry API</h2><p>Docker Registry API可以管理与使用远程镜像仓库Docker Registry.主要提供以下功能:</p>
<ul>
<li><p>镜像信息操作</p>
<p>镜像信息指镜像ID,仓库名,标签,启动命令等能全名描述镜像的内容.无论想要推送还是拉取镜像前,都要进行镜像信息的推送和拉取.</p>
</li>
<li><p>镜像验证</p>
<p>可以通过Docker Registry API所给出的镜像信息中相关字段进行校验,保证镜像数据完整没有被修改.</p>
</li>
<li><p>镜像推送</p>
<p>Docker Registry API提供了分块方式将镜像数据推送到Docker Registry服务器,有利于提高传输速度.镜像服务器收到镜像数据后先进行数据组装,对于缺失部分可以补充上传.</p>
</li>
<li><p>镜像拉取</p>
<p>拉取镜像时同样通过分块方式拉取,再到本地进行组装,提高镜像传输效率.</p>
</li>
<li><p>镜像层控制</p>
<p>当推送一个镜像层到仓库时,Docker Registry API会通过传输的镜像散列值,判断镜像层是否已经存在仓库中,有的话不必传输.</p>
</li>
</ul>
<h2 id="Docker-py"><a href="#Docker-py" class="headerlink" title="Docker-py"></a>Docker-py</h2><p>docker-py为Docker官方提供的Python版本的API接口库,参考文档:<a href="https://docker-py.readthedocs.io/en/stable/">https://docker-py.readthedocs.io/en/stable/</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用pip install docker来安装:</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">C:\Users\assassing>pip install docker
Successfully installed docker-5<span class="token punctuation">.</span>0<span class="token punctuation">.</span>3 pywin32-227 websocket-client-1<span class="token punctuation">.</span>2<span class="token punctuation">.</span>1
C:\Users\assassing>python
Python 3<span class="token punctuation">.</span>8<span class="token punctuation">.</span>1 <span class="token punctuation">(</span>tags/v3<span class="token punctuation">.</span>8<span class="token punctuation">.</span>1:1b293b6<span class="token punctuation">,</span> Dec 18 2019<span class="token punctuation">,</span> 23:11:46<span class="token punctuation">)</span> <span class="token namespace">[MSC v.1916 64 bit (AMD64)]</span> on win32
<span class="token function">Type</span> <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> or <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span>
>>> import docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="镜像查询"><a href="#镜像查询" class="headerlink" title="镜像查询"></a>镜像查询</h3><p>简单查看一下服务端信息:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker

cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'docker info:'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cli<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'docker images:'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cli<span class="token punctuation">.</span>images<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h3><p>尝试使用dockerfile构建一个简单的镜像:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker
<span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO

dockerfile <span class="token operator">=</span> <span class="token triple-quoted-string string">'''
#Share
FROM busybox
VOLUME /data
CMD ["/bin/sh"]
'''</span>
f <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span>dockerfile<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
response <span class="token operator">=</span> <span class="token punctuation">[</span>line <span class="token keyword">for</span> line <span class="token keyword">in</span> cli<span class="token punctuation">.</span>images<span class="token punctuation">.</span>build<span class="token punctuation">(</span>fileobj<span class="token operator">=</span>f<span class="token punctuation">,</span> rm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> tag<span class="token operator">=</span><span class="token string">'pytest/volume'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>启动刚才建立的镜像:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker

cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
container<span class="token operator">=</span>cli<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>run<span class="token punctuation">(</span>image<span class="token operator">=</span><span class="token string">'pytest/volume'</span><span class="token punctuation">,</span>command<span class="token operator">=</span><span class="token string">'/bin/sleep 60'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>2.高级操作</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/63480/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是最流行的开源关系型数据库.</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>使用官方镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true mysql</span>
NAME         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql        MySQL is a widely used, open-source relation…   <span class="token number">11582</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>  
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull mysql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>MySQL服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;</td>
<td>MySQL配置文件目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</td>
<td>MySQL数据文件目录</td>
</tr>
</tbody></table>
<p>MySQL服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>3306</td>
<td>服务端口</td>
</tr>
</tbody></table>
<p>启动一个随机MySQL容器,将要挂载目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --name tempm -d -e MYSQL_ALLOW_EMPTY_PASSWORD=1 mysql</span>
bcf418aec03085c97aeb4336b6cecbb4157dfcaa2f9affbc1a4b64f47a93ca12
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/mysql</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempm:/etc/mysql/conf.d /docker/mysql/conf.d</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempm:/var/lib/mysql /docker/mysql/data</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=mysqlpass -p 3306:3306 -v /docker/mysql/conf.d:/etc/mysql/conf.d:ro -v /docker/mysql/data:/var/lib/mysql mysql</span>
903380791a9ce92461c76fe794b51296312cd685d2cf761bd85fe07d0d86bb2d
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                  NAMES
903380791a9c   mysql          <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">11</span> seconds ago   Up <span class="token number">10</span> seconds   <span class="token number">0.0</span>.0.0:3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, :::3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以使用MySQL镜像作为客户端连接:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm mysql mysql -h192.168.2.241 -uroot -p</span>
Enter password: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>修改MySQL的root用户密码:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'mysqlpass'</span><span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="Oracle-DB"><a href="#Oracle-DB" class="headerlink" title="Oracle DB"></a>Oracle DB</h2><p>Oracle Database 11g(XE)是一款小型入门级数据库.其对数据库大小限制11GB,最多使用1GB内存和CPU单核心.</p>
<p>这时利用的镜像是jaspeen&#x2F;oracle-11g:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull jaspeen/oracle-11g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Oracle DB使用的端口为1521:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 1521:1521 --name oracledb jaspeen/oracle-11g</span>
923d49ca17fefd5be7d61c918573e35644ee0af40b4c156512a7b8b4ad28883b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是一款开源文档数据库(Document-Oriented),为当前最流行的NoSQL数据库.</p>
<h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>使用官方镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true mongo</span>
NAME            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mongo           MongoDB document databases provide high avai…   <span class="token number">8243</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
mongo-express   Web-based MongoDB admin interface, written w…   <span class="token number">1071</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>  
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull mongo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>MongoDB服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;data&#x2F;db&#x2F;</td>
<td>MongDB数据库存放目录</td>
</tr>
</tbody></table>
<p>MongoDB服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>27017</td>
<td>服务端口</td>
</tr>
<tr>
<td>28017</td>
<td>HTTP访问端口</td>
</tr>
</tbody></table>
<p>启动一个随机MongoDB容器,将要挂载目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name tempm mongo</span>
0fdb2a5878a24c95e64cd3f1fb7614ffd4283fb26d3837812326effebfb45c46
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/mongodb</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempm:/data/db /docker/mongodb/db</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动,设置root账号密码为root:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 27017:27017 -p 28017:28017 --name mongo -v /docker/mongodb/db:/data/db -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=root mongo</span>
14d297ff4282ea50bbcb0383ebb51e0fc6da0685dd83cfa9775892803da1b7a5
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                                                                          NAMES
14d297ff4282   mongo          <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">7</span> seconds ago   Up <span class="token number">5</span> seconds   <span class="token number">0.0</span>.0.0:27017-<span class="token operator">></span><span class="token number">27017</span>/tcp, :::27017-<span class="token operator">></span><span class="token number">27017</span>/tcp, <span class="token number">0.0</span>.0.0:28017-<span class="token operator">></span><span class="token number">28017</span>/tcp, :::28017-<span class="token operator">></span><span class="token number">28017</span>/tcp   mongo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个开源的基于内存的数据结构储存系统,可以用作数据库,缓存和消息中间件.</p>
<h3 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h3><p>使用官方镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true redis</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
redis     Redis is an <span class="token function">open</span> <span class="token builtin class-name">source</span> key-value store that…   <span class="token number">10076</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>  
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><p>Memcached是一个将数据缓存在内存的工具,经常被应用在Web服务程序中.</p>
<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>Apache Cassandra是个开源的分布式数据库.</p>
<h3 id="下载-3"><a href="#下载-3" class="headerlink" title="下载"></a>下载</h3><p>使用官方镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true cassandra</span>
NAME        DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
cassandra   Apache Cassandra is an open-source distribut…   <span class="token number">1327</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>     
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull cassandra</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>网站服务</title>
    <url>/36112/</url>
    <content><![CDATA[<h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache是一款相对重量级的开源Web服务器软件.Docker中的官方Apache镜像实际上使用Apache 2.</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官方提供的Apache镜像不带PHP环境,只能运行静态HTML文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true apache</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
httpd     The Apache HTTP Server Project                  <span class="token number">3737</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span> 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull httpd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>httpd服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;cgi-bin</td>
<td>动态网页数据存放处</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf</td>
<td>配置文件目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs</td>
<td>静态网页数据存放处</td>
</tr>
</tbody></table>
<p>httpd服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td>http端口</td>
</tr>
<tr>
<td>443</td>
<td>https端口</td>
</tr>
</tbody></table>
<p>启动一个随机httpd容器,将要挂载目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --name tempc -d httpd</span>
c8ba888b67fe1db1ca1e48d18d9d985
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/httpd</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp tempc:/usr/local/apache2/cgi-bin /docker/httpd/cgi-bin</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp tempc:/usr/local/apache2/conf /docker/httpd/conf</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp tempc:/usr/local/apache2/htdocs /docker/httpd/htdocs</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name httpd -p 80:80 -p 443:443 -v /usr/local/apache2/cgi-bin:/docker/httpd/cgi-bin:ro -v /usr/local/apache2/conf:/docker/httpd/conf:ro -v /usr/local/apache2/htdocs:/docker/httpd/htdocs:ro httpd</span>
9f3e1979ef2af86695e92490b9134af465919baf064dd843b7d78a34955ae194
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                                                                      NAMES
9f3e1979ef2a   httpd          <span class="token string">"httpd-foreground"</span>       About a minute ago   Up About a minute   <span class="token number">0.0</span>.0.0:80-<span class="token operator">></span><span class="token number">80</span>/tcp, :::80-<span class="token operator">></span><span class="token number">80</span>/tcp, <span class="token number">0.0</span>.0.0:443-<span class="token operator">></span><span class="token number">443</span>/tcp, :::443-<span class="token operator">></span><span class="token number">443</span>/tcp   httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一款功能强大的开源反向代理服务器,支持HTTP,HTTPS,SMTP,POP3,IMAP等协议.同时它可以作为负载均衡器,HTTP缓存或Web服务器.</p>
<h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>使用官方的镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true nginx</span>
NAME      DESCRIPTION                STARS     OFFICIAL   AUTOMATED
nginx     Official build of Nginx.   <span class="token number">15698</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>Nginx服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</td>
<td>网页数据存放处</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</td>
<td>配置文件目录</td>
</tr>
</tbody></table>
<p>Nginx作为Web服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td>http端口</td>
</tr>
<tr>
<td>443</td>
<td>https端口</td>
</tr>
</tbody></table>
<p>启动一个随机httpd容器,将要挂载目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name tempn nginx</span>
fb67cb1fce9f32b57729cb62c2a5d716edc1d42d39fcd1faae1bc57f6bab6a9d
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/nginx</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp tempn:/usr/share/nginx/html /docker/nginx/html</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp tempn:/etc/nginx/conf.d /docker/nginx/conf.d</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempn</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name nginx -p 80:80 -p 443:443 -v /docker/nginx/html:/usr/share/nginx/html:ro -v /docker/nginx/conf.d:/etc/nginx/conf.d:ro nginx</span>
220f821e4fed6e1cc421509bbfbaf6b36a71739b69c89c14d929a34e27ab0524
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                                      NAMES
220f821e4fed   nginx          <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">21</span> seconds ago   Up <span class="token number">19</span> seconds   <span class="token number">0.0</span>.0.0:80-<span class="token operator">></span><span class="token number">80</span>/tcp, :::80-<span class="token operator">></span><span class="token number">80</span>/tcp, <span class="token number">0.0</span>.0.0:443-<span class="token operator">></span><span class="token number">443</span>/tcp, :::443-<span class="token operator">></span><span class="token number">443</span>/tcp   nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat是Apache软件基金会下Jakarta项目开发的一个Servlet容器.由于Tomcat本身含有一个HTTP服务器,也可以当作单独的Web服务器来使用.</p>
<p>使用官方镜像运行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -P --rm tomcat</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                                      NAMES
8637d7207d2a   tomcat         <span class="token string">"catalina.sh run"</span>        <span class="token number">2</span> minutes ago    Up <span class="token number">2</span> minutes    <span class="token number">0.0</span>.0.0:49154-<span class="token operator">></span><span class="token number">8080</span>/tcp, :::49154-<span class="token operator">></span><span class="token number">8080</span>/tcp                                infallible_hertz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h2><p>Jetty是一个开源servlet容器,它为基于Java的Web内容提供运行环境.</p>
<p>使用官方镜像运行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true jetty</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
jetty     Jetty provides a Web server and javax.servle…   <span class="token number">376</span>       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>   
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -P jetty</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                                      NAMES
a2987c551b7c   jetty          <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">35</span> seconds ago   Up <span class="token number">34</span> seconds   <span class="token number">0.0</span>.0.0:49155-<span class="token operator">></span><span class="token number">8080</span>/tcp, :::49155-<span class="token operator">></span><span class="token number">8080</span>/tcp                                sweet_newton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins是一个应用广泛的持续集成和持续交付工具.</p>
<h3 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h3><p>使用官方镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true jenkins</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
jenkins   DEPRECATED<span class="token punctuation">;</span> use <span class="token string">"jenkins/jenkins:lts"</span> instead   <span class="token number">5343</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull jenkins/jenkins:lts</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>Jenkins服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;jenkins_home</td>
<td>Jenkins工作目录</td>
</tr>
</tbody></table>
<p>Jenkins服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>8080</td>
<td>Web端访问端口</td>
</tr>
<tr>
<td>50000</td>
<td>代理访问端口</td>
</tr>
</tbody></table>
<p>启动一个随机Jenkins容器,将要挂载目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name tempj jenkins/jenkins:lts</span>
37b69360599bfbcc765a96a4dc7d9a75971a4e489544f04f3fb1aa1df3b085f8
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/jenkins</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempj:/var/jenkins_home /docker/jenkins/jenkins_home</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempj</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为容器中的Jenkins是通过jenkins用户来运行的,所以需要修改目录权限让所有用户可读写:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># chmod -R 777 /docker/jenkins/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -v /docker/jenkins/jenkins_home:/var/jenkins_home jenkins/jenkins:lts</span>
7bd94f843fb91b274d76a80db188e0c68a46b4a1d84e34d2b68abee3134e4e02
<span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS        PORTS                                                                                      NAMES
01cee4cce220   jenkins/jenkins:lts   <span class="token string">"/sbin/tini -- /usr/…"</span>   <span class="token number">2</span> seconds ago   Up <span class="token number">1</span> second   <span class="token number">0.0</span>.0.0:8080-<span class="token operator">></span><span class="token number">8080</span>/tcp, :::8080-<span class="token operator">></span><span class="token number">8080</span>/tcp, <span class="token number">0.0</span>.0.0:50000-<span class="token operator">></span><span class="token number">50000</span>/tcp, :::50000-<span class="token operator">></span><span class="token number">50000</span>/tcp   jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用浏览器访问192.168.2.241:8080时,提示需要解锁密码:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword</span>
8f269df3531845b6be345f466eb9bff3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>解锁之后便是等待插件安装完成了.默认用户为admin,在用户设置中可以修改密码.</p>
<h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p>GitLab是一款开源的源码管理系统,有CE和EE版本.</p>
<h3 id="下载-3"><a href="#下载-3" class="headerlink" title="下载"></a>下载</h3><p>CE版本使用gitlab&#x2F;gitlab-ce这个镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull gitlab/gitlab-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><p>Gitlab服务中主要使用的目录如下:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;gitlab&#x2F;</td>
<td>Gitlab配置文件目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;</td>
<td>Gitlab数据文件目录</td>
</tr>
</tbody></table>
<p>Gitlab服务使用的端口如下:</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td>Web端访问端口</td>
</tr>
<tr>
<td>443</td>
<td>Web端加密访问端口</td>
</tr>
</tbody></table>
<p>启动一个随机的GitLab容器,将需要的目录复制出来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name tempg gitlab/gitlab-ce</span>
7580997687bd318e0e119f45ffd9f33a62d52779450495615790bb5b843b4681
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /docker/gitlab</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempg:/etc/gitlab/ /docker/gitlab/etc/</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp -a tempg:/var/opt/gitlab/ /docker/gitlab/opt/</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -f tempg</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h3><p>修改好配置文件后挂载目录和映射端口启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name gitlab -p 80:80 -v /docker/gitlab/etc:/etc/gitlab:ro -v /docker/gitlab/opt:/var/opt/gitlab gitlab/gitlab-ce</span>
2b7e5bd941e3dbe34a2a0208edc2e429fc6d6d4ca48d6688c68a7368fabed4f8
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID   IMAGE              COMMAND                  CREATED         STATUS                            PORTS                                                NAMES
2b7e5bd941e3   gitlab/gitlab-ce   <span class="token string">"/assets/wrapper"</span>        <span class="token number">9</span> seconds ago   Up <span class="token number">8</span> seconds <span class="token punctuation">(</span>health: starting<span class="token punctuation">)</span>   <span class="token number">22</span>/tcp, <span class="token number">443</span>/tcp, <span class="token number">0.0</span>.0.0:80-<span class="token operator">></span><span class="token number">80</span>/tcp, :::80-<span class="token operator">></span><span class="token number">80</span>/tcp   gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一次启动需要等待大约五分钟时间:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker logs -f gitlab</span>
Recipe: gitlab::database_reindexing_disable
  * crond_job<span class="token punctuation">[</span>database-reindexing<span class="token punctuation">]</span> action delete
    * file<span class="token punctuation">[</span>/var/opt/gitlab/crond/database-reindexing<span class="token punctuation">]</span> action delete <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>
     <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>
Recipe: gitlab::gitlab-rails<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>启动之后查询默认管理用户root的密码:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it gitlab grep Password: /etc/gitlab/initial_root_password</span>
Password: <span class="token assign-left variable">Sy9zHOfGxlKvOMYowtcvgBR2WZfgMgCFZHxdmzmo5zg</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/1165/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h2><p>BusyBox是一个集成了一百多常用Linux命令的精简工具箱,总大小只有不到2MB.</p>
<p>可以到Docker Hub上搜索下载:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true busybox</span>
NAME      DESCRIPTION           STARS     OFFICIAL   AUTOMATED
busybox   Busybox base image.   <span class="token number">2379</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span> 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull busybox</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images busybox</span>
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
busybox      latest    16ea53ea7c65   <span class="token number">5</span> weeks ago   <span class="token number">1</span>.24MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用-it的方式来启动交互式容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it busybox</span>
/ <span class="token comment"># vi</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped <span class="token punctuation">(</span>signal<span class="token punctuation">)</span>           <span class="token function">vi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h2><p>Alpine操作系统是一个面向安全的轻型Linux发行版,它采用musl libc和BusyBox来减小系统体积和资源消耗,比BusyBox功能更完善.此外Alpine还提供了包管理工具apk查询和安装软件包.</p>
<p>Alpine Docker镜像仅5MB左右大小,是Docker官方推荐的默认基础环境镜像.使用alpine作为基础镜像的镜像名会在后面加上-alpine,例如python:3.5-alpine.</p>
<p>可以在Docker Hub上搜索下载:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true alpine</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
alpine    A minimal Docker image based on Alpine Linux…   <span class="token number">8012</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull alpine</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images alpine</span>
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
alpine       latest    14119a10abf4   <span class="token number">8</span> weeks ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行时可以将需要在alpine中运行的命令写在docker run最后:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run alpine echo '555'</span>
<span class="token number">555</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在alpine容器中安装软件使用apk add命令,软件包名可以到<a href="https://pkgs.alpinelinux.org/packages%E6%90%9C%E7%B4%A2">https://pkgs.alpinelinux.org/packages搜索</a>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~ <span class="token comment"># apk add vim</span>
<span class="token punctuation">(</span><span class="token number">1</span>/5<span class="token punctuation">)</span> Installing xxd <span class="token punctuation">(</span><span class="token number">8.2</span>.3437-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span>/5<span class="token punctuation">)</span> Installing lua5.3-libs <span class="token punctuation">(</span><span class="token number">5.3</span>.6-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span>/5<span class="token punctuation">)</span> Installing ncurses-terminfo-base <span class="token punctuation">(</span><span class="token number">6</span>.2_p20210612-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">4</span>/5<span class="token punctuation">)</span> Installing ncurses-libs <span class="token punctuation">(</span><span class="token number">6</span>.2_p20210612-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span> Installing <span class="token function">vim</span> <span class="token punctuation">(</span><span class="token number">8.2</span>.3437-r0<span class="token punctuation">)</span>
Executing busybox-1.33.1-r3.trigger
OK: <span class="token number">25</span> MiB <span class="token keyword">in</span> <span class="token number">19</span> packages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Debian-x2F-Ubuntu"><a href="#Debian-x2F-Ubuntu" class="headerlink" title="Debian&#x2F;Ubuntu"></a>Debian&#x2F;Ubuntu</h2><p>Debian和Ubuntu都是Debian系的服务器操作系统.</p>
<p>可以在Docker Hub上搜索下载:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true debian</span>
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu    Ubuntu is a Debian-based Linux operating sys…   <span class="token number">12999</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
debian    Debian is a Linux distribution that's compos…   <span class="token number">4039</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull debian</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用docker run命令直接运行镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm -it debian</span>
root@67c7d35efc34:/<span class="token comment"># echo $SHELL</span>
/bin/bash
root@67c7d35efc34:/<span class="token comment"># cat /etc/issue</span>
Debian GNU/Linux <span class="token number">11</span> <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果考虑用ubuntu作为基础镜像,通常用apt-get来更新安装软件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm -it ubuntu</span>
root@a5c5f0b0a7d5:/<span class="token comment"># cat /etc/lsb-release </span>
<span class="token assign-left variable">DISTRIB_ID</span><span class="token operator">=</span>Ubuntu
<span class="token assign-left variable">DISTRIB_RELEASE</span><span class="token operator">=</span><span class="token number">20.04</span>
<span class="token assign-left variable">DISTRIB_CODENAME</span><span class="token operator">=</span>focal
<span class="token assign-left variable">DISTRIB_DESCRIPTION</span><span class="token operator">=</span><span class="token string">"Ubuntu 20.04.3 LTS"</span>
root@a5c5f0b0a7d5:/<span class="token comment"># apt-get update</span>
Fetched <span class="token number">19.5</span> MB <span class="token keyword">in</span> 5s <span class="token punctuation">(</span><span class="token number">3616</span> kB/s<span class="token punctuation">)</span>                
Reading package lists<span class="token punctuation">..</span>. Done
root@a5c5f0b0a7d5:/<span class="token comment"># apt-get install -y curl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="CentOS-x2F-Fedora"><a href="#CentOS-x2F-Fedora" class="headerlink" title="CentOS&#x2F;Fedora"></a>CentOS&#x2F;Fedora</h2><p>CentOS和Fedora都是基于Redhat的Linux发行版:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true centos</span>
NAME      DESCRIPTION                     STARS     OFFICIAL   AUTOMATED
centos    The official build of CentOS.   <span class="token number">6810</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull centos</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>CentOS最新版为8.4版本,一般使用的是CentOS:7版本.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm centos</span>
<span class="token punctuation">[</span>root@be4eb8a8025a /<span class="token punctuation">]</span><span class="token comment"># cat /etc/centos-release</span>
CentOS Linux release <span class="token number">8.4</span>.2105
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm centos:7</span>
<span class="token punctuation">[</span>root@e6de73058535 /<span class="token punctuation">]</span><span class="token comment"># cat /etc/centos-release</span>
CentOS Linux release <span class="token number">7.9</span>.2009 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>构建镜像</title>
    <url>/28413/</url>
    <content><![CDATA[<h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><p>想要构建一个系统基础镜像,可以借助debootstrap工具:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># yum install -y debootstrap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下载所需文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># debootstrap --arch amd64 trusty ubutu-trusty http://mirrors.163.com/ubuntu/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>提交生成基础镜像,名为ubase:0.1:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span><span class="token comment"># cd ubutu-trusty/</span>
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span><span class="token comment"># tar -c .|docker import - ubase:0.1</span>
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY                     TAG       IMAGE ID       CREATED         SIZE
ubase                          <span class="token number">0.1</span>       75d5ee4917e0   <span class="token number">8</span> seconds ago   228MB
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span><span class="token comment"># docker run -it ubase:0.1 /bin/bash</span>
root@e85c74d94582:/<span class="token comment"># cat /etc/os-release     </span>
<span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu"</span>
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">"14.04, Trusty Tahr"</span>
<span class="token assign-left variable">ID</span><span class="token operator">=</span>ubuntu
<span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span>debian
<span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu 14.04 LTS"</span>
<span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">"14.04"</span>
<span class="token assign-left variable">HOME_URL</span><span class="token operator">=</span><span class="token string">"http://www.ubuntu.com/"</span>
<span class="token assign-left variable">SUPPORT_URL</span><span class="token operator">=</span><span class="token string">"http://help.ubuntu.com/"</span>
<span class="token assign-left variable">BUG_REPORT_URL</span><span class="token operator">=</span><span class="token string">"http://bugs.launchpad.net/ubuntu/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile是由Docker提供的进行镜像自动化构建的配置文件,包含所有用于构建镜像所执行的命令.</p>
<p>Dockerfile本质上是一个简单的文本文件,使用DSL(Domain Specific Language)语法,其内容包括三种形式:</p>
<ul>
<li>注释行: 使用#开头的文本行,用于记录一些额外的说明文字.例如: <code># Echo message</code></li>
<li>指令行: 指令行分两部分,行首是指令名称(INSTRUCTION),一般采用全部大写字母格式.后面是参数(arguments).例如: <code>RUN echo &#39;Building&#39;</code></li>
<li>解析指令行: 解析指令行(Parser Directives)也是使用#作为开头,主要作用是提供一些解析Dockerfile需要使用的参数,一般很少用到.例如: <code># directive=value</code></li>
</ul>
<p>通过Dockerfile建立镜像的每一步操作(执行类似docker commit操作)都会生成一层镜像,在建立镜像层时本地已存在的镜像层会直接采用.无论什么时候,只要某层发生变化,其上面所有层的缓存都会失效.</p>
<p>当使用Dockerfile构建失败时,可以使用docker run命令运行基于构建已经成功的最后一步创建的镜像来启动容器,调试失败的构建命令.之后修改Dockerfile文件再次尝试构建.</p>
<p>为了减少镜像层数量,可以通过&amp;&amp;或sh脚本合并一些构建过程中的操作.</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><p>基础指令是控制Dockerfile整体性质的指令.</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM指令用来指定要构建的镜像是基于哪个镜像建立.作为必备指令,FROM指令必须作为Dockerfile第一条指令.允许出现多个FROM指令,以每个FROM指令为界限生成不同镜像.</p>
<p>FROM指令的格式为: <code>FROM &lt;image&gt;:&lt;tag&gt;</code> 或 <code>FROM &lt;image&gt;@&lt;digest&gt;</code>.其中&lt;tag&gt;和&lt;digest&gt;都是可选项.</p>
<p>例如以mysql:5.6镜像作为基础镜像: <code>FROM mysql:5.6</code>.</p>
<p>如果不以任何镜像为基础,那么写法为: <code>FROM scratch</code>.</p>
<p>为了保证镜像精简,可以选用体积较小的镜像如Alpine或Debian作为基础镜像.</p>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER指令用处是提供镜像的作者信息,非必须提供.</p>
<p>其格式为: <code>MAINTAINER &lt;name&gt;</code>.</p>
<p>例如填上制作者的联系方式: <code>MAINTAINER bbq@123.com</code>.</p>
<h2 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h2><p>控制指令是Dockerfile的核心部分,通过控制指令来描述整个镜像的构建过程.</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN指令用来给定构建镜像需要被执行的操作.每条RUN指令执行后,会在当前镜像层创建一个新的镜像层.</p>
<ul>
<li><p>指令格式:  <code>RUN command param1 param2 ...</code> </p>
<p>此种形式运行的命令是以shell来执行操作,Linux上默认选择&#x2F;bin&#x2F;sh作为shell程序.当指令较长时可以用\来对命令拆行.例如执行安装多个程序命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token punctuation">\</span>
        gcc <span class="token punctuation">\</span>
        <span class="token function">make</span> <span class="token punctuation">\</span>
        <span class="token function">curl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指令格式:  <code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>此种形式运行命令,是将命令和参数都使用双引号进行引用,并逐个传递.使用这种方式运行可以避免基础镜像中没有shell程序,或临时切换shell程序.例如使用&#x2F;bin&#x2F;bash作为shell:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span>, <span class="token string">"-c"</span>, <span class="token string">"echo build"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>在使用RUN指令时,Docker判断是否采用缓存构建的依据是给出的指令是否与生成缓存使用的指令一致.如果执行结果有差异也会采用缓存中的数据.这时可以通过docker build命令中加入–no-cache选项来忽略缓存.</p>
<p>在构建时安装了程序后,需要及时清理缓存和临时文件,这样可以减少镜像体积.</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>WORKDIR指令用于切换构建过程中的工作目录,可以多次指定.给出的目录方式可以使用绝对路径或相对路径.</p>
<p>指令格式: <code>WORKDIR /root/bin</code>.</p>
<p>可以在WORKDIR指令中使用环境变量.例如调用BASEDIR变量:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENV BASEDIR /project
WORKDIR <span class="token variable">$BASEDIR</span>/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果目录不存在会自动创建.</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD能为镜像添加触发器(tragger),后面指定的指令不会在当前镜像构建时执行,而在被其他镜像构建时用FROM调用后执行.一般对于使用ONBUILD指令的镜像在镜像名后有-onbuild.</p>
<p>指令格式: <code>ONBUILD INSTRUCTION arguments</code>.</p>
<p>ONBUILD指令只会在构建子镜像中执行,子镜像构建完成后,指令会消失而不会继承到后辈镜像中.</p>
<p>例如: <code>ONBUILD ADD . /app/src</code>.</p>
<h2 id="引入指令"><a href="#引入指令" class="headerlink" title="引入指令"></a>引入指令</h2><p>主要是将文件加入到构建镜像中.</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>可以使用ADD指令将文件从外部传递到镜像内部.</p>
<p>指令格式: <code>ADD &lt;src&gt;... &lt;dest&gt;</code> 或 <code>ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;DEST&gt;&quot;]</code>.后种形式用来处理带空格的文件名.</p>
<p>指令用法如下:</p>
<ul>
<li>指定源目标时,需要使用相对路径.也就是Dockerfile文件所在路径为根基目录,源目标不能脱离根基目录.</li>
<li>指定源目标是压缩文件(gzip, bzip2, xz)时,Docker会自动解压文件内容到目标目录.</li>
<li>指定源目标是目录时,目录并不会被复制进镜像,而是复制目录中的内容.</li>
<li>指定源目标还能指定URL地址.</li>
<li>指定源目标支持多个目标与通配符,此时目标目录必须以&#x2F;结尾.</li>
<li>指定源目标与构建缓存中的文件不符时,会忽略缓存.</li>
<li>指定镜像目标目录可以用绝对路径或相对路径,相对路径以WORKDIR指令设置的工作目录为根基目录.</li>
<li>目标目录不存在时,会自动创建.</li>
</ul>
<p>例如将当前目录下txt格式文件复制到镜像&#x2F;work&#x2F;目录下: <code>ADD *.txt /work/</code>.</p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY指令与ADD指令用法一致,主要区别是COPY指令不能指定URL地址和自动解压.</p>
<h2 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h2><p>执行指令能够指定通过镜像建立容器时,容器默认执行的命令.Dockerfile中至少有一条CMD或ENTRYPOINT指令.</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD指令用来指定由镜像创建的容器中的主体程序,也就是配置镜像的默认入口程序.有两种调用格式:</p>
<ul>
<li><p>指令格式:  <code>CMD command param1 param2 ...</code> 或 <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>用法和RUN指令类似,都是取决于是否使用Shell程序来执行命令.前一种示例:<code>CMD echo &quot;test.&quot; | wc -</code></p>
<p>一般用后一种格式绑定执行程序,例如:<code>CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</code></p>
</li>
<li><p>指令格式:  <code>CMD [&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>将给出的参数传给ENTRYPOINT指令给出的程序.</p>
</li>
</ul>
<p>因为容器只会绑定一个应用程序,所以Dockerfile中只存在一个CMD指令.设置多个CMD指令则以最后一个为准.</p>
<p>此外CMD指令可以被创建容器时,自定义的启动指令给覆盖掉.</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT指令用于设置主程序启动前的准备工作.例如要在容器中额外启动sshd服务,可以把这些服务写到脚本中,通过ENTRYPOINT指令来启动.在启动脚本中通过exec命令启动的服务,可让服务在容器中使用PID 1作为进程号.</p>
<p>Dockerfile中同样只能有一个ENTRYPOINT.可以被创建容器时,加入的–entrypoint参数给覆盖掉.</p>
<p>指令格式: <code>ENTRYPOINT command params ...</code> 或 <code>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code>.两种指令格式在效果上同CMD一样.使用shell方式运行时,入口程序不能接收SIGTERM.</p>
<p>如果同时存在CMD和ENTRYPOINT指令指定可执行命令,CMD会在ENTRYPOINT之前运行.当CMD指令不可执行时,所有CMD指令或通过docker run方式指定的命令,作为参数拼接到ENTRYPOINT指令给出的命令之后,传给ENTRYPOINT指令给出的程序.</p>
<p>当需要把容器当作一个命令行工具使用时可以通过ENTRYPOINT设置镜像的入口程序.例如配合CMD命令启动时显示帮助文档:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"Pygame"</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">"--help"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><p>若要对容器进行相关环境或网络等配置,可以通过配置指令来实现.</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>如果容器中的应用程序需要让其他客户端访问到它提供的端口,需要通过EXPOSE指令显式给出对外提供的端口号.</p>
<p>指令格式: <code>EXPOSE &lt;port&gt;</code>.</p>
<p>只需要将开放端口逐一传入即可,多个端口用空格隔开.例如开放容器的22, 80和443端口: <code>EXPOSE 22 80 443</code>.</p>
<p>还可以设置开放的端口协议: <code>EXPOSE 11211/tcp 11211/udp</code>.</p>
<p>创建容器时使用-P参数能将EXPOSE中端口映射到主机上随机端口.使用-p可以映射EXPOSE中没有列出的端口.</p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>使用ENV指令来设置环境变量,有两种设置格式:</p>
<ul>
<li><p>指令格式:  <code>ENV &lt;key&gt; &lt;value&gt;</code>.</p>
<p>在键名key之后数据都会被视为环境变量的值.例如设置myName值为John Doe: <code>ENV myName John Doe</code>.</p>
</li>
<li><p>指令格式:  <code>ENV &lt;key&gt;=&lt;value&gt;</code>.</p>
<p>可以一次指定多个环境变量,并且可以使用\进行换行连接.由于每使用一次ENV指令都会生成镜像层,因此建议使用此格式来定义环境变量.例如: <code>ENV myCat=fluffy</code></p>
</li>
</ul>
<p>环境变量能够被继承,基础镜像中的环境变量会继承到构建镜像中.此外环境变量会存在基于构建镜像运行的容器中.</p>
<p>容器创建时,可以通过–env参数来新增或修改环境变量.</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL指令用来设置镜像的标签.</p>
<p>指令格式: <code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... </code>.</p>
<p>每个LABEL指令都会产生一个新的镜像层,所以尽量将标签记到一个LABEL指令中.</p>
<p>例如: <code>LABEL version=&quot;1.0&quot; description=&quot;Web Server&quot;</code>.</p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个数据挂载点用于持久化.</p>
<p>指令格式: <code>VOLUME [&quot;/DIR&quot;]</code>或 <code>VOLUME /SRC /DST</code>.</p>
<p>运行容器时可以从本地或其他容器挂载数据卷.例如把&#x2F;data挂载到容器中&#x2F;etc&#x2F;dfs: <code>VOLUME /data /etc/dfs</code>.</p>
<p>如果容器中的目标目录不存在,会自动新建.</p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>配置容器的健康检查.</p>
<p>指令格式: <code>HEALTHCHECK [OPTIONS] CMD command</code></p>
<p>根据所执行命令返回值是否为0来判断.为1则容器不能工作.</p>
<p>OPTIONS可以指定的参数:</p>
<ul>
<li>-interval&#x3D;DURATION (default: 30s): 多久检查一次.</li>
<li>-timeout&#x3D;DURATION (default: 30s): 每次检查等待结果的超时.</li>
<li>-retries&#x3D;N (default: 3): 重试尝试次数.</li>
</ul>
<p>例如: <code>HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1</code>.</p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>USER指令用于设置执行用户或UID.如果容器中应用程序运行时不需要特权,可以通过USER指令把应用程序所有者设为非root用户.此时在容器中新建用户和组需要指定UID和GID,因为每次编译镜像系统会分配不同UID&#x2F;GID.</p>
<p>指令格式: <code>USER root</code>.</p>
<p>USER指令对其后的RUN, CMD和ENTRYPOINT指令都会起作用.</p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>和ENV作用类似,ARG用于定义只在镜像构建过程中使用的局部变量.</p>
<p>指令格式: <code>ARG &lt;name&gt;=&lt;default&gt;</code>.</p>
<p>ARG从定义它的地方开始生效,而不是调用的地方.例如: <code>ARG build_user=www</code>.</p>
<p>也可以仅声明变量名不指定变量值,由外部传递变量(docker build –build-arg来赋值).例如: <code>ARG site</code>.</p>
<p>如果ENV指令和ARG指令定义了相同的变量,以ENV定义的环境变量为准.</p>
<p>Docker内置一些镜像创建变量: HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, NO_PROXY.</p>
<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>用来定义程序停止信号,例如: <code>STOPSIGNAL 9</code>.</p>
<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>使用SHELL指令可以设定CMD和ENTRYPOINT等指令默认使用的shell程序.</p>
<p>指令格式: <code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>
<p>例如修改默认执行shell sh为&#x2F;bin&#x2F;bash: <code>SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]</code></p>
<h2 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h2><p>在Dockerfile中除了指令外的一些特殊的使用方法.</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过ENV定义的环境变量,可以在之后的命令中调用,调用方式有以下几种:</p>
<ul>
<li>$变量名: 这是最普通的调用方法,例如: <code>RUN echo $HOME</code>.</li>
<li>${变量名}: 用花括号将变量名括起来,可避免出现歧义.例如: <code>RUN echo $&#123;HOME&#125;</code>.</li>
<li>${变量:-替换内容}: 当变量不存在时,用替换内容代替变量.</li>
<li>${变量:+替换内容}: 当变量已定义和复制,替换内容会替换占位符.变量不存在,占位符会被直接清除.</li>
</ul>
<h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>针对不同系统使用的特殊符号不同,而引用解析指令行功能来消除歧义.</p>
<p>例如在Linux中使用\符号来进行命令换行,而在Windows系统中作为目录分隔符来用.可以设置escape的值来设置换行分隔符为&#96;,这样Windows路径中的\就不会被错误解析了:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># escape=`</span>

FROM windowsservercore
COPY test.txt c:<span class="token punctuation">\</span>
RUN <span class="token function">dir</span> c:<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>可以使用类似Git忽略功能的文件.dockerignore,来对构建镜像时一些敏感信息或无用文件进行忽略.</p>
<p>在Docker中,通常倾向于忽略掉所有文件,只保留确定需要传入镜像的文件.</p>
<p>例如保留conf.xml文件和config&#x2F;user.xml文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Keep files</span>
*
<span class="token operator">!</span>conf.xml
<span class="token operator">!</span>config/user.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="示例样本"><a href="#示例样本" class="headerlink" title="示例样本"></a>示例样本</h2><h3 id="普通样本"><a href="#普通样本" class="headerlink" title="普通样本"></a>普通样本</h3><p>带说明内容的构建样本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># This my first nginx Dockerfile</span>
<span class="token comment"># Version 1.0</span>
<span class="token comment"># Base images 基础镜像</span>
FROM centos
<span class="token comment">#MAINTAINER 维护者信息</span>
MAINTAINER tianfeiyu 
<span class="token comment">#ENV 设置环境变量</span>
ENV <span class="token environment constant">PATH</span> /usr/local/nginx/sbin:<span class="token environment constant">$PATH</span>
<span class="token comment">#ADD  文件放在当前目录下，拷过去会自动解压</span>
ADD nginx-1.8.0.tar.gz /usr/local/  
ADD epel-release-latest-7.noarch.rpm /usr/local/  
<span class="token comment">#RUN 执行以下命令 </span>
RUN <span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> /usr/local/epel-release-latest-7.noarch.rpm
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">wget</span> lftp gcc gcc-c++ <span class="token function">make</span> openssl-devel pcre-devel pcre <span class="token operator">&amp;&amp;</span> yum clean all
RUN <span class="token function">useradd</span> <span class="token parameter variable">-s</span> /sbin/nologin <span class="token parameter variable">-M</span> www
<span class="token comment">#WORKDIR 相当于cd</span>
WORKDIR /usr/local/nginx-1.8.0 
RUN ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx <span class="token parameter variable">--user</span><span class="token operator">=</span>www <span class="token parameter variable">--group</span><span class="token operator">=</span>www --with-http_ssl_module --with-pcre <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
RUN <span class="token builtin class-name">echo</span> <span class="token string">"daemon off;"</span> <span class="token operator">>></span> /etc/nginx.conf
<span class="token comment">#EXPOSE 映射端口</span>
EXPOSE <span class="token number">80</span>
<span class="token comment">#CMD 运行以下命令</span>
CMD <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="说明样本"><a href="#说明样本" class="headerlink" title="说明样本"></a>说明样本</h3><p>另外一个Nginx镜像构建样本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## Set the base image to CentOS  基于centos镜像</span>
FROM centos
<span class="token comment"># File Author / Maintainer  作者信息</span>
MAINTAINER <span class="token builtin class-name">test</span> test@example.com
<span class="token comment"># Install necessary tools  安装一些依赖的包</span>
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> pcre-devel <span class="token function">wget</span> net-tools gcc zlib zlib-devel <span class="token function">make</span> openssl-devel
<span class="token comment"># Install Nginx  安装nginx</span>
ADD http://nginx.org/download/nginx-1.8.0.tar.gz <span class="token builtin class-name">.</span>  <span class="token comment"># 添加nginx的压缩包到当前目录下</span>
RUN <span class="token function">tar</span> zxvf nginx-1.8.0.tar.gz  <span class="token comment"># 解包</span>
RUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /usr/local/nginx  <span class="token comment"># 创建nginx目录</span>
RUN <span class="token builtin class-name">cd</span> nginx-1.8.0 <span class="token operator">&amp;&amp;</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>  <span class="token comment"># 编译安装</span>
RUN <span class="token function">rm</span> <span class="token parameter variable">-fv</span> /usr/local/nginx/conf/nginx.conf  <span class="token comment"># 删除自带的nginx配置文件</span>
ADD http://www.apelearn.com/study_v2/.nginx_conf /usr/local/nginx/conf/nginx.conf  <span class="token comment"># 添加nginx配置文件</span>
<span class="token comment"># Expose ports  开放80端口出来</span>
EXPOSE <span class="token number">80</span>
<span class="token comment"># Set the default command to execute when creating a new container  这里是因为防止服务启动后容器会停止的情况，所以需要多执行一句tail命令</span>
ENTRYPOINT /usr/local/nginx/sbin/nginx <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> <span class="token parameter variable">-f</span> /etc/passwd
<span class="token comment">#如果你本地的宿主机上，已经有nginx配置文件了，则可以把ADD更改为使用COPY来进行拷贝</span>
COPY /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="多步骤创建"><a href="#多步骤创建" class="headerlink" title="多步骤创建"></a>多步骤创建</h3><p>先创建一段go语言程序源码,只输出hello信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi main.go</span>
// main.go will output <span class="token string">"Hello, Docker"</span>
package main

<span class="token function">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

func <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt.Println<span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编写Dockerfile文件,编译和运行合在一起:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># vi Dockerfile_builder</span>
FROM golang as builder
RUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /go/src/test
WORKDIR /go/src/test
COPY main.go <span class="token builtin class-name">.</span>
RUN go <span class="token function">env</span> <span class="token parameter variable">-w</span> <span class="token assign-left variable">GO111MODULE</span><span class="token operator">=</span>auto
RUN <span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span>O <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux go build <span class="token parameter variable">-o</span> app <span class="token builtin class-name">.</span>

FROM alpine:latest
WORKDIR /root/
COPY <span class="token parameter variable">--from</span><span class="token operator">=</span>builder /go/src/test/app <span class="token builtin class-name">.</span>
CMD <span class="token punctuation">[</span><span class="token string">"./app"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构建并运行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># docker build -t builder/go_app:1.0.0 -f Dockerfile_builder .</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm builder/go_app:1.0.0</span>
Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>2.高级操作</category>
      </categories>
  </entry>
  <entry>
    <title>网络模块</title>
    <url>/13102/</url>
    <content><![CDATA[<h1 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h1><h2 id="原生网络模式"><a href="#原生网络模式" class="headerlink" title="原生网络模式"></a>原生网络模式</h2><p>Docker自带了三种常用的网络模式none,host和bridge,只能用于同一宿主机内容器间通信,默认使用Bridge网络.</p>
<h3 id="None网络"><a href="#None网络" class="headerlink" title="None网络"></a>None网络</h3><p>也就是没有网络,挂在这个网络下的容器除了lo没有网卡.可以给一些安全性要求高的单机应用使用.</p>
<h3 id="Host网络"><a href="#Host网络" class="headerlink" title="Host网络"></a>Host网络</h3><p>使用host网络的容器中网络配置与host完全一样,Docker没有给容器创建单独的网络命名空间.用在一些对网络性能要求高应用中.另外一种用途是让容器可以直接配置宿主机网络(–privileged&#x3D;true),用在某些跨主机网络解决方案.</p>
<p>由于和宿主机公用网络,所以需要考虑端口冲突问题.另外与宿主机同一子网的机器也能发现容器的存在.</p>
<h3 id="Bridge网络"><a href="#Bridge网络" class="headerlink" title="Bridge网络"></a>Bridge网络</h3><p>Docker通过Network Namespace为每个容器建立了独立网络,形成完全与宿主机隔离的环境.</p>
<p>默认情况下,Docker会在宿主机上架设一个名为docker0的虚拟网桥,用来连接宿主机与容器.容器与docker0之间通过Veth Pair(Virtual Ethernet Pair)来连接,所有连接到docker0上的容器同属于一个子网中,而宿主机也通过虚拟网卡连接到了docker0上.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># ifconfig docker0</span>
docker0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>
        inet <span class="token number">172.17</span>.0.1  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">172.17</span>.255.255
        inet6 fe80::42:b4ff:fe98:85d5  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>
        ether 02:42:b4:98:85:d5  txqueuelen <span class="token number">0</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets <span class="token number">794</span>  bytes <span class="token number">2870284</span> <span class="token punctuation">(</span><span class="token number">2.7</span> MiB<span class="token punctuation">)</span>
        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>
        TX packets <span class="token number">934</span>  bytes <span class="token number">5709678</span> <span class="token punctuation">(</span><span class="token number">5.4</span> MiB<span class="token punctuation">)</span>
        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># brctl show docker0</span>
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0         <span class="token number">8000</span>.0242b49885d5       no              veth5f73575
                                                        veth8125268<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="跨主机网络"><a href="#跨主机网络" class="headerlink" title="跨主机网络"></a>跨主机网络</h2><p>Docker原生支持跨主机网络方案overlay和macvlan,常用第三方跨主机网络方案有:flannel, weave和calico.</p>
<h3 id="Overlay网络"><a href="#Overlay网络" class="headerlink" title="Overlay网络"></a>Overlay网络</h3><p>Overlay是一种虚拟交换技术,主要是解决不同IP地址段之间的网络通信问题.Docker使用的Overlay技术是借助于libnetwork实现的VxLAN.</p>
<p>在Overlay网络中,网桥br0除了连接所有的endpoint还会连接一个vxlan设备,用于与其他host建立vxlan tunnel,容器之间通过这个隧道来通信.</p>
<p>Overlay网络需要一个K-V服务器比如Consul, zookeeper或etcd来储存相关主机信息.</p>
<h3 id="Macvlan网络"><a href="#Macvlan网络" class="headerlink" title="Macvlan网络"></a>Macvlan网络</h3><p>macvlan本身是Linux内核模块,其功能是允许同一个物理网卡配置多个MAC地址,本质上是一种网卡虚拟化技术.其优点是性能好,因为不需要创建网桥,直接通过以太端口连接到物理网络.</p>
<p>在macvlan中容器的网口直接与宿主机的网卡连接,容器无需通过NAT和端口映射就能与外网直接通信,在网络上与其他独立主机没有区别,因此一个网卡只能创建一个macvlan网络.</p>
<p>可以通过Vlan将物理的二层网络划分成最多4094个逻辑网络,每个VLAN由ID区分互相隔离,也就是eth0.xxx的形式,可供macvlan连接.</p>
<h3 id="Flannel网络"><a href="#Flannel网络" class="headerlink" title="Flannel网络"></a>Flannel网络</h3><p>flannel是CoreOS开发的容器网络解决方案,它为每个host分配一个subnet,容器从此subnet中分配IP,这些IP可以在host间路由.每个subnet都是从一个更大的IP池中划分的,flannel会在每个主机上运行flanneld的agent,从池子中分配subnet.</p>
<p>flannel使用etcd存放网络配置信息,数据包转发由基于vxlan或host-gw的backend实现.</p>
<p>flannel没有DNS服务,容器无法通过hostname通信.</p>
<p>flannel网络利用默认bridge网络,容器通过docker0访问外网.</p>
<h3 id="Weave网络"><a href="#Weave网络" class="headerlink" title="Weave网络"></a>Weave网络</h3><p>weave创建的虚拟网路可以将多主机的容器连接起来,就像在一个交换机中.</p>
<p>此外weave的DNS模块可以使容器通过hostname访问.</p>
<h3 id="Calico网络"><a href="#Calico网络" class="headerlink" title="Calico网络"></a>Calico网络</h3><p>Calico使一个纯三层的虚拟网络方案,Calico为每个容器分配一个IP,每个host都是router,把不同host的容器连接起来.与VxLAN不同的是,Calico不对数据包做额外封装,不需要NAT,此外还能动态定义ACL规则.</p>
<h2 id="网络方案比较"><a href="#网络方案比较" class="headerlink" title="网络方案比较"></a>网络方案比较</h2><p>从下面几个方面比较,根据不同场景选择最适合方案.</p>
<table>
<thead>
<tr>
<th></th>
<th>Overlay</th>
<th>Macvlan</th>
<th>Falnnel(v)</th>
<th>Falnnel(h)</th>
<th>Weave</th>
<th>Calico</th>
</tr>
</thead>
<tbody><tr>
<td>网络模型</td>
<td>VxLAN</td>
<td>Underlay</td>
<td>VxLAN</td>
<td>Underlay纯三层</td>
<td>VxLAN</td>
<td>Underlay纯三层</td>
</tr>
<tr>
<td>数据库</td>
<td>etcd</td>
<td>-</td>
<td>etcd</td>
<td>etcd</td>
<td>-</td>
<td>etcd</td>
</tr>
<tr>
<td>IPAM</td>
<td>单子网</td>
<td>自定义</td>
<td>每主机一子网</td>
<td>每主机一子网</td>
<td>单子网</td>
<td>每主机一子网</td>
</tr>
</tbody></table>
<h3 id="网络模型比较"><a href="#网络模型比较" class="headerlink" title="网络模型比较"></a>网络模型比较</h3><p>跨主机网络意味将不同主机上容器用同一个虚拟网络连接起来,这个虚拟网络的拓扑结构和实现技术就是网络模型:</p>
<ul>
<li>Overlay: 建立主机间VxLAN隧道,原始数据包在发送端被封装成VxLAN数据包,到达目的地后在接收端解包.</li>
<li>Macvlan: 网络在二层上通过VLAN连接容器,在三层上依赖外部网关连接不同macvlan.不需要封装数据包.</li>
<li>Falnnel: 使用两种backend.vxlan与overlay类似,host-gw将主机作为网关依赖三层IP转发,不需要封装数据包.</li>
<li>Weave: 同样通过VxLAN实现.</li>
<li>Calico: 与Falnnel的host-gw类似,依赖三层IP转发.</li>
</ul>
<h3 id="储存依赖"><a href="#储存依赖" class="headerlink" title="储存依赖"></a>储存依赖</h3><p>其中Overlay, Flannel和Calico都需要额外etcd或consul服务支持,Macvlan是简单的local网络,不需要保存和共享网络信息.Weave自己负责在主机间交换网络配置信息.</p>
<h3 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h3><p>在驱动管理IP地址的分配(IPAM)方面:</p>
<ul>
<li>Overlay: 网络中所有主机共享同一个子网,容器启动时会顺序分配IP,可以通过–subnet来设置子网空间.</li>
<li>Macvlan: 需要用户自己管理子网空间,为容器分配IP,不同子网通信依赖外部网关.</li>
<li>Flannel: 为每个主机分配独立子网空间,用户只需要指定一个大的IP池.不同子网之间路由会自动配置.</li>
<li>Weave: 默认配置下所有容器使用10.32.0.0&#x2F;12子网,可以通过–ipalloc-range设置子网空间.</li>
<li>Calico: 从IP Pool中为每个主机分配自己的子网空间,可自定义IP池.</li>
</ul>
<h3 id="连通与隔离"><a href="#连通与隔离" class="headerlink" title="连通与隔离"></a>连通与隔离</h3><p>在网络中容器通信,隔离与外网通信方面:</p>
<ul>
<li>Overlay: 同一网络中容器可通信,不同网络之间可将容器加入多个网络来实现通信.外网通信依赖Docker网桥.</li>
<li>Macvlan: 网络的连通或隔离完全取决于二层VLAN和三层路由.</li>
<li>Flannel: 不同网络中容器可直接通信,没有提供隔离.外网通信依赖Docker网桥.</li>
<li>Weave: 默认所有容器在同一网络,为容器指定不同子网来隔离.外网通信需将主机加入weave网络并作为网关.</li>
<li>Calico: 默认只允许同一网络中容器通信.通过Policy设定可以实现自由控制网络访问.</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>使用Underlay的网络性能优于使用Overlay(VxLAN)的网络.Overlay网络利用隧道技术,将数据包封装到UDP中进行传输,封装与解包存在额外开销.</p>
<p>不过Overlay较Underlay可以支持更多的二层网段,能更好地利用已有网络,以及可以避免物理交换机MAC表耗尽等优势.</p>
<h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>在容器内部修改的&#x2F;etc&#x2F;hostname,&#x2F;etc&#x2F;hosts和&#x2F;etc&#x2F;resolve.conf文件内容仅在本次容器运行期间有效,容器退出后修改丢失,即使用docker commit命令保存成镜像也不会保留修改.</p>
<h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>容器与宿主机通过docker0网桥沟通,而容器与外网访问可以通过docker0转发到宿主机外网网卡上,只要宿主机开启了端口转发功能,容器即可访问宿主机外部的网络:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># sysctl net.ipv4.conf.all.forwarding</span>
net.ipv4.conf.all.forwarding <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># iptables -t nat -L -n</span>
Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination              
DNAT       tcp  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0      tcp dpt:5000 to:172.17.0.3:5000
DNAT       tcp  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0      tcp dpt:49156 to:172.17.0.5:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是默认情况下外部网络无法访问容器,可以使用端口映射方式,将容器的端口与宿主机端口绑定,外部网络便能通过此端口访问容器中的应用和服务.</p>
<p>端口映射可以在建立镜像时使用-P参数,将容器需要暴露端口随机映射到主机空闲端口上(默认49000~49900端口):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -P nginx</span>
555e6a418454ecbb450e519e09ec483645d97d56569627b827e1b54781f6afde
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect -f=&#123;&#123;.NetworkSettings.Ports&#125;&#125; 555e6a41</span>
map<span class="token punctuation">[</span><span class="token number">80</span>/tcp:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token number">0.0</span>.0.0 <span class="token number">49153</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>:: <span class="token number">49153</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用-p参数来固定要映射到的宿主机端口,可以指定端口类型为udp:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 192.168.2.241:8001:80/udp nginx</span>
38769e47eebdc96ce3f0eded75e6b8c3de90609e42f01a09148911dc4ea025bb
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect -f=&#123;&#123;.NetworkSettings.Ports&#125;&#125; 38769e47</span>
map<span class="token punctuation">[</span><span class="token number">80</span>/tcp:<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token number">80</span>/udp:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token number">192.168</span>.2.241 <span class="token number">8001</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h3><p>有时一个容器中运行的应用程序,需要与运行在另外一个容器中的应用程序通过网络交换数据,这时就需要通过容器连接来完成.</p>
<p>要设置容器间通信,可以在创建容器时使用–link参数指定要连接的容器,这样会打开对被连接容器的网络访问.</p>
<p>例如创建一个MySQL容器,并让一个Web服务容器连接到它:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name mysql --env='MYSQL_ALLOW_EMPTY_PASSWORD=1' mysql</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 80:80 -p 443:443 --name web --link mysql:db nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>连接容器并不需要指明或映射被连接容器mysql的端口,被连接容器端口只在容器间的通信中使用,不会被暴露在外网中,也不会被其他容器访问到.建立连接唯一需要确保的条件是连接和被连接的容器都要处于运行状态.</p>
<p>另外为了避免连接容器名与连接容器内某些配置重名,Docker支持容器间使用别名进行连接.例如上面就使用db来作为容器mysql的别名.在web容器中可以使用db作为访问时的主机名.可以查看容器web中的&#x2F;etc&#x2F;hosts文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it web cat /etc/hosts</span>
<span class="token number">127.0</span>.0.1       localhost
<span class="token number">172.17</span>.0.4      db f2159e1085ed mysql
<span class="token number">172.17</span>.0.5      1286ab689c48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外在web容器中,通过env命令能看到mysql容器的环境变量.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it web env</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>1286ab689c48
<span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>xterm
<span class="token assign-left variable">DB_PORT</span><span class="token operator">=</span>tcp://172.17.0.4:3306
<span class="token assign-left variable">DB_PORT_3306_TCP</span><span class="token operator">=</span>tcp://172.17.0.4:3306
<span class="token assign-left variable">DB_PORT_3306_TCP_ADDR</span><span class="token operator">=</span><span class="token number">172.17</span>.0.4
<span class="token assign-left variable">DB_PORT_3306_TCP_PORT</span><span class="token operator">=</span><span class="token number">3306</span>
<span class="token assign-left variable">DB_PORT_3306_TCP_PROTO</span><span class="token operator">=</span>tcp
<span class="token assign-left variable">DB_PORT_33060_TCP</span><span class="token operator">=</span>tcp://172.17.0.4:33060
<span class="token assign-left variable">DB_PORT_33060_TCP_ADDR</span><span class="token operator">=</span><span class="token number">172.17</span>.0.4
<span class="token assign-left variable">DB_PORT_33060_TCP_PORT</span><span class="token operator">=</span><span class="token number">33060</span>
<span class="token assign-left variable">DB_PORT_33060_TCP_PROTO</span><span class="token operator">=</span>tcp
<span class="token assign-left variable">DB_NAME</span><span class="token operator">=</span>/web/db
<span class="token assign-left variable">DB_ENV_MYSQL_ALLOW_EMPTY_PASSWORD</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">DB_ENV_GOSU_VERSION</span><span class="token operator">=</span><span class="token number">1.12</span>
<span class="token assign-left variable">DB_ENV_MYSQL_MAJOR</span><span class="token operator">=</span><span class="token number">8.0</span>
<span class="token assign-left variable">DB_ENV_MYSQL_VERSION</span><span class="token operator">=</span><span class="token number">8.0</span>.27-1debian10
<span class="token assign-left variable">NGINX_VERSION</span><span class="token operator">=</span><span class="token number">1.21</span>.3
<span class="token assign-left variable">NJS_VERSION</span><span class="token operator">=</span><span class="token number">0.6</span>.2
<span class="token assign-left variable">PKG_RELEASE</span><span class="token operator">=</span><span class="token number">1</span>~buster
<span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>Docker服务端自带一个内嵌DNS服务器,使容器可以通过容器名来通信.</p>
<p>但使用Docker DNS有个限制,只能在用户自定义网络中使用.也就是说默认桥接网络docker0中是无法使用解析的.</p>
<h3 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h3><p>可以通过docker network ls命令查看Docker中定义的网络:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>
NETWORK ID     NAME      DRIVER    SCOPE
3b3d933326d5   bridge    bridge    <span class="token builtin class-name">local</span>
9c9f9149deef   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>
76306c358978   none      null      <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进一步通过docker network inspect能查看网络详情:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network inspect bridge </span>
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"3b3d933326d5a4dc198970d76c88ae265a09aab3edd12c1eb44d141c769628c8"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-22T06:08:04.744492282+08:00"</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每运行一个容器,都会在全局注册相关的网络信息.</p>
<h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>可以使用docker network create命令自建一个桥接网络,并设置被容器所使用,以此隔绝不相干的应用容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network create --driver bridge mybridge</span>
83a3f95af6b114c139f8887f48ac4d5dca739bfc310b8b209c5336cf211706d1
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm --net=mybridge ubuntu:18.04 </span>
root@b476cb94f196:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>自建网络时能使用–subnet和–gateway参数来自定义网段和网关.</p>
<h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><p>删除没在使用的自建网络使用docker network rm命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network rm mybridge</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以使用docker network prune命令自动清理未被使用的网络.</p>
<h3 id="加入网络"><a href="#加入网络" class="headerlink" title="加入网络"></a>加入网络</h3><p>处于不同bridge网络的容器,虽然有互通路由表规则,但在容器内iptables中会隔离掉访问.可以通过添加一块联通对方网桥的网卡来通信.使用命令docker network connect来添加容器dshell中联通mybridge网桥的网卡:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network connect mybridge dshell</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同时也能通过docker network disconnect命令随时将容器的网络与容器断开:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker network disconnect mybridge dshell</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="加入容器"><a href="#加入容器" class="headerlink" title="加入容器"></a>加入容器</h3><p>加入容器是一种另类的容器间通信方式,它可以使两个以上容器共享一个网络栈,共享网卡和配置信息.</p>
<p>使用加入容器功能除了可以让程序通过lo口高速通信外,还能用于监控网络程序的容器布置.</p>
<p>例如新建容器加入到容器dshell中:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --network=container:dshell alpine</span>
/ <span class="token comment"># ip addr show</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">48</span>: eth0@if49: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="token number">103</span>: eth1@if104: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.18</span>.0.2/16 brd <span class="token number">172.18</span>.255.255 scope global eth1
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>2.高级操作</category>
      </categories>
  </entry>
  <entry>
    <title>数据管理</title>
    <url>/7899/</url>
    <content><![CDATA[<h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><h2 id="数据卷特点"><a href="#数据卷特点" class="headerlink" title="数据卷特点"></a>数据卷特点</h2><p>容器内的文件环境,是由UFS提供的一个临时层,所有的操作都会随着容器删除被丢弃.为了达到从外界获取文件以及持久化储存文件的目的,Docker提出了数据卷(Data Volume)的概念.数据卷就是一个挂载在容器内文件系统中的文件或目录,每次启动容器时会自动挂载到容器,它可以脱离容器的生命周期而独立存在.</p>
<p>数据卷作为容器的一个特殊文件或目录,与其他文件或目录有很大差别:</p>
<ul>
<li>数据卷中数据不继承于镜像,也不在临时层所管理范围内,所以没有写时复制机制,所有文件操作即时生效.这些数据也不会被docker commit命令提交到新的镜像中.</li>
<li>数据卷不依赖于容器,数据卷独立于容器之外,多个容器可以共享同一个数据卷.通过数据卷可以实现容器之间的文件共享.</li>
</ul>
<h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><p>可以在创建容器时一同创建数据卷,通过-v参数向容器中挂载一个数据卷,Docker会自动创建这个数据卷:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker create --name vdisk -v /disk alpine</span>
000385b2005b5f79c1d1d05df5c981ac4dd3cffe1cc4d272691660151aebd26c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这样就为容器vdisk创建了一个路径为&#x2F;disk的数据卷.可以多次使用-v参数来挂载多个需要的数据卷.</p>
<p>可以使用docker volume create命令来创建一个自定义名为disk1的数据卷:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker volume create --name disk1</span>
disk1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所有建立的数据卷默认存放在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;路径下.</p>
<h2 id="查询数据卷"><a href="#查询数据卷" class="headerlink" title="查询数据卷"></a>查询数据卷</h2><p>通过docker volume ls命令来查看已创建的数据卷列表:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker volume ls</span>
DRIVER    VOLUME NAME
<span class="token builtin class-name">local</span>     21470509cc37589319a7eab45bdb9ca12ad4d500ff49228ce0b65cd985fb62fb
<span class="token builtin class-name">local</span>     disk1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用docker volume inspect命令来查看指定数据卷的基本信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker volume inspect disk1</span>
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-22T09:58:06+08:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/disk1/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"disk1"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h2><p>在创建容器时创建的数据卷,会自动挂载到容器中.而使用docker create或docker run命令创建容器时,可以用-v选项指定挂载数据卷,格式为:<code>-v 数据卷名:容器路径 </code>.卷可以绕过分层的联合文件系统为Docker提供持久数据或共享数据,这也意味着对卷的修改会直接生效,当提交或创建镜像时,卷不被包含在镜像中.</p>
<p>在挂载宿主机目录或文件到容器时,默认权限是读写(rw),可以对数据的权限做限制.例如以只读(ro)的方式挂载目录&#x2F;root&#x2F;disk1,可以保证程序数据不会被容器内程序修改:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker create --name vdisk2 -v /root/disk1:/disk1:ro alpine</span>
d44ab826d5ddd43bcdfa966648acb57d19f1982f22b28053f6e4b3b223118351<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>有时不希望将数据保存在宿主机或容器中,可以使用–tmpfs参数来挂载只存在内存中的tmpfs数据卷.</p>
<h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><p>可以使用docker volume rm命令来删除数据卷:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker volume rm disk1</span>
disk1
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># ll /var/lib/docker/volumes/disk1/</span>
ls: cannot access /var/lib/docker/volumes/disk1/: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到本地的对应目录也一并被删除了.</p>
<p>如果是随容器创建数据卷,最好使用-v参数随着容器一起删除:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm -v 000385b </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>批量删除卷可以使用docker volume ls -q查询返回卷ID后删除:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span><span class="token comment"># docker volume rm $(docker volume ls -q)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>数据卷容器是专门用于存放数据卷的容器,它并没有直接管理或控制数据卷,只是其他容器使用数据卷的桥梁.其作用是为了保证数据卷安全,不会随着其他容器而删除.</p>
<p>创建数据卷容器和普通的容器创建方法没有差别,数据卷容器不需要保持运行.创建数据卷容器时所使用的数据卷目录,会在其他容器连接到此数据卷容器时,作为对应访问数据卷的目录.</p>
<p>例如创建一个专门存放日志的数据卷容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker create --name logdata -v /logs alpine </span>
118002bf522df93e5e31011c74f0760d317ae235f23dca24f413068a1abe2d7a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>需要使用数据卷时,可以使用–volumes-from参数来挂载指定数据卷中所有的数据卷:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm --volumes-from logdata ubuntu:18.04 /bin/bash</span>
root@7baf237b2484:/<span class="token comment"># ll -d /logs</span>
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Oct <span class="token number">22</span> 02:49 /logs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以多次使用–volumes-from参数,挂载多个不同的数据卷容器来同时使用.</p>
<h2 id="数据卷备份"><a href="#数据卷备份" class="headerlink" title="数据卷备份"></a>数据卷备份</h2><p>使用数据卷容器能方便地备份数据卷的内容.利用新建的容器,把数据卷容器和宿主机目录连接起来,再执行打包命令,即可实现快速备份:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --volumes-from logdata -v $(pwd):/backup --rm ubuntu:18.04 tar cf /backup/logdata.tar /logs</span>
tar: Removing leading `/' from member names
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># ll logdata.tar </span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">10240</span> Oct <span class="token number">22</span> <span class="token number">11</span>:10 logdata.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>恢复数据则反过来操作:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --volumes-from logdata -v $(pwd):/backup --rm ubuntu:18.04 tar xf /backup/logdata.tar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>2.高级操作</category>
      </categories>
  </entry>
  <entry>
    <title>容器操作</title>
    <url>/583/</url>
    <content><![CDATA[<h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>创建容器可以使用docker create命令或docker run命令.</p>
<h3 id="创建静止容器"><a href="#创建静止容器" class="headerlink" title="创建静止容器"></a>创建静止容器</h3><p>使用docker create命令可以创建一个处于停止状态的容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker create alpine</span>
53b658ada694f5d5a5a5ba8e1bf656db4de8bacd79d4ae49857fe1ce27f60292<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>创建容器后,Docker会立即返回容器的ID.每个容器的ID都是唯一的.</p>
<p>在大多数镜像中已经设定了基于这个镜像的容器,在启动时要运行的程序,也可以在创建容器时重新指定容器所绑定的应用程序.例如指定运行tail -f &#x2F;var&#x2F;log&#x2F;messages命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker create ubuntu:18.04 tail -f /var/log/messages</span>
a7420c78df7388b3317364e0089491928ff0e2d184261d49b8315bc4fce8ed0d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="创建运行容器"><a href="#创建运行容器" class="headerlink" title="创建运行容器"></a>创建运行容器</h3><p>使用docker run命令可以创建两种类型的容器:</p>
<ul>
<li><p><strong>交互型容器</strong></p>
<p>容器运行默认在前台,通常会指定有交互的控制台,可以给容器输入,得到容器输出.如果创建容器的终端被关闭,容器内部使用exit命令退出,或调用docker stop(kill)命令后,容器会变成停止状态.</p>
<p>创建一个交互式容器,需要加入-t选项让Docker为容器创建一个伪终端并绑定到容器标准输入上.加入-i选项让容器的标准输入保持打开.例如创建启动一个名为myshell的Ubuntu容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -i -t --name=myshell ubuntu:18.04 /bin/bash</span>
root@fffa37ac6638:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>容器启动以后进入bash shell,由提示符可得用户名为root,主机名也就是容器短ID为fffa37ac6638.</p>
<p>要退出容器可以使用快捷键Ctrl+D或exit命令,之后容器会停止.要让容器继续运行可以使用快捷键Ctrl+PQ来退出交互模式.</p>
</li>
<li><p><strong>后台型容器</strong></p>
<p>容器运行在后台,创建启动之后和终端无关.只有调用docker stop或docker kill命令才能使容器变成停止状态.</p>
<p>在实际应用中,大多数容器都是后台运行式容器,在创建时使用-d参数.例如创建后台运行的ubuntu容器,并指定一个不会终止的命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --restart=always --name dshell -d ubuntu:18.04 /bin/sh -c "while true; do echo sleeping; sleep 1; done"</span>
bb018e9f0619a23f0e4cdc23cee2b738ecc3dc34dc8c7d3eaa4b93c9ddcd2b7e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="创建启动参数"><a href="#创建启动参数" class="headerlink" title="创建启动参数"></a>创建启动参数</h2><p>使用docker run命令启动容器时可以指定一些启动参数.</p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>常用启动参数如下:</p>
<ul>
<li><strong>-d</strong>: 设置容器在后台运行.</li>
<li><strong>-i</strong>: 保持标准输入打开.</li>
<li><strong>-t</strong>: 分配一个伪终端.</li>
<li><strong>–name&#x3D;’’</strong>: 设定容器名称,如果不指定系统会随机分配一个名称.最大用途是用在两个容器之间建立link通信.</li>
<li><strong>–restart&#x3D;””</strong>: 重启策略,可以设置为以下几种策略:<ul>
<li>No: 默认选项,没有任何重启操作.</li>
<li>Always: 无论容器处于什么状态都执行重启.同时容器会在Docker服务端启动时自启动.</li>
<li>On-failure: 当容器的命令返回非0值时重启.</li>
<li>Unless-stopped: 和Always类似,但不会自启动.</li>
</ul>
</li>
<li><strong>–rm</strong>: 容器退出后,自动删除容器.不能和-d与-rm同时使用.</li>
<li><strong>–privileged</strong>: 特权模式.容器可以访问除AppArmor和SELinux之外的主机所有进程.</li>
<li><strong>–env&#x3D;[]</strong>: 指定容器内环境变量.</li>
</ul>
<h3 id="网络参数"><a href="#网络参数" class="headerlink" title="网络参数"></a>网络参数</h3><p>和网络有关启动参数如下:</p>
<ul>
<li><strong>–net&#x3D;””</strong>: 设置容器采用的网络方式,默认为bridge.有以下几种模式:<ul>
<li>none: 不使用网络.容器不能访问外部网络,内部存在回路地址.</li>
<li>bridge: 桥接模式.容器通常连接到docker0网桥的veth口,网桥再连接到宿主机网络端口上.</li>
<li>host: 主机模式.直接使用宿主机网络,共享端口.容器所有暴露端口和容器连接将失效.</li>
<li>container: 容器模式.将容器的网络栈合并在一起,容器可以不需要IP来通信.</li>
<li>自定义网络: 对于Overlay和用户定义的multi-host模式可以被Docker采用.</li>
</ul>
</li>
<li><strong>-p</strong>: 设置容器映射到主机的端口,设置格式为<code>-p 主机端口:容器端口</code>.</li>
<li>–link&#x3D;””: 链接到其他容器.更推荐使用–net参数来为需要连接的容器分配一个专有网络.</li>
<li>–expose&#x3D;[]: 设置容器暴露的端口或端口范围.</li>
<li>-P: 通过NAT将容器设置暴露的端口自动映射到本机临时端口,默认选取端口号范围49153~65535.</li>
<li>–dns&#x3D;[]: 设置容器使用的DNS服务器.</li>
<li>–add-host&#x3D;””: 在容器内&#x2F;etc&#x2F;hosts文件中加入自定义主机名解析.</li>
<li>–ip&#x3D;””: 设置容器的IP地址.</li>
<li>–hostname&#x3D;””: 设置容器主机名</li>
</ul>
<h3 id="文件参数"><a href="#文件参数" class="headerlink" title="文件参数"></a>文件参数</h3><p>和文件系统挂载有关的参数如下:</p>
<ul>
<li><strong>-v</strong>: 挂载主机上的文件到容器,设置格式为<code>-v 主机路径:容器路径</code>.</li>
<li><strong>–tmpfs&#x3D;[]</strong>: 挂载临时文件系统到容器.</li>
<li>–device&#x3D;””: 挂载宿主机设备到容器内,默认可读写,可以自定义权限.</li>
<li>–volumes-from&#x3D;[]: 从其他容器挂载卷.</li>
<li>–workdir&#x3D;””: 设置容器内的默认工作目录.</li>
</ul>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><p>其他一些不常用启动参数:</p>
<ul>
<li>–pid&#x3D;””: 控制容器中进程使用什么pid.容器中执行程序pid从1开始算起.常用–pid&#x3D;host来和宿主机共享PID.</li>
<li>–ust&#x3D;””: 设置容器中使用的hostname和domain模式.</li>
<li>–ipc&#x3D;””: 设置进程间通信模式.</li>
<li>–log-driver: 设置容器日志等级,可以设置成以下等级:<ul>
<li>none: 不显示日志.</li>
<li>json-file: 默认输出格式.</li>
<li>syslog: 将日志输出到系统日志&#x2F;var&#x2F;log&#x2F;message中.</li>
<li>journald: 将日志写入到journald.</li>
</ul>
</li>
<li>–isolation&#x3D;””: 设置容器使用的隔离机制.</li>
<li>-h: 设置容器主机名.</li>
</ul>
<h2 id="管理容器"><a href="#管理容器" class="headerlink" title="管理容器"></a>管理容器</h2><p>除了创建容器之外的管理容器命令.</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>想要启动一个停止状态的容器,使用docker start命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker start fffa37ac663</span>
fffa37ac663<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>针对一个运行中的容器,可以使用docker restart命令来重启:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker restart myshell</span>
myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>此外使用docker unpause命令来恢复一个暂停的容器运行.</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>使用docker stop命令可以给容器中的进程发送SIGTERM信号,默认等待10秒后,会发送SIGKILL信号来终止容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker stop 74b23cb72</span>
74b23cb72<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>要发送SIGKILL信号来立即强行停止容器,使用docker kill命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker kill fffa37a</span>
fffa37a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>此外还可以使用docker pause命令来暂停容器.</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>当容器不再被需要时,可以使用docker rm命令删除停止状态的容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rm 74b23cb722 myshell</span>
74b23cb722
myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当然支持-f参数来强行删除运行中的容器.</p>
<h3 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h3><p>可以使用docker rename命令来对容器进行重命名:</p>
<pre class="line-numbers language-none"><code class="language-none">[root@server4 .docker]# docker rename 86e7325c7729 cent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="清理容器"><a href="#清理容器" class="headerlink" title="清理容器"></a>清理容器</h3><p>使用docker container prune命令会清除所有处于停止状态的容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker container prune</span>
WARNING<span class="token operator">!</span> This will remove all stopped containers.
Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Deleted Containers:
525899c2d8701ca12d44ac21d28beca50356c92cefe7d2c7159904c15dc41344

Total reclaimed space: 0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出容器使用docker export命令.正在运行中的容器也可以导出,并且不用担心容器依赖的镜像问题:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker export 53b658ada > a.tar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同导出镜像一样,可以同时导出多个容器到一个文件.</p>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>可以使用docker import命令导入通过docker export命令导出的容器作为镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker import a.tar user1:0.1</span>
sha256:7549e3270b729e1e908cde70ba3e0f2f9bf1b5abff2482fefa13775c2c62de2e
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
user1                     <span class="token number">0.1</span>       7549e3270b72   <span class="token number">7</span> seconds ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和导入镜像的功能相比,容器快照文件会丢弃所有的历史记录和元数据信息.</p>
<p>另外docker import命令还可以用来导入模板创建镜像.</p>
<h2 id="查询容器"><a href="#查询容器" class="headerlink" title="查询容器"></a>查询容器</h2><p>查询容器信息的常用操作如下.</p>
<h3 id="查询容器列表"><a href="#查询容器列表" class="headerlink" title="查询容器列表"></a>查询容器列表</h3><p>查看正在运行中的容器使用docker ps命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps</span>
CONTAINER ID IMAGE        COMMAND                CREATED        STATUS    PORTS    NAMES
74b23cb722cb ubuntu:18.04 <span class="token string">"/bin/sh -c 'while t…"</span> <span class="token number">22</span> seconds ago Up <span class="token number">21</span> seconds      dshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其结果显示标头含义如下:</p>
<ul>
<li>CONTAINER ID: 容器ID,全长为64位的十六进制.可以使用容器ID前几位来操作容器.</li>
<li>IMAGE: 创建容器时使用的镜像.</li>
<li>COMMAND: 容器最后运行的命令.</li>
<li>CREATED: 创建容器的时间.</li>
<li>STATUS: 容器的状态,其UP后时间表示容器已经运行的时长.如果是Exited(0)的形式,括号内的数字表示容器退出时的状态码,常见的有:0(执行完正常退出), 125(docker命令参数错误), 126(权限限制命令无法执行), 127(容器内的命令无法找到).</li>
<li>PORTS: 对外开放的端口.</li>
<li>NAMES: 容器名,和容器ID一样标识容器,所以不能重名.</li>
</ul>
<p>查看所有容器使用-a参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps -a</span>
CONTAINER ID IMAGE         COMMAND           CREATED        STATUS  PORTS  NAMES
74b23cb722cb ubuntu:18.04  <span class="token string">"/bin/sh -c 'wh"</span>  <span class="token number">9</span> minutes ago  Up <span class="token number">9</span> minutes   dshell
fffa37ac6638 ubuntu:18.04  <span class="token string">"/bin/bash"</span>       <span class="token number">25</span> minutes ago Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span>   myshell
53b658ada694 alpine        <span class="token string">"/bin/sh"</span>         <span class="token number">36</span> minutes ago Created        charming_jones<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看最近创建的2个容器使用-n&#x3D;x参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker ps -n=2</span>
CONTAINER ID IMAGE         COMMAND           CREATED        STATUS  PORTS  NAMES
74b23cb722cb ubuntu:18.04  <span class="token string">"/bin/sh -c 'wh"</span>  <span class="token number">9</span> minutes ago  Up <span class="token number">9</span> minutes   dshell
fffa37ac6638 ubuntu:18.04  <span class="token string">"/bin/bash"</span>       <span class="token number">25</span> minutes ago Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span>   myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>此外还有-f过滤参数,在镜像多的时候可以快速过滤镜像.可以过滤的方法有:</p>
<ul>
<li>id: 容器ID.</li>
<li>label: 容器的标记,可以来源于创建容器的镜像,或者在创建容器时通过–label参数设置.</li>
<li>name: 容器的名称.</li>
<li>exited: 容器停止时主进程的返回码.注意要与-a参数配合使用.</li>
<li>status: 容器的状态,可以是以下状态中一种:created, restarting, running, paused, exited, dead.</li>
<li>ancestor: 创建容器的镜像,可以指定镜像名或镜像ID.</li>
<li>before: 给出一个容器名或容器ID,返回给定容器之前创建的容器.</li>
<li>since: 给出一个容器名或容器ID,返回给定容器之后创建的容器.</li>
<li>isolation: 隔离性,可以是default, process, hyperv等机制,只对Windows有用.</li>
<li>volume: 显示使用指定数据卷或挂载点的容器.</li>
<li>network: 显示使用指定网络ID或网络名称的容器.</li>
</ul>
<h3 id="查询容器进程"><a href="#查询容器进程" class="headerlink" title="查询容器进程"></a>查询容器进程</h3><p>使用docker top命令,可以查看容器中正在运行的进程:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker top dshell </span>
<span class="token environment constant">UID</span>  PID   <span class="token environment constant">PPID</span>  C  STIME  TTY TIME      CMD
root <span class="token number">6625</span>  <span class="token number">6605</span>  <span class="token number">0</span>  <span class="token number">22</span>:29  ?   00:00:00  /bin/sh <span class="token parameter variable">-c</span> <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> sp<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
root <span class="token number">7736</span>  <span class="token number">6625</span>  <span class="token number">0</span>  <span class="token number">22</span>:38  ?   00:00:00  <span class="token function">sleep</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>dock top命令显示结果类似于ps命令,它还可以套用ps命令的参数.</p>
<h3 id="查询统计信息"><a href="#查询统计信息" class="headerlink" title="查询统计信息"></a>查询统计信息</h3><p>使用docker stats命令来实时查询容器内进程对系统资源使用情况:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker stats</span>
CONTAINER ID NAME             CPU %  MEM USAGE / LIMIT MEM %  NET I/O     BLOCK I/O  PIDS
69e11c2ea066 reverent_vaughan <span class="token number">0.00</span>%  408KiB / <span class="token number">3</span>.682GiB <span class="token number">0.01</span>%  656B / 0B   0B / 0B       <span class="token number">1</span>
c2382935fd0b dshell           <span class="token number">0.16</span>%  600KiB / <span class="token number">3</span>.682GiB <span class="token number">0.02</span>%  656B / 0B   <span class="token number">2</span>.26MB / 0B   <span class="token number">2</span>
099bc0337b97 myshell          <span class="token number">0.00</span>%  404KiB / <span class="token number">3</span>.682GiB <span class="token number">0.01</span>%  656B / 0B   0B / 0B       <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="查询容器详情"><a href="#查询容器详情" class="headerlink" title="查询容器详情"></a>查询容器详情</h3><p>同样可以使用docker inspect来查看容器的配置信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect dshell</span>
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"c2382935fd0b1ea40949266e0818da70c0518c0ed340558c68fd97987be5fc2f"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-21T14:29:54.535612575Z"</span>,
        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/sh"</span>,
        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"-c"</span>,
            <span class="token string">"while true; do echo sleeping; sleep 1; done"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="查询容器日志"><a href="#查询容器日志" class="headerlink" title="查询容器日志"></a>查询容器日志</h3><p>对于后台型容器,可以使用docker logs命令来查看容器日志.它将输出到标准输出的数据作为日志输出到运行docker logs命令的终端上.</p>
<p>默认情况下,logs输出的是从容器启动到调用执行logs命令时的所有输出.使用-f参数持续打印输出日志:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker logs -f dshell</span>
sleeping
sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>也可以使用–tail参数来查看日志末尾输出行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker logs --tail=5 dshell </span>
sleeping
sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>加入-t参数能显示日志输出时间:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker logs --tail=5 -t dshell </span>
<span class="token number">2021</span>-10-21T14:36:55.905640558Z sleeping
<span class="token number">2021</span>-10-21T14:36:56.907301372Z sleeping
<span class="token number">2021</span>-10-21T14:36:57.908906032Z sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>一些常用的操作容器方式.</p>
<h3 id="依附容器"><a href="#依附容器" class="headerlink" title="依附容器"></a>依附容器</h3><p>在使用docker start或docker restart启动的交互型容器中并没有具体终端可以依附,这时需要通过docker attach命令来将终端依附到容器上.也就相当于将容器切换到前台交互模式:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker start 099bc03</span>
099bc03
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker attach 099bc03</span>
root@099bc0337b97:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以通过Ctrl+P+Q快捷键退出容器,这样容器会保持运行.</p>
<p>后台型容器(只有-d没有-it参数)无法依附终端,因为它本身就不接受用户交互式输入.</p>
<h3 id="容器内执行命令"><a href="#容器内执行命令" class="headerlink" title="容器内执行命令"></a>容器内执行命令</h3><p>可以使用docker exec命令在容器中运行新的任务.任务可以指定在后台运行或为交互型任务.</p>
<p>例如在后台执行创建文件,使用-d参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec -d dshell touch /root/data.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建一个交互型任务任务使用-it参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it dshell /bin/bash</span>
root@c2382935fd0b:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>可以通过docker cp命令来操作容器与主机之间的文件复制.其格式命令如下:<code>docker cp 源地址 目标地址</code>.</p>
<p>例如将本地文件&#x2F;root&#x2F;ftp.sh复制到容器myshell的&#x2F;home&#x2F;目录下面:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp /root/ftp.sh myshell:/home/</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker exec myshell ls /home</span>
ftp.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例如将容器myshell下的文件&#x2F;home&#x2F;ftp.sh取出到本地&#x2F;root&#x2F;bin&#x2F;目录下面:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker cp myshell:/home/ftp.sh /root/bin/</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># ll /root/bin</span>
total <span class="token number">4</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">52</span> Sep <span class="token number">23</span> <span class="token number">19</span>:18 ftp.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>Docker通过cgroup来限制容器可使用资源.</p>
<h3 id="内存限额"><a href="#内存限额" class="headerlink" title="内存限额"></a>内存限额</h3><p>默认情况下对容器资源使用没有限制.可以在创建容器时通过-m参数限制容器占用最大内存,–memory-swap参数限制最大虚拟内存(默认为内存两倍):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -m 20M --memory-swap=30M alpine</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="CPU限额"><a href="#CPU限额" class="headerlink" title="CPU限额"></a>CPU限额</h3><p>Docker通过设置CPU使用权重来分配容器可使用的CPU资源.通常只有CPU资源紧张情况下,才能得到实际限制.使用-c参数来设置,默认为1024:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it -c 128 alpine</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># cat /sys/fs/cgroup/cpu/docker/1ffdbd1af1c64/cpu.shares </span>
<span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="读写限制"><a href="#读写限制" class="headerlink" title="读写限制"></a>读写限制</h3><p>Docker可以通过Block IO来限制容器读写磁盘的宽带.设置方式有以下三种:</p>
<ul>
<li><p>设置权重</p>
<p>默认情况下容器能平等地读写磁盘,可以通过设置–blkio-weight参数来改变读写优先级.默认值为500:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --blkio-weight 300 alpine</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>限制读写速度bps</p>
<p>bps是byte per second,每秒读写的数据量.限制对某个设备的读写速度的参数为–device-read-bps和device-write-bps.</p>
<p>例如限制容器写&#x2F;dev&#x2F;sda的速率为10MB&#x2F;s:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --device-write-bps /dev/sda:10MB alpine</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>限制iops次数</p>
<p>iops是io per second,每秒IO的次数.限制参数为–device-read-iops和device-write-iops.</p>
<p>例如限制容器对&#x2F;dev&#x2F;sda的每秒IO次数为100:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --device-write-iops /dev/sda:100 alpine</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>仓库操作</title>
    <url>/19190/</url>
    <content><![CDATA[<h1 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h1><h2 id="登录仓库"><a href="#登录仓库" class="headerlink" title="登录仓库"></a>登录仓库</h2><p>登录仓库使用docker login命令:<code>docker login -u 用户名 -p 密码 服务器地址</code>.如果没有给出镜像仓库服务器的地址,会采用Docker Daemon中的默认值.</p>
<p>例如不使用账号参数登录Docker Hub:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker login</span>
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, <span class="token function">head</span> over to https://hub.docker.com to create one.
Username: assassing
Password: 
WARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/<span class="token comment">#credentials-store</span>

Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h2><p>在从Docker Hub下载慢的情况下,可以配置镜像仓库:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://mirror.ccs.tencentyun.com"</span>,
    <span class="token string">"http://docker.mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://5ifniqg5.mirror.aliyuncs.com"</span>,
    <span class="token string">"https://registry.docker-cn.com"</span>,
    <span class="token string">"http://hub-mirror.c.163.com"</span>,
    <span class="token string">"https://mirror.ccs.tencentyun.com"</span>
    <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>自建的私有仓库一般不会设置TLS,需要把仓库地址添加到信任列表:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"192.168.2.241:5000"</span>,
    <span class="token string">"192.168.2.234:5999"</span>
    <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>可以通过官方提供的开源镜像分发工具Docker Registry来简单搭建一套本地私有仓库环境.</p>
<p>镜像存储模块与本地镜像存储相似,Registry将镜像记录在清单文件中,并同时记录验证信息,形成镜像数据库.</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建镜像仓库时,需要把镜像存放目录挂载出来,例如挂载到&#x2F;var&#x2F;docker_registry目录下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 5000:5000 -v /var/docker_registry:/var/lib/registry registry:2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以通过浏览器访问<a href="http://192.168.2.241:5000/v2/%E6%9D%A5%E7%A1%AE%E8%AE%A4%E9%95%9C%E5%83%8F%E5%B7%B2%E7%BB%8F%E6%AD%A3%E7%A1%AE%E5%90%AF%E5%8A%A8">http://192.168.2.241:5000/v2/来确认镜像已经正确启动</a>.</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>要想通过http来使用本地私有仓库,需要修改启动配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/docker/daemon.json</span>
<span class="token punctuation">&#123;</span>
    <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://mirror.ccs.tencentyun.com"</span><span class="token punctuation">]</span>,
    <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"192.168.2.241:5000"</span>
   <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>上传同样使用tag修改镜像标记后用push上传:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker tag user1:0.1 192.168.2.241:5000/user241:v1.0</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker push 192.168.2.241:5000/user241:v1.0</span>
The push refers to repository <span class="token punctuation">[</span><span class="token number">192.168</span>.2.241:5000/user241<span class="token punctuation">]</span>
c49567fcf544: Pushed 
v1.0: digest: sha256:50e4c287c3287307a0af663b479db763335aeb444f64bb00eb19f547553e38c0 size: <span class="token number">527</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>在另外一台主机上使用docker pull来拉取仓库中的镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># docker pull 192.168.2.241:5000/user241:v1.0</span>
v1.0: Pulling from user241
01b4f4cd1c49: Pull complete 
Digest: sha256:50e4c287c3287307a0af663b479db763335aeb444f64bb00eb19f547553e38c0
Status: Downloaded newer image <span class="token keyword">for</span> <span class="token number">192.168</span>.2.241:5000/user241:v1.0
<span class="token number">192.168</span>.2.241:5000/user241:v1.0
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY                   TAG       IMAGE ID       CREATED       SIZE
<span class="token number">192.168</span>.2.241:5000/user241   v1.0      7549e3270b72   <span class="token number">7</span> hours ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>对于镜像的创建,更新,分发等操作,Docker Registry提供HTTP API接口来实现操作调用.主要功能如下表:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>&#x2F;v2&#x2F;</td>
<td>检查是否支持2.0接口</td>
</tr>
<tr>
<td>GET</td>
<td>&#x2F;v2&#x2F;&lt;name&gt;&#x2F;tags&#x2F;list</td>
<td>获得镜像的标签列表</td>
</tr>
<tr>
<td>GET&#x2F;PUT&#x2F;DELETE</td>
<td>&#x2F;v2&#x2F;&lt;name&gt;&#x2F;manifests&#x2F;&lt;reference&gt;</td>
<td>获得&#x2F;修改&#x2F;删除镜像的主要信息</td>
</tr>
<tr>
<td>GET&#x2F;DELETE</td>
<td>&#x2F;v2&#x2F;&lt;name&gt;&#x2F;blobs&#x2F;&lt;digest&gt;</td>
<td>获得&#x2F;删除镜像层</td>
</tr>
<tr>
<td>POST</td>
<td>&#x2F;v2&#x2F;&lt;name&gt;&#x2F;blobs&#x2F;uploads&#x2F;</td>
<td>开始分块上传</td>
</tr>
<tr>
<td>GET</td>
<td>&#x2F;v2&#x2F;catalog</td>
<td>获得镜像列表</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>镜像操作</title>
    <url>/16210/</url>
    <content><![CDATA[<h1 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>一般镜像通过Docker Hub来获取.</p>
<h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>通过docker search命令可以搜索公共仓库Docker Hub中的镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search python</span>
NAME                       DESCRIPTION               STARS     OFFICIAL   AUTOMATED
python                     Python is an interpreted, <span class="token number">6632</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
pypy                       PyPy is a fast, compliant <span class="token number">290</span>       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
nikolaik/python-nodejs     Python with Node.js       <span class="token number">86</span>                   <span class="token punctuation">[</span>OK<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>搜索结果以STARS排序,默认显示25个结果.其字段说明如下:</p>
<ul>
<li>NAME: 镜像名称.</li>
<li>DESCRIPTION: 创建者对镜像的简单描述.</li>
<li>STARS: 镜像在官方镜像仓库中受欢迎程度.</li>
<li>OFFICIAL: 是否由Docker官方提供.</li>
<li>AUTOMATED: 镜像是否使用了自动构建.</li>
</ul>
<p>设置搜索结果数目限制到100个:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --limit 100 centos</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用–filter参数来限制搜索结果只显示官方构建的nginx镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=is-official=true nginx</span>
NAME      DESCRIPTION                STARS     OFFICIAL   AUTOMATED
nginx     Official build of Nginx.   <span class="token number">15666</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>过滤收藏数小于10的镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker search --filter=stars=10 linux</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>Docker运行容器前需要本地存在对应的镜像,获取镜像的命令为docker pull.</p>
<p>例如从Docker hub拉取Ubuntu 18.04系统的基础镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull ubuntu:18.04</span>
<span class="token number">18.04</span>: Pulling from library/ubuntu
<span class="token number">284055322776</span>: Pull complete 
Digest: sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6
Status: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04
docker.io/library/ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Docker会利用镜像的分层机制,将镜像分为多个包进行下载,当所有镜像层的下载和解压等操作完成后,镜像会出现在本地镜像仓库中.</p>
<p>不指定TAG默认使用latest标签例如从网易镜像站下载Ubuntu最新版镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker pull hub-mirror.c.163.com/public/ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>另外还有-a参数可以一次性下载所有标签版本镜像.</p>
<h2 id="管理镜像"><a href="#管理镜像" class="headerlink" title="管理镜像"></a>管理镜像</h2><p>镜像管理命令和容器管理命令相似.</p>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>可以使用docker commit将容器转为镜像,来保存在容器中做的更改:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker commit c238293 newimage:v1</span>
sha256:392f66f55bace6d10def28028edc90eebc3bb1e23e8e30a030aeb8f96e98ac8e
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
newimage                  v1        392f66f55bac   <span class="token number">4</span> seconds ago   <span class="token number">63</span>.1MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是一种手工创建镜像方式,容易出错且可重复性弱,因此最好使用docker build命令通过Dockerfile来构建镜像.</p>
<p>默认情况下docker build命令会自动找到指定目录下的Dockerfile文件,也可以通过-f参数指定要采用的文件名:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># vi Dockerfile</span>
FROM ubuntu:18.04
CMD <span class="token builtin class-name">echo</span> <span class="token string">"Hello Dockerfile"</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker build .</span>
Sending build context to Docker daemon  <span class="token number">5</span>.938MB
Step <span class="token number">1</span>/2 <span class="token builtin class-name">:</span> FROM ubuntu:18.04
 ---<span class="token operator">></span> 5a214d77f5d7
Step <span class="token number">2</span>/2 <span class="token builtin class-name">:</span> CMD <span class="token builtin class-name">echo</span> <span class="token string">"Hello Dockerfile"</span>
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> 2fe4d2fa8be2
Removing intermediate container 2fe4d2fa8be2
 ---<span class="token operator">></span> 4e73bed1428a
Successfully built 4e73bed1428a
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
<span class="token operator">&lt;</span>none<span class="token operator">></span>                    <span class="token operator">&lt;</span>none<span class="token operator">></span>    4e73bed1428a   <span class="token number">12</span> seconds ago   <span class="token number">63</span>.1MB
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run --rm 4e73</span>
Hello Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用-t参数可以指定被构建镜像的名称和标签:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker build -t assassing/redis:2.3 .</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>要删除本地镜像可以使用docker rmi命令.如果一个镜像对应多个tag,只有最后一个tag被删除时镜像才被真正删除:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rmi 5a214d77</span>
Error response from daemon: conflict: unable to delete 5a214d77f5d7 <span class="token punctuation">(</span>must be forced<span class="token punctuation">)</span> - image is referenced <span class="token keyword">in</span> multiple repositories
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker rmi base:1.0</span>
Untagged: base:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果镜像中含有与其他镜像共享的镜像层,这些层会被保留下来,只删除未被使用的层.</p>
<p>镜像被容器使用中可以使用-f参数来强制删除镜像:</p>
<pre class="line-numbers language-none"><code class="language-none">[root@server4 ~]# docker rmi -f nginx
Untagged: nginx:latest
Untagged: nginx@sha256:644a70516a26004c97d0d85c7fe1d0c3a67ea8ab7ddf4aff193d9f301670cf36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>强制删除镜像并不会先停止与删除对应的容器,很容易造成一些难以处理的遗留问题.最好还是先关闭或清理掉使用此镜像的容器再删除镜像.</p>
<h3 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h3><p>想要清理系统中遗留的一些临时镜像文件或一些没有被使用的镜像,可以通过docker image prune命令来清理:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker image prune</span>
WARNING<span class="token operator">!</span> This will remove all dangling images.
Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Total reclaimed space: 0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p>导出镜像使用docker save命令.例如将alpine镜像导出到本地a.tar文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images alpine</span>
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
alpine       latest    14119a10abf4   <span class="token number">7</span> weeks ago   <span class="token number">5</span>.6MB
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker save -o a.tar alpine</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># ll a.tar </span>
-rw-------. <span class="token number">1</span> root root <span class="token number">5874688</span> Oct <span class="token number">20</span> <span class="token number">23</span>:22 a.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以用输出重定向来导出到指定文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker save alpine > a1.tar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可一次导出多个镜像到单文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker save -o docker.tar alpine hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><p>使用docker load命令来从文件中导入镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker load -i docker.tar </span>
e2eb06d8af82: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">5</span>.865MB/5.865MB
Loaded image: alpine:latest
e07ee1baac5f: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">14</span>.85kB/14.85kB
Loaded image: hello-world:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样可以使用输入重定向来从文件中导入:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker load &lt; 2.tar </span>
2653d992f4ef: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">216</span>.5MB/216.5MB
Loaded image ID: sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h2><p>镜像在文件系统中以分层文件的形式储存.</p>
<h3 id="查询镜像列表"><a href="#查询镜像列表" class="headerlink" title="查询镜像列表"></a>查询镜像列表</h3><p>使用docker images命令可以列出本地镜像列表:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
ubuntu        <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果显示字段说明如下:</p>
<ul>
<li>REPOSITORY: 镜像名或镜像来源仓库.如果有Namespace也会一并显示.</li>
<li>TAG: 镜像标签,用来标记不同版本信息.</li>
<li>IMAGE ID: 镜像的ID,也是镜像的唯一标识.可以使用ID前几个字符来代替完整ID使用.</li>
<li>CREATED: 镜像的创建时间.</li>
<li>SIZE: 镜像大小,包括被共享的镜像层,实际占用储存空间可能更小.</li>
</ul>
<p>镜像多时可以使用通配符来过滤镜像:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images ubu*</span>
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="查询镜像详情"><a href="#查询镜像详情" class="headerlink" title="查询镜像详情"></a>查询镜像详情</h3><p>可以通过docker inspect命令获取镜像详细信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect ubuntu:18.04</span>
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:5a214d77f5d747e6ed81632310baa6190301feeb875cf6bf9da560108fa09972"</span>,
        <span class="token string">"RepoTags"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"base:1.0"</span>,
            <span class="token string">"ubuntu:18.04"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"RepoDigests"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"ubuntu@sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6"</span>
        <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以通过镜像ID来查询:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect 5a21</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询结果以json格式返回,可以使用输出格式化进行过滤:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker inspect -f &#123;&#123;".ContainerConfig.Hostname"&#125;&#125; alpine</span>
330289c649db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="查询镜像历史"><a href="#查询镜像历史" class="headerlink" title="查询镜像历史"></a>查询镜像历史</h3><p>可以通过docker history命令来查看组成镜像的每层具体内容:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker history --no-trunc alpine</span>
IMAGE          CREATED       CREATED BY                            SIZE      COMMENT
14119a10abf4   <span class="token number">7</span> weeks ago   /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop)  CMD ["/bin/sh"]    0B        </span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">7</span> weeks ago   /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop) ADD file:aad4290d   5.6MB </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h2><p>和镜像操作有关的一个是镜像改名,一个是上传镜像.</p>
<h3 id="镜像改名"><a href="#镜像改名" class="headerlink" title="镜像改名"></a>镜像改名</h3><p>可以使用docker tag命令来为本地镜像添加标签,再删除原镜像,来达到给镜像改名的目的.</p>
<p>例如给ubuntu:18.04镜像添加一个新的标签base:1.0:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker tag ubuntu:18.04 base:1.0</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
base          <span class="token number">1.0</span>       5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
ubuntu        <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到多了一个base:1.0的镜像,镜像ID和ubuntu:18.04一样.加标签就类似于文件硬连接功能.</p>
<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>上传镜像到仓库可以使用docker push命令.上传之前需要给目标镜像打好标签,传到Docker Hub的Namespace为用户名,传到私有仓库的Namespace变为仓库地址:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker tag alpine:latest assassing/a1:latest</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker push assassing/a1:latest</span>
The push refers to repository <span class="token punctuation">[</span>docker.io/assassing/a1<span class="token punctuation">]</span>
e2eb06d8af82: Mounted from library/alpine 
latest: digest: sha256:69704ef328d05a9f806b6b8502915e6a0a4faa4d72018dc42343f511490daf8a size: <span class="token number">528</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>安装配置</title>
    <url>/61253/</url>
    <content><![CDATA[<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>由于Docker运行于Linux内核中,因此对于系统要求如下:</p>
<ul>
<li>系统必须位为64位操作系统;</li>
<li>系统内核版本需要大于3.10;</li>
<li>硬盘要足够大.</li>
</ul>
<p>可以使用以下命令查询系统位数和内核版本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span><span class="token comment"># uname -r</span>
<span class="token number">3.10</span>.0-1160.42.2.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Docker引擎分为两个版本,社区版本(CE, Community Edition)和企业版本(EE, Enterprise Edition).通常安装社区稳定版.</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>在之前安装过Docker的主机上,需要完全卸载后再安装.</p>
<p>全新安装需要先修改仓库配置,增加docker-ce安装源:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y yum-utils</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span>
Loaded plugins: fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing <span class="token function">file</span> https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假如要安装nightly或test版本,使用下面的命令来启用对应仓库.关闭使用–disable参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum-config-manager --enable docker-ce-nightly</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum-config-manager --enable docker-ce-test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>安装最新版docker-ce:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y docker-ce docker-ce-cli containerd.io</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要安装特定版本,可以使用yum list来查询:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum list docker-ce --showduplicates | sort -r</span>
docker-ce.x86_64            <span class="token number">3</span>:20.10.9-3.el7                    docker-ce-stable 
docker-ce.x86_64            <span class="token number">3</span>:20.10.9-3.el7                    @docker-ce-stable
docker-ce.x86_64            <span class="token number">3</span>:20.10.8-3.el7                    docker-ce-stable <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如安装20.10.10版本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y docker-ce-20.10.10 docker-ce-cli-20.10.10 containerd.io</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Docker安装时会新建一个docker组,可以将普通用户加入此组,这样普通用户就能直接运行docker命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># useradd -p user10 user10</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># su -l user10</span>
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image <span class="token function">ls</span>
Got permission denied <span class="token keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="token string">"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/images/json"</span><span class="token builtin class-name">:</span> dial unix /var/run/docker.sock: connect: permission denied
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">'usermod -G docker user10'</span>
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="更新Docker"><a href="#更新Docker" class="headerlink" title="更新Docker"></a>更新Docker</h2><p>在docker仓库源启用的情况下,使用yum upgrade来更新:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum upgrade</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h2><p>使用下面的命令完全卸载Docker旧版本及相关程序:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除新版Docker引擎:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ yum remove docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除Docker使用的库,镜像和容器等数据:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># rm -rf /var/lib/docker</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># rm -rf /var/lib/containerd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><p>启动服务与设置开机启动:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now docker</span>
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>启动之后使用hello-world镜像来测试Docker功能是否正常:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker run hello-world</span>
Unable to <span class="token function">find</span> image <span class="token string">'hello-world:latest'</span> locally
latest: Pulling from library/hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="查询Docker版本"><a href="#查询Docker版本" class="headerlink" title="查询Docker版本"></a>查询Docker版本</h2><p>使用docker version命令来查询Docker服务端和客户端的版本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker version</span>
Client: Docker Engine - Community
 Version:           <span class="token number">20.10</span>.9
 API version:       <span class="token number">1.41</span>
 Go version:        go1.16.8
 Git commit:        c2ea9bc
 Built:             Mon Oct  <span class="token number">4</span> <span class="token number">16</span>:08:14 <span class="token number">2021</span>
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      <span class="token boolean">true</span>

Server: Docker Engine - Community
 Engine:
  Version:          <span class="token number">20.10</span>.9
  API version:      <span class="token number">1.41</span> <span class="token punctuation">(</span>minimum version <span class="token number">1.12</span><span class="token punctuation">)</span>
  Go version:       go1.16.8
  Git commit:       79ea9d3
  Built:            Mon Oct  <span class="token number">4</span> <span class="token number">16</span>:06:37 <span class="token number">2021</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="token boolean">false</span>
 containerd:
  Version:          <span class="token number">1.4</span>.11
  GitCommit:        5b46e404f6b9f661a205e28d59c982d3634148f8
 runc:
  Version:          <span class="token number">1.0</span>.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          <span class="token number">0.19</span>.0
  GitCommit:        de40ad0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="查看Docker信息"><a href="#查看Docker信息" class="headerlink" title="查看Docker信息"></a>查看Docker信息</h2><p>可以使用docker info来查看Docker运行状态:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># docker info</span>
Client:
 Context:    default
 Debug Mode: <span class="token boolean">false</span>
 Plugins:
  app: Docker App <span class="token punctuation">(</span>Docker Inc., v0.9.1-beta3<span class="token punctuation">)</span>
  buildx: Build with BuildKit <span class="token punctuation">(</span>Docker Inc., v0.6.3-docker<span class="token punctuation">)</span>
  scan: Docker Scan <span class="token punctuation">(</span>Docker Inc., v0.8.0<span class="token punctuation">)</span>

Server:
 Containers: <span class="token number">1</span>
  Running: <span class="token number">0</span>
  Paused: <span class="token number">0</span>
  Stopped: <span class="token number">1</span>
 Images: <span class="token number">5</span>
 Server Version: <span class="token number">20.10</span>.9
 Storage Driver: overlay2
  Backing Filesystem: xfs
  Supports d_type: <span class="token boolean">true</span>
  Native Overlay Diff: <span class="token boolean">true</span>
  userxattr: <span class="token boolean">false</span>
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: <span class="token number">1</span>
 Plugins:
  Volume: <span class="token builtin class-name">local</span>
  Network: bridge <span class="token function">host</span> ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file <span class="token builtin class-name">local</span> logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 5b46e404f6b9f661a205e28d59c982d3634148f8
 runc version: v1.0.2-0-g52b36a2
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: <span class="token number">3.10</span>.0-1160.42.2.el7.x86_64
 Operating System: CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
 OSType: linux
 Architecture: x86_64
 CPUs: <span class="token number">16</span>
 Total Memory: <span class="token number">3</span>.682GiB
 Name: server4
 ID: 7YVL:YG7U:BI3Q:BOVZ:XRWD:7BQO:6H3R:2BUW:OCQO:7JKZ:2OWC:UL2Q
 Docker Root Dir: /var/lib/docker
 Debug Mode: <span class="token boolean">false</span>
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: <span class="token boolean">false</span>
 Insecure Registries:
  <span class="token number">127.0</span>.0.0/8
 Registry Mirrors:
  https://mirror.ccs.tencentyun.com/
 Live Restore Enabled: <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用docker system df命令来查询Docker磁盘空间使用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@UAT1542 ~<span class="token punctuation">]</span><span class="token comment"># docker system df</span>
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          <span class="token number">21</span>        <span class="token number">8</span>         <span class="token number">7</span>.737GB   <span class="token number">3</span>.526GB <span class="token punctuation">(</span><span class="token number">45</span>%<span class="token punctuation">)</span>
Containers      <span class="token number">10</span>        <span class="token number">9</span>         <span class="token number">18</span>.21GB   175B <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span>
Local Volumes   <span class="token number">10</span>        <span class="token number">3</span>         <span class="token number">135</span>.9kB   <span class="token number">101</span>.9kB <span class="token punctuation">(</span><span class="token number">74</span>%<span class="token punctuation">)</span>
Build Cache     <span class="token number">0</span>         <span class="token number">0</span>         0B        0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h2><p>使用docker system prune来清理无用数据:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@UAT1542 ~<span class="token punctuation">]</span><span class="token comment"># docker system prune</span>
WARNING<span class="token operator">!</span> This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache

Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Deleted Containers:
5c6cdebbb209507a4886debe278f59cdf1dbebd6a8cfbf3b1ea32828cf3adbfa

Total reclaimed space: 175B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><p>Docker服务启动实际上是调用了dockerd命令,Docker Daemon常用启动参数如下:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>–api-cors-header&#x3D;””</td>
<td>设定远程访问API所需的cors-header</td>
</tr>
<tr>
<td>–authorization-plugin&#x3D;[]</td>
<td>设置认证插件列表</td>
</tr>
<tr>
<td>-b, –bridge&#x3D;””</td>
<td>设置容器使用的网桥</td>
</tr>
<tr>
<td>–bip&#x3D;””</td>
<td>设定网络桥IP和子网掩码</td>
</tr>
<tr>
<td>-D, –debug&#x3D;false</td>
<td>启动Debug模式</td>
</tr>
<tr>
<td>-d, –daemon&#x3D;false</td>
<td>启动守护进程模式</td>
</tr>
<tr>
<td>–default-gateway&#x3D;””</td>
<td>设置容器使用的IPv4网关</td>
</tr>
<tr>
<td>–dns&#x3D;[]</td>
<td>设置容器使用的DNS服务器列表</td>
</tr>
<tr>
<td>–default-ulimit&#x3D;[]</td>
<td>设定容器默认的ulimit参数</td>
</tr>
<tr>
<td>-exec-opt&#x3D;[]</td>
<td>设定管理容器使用的参数</td>
</tr>
<tr>
<td>–exec-root&#x3D;”&#x2F;var&#x2F;run&#x2F;Docker”</td>
<td>设定exec-driver默认根目录地址</td>
</tr>
<tr>
<td>–fixed-cidr&#x3D;””</td>
<td>设定容器使用的IPv4子网段</td>
</tr>
<tr>
<td>-G, –group&#x3D;”Docker”</td>
<td>设定UNIX Socket文件用户所属组</td>
</tr>
<tr>
<td>-g, –graph&#x3D;”&#x2F;var&#x2F;lib&#x2F;Docker”</td>
<td>设定Docker服务运行时的根目录</td>
</tr>
<tr>
<td>-H, –host&#x3D;[]</td>
<td>设定Docker服务监听地址</td>
</tr>
<tr>
<td>–icc&#x3D;ture</td>
<td>允许容器之间互相通信</td>
</tr>
<tr>
<td>–insecure-registry&#x3D;[]</td>
<td>设定可信任仓库地址</td>
</tr>
<tr>
<td>–ip&#x3D;0.0.0.0</td>
<td>设定绑定容器端口信息时的默认IP</td>
</tr>
<tr>
<td>–ip-forward&#x3D;true</td>
<td>允许转发IPv4数据包</td>
</tr>
<tr>
<td>–ip-masq&#x3D;true</td>
<td>允许IP伪装</td>
</tr>
<tr>
<td>–iptables&#x3D;true</td>
<td>允许修改iptables规则</td>
</tr>
<tr>
<td>–ipv6&#x3D;true</td>
<td>允许使用IPv6网络</td>
</tr>
<tr>
<td>-l, –log-level&#x3D;”info”</td>
<td>设定日志输出等级</td>
</tr>
<tr>
<td>–label&#x3D;[]</td>
<td>按照Key&#x3D;Value设定Daemon标签</td>
</tr>
<tr>
<td>–log-driver&#x3D;”json-file”</td>
<td>设定日志驱动格式</td>
</tr>
<tr>
<td>–log-opt&#x3D;[]</td>
<td>设定日志记录驱动参数</td>
</tr>
<tr>
<td>–mtu&#x3D;0</td>
<td>设定容器MTU值</td>
</tr>
<tr>
<td>-p, –pidfile&#x3D;”&#x2F;var&#x2F;run&#x2F;Docker.pid”</td>
<td>设定Docker.pid文件路径</td>
</tr>
<tr>
<td>–registry-mirror&#x3D;[]</td>
<td>设定优先访问的仓库镜像地址</td>
</tr>
<tr>
<td>-s, –storage-driver&#x3D;””</td>
<td>设定数据储存驱动方式</td>
</tr>
<tr>
<td>–selinux-enabled&#x3D;false</td>
<td>启动SELinux</td>
</tr>
<tr>
<td>–storage-opt&#x3D;[]</td>
<td>设定数据储存驱动参数</td>
</tr>
<tr>
<td>–tls&#x3D;false</td>
<td>启动TLS,但不启用客户端认证</td>
</tr>
<tr>
<td>–tlscacert&#x3D;”~&#x2F;.Docker&#x2F;ca.pem”</td>
<td>设定CA证书位置</td>
</tr>
<tr>
<td>–tlscert&#x3D;”~&#x2F;.Docker&#x2F;cert.pem”</td>
<td>设定TLS证书位置</td>
</tr>
<tr>
<td>–tlskey&#x3D;”~&#x2F;.Docker&#x2F;key.pem”</td>
<td>设定TLS密钥位置</td>
</tr>
<tr>
<td>–tlsverify&#x3D;false</td>
<td>启动TLS来验证远程访问请求</td>
</tr>
<tr>
<td>–userland-proxy&#x3D;true</td>
<td>启动指定的网络代理</td>
</tr>
<tr>
<td>-v, –version&#x3D;false</td>
<td>输出Docker版本信息</td>
</tr>
</tbody></table>
<p>如果参数后有[]标记,代表此参数可以使用多次.例如开启Debug模式,并监听本地2376端口:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># dockerd -D -H tcp:/127.0.0.1:2376</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以将启动参数写入&#x2F;etc&#x2F;docker&#x2F;daemon.json内,由dockerd服务启动时读取.注意不能同启动配置文件有同样的配置项,否则启动会报错.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/docker/daemon.json</span>
<span class="token punctuation">&#123;</span>
        <span class="token string">"debug"</span><span class="token builtin class-name">:</span> true,
        <span class="token string">"hosts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"tcp://127.0.0.1:2376"</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以修改文件&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service中ExecStart后面的参数来配置启动参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># vi /usr/lib/systemd/system/docker.service </span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd <span class="token parameter variable">-H</span> fd:// <span class="token parameter variable">--containerd</span><span class="token operator">=</span>/run/containerd/containerd.sock <span class="token parameter variable">-H</span> tcp://192.168.2.234:5999
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>关于本站</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>本地创作用 Typora 编写文档，完成后通过 hexo 生成静态网页，并自动上传到 github 仓库。</p>
<p>本地服务器上运行带 git 命令的容器，周期性拉取 github 仓库更新到指定目录。</p>
<p>本地服务器上运行 nginx 容器，将域名指向 git 拉取到的仓库内容，自动完成更新。</p>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
