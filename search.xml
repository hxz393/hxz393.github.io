<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 NFS 同步 K8s 配置</title>
    <url>/1345941684/</url>
    <content><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
<p>在 K8s 中，可以使用 NFS 网络文件系统服务，来共享与备份发布有关的 YAML 文件和部分服务配置文件。</p>
<p>本地环境中，需要用到 NFS 服务的有：</p>
<ul>
<li>k8s-101、k8s-102、k8s-103：K8s 主节点，同步 <code>/hxz393</code> 目录。用于存放集群发布文件和配置。</li>
<li>k8s-106：专职备份节点，共享 <code>/backup</code> 目录。</li>
</ul>
<p>如果生产环境使用的云服务商，可以直接购买云服务商提供的 NFS 服务，价格便宜且稳定。购买之后，只需要将其挂载并开机挂载到本地指定目录即可。</p>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<p>在 4 个节点上使用 <code>yum</code> 安装并启动相关服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install nfs-utils rpcbind -y</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now rpcbind</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now nfs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h1>
<p>增加 NFS 最大连接客户端数量,默认为 2:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "options sunrpc tcp_slot_table_entries=128" >> /etc/modprobe.d/sunrpc.conf</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "options sunrpc tcp_max_slot_table_entries=128" >>  /etc/modprobe.d/sunrpc.conf</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sysctl -w sunrpc.tcp_slot_table_entries=128</span>
sunrpc.tcp_slot_table_entries <span class="token operator">=</span> <span class="token number">128</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart rpcbind &amp;&amp; systemctl restart nfs-server</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1>
<p>在主节点上新建目录 <code>/hxz393</code>，配置成共享并立即生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /hxz393</span>
<span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># echo -e "/hxz393 *(rw,no_root_squash,sync,no_subtree_check)">>/etc/exports</span>
<span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># exportfs -r</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同样在备份节点上新建并共享目录 <code>/backup</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-106 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /backup</span>
<span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># echo -e "/backup *(rw,no_root_squash,sync,no_subtree_check)">>/etc/exports</span>
<span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># exportfs -r</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="查看"><a class="markdownIt-Anchor" href="#查看"></a> 查看</h1>
<p>查询挂载目录，验证配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># showmount -e k8s-101</span>
Export list <span class="token keyword">for</span> k8s-101:
/hxz393 *
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># showmount -e 192.168.1.106</span>
Export list <span class="token keyword">for</span> <span class="token number">192.168</span>.1.106:
/backup *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h1>
<p>挂载命令为 <code>mount</code> 后面接远程目录和本地目录。本地目录需要事先建立好：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /backup</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mount 192.168.1.106:/backup /backup</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以按需求，将 NFS 共享目录设为开机挂载。只需要将挂载命令写入到 <code>/etc/rc.d/rc.local</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "mount 192.168.1.106:/backup /backup" >>/etc/rc.d/rc.local</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># chmod ug+x /etc/rc.d/rc.local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但这样做会有个风险：如果在开机时网络未就绪或 NFS 服务器无法访问，那么在等待很长一段时间后会挂载失败。之后在系统中任何对挂载目录的操作，都会卡成僵尸。</p>
<p>所以保守点还是在需要用的时候挂载，不需要用了及时卸载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># umount /backup</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h1>
<p>对主节点上关键目录 <code>/hxz393</code> 用 <code>rsync</code> + <code>inotify</code> 做同步。先安装工具：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum -y install rsync inotify-tools</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改 k8s-101 上 rsync 配置文件如下。节点 k8s-102 和 k8s-103 只能从 k8s-101 单向同步，因此配置文件中将 <code>master_web</code> 改为 <code>slave_web</code>。具体配置说明可见注释：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /etc/rsyncd.conf&lt;&lt;EOF</span>
<span class="token comment">#rsync通用配置文件,配置的注释不要写在配置后面</span>
uid <span class="token operator">=</span> root
gid <span class="token operator">=</span> root
use <span class="token function">chroot</span> <span class="token operator">=</span> <span class="token number">0</span>
port <span class="token operator">=</span> <span class="token number">873</span>
<span class="token comment">##允许ip访问设置</span>
hosts allow <span class="token operator">=</span> <span class="token number">192.168</span>.1.0/24
max connections <span class="token operator">=</span> <span class="token number">0</span>
<span class="token function">timeout</span> <span class="token operator">=</span> <span class="token number">300</span>
pid <span class="token function">file</span> <span class="token operator">=</span> /var/run/rsyncd.pid
lock <span class="token function">file</span> <span class="token operator">=</span> /var/run/rsyncd.lock
log <span class="token function">file</span> <span class="token operator">=</span> /var/log/rsyncd.log
log <span class="token function">format</span> <span class="token operator">=</span> %t %a %m %f %b
transfer logging <span class="token operator">=</span> <span class="token function">yes</span>
syslog facility <span class="token operator">=</span> local3
<span class="token comment">#方括号中为模块声明,这里master_web对应了主web机配置,从服务器可都为[slave_web],方便inotify脚本配置</span>
<span class="token punctuation">[</span>master_web<span class="token punctuation">]</span>
<span class="token comment">#指定当前模块在rsync服务器上的同步路径，该参数是必须指定的</span>
path <span class="token operator">=</span> /hxz393/
<span class="token comment">#注释,可以同模块名一样,从服务器可都为slave_web</span>
comment <span class="token operator">=</span> master_web
ignore errors
<span class="token comment">##是否允许客户端上传文件</span>
<span class="token builtin class-name">read</span> only <span class="token operator">=</span> no
list <span class="token operator">=</span> no
<span class="token comment">##指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块</span>
auth <span class="token function">users</span> <span class="token operator">=</span> <span class="token function">rsync</span>
<span class="token comment">##保存密码和用户名文件，需要自己生成</span>
secrets <span class="token function">file</span> <span class="token operator">=</span> /etc/rsyncd.passwd
EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成密码文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "rsync:kKWA.J2V3tq3" > /etc/rsyncd.passwd</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /hxz393/local/nfs/config</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "kKWA.J2V3tq3" > /hxz393/local/nfs/config/rsyncd.passwd</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># chmod 600 /etc/rsyncd.passwd /hxz393/local/nfs/config/rsyncd.passwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart rsyncd</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable rsyncd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 k8s-101 上测试下同步 <code>/hxz393</code> 到 k8s-102：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># rsync -avzp --delete  /hxz393/ rsync@192.168.1.102::slave_web --password-file=/hxz393/local/nfs/config/rsyncd.passwd</span>
sending incremental <span class="token function">file</span> list
./
local/
local/k8s/
local/k8s/apply/
local/k8s/apply/kube-flannel.yml
local/k8s/apply/kube-namespaces.yml
local/k8s/config/
local/k8s/config/admin.conf
local/k8s/config/kubeadm-config.yaml
local/nfs/
local/nfs/config/
local/nfs/config/rsyncd.passwd

sent <span class="token number">6,380</span> bytes  received <span class="token number">156</span> bytes  <span class="token number">13,072</span>.00 bytes/sec
total size is <span class="token number">11,704</span>  speedup is <span class="token number">1.79</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同步测试没问题后，在 k8s-101 上写入开机自启动脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># vi /hxz393/local/nfs/rsync.sh</span>
<span class="token comment">#!/bin/bash</span>
<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>

<span class="token assign-left variable">host1</span><span class="token operator">=</span><span class="token string">"192.168.1.102"</span>
<span class="token assign-left variable">host2</span><span class="token operator">=</span><span class="token string">"192.168.1.103"</span>
<span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">"/hxz393/"</span>
<span class="token assign-left variable">des</span><span class="token operator">=</span><span class="token string">"slave_web"</span>
<span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token string">"/hxz393/local/nfs/config/rsyncd.passwd"</span>
<span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token string">"rsync"</span>
<span class="token assign-left variable">inotifywait</span><span class="token operator">=</span><span class="token string">"/usr/bin/inotifywait"</span>
<span class="token assign-left variable">log</span><span class="token operator">=</span><span class="token string">"/tmp/rsync.log"</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$&#123;inotifywait&#125;</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"inotifywait tool does not exist."</span>
    <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>

<span class="token variable">$&#123;inotifywait&#125;</span> <span class="token parameter variable">-mrq</span> <span class="token parameter variable">--timefmt</span> <span class="token string">'%Y%m%d %H:%M'</span> <span class="token parameter variable">--format</span> <span class="token string">'%T %w%f%e'</span> <span class="token parameter variable">-e</span> modify,delete,create,attrib <span class="token variable">$&#123;src&#125;</span> <span class="token punctuation">\</span>
<span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> files <span class="token punctuation">;</span><span class="token keyword">do</span>
 <span class="token function">rsync</span> <span class="token parameter variable">-avzP</span> <span class="token parameter variable">--delete</span> <span class="token parameter variable">--timeout</span><span class="token operator">=</span><span class="token number">100</span> --password-file<span class="token operator">=</span><span class="token variable">$&#123;password&#125;</span> <span class="token variable">$&#123;src&#125;</span> <span class="token variable">$&#123;user&#125;</span>@<span class="token variable">$&#123;host1&#125;</span>::<span class="token variable">$&#123;des&#125;</span> <span class="token operator">>></span><span class="token variable">$&#123;log&#125;</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span>
 <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;files&#125;</span> 同步到<span class="token variable">$&#123;host1&#125;</span>"</span> <span class="token operator">>></span><span class="token variable">$&#123;log&#125;</span>
 <span class="token function">rsync</span> <span class="token parameter variable">-avzP</span> <span class="token parameter variable">--delete</span> <span class="token parameter variable">--timeout</span><span class="token operator">=</span><span class="token number">100</span> --password-file<span class="token operator">=</span><span class="token variable">$&#123;password&#125;</span> <span class="token variable">$&#123;src&#125;</span> <span class="token variable">$&#123;user&#125;</span>@<span class="token variable">$&#123;host2&#125;</span>::<span class="token variable">$&#123;des&#125;</span> <span class="token operator">>></span><span class="token variable">$&#123;log&#125;</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span>
 <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;files&#125;</span> 同步到<span class="token variable">$&#123;host2&#125;</span>"</span> <span class="token operator">>></span><span class="token variable">$&#123;log&#125;</span>
<span class="token keyword">done</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># bash -n /hxz393/local/nfs/rsync.sh</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># chmod 755 /hxz393/local/nfs/rsync.sh</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "nohup bash /hxz393/local/nfs/rsync.sh > /tmp/rsync.sh.log 2>&amp;1 &amp;" >> /etc/rc.d/rc.local</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># chmod 744 /etc/rc.d/rc.local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>4.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>使用 KubeSphere 作为 K8s 管理平台</title>
    <url>/1139906495/</url>
    <content><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
<p>KubeSphere 是一个开放源代码的、基于 Kubernetes 构建的集群管理系统。对比使用 <code>kubectl</code> 命令来管理集群，KubeSphere 能帮助用户简化Kubernetes的使用，并优化云原生应用的管理和开发。</p>
<p>全中文官方文档：<a href="https://kubesphere.io/zh/docs/">https://kubesphere.io/zh/docs/</a></p>
<h1 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h1>
<p>部署当前最新版本 v3.3.2。</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<p>先从 Github 上把部署和配置文件下载下来:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /hxz393/local/kubesphere/apply</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cd /hxz393/local/kubesphere/apply</span>
<span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.2/kubesphere-installer.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.2/cluster-configuration.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>按需要修改配置文件，内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cat /hxz393/local/kubesphere/apply/cluster-configuration.yaml</span>
---
apiVersion: installer.kubesphere.io/v1alpha1
kind: ClusterConfiguration
metadata:
  name: ks-installer
  namespace: kubesphere-system
  labels:
    version: v3.3.2
spec:
  persistence:
    storageClass: <span class="token string">"longhorn"</span>   <span class="token comment"># If there is no default StorageClass in your cluster, you need to specify an existing StorageClass here.</span>
  authentication:
    <span class="token comment"># adminPassword: ""     # Custom password of the admin user. If the parameter exists but the value is empty, a random password is generated. If the parameter does not exist, P@88w0rd is used.</span>
    jwtSecret: <span class="token string">""</span>           <span class="token comment"># Keep the jwtSecret consistent with the Host Cluster. Retrieve the jwtSecret by executing "kubectl -n kubesphere-system get cm kubesphere-config -o yaml | grep -v "apiVersion" | grep jwtSecret" on the Host Cluster.</span>
  local_registry: <span class="token string">""</span>        <span class="token comment"># Add your private registry address if it is needed.</span>
  <span class="token comment"># dev_tag: ""               # Add your kubesphere image tag you want to install, by default it's same as ks-installer release version.</span>
  etcd:
    monitoring: <span class="token boolean">true</span>        <span class="token comment"># Enable or disable etcd monitoring dashboard installation. You have to create a Secret for etcd before you enable it.</span>
    endpointIps: <span class="token string">"192.168.1.101,192.168.1.102,192.168.1.103"</span>  <span class="token comment"># etcd cluster EndpointIps. It can be a bunch of IPs here.</span>
    port: <span class="token number">2379</span>              <span class="token comment"># etcd port.</span>
    tlsEnable: <span class="token boolean">true</span>
  common:
    core:
      console:
        enableMultiLogin: <span class="token boolean">true</span>  <span class="token comment"># Enable or disable simultaneous logins. It allows different users to log in with the same account at the same time.</span>
        port: <span class="token number">10004</span>
        type: NodePort

    <span class="token comment"># apiserver:            # Enlarge the apiserver and controller manager's resource requests and limits for the large cluster</span>
    <span class="token comment">#  resources: &#123;&#125;</span>
    <span class="token comment"># controllerManager:</span>
    <span class="token comment">#  resources: &#123;&#125;</span>
    redis:
      enabled: <span class="token boolean">false</span>
      enableHA: <span class="token boolean">false</span>
      volumeSize: 2Gi <span class="token comment"># Redis PVC size.</span>
    openldap:
      enabled: <span class="token boolean">false</span>
      volumeSize: 2Gi   <span class="token comment"># openldap PVC size.</span>
    minio:
      volumeSize: 20Gi <span class="token comment"># Minio PVC size.</span>
    monitoring:
      <span class="token comment"># type: external   # Whether to specify the external prometheus stack, and need to modify the endpoint at the next line.</span>
      endpoint: http://prometheus-operated.kubesphere-monitoring-system.svc:9090 <span class="token comment"># Prometheus endpoint to get metrics data.</span>
      GPUMonitoring:     <span class="token comment"># Enable or disable the GPU-related metrics. If you enable this switch but have no GPU resources, Kubesphere will set it to zero.</span>
        enabled: <span class="token boolean">false</span>
    gpu:                 <span class="token comment"># Install GPUKinds. The default GPU kind is nvidia.com/gpu. Other GPU kinds can be added here according to your needs.</span>
      kinds:
      - resourceName: <span class="token string">"nvidia.com/gpu"</span>
        resourceType: <span class="token string">"GPU"</span>
        default: <span class="token boolean">true</span>
    es:   <span class="token comment"># Storage backend for logging, events and auditing.</span>
      master:
        volumeSize: 1Gi  <span class="token comment"># The volume size of Elasticsearch master nodes.</span>
        replicas: <span class="token number">1</span>      <span class="token comment"># The total number of master nodes. Even numbers are not allowed.</span>
      <span class="token comment">#   resources: &#123;&#125;</span>
      data:
        volumeSize: 10Gi  <span class="token comment"># The volume size of Elasticsearch data nodes.</span>
        replicas: <span class="token number">1</span>       <span class="token comment"># The total number of data nodes.</span>
      <span class="token comment">#   resources: &#123;&#125;</span>
      logMaxAge: <span class="token number">7</span>             <span class="token comment"># Log retention time in built-in Elasticsearch. It is 7 days by default.</span>
      elkPrefix: logstash      <span class="token comment"># The string making up index names. The index name will be formatted as ks-&lt;elk_prefix>-log.</span>
      basicAuth:
        enabled: <span class="token boolean">false</span>
        username: <span class="token string">""</span>
        password: <span class="token string">""</span>
      externalElasticsearchHost: <span class="token string">""</span>
      externalElasticsearchPort: <span class="token string">""</span>
  alerting:                <span class="token comment"># (CPU: 0.1 Core, Memory: 100 MiB) It enables users to customize alerting policies to send messages to receivers in time with different time intervals and alerting levels to choose from.</span>
    enabled: <span class="token boolean">true</span>         <span class="token comment"># Enable or disable the KubeSphere Alerting System.</span>
    thanosruler:
      replicas: <span class="token number">1</span>
  auditing:                <span class="token comment"># Provide a security-relevant chronological set of records，recording the sequence of activities happening on the platform, initiated by different tenants.</span>
    enabled: <span class="token boolean">true</span>          <span class="token comment"># Enable or disable the KubeSphere Auditing Log System.</span>
    <span class="token comment"># operator:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment"># webhook:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
  devops:                  <span class="token comment"># (CPU: 0.47 Core, Memory: 8.6 G) Provide an out-of-the-box CI/CD system based on Jenkins, and automated workflow tools including Source-to-Image &amp; Binary-to-Image.</span>
    enabled: <span class="token boolean">false</span>             <span class="token comment"># Enable or disable the KubeSphere DevOps System.</span>
    <span class="token comment"># resources: &#123;&#125;</span>
    jenkinsMemoryLim: 4Gi      <span class="token comment"># Jenkins memory limit.</span>
    jenkinsMemoryReq: 2Gi   <span class="token comment"># Jenkins memory request.</span>
    jenkinsVolumeSize: 8Gi     <span class="token comment"># Jenkins volume size.</span>
  events:                  <span class="token comment"># Provide a graphical web console for Kubernetes Events exporting, filtering and alerting in multi-tenant Kubernetes clusters.</span>
    enabled: <span class="token boolean">true</span>          <span class="token comment"># Enable or disable the KubeSphere Events System.</span>
    <span class="token comment"># operator:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment"># exporter:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    ruler:
      enabled: <span class="token boolean">true</span>
      replicas: <span class="token number">1</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
  logging:                 <span class="token comment"># (CPU: 57 m, Memory: 2.76 G) Flexible logging functions are provided for log query, collection and management in a unified console. Additional log collectors can be added, such as Elasticsearch, Kafka and Fluentd.</span>
    enabled: <span class="token boolean">true</span>         <span class="token comment"># Enable or disable the KubeSphere Logging System.</span>
    logsidecar:
      enabled: <span class="token boolean">true</span>
      replicas: <span class="token number">1</span>
      <span class="token comment"># resources: &#123;&#125;</span>
  metrics_server:                    <span class="token comment"># (CPU: 56 m, Memory: 44.35 MiB) It enables HPA (Horizontal Pod Autoscaler).</span>
    enabled: <span class="token boolean">true</span>                   <span class="token comment"># Enable or disable metrics-server.</span>
  monitoring:
    storageClass: <span class="token string">"longhorn"</span>                 <span class="token comment"># If there is an independent StorageClass you need for Prometheus, you can specify it here. The default StorageClass is used by default.</span>
    node_exporter:
      port: <span class="token number">9100</span>
      <span class="token comment"># resources: &#123;&#125;</span>
    <span class="token comment"># kube_rbac_proxy:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment"># kube_state_metrics:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    prometheus:
      replicas: <span class="token number">1</span>  <span class="token comment"># Prometheus replicas are responsible for monitoring different segments of data source and providing high availability.</span>
      volumeSize: 5Gi  <span class="token comment"># Prometheus PVC size.</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment">#   operator:</span>
    <span class="token comment">#     resources: &#123;&#125;</span>
    alertmanager:
      replicas: <span class="token number">1</span>          <span class="token comment"># AlertManager Replicas.</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    notification_manager:
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment">#   operator:</span>
    <span class="token comment">#     resources: &#123;&#125;</span>
    <span class="token comment">#   proxy:</span>
    <span class="token comment">#     resources: &#123;&#125;</span>
    gpu:                           <span class="token comment"># GPU monitoring-related plug-in installation.</span>
      nvidia_dcgm_exporter:        <span class="token comment"># Ensure that gpu resources on your hosts can be used normally, otherwise this plug-in will not work properly.</span>
        enabled: <span class="token boolean">false</span>             <span class="token comment"># Check whether the labels on the GPU hosts contain "nvidia.com/gpu.present=true" to ensure that the DCGM pod is scheduled to these nodes.</span>
        <span class="token comment"># resources: &#123;&#125;</span>
  multicluster:
    clusterRole: none  <span class="token comment"># host | member | none  # You can install a solo cluster, or specify it as the Host or Member Cluster.</span>
  network:
    networkpolicy: <span class="token comment"># Network policies allow network isolation within the same cluster, which means firewalls can be set up between certain instances (Pods).</span>
      <span class="token comment"># Make sure that the CNI network plugin used by the cluster supports NetworkPolicy. There are a number of CNI network plugins that support NetworkPolicy, including Calico, Cilium, Kube-router, Romana and Weave Net.</span>
      enabled: <span class="token boolean">false</span> <span class="token comment"># Enable or disable network policies.</span>
    ippool: <span class="token comment"># Use Pod IP Pools to manage the Pod network address space. Pods to be created can be assigned IP addresses from a Pod IP Pool.</span>
      type: none <span class="token comment"># Specify "calico" for this field if Calico is used as your CNI plugin. "none" means that Pod IP Pools are disabled.</span>
    topology: <span class="token comment"># Use Service Topology to view Service-to-Service communication based on Weave Scope.</span>
      type: <span class="token string">"weave-scope"</span> <span class="token comment"># Specify "weave-scope" for this field to enable Service Topology. "none" means that Service Topology is disabled.</span>
  openpitrix: <span class="token comment"># An App Store that is accessible to all platform tenants. You can use it to manage apps across their entire lifecycle.</span>
    store:
      enabled: <span class="token boolean">false</span> <span class="token comment"># Enable or disable the KubeSphere App Store.</span>
  servicemesh:         <span class="token comment"># (0.3 Core, 300 MiB) Provide fine-grained traffic management, observability and tracing, and visualized traffic topology.</span>
    enabled: <span class="token boolean">false</span>     <span class="token comment"># Base component (pilot). Enable or disable KubeSphere Service Mesh (Istio-based).</span>
    istio:  <span class="token comment"># Customizing the istio installation configuration, refer to https://istio.io/latest/docs/setup/additional-setup/customize-installation/</span>
      components:
        ingressGateways:
        - name: istio-ingressgateway
          enabled: <span class="token boolean">false</span>
        cni:
          enabled: <span class="token boolean">false</span>
  edgeruntime:          <span class="token comment"># Add edge nodes to your cluster and deploy workloads on edge nodes.</span>
    enabled: <span class="token boolean">false</span>
    kubeedge:        <span class="token comment"># kubeedge configurations</span>
      enabled: <span class="token boolean">false</span>
      cloudCore:
        cloudHub:
          advertiseAddress: <span class="token comment"># At least a public IP address or an IP address which can be accessed by edge nodes must be provided.</span>
            - <span class="token string">""</span>            <span class="token comment"># Note that once KubeEdge is enabled, CloudCore will malfunction if the address is not provided.</span>
        service:
          cloudhubNodePort: <span class="token string">"30000"</span>
          cloudhubQuicNodePort: <span class="token string">"30001"</span>
          cloudhubHttpsNodePort: <span class="token string">"30002"</span>
          cloudstreamNodePort: <span class="token string">"30003"</span>
          tunnelNodePort: <span class="token string">"30004"</span>
        <span class="token comment"># resources: &#123;&#125;</span>
        <span class="token comment"># hostNetWork: false</span>
      iptables-manager:
        enabled: <span class="token boolean">true</span> 
        mode: <span class="token string">"external"</span>
        <span class="token comment"># resources: &#123;&#125;</span>
      <span class="token comment"># edgeService:</span>
      <span class="token comment">#   resources: &#123;&#125;</span>
  gatekeeper:        <span class="token comment"># Provide admission policy and rule management, A validating (mutating TBA) webhook that enforces CRD-based policies executed by Open Policy Agent.</span>
    enabled: <span class="token boolean">false</span>   <span class="token comment"># Enable or disable Gatekeeper.</span>
    <span class="token comment"># controller_manager:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
    <span class="token comment"># audit:</span>
    <span class="token comment">#   resources: &#123;&#125;</span>
  terminal:
    <span class="token comment"># image: 'alpine:3.15' # There must be an nsenter program in the image</span>
    timeout: <span class="token number">600</span>         <span class="token comment"># Container timeout, if set to 0, no timeout will be used. The unit is seconds</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加监控访问 <code>etcd</code> 的 <code>secret</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl create ns kubesphere-monitoring-system</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  \</span>
--from-file<span class="token operator">=</span>etcd-client-ca.crt<span class="token operator">=</span>/etc/kubernetes/pki/etcd/ca.crt  <span class="token punctuation">\</span>
--from-file<span class="token operator">=</span>etcd-client.crt<span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.crt  <span class="token punctuation">\</span>
--from-file<span class="token operator">=</span>etcd-client.key<span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开始部署:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/kubesphere/apply/kubesphere-installer.yaml</span>
customresourcedefinition.apiextensions.k8s.io/clusterconfigurations.installer.kubesphere.io created
namespace/kubesphere-system created
serviceaccount/ks-installer created
clusterrole.rbac.authorization.k8s.io/ks-installer created
clusterrolebinding.rbac.authorization.k8s.io/ks-installer created
deployment.apps/ks-installer created
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/kubesphere/apply/cluster-configuration.yaml</span>
clusterconfiguration.installer.kubesphere.io/ks-installer created
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>持续观察 <code>ks-installer</code> 的日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-installer -o jsonpath='&#123;.items[0].metadata.name&#125;') -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>直到日志出现登录账号信息：</p>
<blockquote>
<p>#####################################################</p>
<p>Console: <a href="http://192.168.1.101:10004">http://192.168.1.101:10004</a><br />
Account: admin<br />
Password: P@88w0rd<br />
NOTES：</p>
<pre><code>1. After you log into the console, please check the
   monitoring status of service components in
   &quot;Cluster Management&quot;. If any service is not
   ready, please wait patiently until all components 
   are up and running.
2. Please change the default password after login.
</code></pre>
<p>#####################################################<br />
<a href="https://kubesphere.io">https://kubesphere.io</a>             2023-05-21 23:20:30<br />
#####################################################</p>
</blockquote>
<p>表示安装已经初步完成，可以通过上面提示地址来访问 KubeSphere了。</p>
<h2 id="升级"><a class="markdownIt-Anchor" href="#升级"></a> 升级</h2>
<p>必须逐个副版本升级。比如升级到最新的 v3.3.0 必须从 v3.2.x 升级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/kubesphere-installer.yaml  --force</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/kubesphere/apply/cluster-configuration.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-installer -o jsonpath='&#123;.items[0].metadata.name&#125;') -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2>
<p>到官方仓库脚本目录下，找到<a href="https://github.com/kubesphere/ks-installer/blob/master/scripts/kubesphere-delete.sh">删除脚本</a>。下载到本地，修改权限后执行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cd /hxz393/local/kubesphere/apply/</span>
<span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># curl -JLO https://raw.githubusercontent.com/kubesphere/ks-installer/master/scripts/kubesphere-delete.sh</span>
<span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># chmod 744 kubesphere-delete.sh </span>
<span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># ./kubesphere-delete.sh </span>
Note:

Delete the KubeSphere cluster, including the module kubesphere-system kubesphere-devops-system kubesphere-devops-worker kubesphere-monitoring-system kubesphere-logging-system openpitrix-system.
Please reconfirm that you want to delete the KubeSphere cluster.  <span class="token punctuation">(</span>yes/no<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果删除时候卡住，可以置 <code>finalizers</code> 为空。例如删除 <code>rulers.events.kubesphere.io</code> 时卡住，执行 <code>kubectl patch</code> 给 <code>finalizers</code> 参数打补丁：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># kubectl patch crd/rulers.events.kubesphere.io -p '&#123;"metadata":&#123;"finalizers":[]&#125;&#125;' --type=merge</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1>
<p>一般配置在网页端完成。</p>
<h2 id="修改密码"><a class="markdownIt-Anchor" href="#修改密码"></a> 修改密码</h2>
<p>部署完毕后，可以通过浏览器访问前端页面。默认登录用户名 <code>admin</code>，默认密码 <code>P@88w0rd</code>。登录后修改管理员密码。</p>
<p>如忘记集群管理员密码，需要在 host 集群运行命令重置密码。下面把管理员密码设置为 <code>cXrHk1111</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># kubectl patch users admin -p '&#123;"spec":&#123;"password":"cXrHk1111"&#125;&#125;' --type='merge' &amp;&amp; kubectl annotate users admin iam.kubesphere.io/password-encrypted-</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其他集群主节点运行修改命令并不会生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 apply<span class="token punctuation">]</span><span class="token comment"># kubectl get users</span>
NAME      EMAIL                   STATUS
admin     admin@kubesphere.io     Active
hxz393    hxz393@x2b.net          Active<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建用户"><a class="markdownIt-Anchor" href="#创建用户"></a> 创建用户</h2>
<p>创建一个只有普通查看权限的用户 <code>hxz393</code>。</p>
<p>在“平台管理”&gt;“访问控制”&gt;“平台角色”中，新建一个平台角色 <code>viewer</code>：</p>
<ul>
<li>在集群中，勾选查看权限。</li>
<li>在访问控制中，勾选所有查看权限。</li>
<li>点击确定来保存。</li>
</ul>
<p>在“平台管理”&gt;“访问控制”&gt;“用户”中，新建一个用户 <code>hxz393</code>：</p>
<ul>
<li>平台角色选择 <code>viewer</code>。</li>
<li>邮箱地址设置为 <code>hxz393@x2b.net</code>。</li>
<li>密码设置为 <code>CQ*^[t=&gt;o;F84HfCF]FpaD#H_u&amp;3K.?OBv2NI#Xd,4l-X+Qggl*ke*1[nN*n~O[^</code>。</li>
<li>点击确定来保存。</li>
</ul>
<p>如果普通用户忘记密码，管理员没法为其修改密码，只能删除后重建。</p>
<h2 id="安装插件"><a class="markdownIt-Anchor" href="#安装插件"></a> 安装插件</h2>
<p>使用管理员账号登录，在“集群管理”&gt;“定制资源定义”中搜索 <code>clusterconfiguration</code>，点击进去。</p>
<p>编辑 <code>ks-installer</code> 的 yaml 文件，修改对应插件 <code>enabled</code> 的值为 <code>true</code>，点击确定即可在后台更新安装。</p>
<h2 id="配置报警"><a class="markdownIt-Anchor" href="#配置报警"></a> 配置报警</h2>
<p>在“平台管理”&gt;“平台设置”中，选择“通知管理”&gt;“通知渠道”&gt;“钉钉”，配置将报警信息发送给钉钉群：</p>
<ul>
<li>
<p>在钉钉群机器人设置页面，输入Webhook URL 地址。</p>
</li>
<li>
<p>输入 Secret 密钥。</p>
</li>
<li>
<p>在过滤条件中选择告警级别，包含所有级别报警。</p>
</li>
<li>
<p>点击发送测试信息测试连通性，没问题后点击确认保存。</p>
</li>
</ul>
<h2 id="配置域名"><a class="markdownIt-Anchor" href="#配置域名"></a> 配置域名</h2>
<p>添加 Nginx 配置，来通过域名 <code>kubesphere.x2b.net</code> 访问服务。示例如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># vi /hxz393/local/nginx/config/conf.d/kubesphere.x2b.net.conf</span>
server <span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    listen <span class="token number">443</span> ssl<span class="token punctuation">;</span>
    server_name kubesphere.x2b.net<span class="token punctuation">;</span>

    ssl_certificate   /cert/x2b.net.pem<span class="token punctuation">;</span>
    ssl_certificate_key  /cert/x2b.net.key<span class="token punctuation">;</span>
    ssl_session_timeout 5m<span class="token punctuation">;</span>
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span class="token operator">!</span>NULL:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5:<span class="token operator">!</span>ADH:<span class="token operator">!</span>RC4<span class="token punctuation">;</span>
    ssl_protocols TLSv1.2 TLSv1.3 SSLv3<span class="token punctuation">;</span>
    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>
    location / <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system/<span class="token punctuation">;</span>
        proxy_set_header Host   <span class="token variable">$host</span><span class="token punctuation">;</span>
        proxy_set_header X-Real-IP      <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    location /api/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /apis/monitoring.coreos.com/ <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /api/v1/ <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        <span class="token comment"># proxy_redirect off;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /api/clusters/ <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        <span class="token comment"># proxy_redirect off;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	
    location /apis/storage.k8s.io <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /apis/apps/v1/namespaces/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    location /kapis/resources.kubesphere.io/v1alpha2/namespaces <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    location /kapis/resources.kubesphere.io/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /apis/devops.kubesphere.io/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_set_header        Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header        X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header        X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        proxy_connect_timeout  3600s<span class="token punctuation">;</span>
        proxy_read_timeout  3600s<span class="token punctuation">;</span>
        proxy_send_timeout  3600s<span class="token punctuation">;</span>
        send_timeout  3600s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /apis/apps/v1/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /apis/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    location /api/v1/watch/namespaces <span class="token punctuation">&#123;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	

    location /kapis/terminal.kubesphere.io/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    location /kapis/clusters/member/terminal.kubesphere.io/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    location /kapis/clusters/host/terminal.kubesphere.io/ <span class="token punctuation">&#123;</span>
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_redirect off<span class="token punctuation">;</span>
        proxy_pass http://ks-console.kubesphere-system<span class="token punctuation">;</span>
        proxy_set_header    Host <span class="token variable">$host</span><span class="token builtin class-name">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>
        proxy_set_header    Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header    X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        proxy_set_header    Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span> 
        proxy_set_header    X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># for i in $(kubectl get pod -n local|grep nginx|awk '&#123;print $1&#125;');do kubectl exec -it -n local $i -- nginx -s reload; done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="多集群"><a class="markdownIt-Anchor" href="#多集群"></a> 多集群</h1>
<p>KubeSphere 可以支持多集群管理。</p>
<h2 id="主集群配置"><a class="markdownIt-Anchor" href="#主集群配置"></a> 主集群配置</h2>
<p>也叫 Host 集群。修改 <code>ClusterConfiguration</code> 文件，配置 <code>clusterRole</code> 为 <code>host</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># kubectl edit cc ks-installer -n kubesphere-system</span>
<span class="token punctuation">..</span>.
    storageClass: longhorn
  multicluster:
    clusterRole: <span class="token function">host</span>
  network:
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l 'app in (ks-install, ks-installer)' -o jsonpath='&#123;.items[0].metadata.name&#125;') -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取 <code>jwtSecre</code> 用于集群验证：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># kubectl -n kubesphere-system get cm kubesphere-config -o yaml | grep -v "apiVersion" | grep jwtSecret</span>
      jwtSecret: MzRbXxHS4LFxfPacw0SUc0lNVdcjtImv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="成员集群配置"><a class="markdownIt-Anchor" href="#成员集群配置"></a> 成员集群配置</h2>
<p>在成员集群中，同样修改 <code>clusterRole</code> 值为 <code>member</code>，并且将主集群的 <code>jwtSecret</code> 值填进去：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master1-pro ~<span class="token punctuation">]</span><span class="token comment"># kubectl edit cc ks-installer -n kubesphere-system</span>
<span class="token punctuation">..</span>.
  authentication:
    jwtSecret: MzRbXxHS4LFxfPacw0SUc0lNVdcjtImv
<span class="token punctuation">..</span>.
  multicluster:
    clusterRole: member
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@k8s-master1-pro ~<span class="token punctuation">]</span><span class="token comment"># kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l 'app in (ks-install, ks-installer)' -o jsonpath='&#123;.items[0].metadata.name&#125;') -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="导入成员集群"><a class="markdownIt-Anchor" href="#导入成员集群"></a> 导入成员集群</h2>
<p>最后是在主集群导入成员集群：</p>
<ul>
<li>
<p>使用管理员登录主集群控制面板，在集群管理页面多了一个添加集群按钮。</p>
</li>
<li>
<p>点击添加后，输入集群名称、选择标签、输入描述，点击下一步。</p>
</li>
<li>
<p>在集群设置页面，连接方式选择直接连接。粘贴成员集群主节点上 <code>$HOME/.kube/config</code> 文件内容。注意修改 <code>server</code> 地址要能直连访问。</p>
</li>
<li>
<p>点击创建来完成。</p>
</li>
</ul>
<p>成员集群加入成功后，在主集群即能管理成员集群。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>4.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Longhorn 作为 K8s 后端储存</title>
    <url>/1964569963/</url>
    <content><![CDATA[<h1 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍"></a> 简单介绍</h1>
<p>Longhorn 是一个分布式存储系统，具有以下特点：</p>
<ul>
<li>使用 Longhorn 卷作为 K8s 集群的持久存储卷。</li>
<li>使用块存储设备作为基础卷，无需依赖云服务提供商。</li>
<li>通过在多个节点上存储副本来提供高可用性。</li>
<li>支持将 NFS 用作存储系统的备份源，并且可以设置多个备份源。</li>
<li>支持跨集群灾备，方便在 K8s 集群中迁移数据。</li>
<li>可以在不中断持久卷的情况下升级 Longhorn 系统。</li>
</ul>
<p>官方参考文档：</p>
<p><a href="https://longhorn.io/docs/1.2.6">https://longhorn.io/docs/1.2.6</a></p>
<p>中文参考文档：</p>
<p><a href="https://blog.51cto.com/u_15168528/3605855">https://blog.51cto.com/u_15168528/3605855</a></p>
<p>结构原理：</p>
<p><a href="https://jishuin.proginn.com/p/763bfbd73e98">https://jishuin.proginn.com/p/763bfbd73e98</a></p>
<h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1>
<p>在集群中每个节点安装并启动 open-iscsi :</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y nfs-utils</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum --setopt=tsflags=noscripts install -y iscsi-initiator-utils</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># /sbin/iscsi-iname -p "InitiatorName=iqn.2022-05.org.open-iscsi" > /etc/iscsi/initiatorname.iscsi</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now iscsid</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># lsmod | grep iscsi</span>
scsi_transport_iscsi   <span class="token number">110592</span>  <span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或使用官方脚本来安装:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.2.6/deploy/prerequisite/longhorn-iscsi-installation.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="部署流程"><a class="markdownIt-Anchor" href="#部署流程"></a> 部署流程</h1>
<p>在主节点上克隆仓库，并检出到 v1.2.6 分支：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># git clone https://github.com/longhorn/longhorn.git</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cd longhorn &amp;&amp; git checkout v1.2.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果遇到错误：</p>
<blockquote>
<p>fatal: unable to access ‘<a href="https://github.com/longhorn/longhorn.git/">https://github.com/longhorn/longhorn.git/</a>’: TCP connection reset by peer</p>
</blockquote>
<p>多试几次，直到匹配上能连通的 Github 服务器 IP 地址。</p>
<p>运行官方环境检测脚本，一般没有报错：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># bash scripts/environment_check.sh</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  All longhorn-environment-check pods are ready <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>.
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  Required packages are installed.
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  MountPropagation is enabled.
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  Cleaning up longhorn-environment-check pods<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span>  Cleanup completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>deploy</code> 目录下的 <code>longhorn.yaml</code> 文件拷贝出来，直接部署：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># mkdir -p /hxz393/local/longhorn/apply &amp;&amp; cp deploy/longhorn.yaml /hxz393/local/longhorn/apply/</span>
<span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/longhorn/apply/</span>
<span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># kubectl get po -n longhorn-system -owide --watch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>等待所有组件容器变为 Running 状态。</p>
<h1 id="集群配置"><a class="markdownIt-Anchor" href="#集群配置"></a> 集群配置</h1>
<p>配置应用使用的自定义 SC 和前端访问网址。</p>
<h2 id="建立-sc"><a class="markdownIt-Anchor" href="#建立-sc"></a> 建立 SC</h2>
<p>自定义 SC 配置好默认自动备份策略，涵盖了每周一次备份、每天一次备份和每三小时一次快照：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /hxz393/local/longhorn/apply/kube-sc.yaml&lt;&lt;EOF</span>
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: kube-sc
  annotations:
    storageclass.kubernetes.io/is-default-class: <span class="token string">"true"</span>
provisioner: driver.longhorn.io
allowVolumeExpansion: <span class="token boolean">true</span>
reclaimPolicy: Retain
volumeBindingMode: Immediate
parameters:
  numberOfReplicas: <span class="token string">"3"</span>
  staleReplicaTimeout: <span class="token string">"2880"</span>
  fromBackup: <span class="token string">""</span>
  fsType: <span class="token string">"xfs"</span>
  recurringJobSelector: <span class="token string">'[
   &#123;
     "name":"kube-snap",
     "task":"snapshot",
     "cron":"0 0/3 * * ?",
     "retain":5
   &#125;,
   &#123;
     "name":"kube-backup-daily",
     "task":"backup",
     "cron":"0 2 * * ?",
     "retain":7
   &#125;,
   &#123;
     "name":"kube-backup-weekly",
     "task":"backup",
     "cron":"0 3 ? * SAT",
     "retain":4
   &#125;
  ]'</span>
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/longhorn/apply/kube-sc.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="开放端口"><a class="markdownIt-Anchor" href="#开放端口"></a> 开放端口</h2>
<p>修改 longhorn-frontend 服务类型为 nodeport，暴露端口 10005 留作内网访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl -n longhorn-system edit svc longhorn-frontend</span>
<span class="token punctuation">..</span>.
  ports:
  - name: http
    port: <span class="token number">80</span>
    protocol: TCP
    targetPort: http
    nodePort: <span class="token number">10005</span>
  selector:
    app: longhorn-ui
  sessionAffinity: None
  type: NodePort
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过服务器 IP 地址加 10005 端口，能直接打开 Longhorn 控制面板。</p>
<h2 id="配置域名"><a class="markdownIt-Anchor" href="#配置域名"></a> 配置域名</h2>
<p>由于 Longhorn 控制面板默认不带身份验证，如果想通过域名访问，需要自行生成用户密码加密文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># htpasswd -m -c /hxz393/local/nginx/cert/longhorn_passwd assassing</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>命令 <code>htpasswd</code> 为 <code>Apache httpd</code> 服务所带套件，需要自行安装。</p>
<p>建立 <code>nginx</code> 配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># vi /hxz393/local/nginx/config/conf.d/longhorn.x2b.net.conf</span>
server <span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    listen <span class="token number">443</span> ssl<span class="token punctuation">;</span>
    <span class="token comment"># 域名</span>
    server_name longhorn.x2b.net<span class="token punctuation">;</span>

    ssl_certificate   /cert/x2b.net.pem<span class="token punctuation">;</span>
    ssl_certificate_key  /cert/x2b.net.key<span class="token punctuation">;</span>
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span class="token operator">!</span>NULL:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5:<span class="token operator">!</span>ADH:<span class="token operator">!</span>RC4<span class="token punctuation">;</span>
    ssl_protocols TLSv1.2 TLSv1.3 SSLv3<span class="token punctuation">;</span>
    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>
    
    <span class="token comment"># 基本认证</span>
    auth_basic <span class="token string">"nginx basic auth for longhorn"</span><span class="token punctuation">;</span>
    auth_basic_user_file /cert/longhorn_passwd<span class="token punctuation">;</span> 
    location / <span class="token punctuation">&#123;</span>
        <span class="token comment"># k8s服务名</span>
        proxy_pass http://longhorn-frontend.longhorn-system/<span class="token punctuation">;</span>
        proxy_set_header Host   <span class="token variable">$host</span><span class="token punctuation">;</span>
        proxy_set_header X-Real-IP      <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_uri</span> ~* <span class="token string">"/(.*)"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            proxy_pass http://longhorn-frontend.longhorn-system/<span class="token variable">$1</span><span class="token punctuation">;</span>
            <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># for i in $(kubectl get pod -n local|grep nginx|awk '&#123;print $1&#125;');do kubectl exec -it -n local $i -- nginx -s reload; done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过域名 <code>longhorn.x2b.net</code> 访问，需要输入用户名 assassing 的密码来访问。</p>
<h1 id="节点配置node"><a class="markdownIt-Anchor" href="#节点配置node"></a> 节点配置（Node）</h1>
<p>根据需要修改默认节点 Node 配置：</p>
<ul>
<li>删除所有节点默认挂载点。</li>
<li>添加主节点 <code>/ssd</code> 目录作为储存目录 ，开启调度（Scheduling），设置保留磁盘（Storage Reserved）空间为 1 GB。</li>
</ul>
<h1 id="备份任务recurring-job"><a class="markdownIt-Anchor" href="#备份任务recurring-job"></a> 备份任务（Recurring Job）</h1>
<p>创建快照策略 kube-snap，用来自动创建快照：</p>
<ul>
<li>Name：输入名字 kube-snap。</li>
<li>Task：任务类型选择 Snapshot。</li>
<li>Retain：设置保留副本数量为 5。</li>
<li>Concurrency：并发活动数为 3。</li>
<li>Cron：设置任务调度表为 <code>0 0/3 * * ?</code>，代表每 3 小时执行一次。</li>
</ul>
<p>创建备份策略 kube-backup-daily，用来每天自动创建备份。需要先设置好备份 NFS 服务器地址：</p>
<ul>
<li>Name：输入名字 kube-backup-daily。</li>
<li>Task：任务类型选择 Backup。</li>
<li>Retain：设置保留副本数量为 7。</li>
<li>Concurrency：并发活动数为 1。</li>
<li>Cron：设置任务调度表为 <code>0 2 * * ?</code>，代表每天的凌晨 2 点执行。</li>
</ul>
<p>创建备份策略 kube-backup-weekly，用来每周自动创建备份：</p>
<ul>
<li>Name：输入名字 kube-backup-weekly。</li>
<li>Task：任务类型选择 Backup。</li>
<li>Retain：设置保留副本数量为 4。</li>
<li>Concurrency：并发活动数为 1。</li>
<li>Cron：设置任务调度表为 <code>0 6 ? * SAT</code>，代表每周六早上 6 点执行。</li>
</ul>
<h1 id="功能设置setting"><a class="markdownIt-Anchor" href="#功能设置setting"></a> 功能设置（Setting）</h1>
<p>遵循最小化配置原则，一般不建议修改默认配置。修改前请一定先查询官方文档。</p>
<h2 id="orphan"><a class="markdownIt-Anchor" href="#orphan"></a> Orphan</h2>
<ul>
<li>
<p>Orphan Auto-Deletion</p>
<p>自动删除孤儿容器。</p>
</li>
</ul>
<h2 id="backup"><a class="markdownIt-Anchor" href="#backup"></a> Backup</h2>
<ul>
<li>
<p>Backup Target</p>
<p>填写备份 NFS 服务器地址。例如：<code>nfs://192.168.1.106:/backup</code>。</p>
</li>
</ul>
<h2 id="scheduling"><a class="markdownIt-Anchor" href="#scheduling"></a> Scheduling</h2>
<ul>
<li>
<p>Replica Node Level Soft Anti-Affinity</p>
<p>开启节点级别反亲和策略。同节点部署多个相同的副本没有意义。</p>
</li>
<li>
<p>Storage Over Provisioning Percentage</p>
<p>设置超量调度百分比为 100%。</p>
</li>
</ul>
<h1 id="本地挂载"><a class="markdownIt-Anchor" href="#本地挂载"></a> 本地挂载</h1>
<p>可以将活动中的储存卷挂载到本地，来管理卷内文件：</p>
<ul>
<li>在卷的详细信息（Volume Details）中找到 <code>Attached Node &amp; Endpoint</code>，这是 PVC 挂载到的目标服务器和设备名。</li>
<li>登录目标服务器，使用 <code>mount</code> 命令来挂载 <code>RWX</code> 卷。例如：<code>mount /dev/longhorn/pvc-9a38209a-ca92-44b3-adba-e1c629437409 /root/temp_pvc</code>。</li>
<li>维护完毕用 <code>umount</code> 卸载卷：<code>umount /root/temp_pvc</code>。</li>
</ul>
<h1 id="磁盘瘦身"><a class="markdownIt-Anchor" href="#磁盘瘦身"></a> 磁盘瘦身</h1>
<p>针对 <code>RWO</code> 格式的卷，1.40 以上版本提供清理磁盘空间功能，在卷操作中选择 <code>Trim Filesystem</code> 即可。</p>
<p>对于 <code>RWX</code> 卷需要手动清理。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir 111 &amp;&amp; mount /dev/longhorn/pvc-41795a8f-d3bf-406b-acfd-fa7d88e44e73 111</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># fstrim 111</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># umount 111 &amp;&amp; rmdir 111</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="版本升级"><a class="markdownIt-Anchor" href="#版本升级"></a> 版本升级</h1>
<p>目前最新版为 1.4.2，根据官方文档说明，从 1.2.X 升级需要先升级到 1.3.3 版本，再升级到 1.4.2。升级时访问控制台会中断一会，但不影响储存卷工作。</p>
<p>依然可以用安装时克隆的仓库来操作。或则删除后重新克隆仓库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cd longhorn &amp;&amp; git checkout v1.3.3</span>
Previous HEAD position was f936f6e<span class="token punctuation">..</span>. Release <span class="token number">1.2</span>.6
HEAD is now at f57838c<span class="token punctuation">..</span>. release: <span class="token number">1.3</span>.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>后续步骤和安装一样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># cp deploy/longhorn.yaml /hxz393/local/longhorn/apply/</span>
<span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/longhorn/apply/</span>
<span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># kubectl get po -n longhorn-system -owide --watch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果网络不错，可以直接指定 Github 上的发布文件来升级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 longhorn<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.4.2/deploy/longhorn.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>升级后需要重新修改前端服务类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl -n longhorn-system edit svc longhorn-frontend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="数据恢复"><a class="markdownIt-Anchor" href="#数据恢复"></a> 数据恢复</h1>
<p>通过控制面板正常恢复卷备份操作不在本段讨论之列。这里要假设的是一个极端的情况：整个 K8s 集群或者 Longhorn 系统失败且无法恢复，要怎么取出 Longhrn 卷的数据。</p>
<p>由于 Longhorn 在磁盘中，以 img 格式来封装数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># ll /ssd/replicas/pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2-8d14ac1d/</span>
total <span class="token number">1312920</span>
-rw------- <span class="token number">1</span> root root       <span class="token number">4096</span> May <span class="token number">21</span> <span class="token number">21</span>:28 revision.counter
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">5368709120</span> May <span class="token number">21</span> <span class="token number">21</span>:28 volume-head-007.img
-rw-r--r-- <span class="token number">1</span> root root        <span class="token number">187</span> May <span class="token number">21</span> 08:00 volume-head-007.img.meta
-rw-r--r-- <span class="token number">1</span> root root        <span class="token number">203</span> May <span class="token number">21</span> 08:00 volume.meta
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">5368709120</span> May <span class="token number">21</span> 08:00 volume-snap-kube-bac-3fe04efe-14ed-4dc9-a3d6-e938e20bb8e3.img
-rw-r--r-- <span class="token number">1</span> root root        <span class="token number">193</span> May <span class="token number">21</span> 08:00 volume-snap-kube-bac-3fe04efe-14ed-4dc9-a3d6-e938e20bb8e3.img.meta
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">5368709120</span> May <span class="token number">21</span> 08:00 volume-snap-kube-sna-427d25c2-4eea-4e6a-a6c0-791e931451ef.img
-rw-r--r-- <span class="token number">1</span> root root        <span class="token number">210</span> May <span class="token number">21</span> 08:00 volume-snap-kube-sna-427d25c2-4eea-4e6a-a6c0-791e931451ef.img.meta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以即使找到了 PV 所在目录也无法直接操作。先查看卷目录下的 <code>volume.meta</code> 文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># cat /ssd/replicas/pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2-8d14ac1d/volume.meta</span>
<span class="token punctuation">&#123;</span><span class="token string">"Size"</span>:5368709120,<span class="token string">"Head"</span><span class="token builtin class-name">:</span><span class="token string">"volume-head-007.img"</span>,<span class="token string">"Dirty"</span>:true,<span class="token string">"Rebuilding"</span>:false,<span class="token string">"Error"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"Parent"</span><span class="token builtin class-name">:</span><span class="token string">"volume-snap-kube-sna-427d25c2-4eea-4e6a-a6c0-791e931451ef.img"</span>,<span class="token string">"SectorSize"</span>:512,<span class="token string">"BackingFilePath"</span><span class="token builtin class-name">:</span><span class="token string">""</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过文件内容，无法得知卷的用途。只知道卷的大小为 5368709120 Bytes（5 GB）。</p>
<p>接着使用 <code>longhorn-engine</code> 镜像手动创建卷容器，命令参数为：<code>docker run -v /dev:/host/dev -v /proc:/host/proc -v 卷实际路径:/volume --privileged longhornio/longhorn-engine:v1.4.1 launch-simple-longhorn 卷名 卷大小</code>。</p>
<p>在上面例子中，卷路径是 <code>/ssd/replicas/pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2-8d14ac1d/</code>，卷大小为 <code>5368709120</code>。而卷名，也就是 PV 名字 <code>pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2</code> 在路径名中也有体现，统一去掉最后一段 8 位长度 UUID 名 <code>8d14ac1d</code> 即可，PV 名字长度是固定的 40 位。</p>
<p>所以实际要运行的命令是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># docker run -v /dev:/host/dev -v /proc:/host/proc -v /ssd/replicas/pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2-8d14ac1d:/volume --privileged longhornio/longhorn-engine:v1.4.1 launch-simple-longhorn pvc-10efcd2b-df0d-4af3-b9cc-3b61368bbdb2 5368709120</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果运行顺利，可以通过 <code>mount</code> 命令来挂载块设备 <code>/dev/longhorn/卷名</code>。挂载步骤参考：<a href="#%E6%9C%AC%E5%9C%B0%E6%8C%82%E8%BD%BD">本地挂载</a>。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>4.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 资源管理</title>
    <url>/948924982/</url>
    <content><![CDATA[<h1 id="高级调度"><a class="markdownIt-Anchor" href="#高级调度"></a> 高级调度</h1>
<p>Kubernetes（k8s）是一个强大的容器编排平台，具备许多高级调度功能，以优化容器的资源利用和性能。以下是一些常见的 k8s 高级调度功能：</p>
<ol>
<li>亲和性调度（Affinity Scheduling）：通过亲和性调度规则，将容器调度到具有特定标签或节点上，以满足应用程序的需求。亲和性调度可以实现容器之间的亲和关系，如将相关的容器调度到相同的节点上，或将某个容器调度到特定类型的节点上。</li>
<li>反亲和性调度（Anti-Affinity Scheduling）：与亲和性调度相反，反亲和性调度可以将容器调度到具有特定标签或节点上的不同节点，以提高容器的高可用性和容错性。</li>
<li>资源限制（Resource Limits）：可以为容器设置资源限制，如 CPU 和内存限制，以确保容器在运行时不会超出预定义的资源限制，从而避免资源竞争和意外的崩溃。</li>
<li>资源配额（Resource Quotas）：通过资源配额，可以限制命名空间中的容器使用的总资源量，包括 CPU、内存、存储等。资源配额可以帮助确保不同应用程序之间的资源隔离和公平分配。</li>
<li>亲和性互斥（Affinity Preemption）：通过亲和性互斥规则，可以防止容器被调度到具有相同亲和性规则的其他容器所在的节点上。这可以避免容器之间的资源冲突和干扰。</li>
<li>水平 Pod 自动伸缩（Horizontal Pod Autoscaling）：根据应用程序的负载和性能需求，可以自动调整 Pod 的副本数量。水平 Pod 自动伸缩功能可根据预定义的规则自动扩展或缩减 Pod 的数量，以满足应用程序的需求。</li>
<li>优先级和预选调度（Priority and Preemption Scheduling）：可以为容器设置优先级和预选条件，以确保重要任务或紧急任务得到优先调度。如果节点资源不足以满足高优先级任务的需求，则可以通过预选调度功能，暂时剥夺低优先级任务的资源，以满足高优先级任务的需求。</li>
<li>自定义调度器（Custom Scheduler）：Kubernetes 允许用户编写自定义调度器，根据特定的调度算法和策略，将容器调度到节点上。自定义调度器可以根据应用程序的特定需求进行优化和定制化。</li>
</ol>
<h2 id="禁止调度"><a class="markdownIt-Anchor" href="#禁止调度"></a> 禁止调度</h2>
<p>有时候需要手动标记节点为不可调度状态来进行维护工作，可以使用 <code>cordon</code> 命令来标记节点不再接收新的 Pod 请求：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl cordon server5-node1
node/server5-node1 cordoned<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同时，可以使用 <code>drain</code> 命令在停止调度后将节点上的 Pod 转移到其他节点上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl drain server5-node1 
node/server5-node1 already cordoned
DEPRECATED WARNING: Aborting the drain <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a list of nodes will be deprecated <span class="token keyword">in</span> v1.23.
The new behavior will <span class="token function">make</span> the drain <span class="token builtin class-name">command</span> go through all nodes even <span class="token keyword">if</span> one or <span class="token function">more</span> nodes failed during the drain.
For now, <span class="token function">users</span> can try such experience via: --ignore-errors
error: unable to drain <span class="token function">node</span> <span class="token string">"server5-node1"</span>, aborting command<span class="token punctuation">..</span>.

There are pending nodes to be drained:
 server5-node1
cannot delete Pods not managed by ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet <span class="token punctuation">(</span>use <span class="token parameter variable">--force</span> to override<span class="token punctuation">)</span>: bar/test, default/host-pid, default/pod-host-network, default/pod-privileged, foo/test
cannot delete DaemonSet-managed Pods <span class="token punctuation">(</span>use --ignore-daemonsets to ignore<span class="token punctuation">)</span>: calico-system/calico-node-2cp86, kube-system/kube-proxy-fnvff
cannot delete Pods with <span class="token builtin class-name">local</span> storage <span class="token punctuation">(</span>use --delete-emptydir-data to override<span class="token punctuation">)</span>: default/pod-readonly<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据提示，可以添加一些参数，例如 <code>--force</code> 用于覆盖，<code>--ignore-daemonsets</code> 用于忽略守护进程集等，以忽略警告信息。</p>
<p>如果想解除不可调度状态，可以使用 <code>uncordon</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl uncordon server5-node1
node/server5-node1 uncordoned<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="污点和容忍度"><a class="markdownIt-Anchor" href="#污点和容忍度"></a> 污点和容忍度</h2>
<p>在使用 kubeadm 建立集群时，主节点会自动设置污点，不允许在其上部署 Pod。可以通过 describe 命令查看污点信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe <span class="token function">node</span> server4-master 
Taints:             node-role.kubernetes.io/master<span class="token operator">=</span>true:NoSchedule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中 Taints 选项包含键、值和生效规则。主节点上的污点信息键为 <code>node-role.kubernetes.io/master</code>，值为 <code>true</code>，生效规则为 NoSchedule。这个污点将阻止 Pod 被调度到该节点上，除非有 Pod 能够容忍该污点。通常，容忍该污点的 Pod 是系统级别的 Pod，例如 kube-proxy：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po kube-proxy-wkgjf <span class="token parameter variable">-n</span> kube-system
Tolerations:                 <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/disk-pressure:NoSchedule <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/memory-pressure:NoSchedule <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/network-unavailable:NoSchedule <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/not-ready:NoExecute <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/pid-pressure:NoSchedule <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/unreachable:NoExecute <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists
                             node.kubernetes.io/unschedulable:NoSchedule <span class="token assign-left variable">op</span><span class="token operator">=</span>Exists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="污点效果"><a class="markdownIt-Anchor" href="#污点效果"></a> 污点效果</h3>
<p>每个污点都关联一个生效规则，共有三种规则：</p>
<ul>
<li>
<p>NoSchedule（不可调度）</p>
<p>如果 Pod 不能容忍这些污点，则 Pod 将无法被调度到包含这些污点的节点上。</p>
</li>
<li>
<p>PreferNoSchedule（优先不调度）</p>
<p>表示尽量不将 Pod 调度到具有该污点的节点上。只有在没有其他可用节点时，才会将 Pod 调度到该节点上。</p>
</li>
<li>
<p>NoExecute（不执行）</p>
<p>这个规则会影响节点上运行的 Pod。如果节点上添加了 NoExecute 污点，那些正在该节点上运行的 Pod 将会从该节点上移除。</p>
</li>
</ul>
<h3 id="添加污点"><a class="markdownIt-Anchor" href="#添加污点"></a> 添加污点</h3>
<p>在生产环境的节点上，可以添加污点来拒绝部署：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl taint <span class="token function">node</span> server4-master node-type<span class="token operator">=</span>prod:NoSchedule
node/server4-master tainted
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe <span class="token function">node</span> server4-master 
Taints:             node-type<span class="token operator">=</span>prod:NoSchedule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此命令会给节点添加一个污点，其中键为 <code>node-type</code>，值为 <code>prod</code>，效果为 NoSchedule。</p>
<h3 id="污点容忍度"><a class="markdownIt-Anchor" href="#污点容忍度"></a> 污点容忍度</h3>
<p>如果需要在有污点的节点上部署 Pod，可以在 Pod 的 <code>spec.template.spec.tolerations</code> 中添加污点容忍度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> dp.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: kubia
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - name: nodejs
        image: luksa/kubia
        ports:
        - name: http
          containerPort: <span class="token number">8080</span>
        resources:
          requests:
            cpu: 100m
      tolerations:
      - key: node-type
        operator: Equal
        value: prod
        effect: NoSchedule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以根据需求灵活配置节点失效（unready 或 unreachable）状态下，Pod 重新调度之前的等待时间：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node.alphakubernetes.io/notReady
  <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists
  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span>
  <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoExecute
<span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node.alphakubernetes.io/unreachable
  <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists
  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">300</span>
  <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoExecute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有定义这两个容忍度，它们会自动添加到 Pod 上，初始等待时间为 300 秒。可以缩短值以减少等待时间。</p>
<h3 id="删除污点"><a class="markdownIt-Anchor" href="#删除污点"></a> 删除污点</h3>
<p>如果需要删除添加的污点，只需在添加污点的命令后加上减号 <code>-</code> 即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl taint <span class="token function">node</span> server5-node1 node-type<span class="token operator">=</span>prod:NoSchedule-
node/server5-node1 untainted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="亲缘性"><a class="markdownIt-Anchor" href="#亲缘性"></a> 亲缘性</h2>
<p>在 Kubernetes（k8s）中，亲缘性（Affinity）是一种调度策略，用于指定容器与节点或其他容器之间的关系。亲缘性可通过标签选择器和节点选择器来定义。</p>
<h3 id="节点亲缘性"><a class="markdownIt-Anchor" href="#节点亲缘性"></a> 节点亲缘性</h3>
<p>节点亲缘性（Node Affinity）允许 Kubernetes 将 Pod 只调度到某个节点子集上。</p>
<p>节点亲缘性规则用于取代节点选择器，其写法如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>
        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> gpu
              <span class="token key atrule">operator</span><span class="token punctuation">:</span> in
              <span class="token key atrule">values</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> <span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>requiredDuringSchedulingIgnoredDuringExecution</code> 用于表示强制性规则，不影响已经在节点上运行的 Pod。规则为 Pod 只会调度到包含 <code>gpu=true</code> 标签的节点上。</p>
<p>可以通过 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 设置软性规则，指定多个节点并调整优先级：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">80</span>
        <span class="token key atrule">preference</span><span class="token punctuation">:</span>
            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> gpu
              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
              <span class="token key atrule">values</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> <span class="token string">"true"</span>
      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">20</span>
        <span class="token key atrule">preference</span><span class="token punctuation">:</span>
            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> zone
              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
              <span class="token key atrule">values</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> <span class="token string">"cn"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，节点亲缘性优先级设置了 Pod 被优先调度到标签为 <code>gpu=true</code> 和 <code>zone=cn</code> 的节点上，其次是拥有 <code>gpu=true</code> 但 <code>zone</code> 值不为 <code>cn</code> 的节点，再次是 <code>zone=cn</code> 的节点，最后是优先级最低的其他节点。</p>
<p>对 <code>node1</code> 打上 <code>gpu=true</code> 和 <code>zone=cn</code> 标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server5-node1 <span class="token assign-left variable">gpu</span><span class="token operator">=</span>true
node/server5-node1 labeled
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server5-node1 <span class="token assign-left variable">zone</span><span class="token operator">=</span>cn
node/server5-node1 labeled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 Deployment 发布一个有 5 个副本的应用，并查看 Pod 分布：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> deploy.label.yaml 
deployment.apps/kubia created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> wide
NAME                    READY   STATUS    RESTARTS   AGE   IP               NODE         kubia-6f84b588d-8b6dn   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9s    <span class="token number">10.244</span>.191.247   server6-node2 
kubia-6f84b588d-kbrks   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9s    <span class="token number">10.244</span>.191.250   server5-node1 
kubia-6f84b588d-kf6p2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9s    <span class="token number">10.244</span>.191.251   server5-node1 
kubia-6f84b588d-pbf7p   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9s    <span class="token number">10.244</span>.191.248   server5-node1 
kubia-6f84b588d-sfqv4   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9s    <span class="token number">10.244</span>.191.249   server5-node1 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，5 个 Pod 中有 4 个被部署到了 <code>node1</code>，另外 1 个部署到了 <code>node2</code>。这是因为使用了 <code>Selector SpreadPriority</code> 函数，它确保属于同一个 ReplicaSet 或 Service 的 Pod 分布到不同节点，避免单节点故障导致服务不可用。</p>
<h3 id="pod-亲缘性"><a class="markdownIt-Anchor" href="#pod-亲缘性"></a> Pod 亲缘性</h3>
<p>如果是协同工作的两个 Pod，可以设置 Pod 亲缘性，将它们尽可能部署到同一节点：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">podAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname
        <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>
          <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
            <span class="token key atrule">app</span><span class="token punctuation">:</span> backend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此部署将创建一个包含强制性要求的 Pod，其中要求该 Pod 尽可能调度到与其他包含标签 <code>app=backend</code> 的 Pod 相同的节点上（通过 <code>topologyKey</code> 字段指定）。</p>
<h3 id="反亲缘性"><a class="markdownIt-Anchor" href="#反亲缘性"></a> 反亲缘性</h3>
<p>除了能让调度器对 Pod 进行协同部署，还可以让 Pod 之间远离彼此。通过 <code>podAntiAffinity</code> 字段来配置，这将导致调度器永远不会选择那些具有与 <code>podAntiAffinity</code> 匹配标签的 Pod 所在节点。</p>
<p>通常用于分离同样消耗大量系统资源的 Pod，或者将 Pod 分布在不同的可用区，以提高服务的可用性。以下是一个反亲缘性的示例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>
          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app
            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
            <span class="token key atrule">values</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> frontend
        <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> <span class="token string">"kubernetes.io/hostname"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="资源请求和限制"><a class="markdownIt-Anchor" href="#资源请求和限制"></a> 资源请求和限制</h1>
<p>资源请求和限制是在 Kubernetes 中用于管理 Pod 资源分配和控制的重要概念。通过设置资源请求和限制，可以确保集群中的容器能够按预期方式运行，并有效地利用可用资源。</p>
<h2 id="使用资源请求"><a class="markdownIt-Anchor" href="#使用资源请求"></a> 使用资源请求</h2>
<p>在创建 Pod 时，可以指定容器对 CPU 和内存资源的请求量（requests）和资源限制量（limits）。下面创建一个 Pod，并指定容器对 CPU 和内存资源的请求量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-requests.yaml
apiVersion: v1
kind: Pod
metadata:
  name: requests-pod
spec:
  containers:
  - image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"dd"</span>, <span class="token string">"if=/dev/zero"</span>, <span class="token string">"of=/dev/null"</span><span class="token punctuation">]</span>
    name: main
    resources:
      requests:
        cpu: 200m
        memory: 100Mi
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-requests.yaml 
pod/requests-pod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述配置中，声明容器需要 200 毫核（1 核 = 1000m）的 CPU 才能正常运行。在没有设置 CPU 资源请求的情况下，该进程可能无法分配到足够的 CPU 资源（当其他进程对 CPU 的需求很大时）。</p>
<p>另外，还配置了容器请求内存为 100MB，表示期望容器内的进程最多使用 100MB 的内存，实际占用可能会小于这个值。</p>
<p>运行容器后，可以使用 <code>top</code> 命令查看 CPU 使用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> requests-pod -- <span class="token function">top</span>
Mem: 7796064K used, 193976K free, 62492K shrd, 4240K buff, 6155012K cached
CPU:  <span class="token number">1.2</span>% usr  <span class="token number">5.6</span>% sys  <span class="token number">0.0</span>% nic <span class="token number">93.1</span>% idle  <span class="token number">0.0</span>% io  <span class="token number">0.0</span>% irq  <span class="token number">0.0</span>% sirq
Load average: <span class="token number">0.83</span> <span class="token number">0.39</span> <span class="token number">0.20</span> <span class="token number">3</span>/895 <span class="token number">19</span>
  PID  <span class="token environment constant">PPID</span> <span class="token environment constant">USER</span>     STAT   VSZ %VSZ CPU %CPU COMMAND
    <span class="token number">1</span>     <span class="token number">0</span> root     R     <span class="token number">1304</span>  <span class="token number">0.0</span>   <span class="token number">0</span>  <span class="token number">6.8</span> <span class="token function">dd</span> <span class="token keyword">if</span> /dev/zero of /dev/null
   <span class="token number">14</span>     <span class="token number">0</span> root     R     <span class="token number">1312</span>  <span class="token number">0.0</span>   <span class="token number">2</span>  <span class="token number">0.0</span> <span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>dd</code> 命令会消耗所有 CPU，但由于它是单线程运行，所以最多只能使用一个核心的资源。进程对 CPU 使用率远远超过了 Pod 定义申请的 1/5 核，因为 <code>requests</code> 不会限制容器可以使用的 CPU 总量。</p>
<h2 id="资源请求对调度影响"><a class="markdownIt-Anchor" href="#资源请求对调度影响"></a> 资源请求对调度影响</h2>
<p>通过设置 <code>requests</code> 指定 Pod 对资源需求的最小值，调度器在将 Pod 调度到节点的过程中会使用该信息。</p>
<p>每个节点可分配资源是一定的，调度器只考虑那些未分配资源量满足 Pod 需求量的节点，而不会将 Pod 调度到无法满足需求的节点。此外，调度器计算的资源量是节点上所有 Pod 的资源请求量之和，与实际资源使用量无关。</p>
<p>调度器基于资源请求量的优先级排序有两个函数：LeastRequestedPriority 和 MostRequestedPriority。前者优先将 Pod 调度到资源请求量较少的节点上，后者则相反。通常在可动态调整节点的云基础设施上使用 MostRequestedPriority，以确保 Kubernetes 尽可能少使用节点。</p>
<p>通过查看节点描述，可以了解节点的资源总量、可分配资源量以及已使用资源量等信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe nodes
Addresses:
  InternalIP:  <span class="token number">192.168</span>.2.206
  Hostname:    server6-node2
Capacity:
  cpu:                <span class="token number">16</span>
  ephemeral-storage:  66678Mi
  hugepages-2Mi:      <span class="token number">0</span>
  memory:             7990040Ki
  pods:               <span class="token number">110</span>
Allocatable:
  cpu:                <span class="token number">16</span>
  ephemeral-storage:  <span class="token number">62925255372</span>
  hugepages-2Mi:      <span class="token number">0</span>
  memory:             7887640Ki
  pods:               <span class="token number">110</span>
Allocated resources:
  <span class="token punctuation">(</span>Total limits may be over <span class="token number">100</span> percent, i.e., overcommitted.<span class="token punctuation">)</span>
  Resource           Requests    Limits
  --------           --------    ------
  cpu                200m <span class="token punctuation">(</span><span class="token number">1</span>%<span class="token punctuation">)</span>   200m <span class="token punctuation">(</span><span class="token number">1</span>%<span class="token punctuation">)</span>
  memory             100Mi <span class="token punctuation">(</span><span class="token number">1</span>%<span class="token punctuation">)</span>  100Mi <span class="token punctuation">(</span><span class="token number">1</span>%<span class="token punctuation">)</span>
  ephemeral-storage  <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span>      <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span>
  hugepages-2Mi      <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span>      <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以创建一个请求 CPU 核数大于节点提供的 CPU 核数的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-requests.yaml
    resources:
      requests:
        cpu: <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于目前没有服务器可以提供 20 核 CPU 资源，因此该 Pod 无法被创建，会一直处于 Pending 状态。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po 
NAME               READY   STATUS    RESTARTS     AGE
requests-pod       <span class="token number">0</span>/1     Pending   <span class="token number">0</span>            63s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po requests-pod
Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  17s   default-scheduler  <span class="token number">0</span>/3 nodes are available: <span class="token number">3</span> Insufficient cpu.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有在释放足够的 CPU 资源后，新的 Pod 才能被正常调度。</p>
<h2 id="cpu-实际分配原则"><a class="markdownIt-Anchor" href="#cpu-实际分配原则"></a> CPU 实际分配原则</h2>
<p>CPU 请求不仅在调度时起作用，还决定了剩余的 CPU 时间如何在 Pod 之间分配。</p>
<p>假设有两个 Pod，一个请求 20% 的 CPU，另一个请求 80% 的 CPU，并且两个 Pod 都能够使用满额的 CPU。在没有限制 CPU 使用量的情况下，这两个 Pod 最终会分别占用 20% 和 80% 的 CPU 使用率。</p>
<p>当第一个 Pod 停止消耗 CPU 时，第二个 Pod 会占满 CPU，直到第一个 Pod 重新开始运行。这样，CPU 分配率又会回到 20% 和 80% 的比例。</p>
<p>通过设置 CPU 请求量，可以在调度时控制 Pod 对 CPU 的分配情况。</p>
<h2 id="使用自定义资源"><a class="markdownIt-Anchor" href="#使用自定义资源"></a> 使用自定义资源</h2>
<p>除了内存和处理器，Kubernetes 还可以添加自定义资源（例如 GPU 单元数）进行分配。需要将自定义资源添加到节点的 API 对象的 capacity 属性中，可以通过执行 HTTP 的 PATCH 请求来完成。</p>
<p>自定义资源的名称可以是任意值，不必以 <code>kubernetes.io</code> 域名开头，例如 <code>example.org/myresource</code>。数量必须是整数。这个值会自动从 capacity 字段复制到 allocatable 字段。</p>
<p>之后，在创建 Pod 时，可以通过设置 <code>spec.resources.requests</code> 字段来指定自定义资源的名称和申请量。</p>
<h2 id="设置资源限制"><a class="markdownIt-Anchor" href="#设置资源限制"></a> 设置资源限制</h2>
<p>请求量只是保证每个容器能够获得所需资源的最小量，而限制值则是容器能够消耗资源的最大量。</p>
<p>CPU 是一种可压缩的资源，可以在不对进程产生不利影响的情况下对使用量进行限制。但内存不能被压缩，一旦系统为进程分配了一块内存，该内存在进程主动释放之前将无法回收。因此，需要限制容器的最大内存分配量。</p>
<p>创建一个带有资源限制的 Pod 与设置资源请求基本相同：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-requests2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: requests-pod2
spec:
  containers:
  - image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"dd"</span>, <span class="token string">"if=/dev/zero"</span>, <span class="token string">"of=/dev/null"</span><span class="token punctuation">]</span>
    name: main
    resources:
      limits:
        cpu: 200m
        memory: 100Mi
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-requests2.yaml
pod/requests-pod2 created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于没有指定 requests，它将被设置为与 limits 相同的值。通过 <code>top</code> 命令查看是否生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> requests-pod2 -- <span class="token function">top</span>
Mem: 7802620K used, 187420K free, 62492K shrd, 4240K buff, 6155304K cached
CPU:  <span class="token number">0.6</span>% usr  <span class="token number">1.8</span>% sys  <span class="token number">0.0</span>% nic <span class="token number">97.5</span>% idle  <span class="token number">0.0</span>% io  <span class="token number">0.0</span>% irq  <span class="token number">0.0</span>% sirq
Load average: <span class="token number">0.11</span> <span class="token number">0.14</span> <span class="token number">0.28</span> <span class="token number">3</span>/896 <span class="token number">24</span>
    PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    
<span class="token number">1743839</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">1304</span>      <span class="token number">4</span>      <span class="token number">0</span> R  <span class="token number">19.9</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:38.53 <span class="token function">dd</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，CPU 使用量被限制在了 20.4%。</p>
<h2 id="超过资源限制"><a class="markdownIt-Anchor" href="#超过资源限制"></a> 超过资源限制</h2>
<p>与资源请求不同，资源限制不受可分配资源量的约束。所有 limits 的总和允许超过节点资源总量的 100%。如果节点资源使用量超过 100%，某些容器将被终止。</p>
<p>对于 CPU 限额，进程只会被限制在规定数值以下。然而，内存限额的表现有所不同。如果进程尝试申请超过限额的内存，容器将因为内存不足而被终止（OOMKilled）。如果重启策略为 OnFailure 或 Always，进程会立即重启。如果在重启后再次超过限额，系统将增加下次重启的间隔时间，间隔时间最多增加到 300 秒。这将导致 pod 的状态显示为 CrashLoopBackOff，系统将以每 5 分钟重启一次的频率进行重启，直到容器运行成功或被删除。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-requests2.yaml
    resources:
      limits:
        cpu: 200m
        memory: 2Mi
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-requests2.yaml
pod/requests-pod2 created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">--watch</span>
NAME               READY   STATUS              RESTARTS      AGE
requests-pod2      <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>             3s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po requests-pod2
Events:
  Type     Reason                  Age                 From               Message
  ----     ------                  ----                ----               -------
  Warning  FailedCreatePodSandBox  20s <span class="token punctuation">(</span>x12 over 33s<span class="token punctuation">)</span>  kubelet            Failed to create pod sandbox: rpc error: code <span class="token operator">=</span> Unknown desc <span class="token operator">=</span> failed to start sandbox container <span class="token keyword">for</span> pod <span class="token string">"requests-pod2"</span><span class="token builtin class-name">:</span> Error response from daemon: failed to create shim: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:722: waiting <span class="token keyword">for</span> init preliminary setup caused: <span class="token builtin class-name">read</span> init-p: connection reset by peer: unknown
  Normal   SandboxChanged          20s <span class="token punctuation">(</span>x12 over 32s<span class="token punctuation">)</span>  kubelet            Pod sandbox changed, it will be killed and re-created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在容器中使用 <code>top</code> 命令可以查看到整个节点的资源使用量。</p>
<h1 id="limitrange"><a class="markdownIt-Anchor" href="#limitrange"></a> LimitRange</h1>
<p>可以通过创建一个 <code>LimitRange</code> 资源来为命名空间中的容器配置最大和最小限额，同时给没有指定限制的容器设置默认值。</p>
<p><code>LimitRange</code> 资源被 <code>LimitRanger</code> 准入控制插件控制。当 API 服务器接收带有 Pod 描述信息的 POST 请求时，会检查设置的限制值是否在范围内，以决定是否创建资源，避免调度失败。</p>
<p><code>LimitRange</code> 作用于同一命名空间中的每个独立 Pod、容器或其他类型对象。它不会限制命名空间中所有 Pod 可用资源的总量，总量是通过 <code>ResourceQuota</code> 对象指定。</p>
<h2 id="创建-limitrange-资源"><a class="markdownIt-Anchor" href="#创建-limitrange-资源"></a> 创建 LimitRange 资源</h2>
<p>下面的配置展示了一个 <code>LimitRange</code> 资源的完整定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> LR-example.yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: example
spec:
  limits:
  - type: Pod      <span class="token comment">##指定了资源类型为Pod</span>
    min:           <span class="token comment">##Pod中所有容器的CPU和内存请求量之和的最小值</span>
      cpu: 50m
      memory: 5Mi
    max:           <span class="token comment">##Pod中所有容器的CPU和内存请求量之和的最大值</span>
      cpu: <span class="token number">1</span>
      memory: 1Gi
  - type: Container <span class="token comment">##指定了资源类型为Container</span>
    defaultRequest: <span class="token comment">##容器没有指定请求量时设置的默认值</span>
      cpu: 100m
      memory: 10Mi
    default:        <span class="token comment">##容器没有指定限制量时设置的默认值</span>
      cpu: 200m
      memory: 100Mi
    min:            <span class="token comment">##容器requests和limits的最小值</span>
      cpu: 50m
      memory: 5Mi
    max:            <span class="token comment">##容器requests和limits的最大值</span>
      cpu: <span class="token number">1</span>
      memory: 1Gi
    maxLimitRequestRatio: <span class="token comment">##每种资源requests与limits的最大比值</span>
      cpu: <span class="token number">4</span>
      memory: <span class="token number">10</span>
  - type: PersistentVolumeClaim  <span class="token comment">##指定请求PVC储存容量的最小最大值</span>
    min:
      storage: 1Gi
    max:
      storage: 10Gi
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> LR-example.yaml
limitrange/example created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的示例中，<code>defaultRequest</code> 和 <code>default</code> 字段指定了容器的默认请求和限制。<code>type</code> 字段指定了限制类型为容器。<code>maxLimitRequestRatio</code> 字段指定了 CPU 和内存的最大限制请求比例。<code>min</code> 字段和 <code>max</code> 字段分别指定了 CPU 和内存的最小和最大限制。设置 CPU 为 4，表示容器的 CPU limits 不能超过 requests 的 4 倍，内存同理。</p>
<p>上面新建的 <code>LimitRange</code> 对象包含了对所有资源的限制，也可以将其分割为多个对象。多个 <code>LimitRange</code> 对象的限制会在校验 Pod 或 PVC 合法性时进行合并。</p>
<p>对 <code>LimitRange</code> 进行修改时，已经存在的 Pod 和 PVC 不会受到影响。</p>
<h2 id="测试限制值"><a class="markdownIt-Anchor" href="#测试限制值"></a> 测试限制值</h2>
<p>尝试创建一个 CPU 申请量大于 <code>LimitRange</code> 允许值的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-2
spec:
  containers:
  - image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"dd"</span>, <span class="token string">"if=/dev/zero"</span>, <span class="token string">"of=/dev/null"</span><span class="token punctuation">]</span>
    name: main
    resources:
      limits:
        cpu: <span class="token number">2</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-2.yaml 
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: error when creating <span class="token string">"pod-2.yaml"</span><span class="token builtin class-name">:</span> pods <span class="token string">"pod-2"</span> is forbidden: <span class="token punctuation">[</span>maximum cpu usage per Pod is <span class="token number">1</span>, but limit is <span class="token number">2</span>, maximum cpu usage per Container is <span class="token number">1</span>, but limit is <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器将返回拒绝创建 Pod 的原因，因为每个 Pod 和容器的最大 CPU 请求量限制为 1 核，但此处容器申请了 2 核。</p>
<h2 id="应用限制默认值"><a class="markdownIt-Anchor" href="#应用限制默认值"></a> 应用限制默认值</h2>
<p>测试资源没有指定 <code>requests</code> 和 <code>limits</code> 的情况下分配到的默认值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-drop.yaml
pod/pod-drop created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po pod-drop
    Limits:
      cpu:     200m
      memory:  100Mi
    Requests:
      cpu:        100m
      memory:     10Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>容器的 <code>requests</code> 和 <code>limits</code> 与 <code>LimitRange</code> 对象中设置的一致。</p>
<p>可以在另一个命名空间中指定不同的 <code>LimitRange</code>，以适应不同的使用场景。</p>
<h1 id="resourcequota"><a class="markdownIt-Anchor" href="#resourcequota"></a> ResourceQuota</h1>
<p>可以通过 <code>ResourceQuota</code> 对象来限制命名空间中可用资源的总量。</p>
<p><code>ResourceQuota</code> 的准入控制插件会检查将要创建的 pod 是否会导致总资源量超出限制。如果超出限制，请求会被拒绝。</p>
<p>资源配额不仅限制了命名空间中 pod 和 PVC（持久化卷声明）可以使用的最大资源总量，还可以限制用户在该命名空间中创建 pod、PVC 以及其他 API 对象的数量。</p>
<h2 id="创建配额"><a class="markdownIt-Anchor" href="#创建配额"></a> 创建配额</h2>
<p>创建一个 <code>ResourceQuota</code> 资源来限制命名空间中所有 pod 允许使用的 CPU 和内存总量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> quota-1.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: cpu-and-mem
spec:
  hard:
    requests.cpu: 440m
    requests.memory: 200Mi
    limits.cpu: <span class="token number">2</span>
    limits.memory: 500Mi
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> quota-1.yaml 
resourcequota/cpu-and-mem created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建后，命名空间内所有 pod 合计可申请的 CPU 数量为 440m，限制总量为 2 核；可申请的内存大小为 440MB，限制内存总量为 500MB。</p>
<h2 id="测试配额"><a class="markdownIt-Anchor" href="#测试配额"></a> 测试配额</h2>
<p>新建一个 pod 进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-readonly.yaml 
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: error when creating <span class="token string">"pod-readonly.yaml"</span><span class="token builtin class-name">:</span> pods <span class="token string">"pod-readonly"</span> is forbidden: failed quota: cpu-and-mem: must specify limits.cpu,limits.memory,requests.cpu,requests.memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>API 服务器提示必须为 pod 设置 <code>limits</code> 和 <code>requests</code> 属性才能建立。设置 <code>limits</code> 后再次尝试建立：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-requests2.yaml 
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: error when creating <span class="token string">"pod-requests2.yaml"</span><span class="token builtin class-name">:</span> pods <span class="token string">"requests-pod2"</span> is forbidden: exceeded quota: cpu-and-mem, requested: <span class="token assign-left variable">requests.memory</span><span class="token operator">=</span>400Mi, used: <span class="token assign-left variable">requests.memory</span><span class="token operator">=</span>10Mi, limited: <span class="token assign-left variable">requests.memory</span><span class="token operator">=</span>200Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这次提示配额不足。查看命名空间 <code>default</code> 下的配额使用量和限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe <span class="token function">quota</span> <span class="token parameter variable">-n</span> default
Name:            cpu-and-mem
Namespace:       default
Resource         Used   Hard
--------         ----   ----
limits.cpu       200m   <span class="token number">2</span>
limits.memory    100Mi  500Mi
requests.cpu     100m   440m
requests.memory  10Mi   200Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="储存配额"><a class="markdownIt-Anchor" href="#储存配额"></a> 储存配额</h2>
<p><code>ResourceQuota</code> 对象同样可以限制命名空间中最多可以声明的持久化储存总量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> quota-2.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: storage
spec:
  hard:
    requests.storage: 500Gi
    ssd.storageclass.storage.k8s.io/requests.storage: 300Gi
    standard.storageclass.storage.k8s.io/requests.storage: 1Ti
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> quota-2.yaml 
resourcequota/storage created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述设置中，对命名空间内所有可申请的 PVC 总量限制为 500GB，名为 <code>ssd</code> 的存储类总量限制为 300GB，名为 <code>standard</code> 的标准存储类总量限制为 1TB。</p>
<h2 id="限制对象数量"><a class="markdownIt-Anchor" href="#限制对象数量"></a> 限制对象数量</h2>
<p>可以限制单个命名空间中 pod、RC（副本控制器）、SVC（服务）等对象的个数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> quota-3.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: objects
spec:
  hard:
    pods: <span class="token number">10</span>
    services: <span class="token number">5</span>
    services.nodeports: <span class="token number">2</span>                   
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> quota-3.yaml 
resourcequota/objects created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述声明限制了命名空间中最多可以运行 10 个 pod，5 个 Service。其中，最多可以有两个类型为 <code>NodePort</code> 的 Service。</p>
<h2 id="分配配额"><a class="markdownIt-Anchor" href="#分配配额"></a> 分配配额</h2>
<p>通过 <code>spec.scopes</code> 属性，可以限制配额的作用范围，有四种范围：</p>
<ul>
<li>
<p><code>BestEffort</code> 和 <code>NotBestEffort</code> 范围决定配额作用于 QoS 的最低优先级与其他优先级；</p>
</li>
<li>
<p><code>Terminating</code> 和 <code>NotTerminating</code> 范围作用于配置了 <code>activeDeadlineSeconds</code> 或未配置的 pod。</p>
</li>
</ul>
<p><code>BestEffort</code> 范围只允许限制 pod 的个数，其他范围可以限制所有资源。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> quota-4.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: besteffort-pods
spec:
  scopes:
  - BestEffort
  - NotTerminating
  hard:
    pods: <span class="token number">10</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> quota-4.yaml 
resourcequota/besteffort-pods created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个配额只会应用于最低优先级以及没有设置有效期的 pod 上，这样的 pod 最多只允许存在 10 个。</p>
<h1 id="qos-等级"><a class="markdownIt-Anchor" href="#qos-等级"></a> QoS 等级</h1>
<p>假设节点中的两个 Pod 已经完全消耗了系统资源，当 Pod 申请更多资源时，必须终止一个 Pod。可以通过 QoS 等级确定优先级较低的 Pod 进行退让。优先级从低到高有三种（BestEffort、Burstable、Guaranteed）。</p>
<p>QoS 等级源自 Pod 包含容器的资源请求和限制配置。</p>
<h2 id="besteffort-等级"><a class="markdownIt-Anchor" href="#besteffort-等级"></a> BestEffort 等级</h2>
<p>分配给未设置任何资源请求和限制的 Pod，它们可能无法分配到任何 CPU 资源，并且在需要为其他 Pod 释放内存时，这些容器将被优先终止。</p>
<p>但是由于没有配置内存限制，在资源充足的情况下可以分配任意数量的内存。</p>
<h2 id="guaranteed-等级"><a class="markdownIt-Anchor" href="#guaranteed-等级"></a> Guaranteed 等级</h2>
<p>分配给所有资源请求和限制相等的 Pod。以下条件决定了 Guaranteed 等级：</p>
<ul>
<li>CPU 和内存都必须设置请求和限制。</li>
<li>每个容器都需要设置资源量。</li>
<li>请求和限制必须相等。</li>
</ul>
<p>可以简单地只指定限制字段，这样默认请求与限制相同。但是这些 Pod 容器无法消耗超过限制的资源。</p>
<h2 id="burstable-等级"><a class="markdownIt-Anchor" href="#burstable-等级"></a> Burstable 等级</h2>
<p>所有其他 Pod 都属于这个等级，包括只定义了请求或限制的单容器 Pod，以及多个容器没有完全指定请求或限制的 Pod。</p>
<p>可以通过使用 describe 命令查看 Pod 中的 QoS Class 字段来获取 QoS 等级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po pod-drop
QoS Class:                   BestEffort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="处理相同-qos-等级容器"><a class="markdownIt-Anchor" href="#处理相同-qos-等级容器"></a> 处理相同 QoS 等级容器</h2>
<p>在相同的 QoS 等级下，每个运行中的进程都有一个 OOM（OutOfMemory）分数的值，当需要释放内存时，分数最高的进程将被终止。</p>
<p>OOM 分数由进程已消耗内存百分比和容器内存请求量固定的 OOM 分数调节因子计算。</p>
<p>例如，Pod A 使用了 1GB 内存，Pod B 使用了 2GB 内存，但是 Pod A 的限制是 2GB，Pod B 的限制是 5GB，根据内存占比，Pod A 大于 Pod B，因此 Pod A 会被优先终止。</p>
<h1 id="自动伸缩"><a class="markdownIt-Anchor" href="#自动伸缩"></a> 自动伸缩</h1>
<p>Horizontal Pod Autoscaling (HPA) 是一种管理由控制器管理的 Pod 副本数量的横向自动伸缩方法，根据当前的负载情况自动触发水平扩展或缩容的行为。</p>
<p>自动伸缩的过程可以分为三个步骤：</p>
<ul>
<li>
<p>获取被伸缩资源对象所管理的所有 Pod 的度量值。</p>
<p>Autoscaler 本身不收集 Pod 的度量数据，而是从 cAdvisor agent 获取数据，并由 Heapster 进行聚合，供 HPA 请求调用。</p>
</li>
<li>
<p>计算使度量值达到（或接近）目标值所需的 Pod 数量。</p>
<p>一旦 Autoscaler 获取了它所调整的资源所管理的所有 Pod 的度量值，它将利用这些度量值来计算所需的副本数量。</p>
<p>当只有一个度量值时，计算副本数量只需将所有 Pod 的度量值求和后除以目标值，再向上取整即可。</p>
<p>当有多个度量值时，将分别计算每个度量值所需的副本数量，并取最大值。</p>
</li>
<li>
<p>更新被伸缩资源的 replicas 字段。</p>
<p>Autoscaler 控制器通过 Scale 子资源来修改被伸缩资源的 replicas 字段，从而启动更多的 Pod 或删除多余的 Pod。</p>
</li>
</ul>
<p>HPA 不允许将最小副本数设置为 0。</p>
<h2 id="基于-cpu-使用率"><a class="markdownIt-Anchor" href="#基于-cpu-使用率"></a> 基于 CPU 使用率</h2>
<p>对于 Autoscaler 来说，CPU 使用率是通过比较 Pod 的 CPU 请求量和实际使用量来确定的，因此必须设置 CPU 的请求量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> dp.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: kubia
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - name: nodejs
        image: luksa/kubia
        ports:
        - name: http
          containerPort: <span class="token number">8080</span>
        resources:
          requests:
            cpu: 100m
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> dp.yaml
deployment.apps/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一个 HPA 对象，将其指向该 Deployment。在 HPA 中设置目标 CPU 使用率为 30%，并指定副本的最小和最大数量。Autoscaler 将持续调整 Deployment 上的副本数量，以使 CPU 使用率接近 30%：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl autoscale deployment kubia --cpu-percent<span class="token operator">=</span><span class="token number">30</span> <span class="token parameter variable">--min</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--max</span><span class="token operator">=</span><span class="token number">5</span>
horizontalpodautoscaler.autoscaling/kubia autoscaled
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get hpa
NAME    REFERENCE          TARGETS         MINPODS   MAXPODS   REPLICAS   AGE
kubia   Deployment/kubia   <span class="token operator">&lt;</span>unknown<span class="token operator">></span>/30%   <span class="token number">1</span>         <span class="token number">5</span>         <span class="token number">3</span>          63s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get deployment
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
kubia   <span class="token number">3</span>/3     <span class="token number">3</span>            <span class="token number">3</span>           2m13s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于三个 Pod 没有活动，CPU 使用率接近于 0。等待 5 分钟后，Autoscaler 将其缩减到 1 个副本。自动扩容操作的等待时间为 3 分钟。</p>
<h2 id="基于内存使用"><a class="markdownIt-Anchor" href="#基于内存使用"></a> 基于内存使用</h2>
<p>基于内存的自动伸缩比基于 CPU 的困难得多，主要原因是扩容后原有的 Pod 需要有一种方式来释放内存。这只能由应用程序完成，系统无法代劳。</p>
<p>系统只能终止并重新启动应用程序，希望它在重新启动后占用较少的内存。在 Autoscaler 上，将持续进行扩容操作，直到达到配置的最大 Pod 数量。</p>
<h2 id="基于其他度量"><a class="markdownIt-Anchor" href="#基于其他度量"></a> 基于其他度量</h2>
<p>定义 HPA 需要三个要素的配合：定义度量类型、被监控的资源类型以及资源的目标使用量。</p>
<p>可以在 HPA 对象中使用三种度量：</p>
<ul>
<li>
<p>Resource 度量类型</p>
<p>Resource 类型基于资源度量来做出自动伸缩决策。</p>
<p>例如，基于 CPU 使用量作为度量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">maxReplicas</span><span class="token punctuation">:</span> <span class="token number">5</span>
  <span class="token key atrule">metrics</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">resource</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> cpu
      <span class="token key atrule">targetAverageUtilization</span><span class="token punctuation">:</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>Pods 度量类型</p>
<p>Pods 类型用于引用与 Pod 直接相关的任何其他类型（包括自定义的度量），例如每秒查询次数（QPS）或消息队列中的消息数量。</p>
<p>例如，使 HPA 控制的 ReplicaSet 控制器下所有 Pod 的平均 QPS 维持在 100 的水平：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">metrics</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> Pods
    <span class="token key atrule">resource</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> qps
      <span class="token key atrule">targetAverageValue</span><span class="token punctuation">:</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>Object 度量类型</p>
<p>Object 度量类型用于指定与 Pod 非直接关联的度量，例如 Ingress 对象。在使用 Object 度量类型时，Autoscaler 只会从该单个对象中获取单个度量数据。</p>
<p>例如，使用 Ingress 对象 frontend 的 latencyMillis 作为度量，如果度量超过目标值太多，则会对 Deployment 资源进行扩容：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">metrics</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> Object
    <span class="token key atrule">resource</span><span class="token punctuation">:</span>
      <span class="token key atrule">metricName</span><span class="token punctuation">:</span> latencyMillis
      <span class="token key atrule">target</span><span class="token punctuation">:</span>
        <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
        <span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
        <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
        <span class="token key atrule">targetValue</span><span class="token punctuation">:</span> <span class="token number">20</span>
      <span class="token key atrule">scaleTargetRef</span><span class="token punctuation">:</span>
        <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
        <span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
        <span class="token key atrule">name</span><span class="token punctuation">:</span> hpans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>并非所有的度量都适合作为自动伸缩的基础。在决定基于自定义度量进行伸缩时，需要考虑 Pod 数量变化对度量值的影响。</p>
<h2 id="纵向自动伸缩"><a class="markdownIt-Anchor" href="#纵向自动伸缩"></a> 纵向自动伸缩</h2>
<p>并非所有应用都可以进行横向伸缩。例如，某些 Pod 运行在特定的单节点上，这时需要进行纵向伸缩。</p>
<p>纵向伸缩通过更改 Pod 的配置文件字段来配置 Pod 的资源请求。可以从官方的 GitHub 上下载部署文件。以下是一个 VPA 的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: autoscaling.k8s.io/v1beta2
kind: VerticalPodAutoscaler
metadata:
  name: nginx-vpa
  namespace: vpa
spec:
  targetRef:
    apiVersion: <span class="token string">"apps/v1"</span>
    kind: Deployment
    name: nginx
  updatePolicy:
    updateMode: <span class="token string">"Off"</span>
  resourcePolicy:
    containerPolicies:
    - containerName: <span class="token string">"nginx"</span>
      minAllowed:
        cpu: <span class="token string">"250m"</span>
        memory: <span class="token string">"100Mi"</span>
      maxAllowed:
        cpu: <span class="token string">"2000m"</span>
        memory: <span class="token string">"2048Mi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>VPA 还需要与 Metrics Server 配合使用，不能与 HPA 同时使用。</p>
<h2 id="节点自动伸缩"><a class="markdownIt-Anchor" href="#节点自动伸缩"></a> 节点自动伸缩</h2>
<p>集群自动伸缩器（Cluster Autoscaler）负责在节点资源不足时自动部署新节点，并在节点长时间使用率低下时下线节点。目前节点自动伸缩支持 GKE、GCE、AWS 和 AZURE。</p>
<p>显然，并非任意一个节点都能满足 Pod 的需求，因此云服务提供商通常将具有相同特性的节点聚合成组。当请求新节点时，需要指明节点的类型。</p>
<p>节点的下线是通过监视所有节点上的 CPU 和内存请求来实现的。如果系统中的 Pod 在该节点上运行（不包括 DaemonSet 部署的服务），则该节点不会被释放。也就是说，只有集群自动伸缩器知道在该节点上运行的 Pod 能够调度到其他节点时，该节点才能被释放。在释放节点之前，该节点会被标记为不可调度，并将其中的 Pod 疏散到其他节点。</p>
<p>如果在下线节点的过程中需要指定最少需要保持运行的 Pod 数量，可以使用 PodDisruptionBudget 资源来进行控制。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 安全资源</title>
    <url>/3406984642/</url>
    <content><![CDATA[<h1 id="安全资源"><a class="markdownIt-Anchor" href="#安全资源"></a> 安全资源</h1>
<p>Kubernetes（k8s）提供了一些安全资源来增强集群的安全性和保护应用程序的机密信息。</p>
<h2 id="认证机制"><a class="markdownIt-Anchor" href="#认证机制"></a> 认证机制</h2>
<p>API 服务器可以配置多个认证插件。API 接收到的请求会经过一个认证插件列表，列表中的每个插件都可以检查这个请求和请求发送者身份。如果列表中有插件可以提取客户端的用户名、用户 ID 和组信息，则停止调用剩余的认证插件，将已经认证过的用户的用户名和组（可能有多个组）返回给 API 进入授权阶段。否则，返回 401 响应状态码。</p>
<p>可以通过在 API 服务器启动时加入选项来开启认证插件。目前可以使用的认证方式有：客户端证书、传入在 HTTP 头中的认证 token、基础的 HTTP 认证。</p>
<h2 id="用户"><a class="markdownIt-Anchor" href="#用户"></a> 用户</h2>
<p>k8s 区分两种连接到 API 服务器的客户端：用户和 pod（pod 中的应用）。这两种类型的客户端都使用认证插件进行认证。</p>
<p>用户应该被管理在外部系统中，例如单点登录系统（SSO）。不能通过 API 服务器创建、更新或删除用户。</p>
<p>pod 使用一种称为 Service Accounts 的机制，该机制被创建和储存在集群中作为 ServiceAccount 资源。</p>
<h2 id="组"><a class="markdownIt-Anchor" href="#组"></a> 组</h2>
<p>正常用户和 ServiceAccount 都可以属于一个或多个组，组用来给多个用户赋予权限。系统内置的组有一些特殊含义：</p>
<ul>
<li>
<p><code>system:unauthenticated</code>：分配给所有认证插件都无法认证的客户端。</p>
</li>
<li>
<p><code>system:authenticated</code>：自动分配给成功通过认证的用户。</p>
</li>
<li>
<p><code>system:serviceaccounts</code>：包含所有系统中的 ServiceAccount 对象。</p>
</li>
<li>
<p><code>system:serviceaccount:&lt;namespace&gt;</code>：包含特定命名空间中的所有 ServiceAccount 对象。</p>
</li>
</ul>
<h1 id="安全上下文"><a class="markdownIt-Anchor" href="#安全上下文"></a> 安全上下文</h1>
<p>可以在 pod 或其所属容器的描述中通过 security-Context 选项配置其他与安全性相关的特征。可以用于整个 pod 或 pod 中单独的容器。</p>
<p>其主要可以达到以下目的：</p>
<ul>
<li>
<p>指定容器中运行进程的用户（用户 ID）。</p>
</li>
<li>
<p>阻止容器以 root 用户运行（容器默认运行用户通常在镜像中指定，需要阻止容器以 root 用户运行）。</p>
</li>
<li>
<p>使用特权模式运行容器，使其对宿主节点的内容具有完全的访问权限。</p>
</li>
<li>
<p>通过添加或禁用内核功能，配置内核访问权限。</p>
</li>
<li>
<p>设置 SELinux 选项，加强对容器的限制。</p>
</li>
<li>
<p>阻止进程写入容器的根文件系统。</p>
</li>
</ul>
<h2 id="设置运行容器用户"><a class="markdownIt-Anchor" href="#设置运行容器用户"></a> 设置运行容器用户</h2>
<p>为了使用与镜像中不同的用户来运行 pod，需要设置 <code>spec.containers.securityContext.runAsUser</code> 选项。在这里，我们创建一个使用 <code>guest</code> 用户运行的容器，其值为 405：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-user.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-user
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      runAsUser: <span class="token number">405</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-user.yaml
pod/pod-user created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-user -- <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">405</span><span class="token punctuation">(</span>guest<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 root 用户运行容器会获取挂载目录的完整访问权限，因此应该阻止使用 root 用户运行容器。设置 <code>securityContext.runAsNonRoot</code> 为 <code>true</code> 来启用此限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-noroot.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-noroot
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      runAsNonRoot: <span class="token boolean">true</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-noroot.yaml
pod/pod-noroot created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时查看 pod 状态会发现无法启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME               READY   STATUS                       RESTARTS   AGE
pod-noroot         <span class="token number">0</span>/1     CreateContainerConfigError   <span class="token number">0</span>          29s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po pod-noroot
Events:
  Type     Reason     Age                From               Message
  ----     ------     ----               ----               -------
  Normal   Pulling    12s <span class="token punctuation">(</span>x6 over 89s<span class="token punctuation">)</span>  kubelet            Pulling image <span class="token string">"alpine"</span>
  Warning  Failed     9s <span class="token punctuation">(</span>x5 over 86s<span class="token punctuation">)</span>   kubelet            Error: container has runAsNonRoot and image will run as root <span class="token punctuation">(</span>pod: <span class="token string">"pod-noroot_default(76916440-73d6-4739-9824-dad1c17e8760)"</span>, container: main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>错误详细信息提示 “container has runAsNonRoot and image will run as root”。限制策略起到了作用。</p>
<h2 id="使用特权模式运行"><a class="markdownIt-Anchor" href="#使用特权模式运行"></a> 使用特权模式运行</h2>
<p>有时候，pod 需要执行宿主节点上能够执行的任何操作，例如操作受保护的系统设备或使用其他在普通容器中无法使用的内核功能。例如，代理 pod 通过修改 iptables 规则使服务规则生效。</p>
<p>要启用特权模式，可以将 <code>spec.containers.securityContext.privileged</code> 设置为 <code>true</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-privileged.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: pod-privileged
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      privileged: <span class="token boolean">true</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-privileged.yaml 
pod/pod-privileged created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启用特权模式后，可以在 <code>/dev</code> 目录下查看到特权设备：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-user -- <span class="token function">ls</span> /dev
core             null             shm              termination-log
fd               ptmx             stderr           <span class="token function">tty</span>
full             pts              stdin            urandom
mqueue           random           stdout           zero
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-privileged -- <span class="token function">ls</span> /dev
agpgart             snapshot            tty49
autofs              snd                 tty5
bsg                 stderr              tty50
btrfs-control       stdin               tty51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上，在特权模式下，可以访问宿主节点上的所有设备，并且可以自由地使用它们。</p>
<h2 id="容器添加内核功能"><a class="markdownIt-Anchor" href="#容器添加内核功能"></a> 容器添加内核功能</h2>
<p>相比让容器运行在特权模式，更安全做法是只给予它真正需要的内核功能权限。Kubernetes 允许为特定容器添加或禁用部分内核功能。</p>
<p>例如，如果需要允许容器修改系统时间，可以在容器的 <code>capabilities</code> 里添加一个名为 <code>CAP_SYS_TIME</code> 的功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-settime.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-settime
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      capabilities:
        add:
        - SYS_TIME
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-settime.yaml 
pod/pod-settime created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Linux 内核功能名称通常以 <code>CAP_</code> 开头，在 pod 模板中必须省略 <code>CAP_</code> 前缀。测试修改系统时间的操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">date</span>
Mon Mar <span class="token number">21</span> <span class="token number">20</span>:12:40 CST <span class="token number">2022</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-settime -- <span class="token function">date</span> +%T <span class="token parameter variable">-s</span> <span class="token string">"20:10:00"</span>
<span class="token number">20</span>:10:00
<span class="token punctuation">[</span>root@server6-node2 ~<span class="token punctuation">]</span>$ <span class="token function">date</span>
Tue Mar <span class="token number">22</span> 04:11:03 CST <span class="token number">2022</span>
<span class="token punctuation">[</span>root@server6-node2 ~<span class="token punctuation">]</span>$ ntpdate cn.pool.ntp.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="容器禁用内核功能"><a class="markdownIt-Anchor" href="#容器禁用内核功能"></a> 容器禁用内核功能</h2>
<p>默认情况下，容器拥有 <code>CAP_CHOWN</code> 权限，允许进程修改文件系统中文件的所有者。如果要禁用此能力，可以在 <code>capabilities.drop</code> 列表中加入 <code>CHOWN</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-drop.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-drop
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      capabilities:
        drop:
        - CHOWN
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-drop.yaml 
pod/pod-drop created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试修改 <code>/tmp</code> 目录所有者的操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> pod-drop -- <span class="token function">chown</span> guest /tmp
chown: /tmp: Operation not permitted
<span class="token builtin class-name">command</span> terminated with <span class="token builtin class-name">exit</span> code <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="阻止写根文件系统"><a class="markdownIt-Anchor" href="#阻止写根文件系统"></a> 阻止写根文件系统</h2>
<p>假设存在一个 PHP 漏洞，攻击者可以通过该漏洞改写 PHP 文件，而这些 PHP 文件位于容器的根文件系统中。为了防止文件被篡改，可以通过设置 <code>securityContext.readOnlyRootFilesystem</code> 为 <code>true</code> 来禁止对根文件系统的写入操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-readonly.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: pod-readonly
spec:
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      readOnlyRootFilesystem: <span class="token boolean">true</span>
    volumeMounts:
    - name: my-volume
      mountPath: /volume
      readOnly: <span class="token boolean">false</span>
  volumes:
  - name: my-volume
    emptyDir: <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-readonly.yaml 
pod/pod-readonly created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个示例中，容器以 root 用户运行，并具有对根目录的写权限。然而，尝试向根文件系统写入文件会失败。与此同时，对挂载的卷进行写入是被允许的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-readonly -- <span class="token function">touch</span> /new-file
touch: /new-file: Read-only <span class="token function">file</span> system
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-readonly -- <span class="token function">touch</span> /volume/new-file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="多用户共享储存卷"><a class="markdownIt-Anchor" href="#多用户共享储存卷"></a> 多用户共享储存卷</h2>
<p>假设一个 Pod 中运行着两个容器，它们共享同一个存储卷。当使用不同的用户运行这两个容器时，可能会出现权限问题。</p>
<p>可以为 Pod 中的所有容器指定 <code>fsGroup</code> 和 <code>supplementalGroups</code>，以允许容器在以任何用户运行时共享文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-shared.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-shared
spec:
  securityContext:
    fsGroup: <span class="token number">555</span>
    supplementalGroups: <span class="token punctuation">[</span><span class="token number">666</span>, <span class="token number">777</span><span class="token punctuation">]</span>
  containers:
  - name: first
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      runAsUser: <span class="token number">1111</span>
    volumeMounts:
    - name: shared-volume
      mountPath: /volume
      readOnly: <span class="token boolean">false</span>
  - name: second
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
    securityContext:
      runAsUser: <span class="token number">2222</span>
    volumeMounts:
    - name: shared-volume
      mountPath: /volume
      readOnly: <span class="token boolean">false</span>
  volumes:
  - name: shared-volume
    emptyDir: <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-shared.yaml 
pod/pod-shared created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中第一个容器以用户 ID 1111 运行，第二个容器以用户 ID 2222 运行，两个容器共享同一个名为 <code>shared-volume</code> 的存储卷。</p>
<p>查看第一个容器中的情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-shared <span class="token parameter variable">-c</span> first -- <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1111</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">555,666</span>,777<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果显示该容器运行的用户所属组为 root，并关联了额外的用户组 555、666、777。</p>
<p>其中，用户组 555 是 <code>fsGroup</code> 的设置，因此该存储卷属于该用户组。当在该存储卷的目录下创建文件时，文件的所有者为用户 ID 1111，属组为用户组 555：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-shared <span class="token parameter variable">-c</span> first -- <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">grep</span> volume
drwxrwsrwx    <span class="token number">2</span> root     <span class="token number">555</span>              <span class="token number">6</span> Mar <span class="token number">21</span> <span class="token number">14</span>:00 volume
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-shared <span class="token parameter variable">-c</span> first -- <span class="token function">ls</span> <span class="token parameter variable">-l</span> /volume/foo
-rw-r--r--    <span class="token number">1</span> <span class="token number">1111</span>     <span class="token number">555</span>              <span class="token number">0</span> Mar <span class="token number">21</span> <span class="token number">14</span>:13 /volume/foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通常情况下，新创建的文件的属组为创建用户的用户组 ID。在设置 <code>supplementalGroups</code> 后，在其他路径创建文件时，文件的所有者和属组都为 root：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-shared <span class="token parameter variable">-c</span> first -- <span class="token builtin class-name">echo</span> foo <span class="token operator">></span> /tmp/foo <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span> <span class="token parameter variable">-l</span> /tmp/foo
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">5</span> Mar <span class="token number">21</span> <span class="token number">22</span>:08 /tmp/foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="系统命名空间"><a class="markdownIt-Anchor" href="#系统命名空间"></a> 系统命名空间</h1>
<p>每个 pod 都有自己的网络、PID 和 IPC 命名空间。这些命名空间将容器中的进程与其他容器或宿主机中的进程隔离开来。</p>
<h2 id="网络命名空间"><a class="markdownIt-Anchor" href="#网络命名空间"></a> 网络命名空间</h2>
<p>部分 pod（特别是系统 pod）需要在宿主节点的默认命名空间中运行，以允许它们看到和操作节点级别的资源和设备。</p>
<p>当 pod 需要使用宿主节点上的网络适配器时，可以通过将 pod spec 中的 <code>hostNetwork</code> 设置为 <code>true</code>，来使用宿主节点的网络命名空间。这种情况下，pod 和宿主节点共享网络接口。</p>
<p>以下是创建一个使用宿主节点默认网络命名空间的 pod 的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pod-host-network.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: pod-host-network
spec:
  hostNetwork: <span class="token boolean">true</span>
  containers:
  - image: alpine
    name: main
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pod-host-network.yaml 
pod/pod-host-network created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> pod-host-network -- <span class="token function">ifconfig</span>
ens37     Link encap:Ethernet  HWaddr 00:0C:29:FB:AF:1E  
          inet addr:192.168.2.205  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::ff32:c0f:6cf:bfea/64 Scope:Link
          inet6 addr: fe80::9e57:89b4:bf98:c4d7/64 Scope:Link
          inet6 addr: 240e:383:404:aa00:a7a8:7fd6:fa4e:470d/64 Scope:Global
          inet6 addr: fe80::b1c4:1b6c:9cd9:7815/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:7563380 errors:0 dropped:584670 overruns:0 frame:0
          TX packets:7392819 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:4215026725 <span class="token punctuation">(</span><span class="token number">3.9</span> GiB<span class="token punctuation">)</span>  TX bytes:2918526795 <span class="token punctuation">(</span><span class="token number">2.7</span> GiB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这样的配置，pod 中的容器将能够查看和访问宿主节点上的网络接口。这对于部署 K8s 控制平面组件时非常有用，因为它们需要使用 <code>hostNetwork</code> 选项。</p>
<h2 id="绑定节点端口"><a class="markdownIt-Anchor" href="#绑定节点端口"></a> 绑定节点端口</h2>
<p>可以通过配置 pod 模板中的 <code>spec.containers.ports.hostPort</code> 字段，将容器的端口绑定到节点端口。</p>
<p>对于使用 <code>hostPort</code> 的 pod，访问宿主节点的端口连接会直接转发到对应的 pod 端口上。而通过 NodePort 服务暴露端口，则连接会被转发到随机的 pod 上。</p>
<p>与此同时，NodePort 服务会在所有节点上绑定端口，即使节点上没有 pod。而 <code>hostPort</code> 只能在有 pod 的节点上访问，并且同一个节点上不能有两个相同的 pod，否则会出现端口冲突。两者的区别如下图所示：</p>
<p><img data-src="../../../images/hostPort%E5%92%8CNodePort%E6%9C%8D%E5%8A%A1%E5%8C%BA%E5%88%AB.jpg" alt="hostPort和NodePort服务区别" /></p>
<p>下面是一个带有 <code>hostPort</code> 选项的 pod 的创建示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-hostport.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-hostport
spec:
  containers:
  - name: kubia
    image: luksa/kubia
    ports:
    - containerPort: <span class="token number">8080</span>
      hostPort: <span class="token number">9000</span>
      protocol: TCP
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-hostport.yaml
pod/kubia-hostport created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> wide
NAME               READY   STATUS    RESTARTS   AGE    IP               NODE            
kubia-hostport     <span class="token number">1</span>/1     Running   <span class="token number">0</span>          18s    <span class="token number">10.244</span>.244.250   server6-node2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这样的配置，我们可以看到 pod 运行在 node2 上，可以通过 node2 的 IP 地址加上端口号 9000 来访问该 pod。</p>
<p><code>hostPort</code> 功能最初用于暴露在每个节点上通过 DaemonSet 部署的系统服务，也用于确保两个副本的 pod 不会被调度到同一节点上。</p>
<h2 id="pid-和-ipc-命名空间"><a class="markdownIt-Anchor" href="#pid-和-ipc-命名空间"></a> PID 和 IPC 命名空间</h2>
<p>pod spec 中的 <code>hostPID</code> 和 <code>hostIPC</code> 选项与 <code>hostNetwork</code> 相似。当设为 true 时，pod 中的容器会使用宿主节点的 PID 和 IPC 命名空间，可以看到宿主机上的全部进程或通过 IPC 机制与它们通信。</p>
<p>创建一个共享宿主机 PID 和 IPC 命名空间的 pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> host-pid.yaml
apiVersion: v1
kind: Pod
metadata:
  name: host-pid
spec:
  hostPID: <span class="token boolean">true</span>
  hostIPC: <span class="token boolean">true</span>
  containers:
  - name: main
    image: alpine
    command: <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> host-pid.yaml
pod/host-pid created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试在容器中查看与关闭宿主机进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> host-pid -- <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">top</span>
 <span class="token number">4974</span> root      <span class="token number">0</span>:00 <span class="token function">top</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> host-pid -- <span class="token function">kill</span> <span class="token parameter variable">-9</span> <span class="token number">4974</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="隔离-pod-网络"><a class="markdownIt-Anchor" href="#隔离-pod-网络"></a> 隔离 Pod 网络</h1>
<p>有时候需要限制 Pod 之间的通信以确保网络安全性。是否可以进行这些配置取决于集群中所使用的 CNI 容器网络插件。如果插件支持，可以通过 NetworkPolicy 资源来配置网络隔离。</p>
<p>一个 NetworkPolicy 会应用在与其匹配的标签选择器所选出的 Pod 上，指定允许访问这些 Pod 的源地址，以及这些 Pod 可以访问的目标地址。这些规则由 ingress 和 egress 规则分别指定。这两种规则都可以匹配由标签选择器选出的 Pod，或者一个命名空间中的所有 Pod，或者通过无类别域间路由（CIDR，Classless Inter-Domain Routing）指定的 IP 地址段。</p>
<h2 id="同命名空间网络隔离"><a class="markdownIt-Anchor" href="#同命名空间网络隔离"></a> 同命名空间网络隔离</h2>
<p>默认情况下，某一命名空间中的 Pod 可以被任意来源访问。</p>
<p>可以在特定命名空间创建一个 NetworkPolicy，阻止任何客户端访问该命名空间的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">5</span><span class="token punctuation">]</span>$ <span class="token function">vi</span> np-deny.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>空的标签选择器匹配命名空间中所有的 Pod。</p>
<h2 id="同命名空间部分访问"><a class="markdownIt-Anchor" href="#同命名空间部分访问"></a> 同命名空间部分访问</h2>
<p>也可以指定在同命名空间中允许互相访问的 Pod，未定义的 Pod 不得与互联：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">5</span><span class="token punctuation">]</span>$ <span class="token function">vi</span> np-postgres.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgres-netpolicy
spec:
  podSelector:
    matchlabels:
      app: database
  ingress:
  - from:
    - podSelector:
      matchLabels:
        app: webserver
    ports:
    - port: <span class="token number">5432</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面配置了允许标签为 <code>app=webserver</code> 的 Pod 访问标签为 <code>app=database</code> 的 Pod 的 5432 端口。</p>
<h2 id="不同命名空间网络隔离"><a class="markdownIt-Anchor" href="#不同命名空间网络隔离"></a> 不同命名空间网络隔离</h2>
<p>假设有多个命名空间分属于不同用户，在 NS 中有标签 <code>tenant:manning</code> 来标记属于哪个用户，只允许同一标签的 Pod，也就是同一用户的 NS 中的 Pod 可以互相访问，不符合标签的用户禁止访问这个 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: np-shopping
spec:
  podSelector:
    matchlabels:
      app: shopping
  ingress:
  - from:
    - namespaceSelector:
      matchLabels:
        tenant: manning
    ports:
    - port: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要其他用户访问，可以创建一个新的 NP 资源，或者在上面的配置中增加一条入向规则。</p>
<p>通常在多租户 K8s 集群中，租户不能为他们的命名空间添加标签，否则可以规避基于 namespaceSelector 的入向规则。</p>
<h2 id="使用-cidr-隔离网络"><a class="markdownIt-Anchor" href="#使用-cidr-隔离网络"></a> 使用 CIDR 隔离网络</h2>
<p>可以通过 CIDR 表示法指定一个 IP 段，例如允许 129.168.1.0/24 段的客户端访问 shopping 的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ingress:
- from:
  - ipBlock:
      cidr: <span class="token number">192.168</span>.1.0/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="限制-pod-对外访问"><a class="markdownIt-Anchor" href="#限制-pod-对外访问"></a> 限制 Pod 对外访问</h2>
<p>也可以通过 egress 来设置出向规则，限制 Pod 的对外流量访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spec:
  podSelector:
    matchlabels:
      app: shopping
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个策略应用于包含标签 <code>app=shopping</code> 的 Pod，它们只能与具有相同标签的 Pod 进行通信。除此之外，不能访问任何地址，无论是 Pod 还是 IP，无论是集群内还是集群外。</p>
<h1 id="serviceaccount"><a class="markdownIt-Anchor" href="#serviceaccount"></a> ServiceAccount</h1>
<p>下面简称 SA。</p>
<p>每个 pod 都与一个 SA 相关联，SA 代表了运行在 pod 中应用程序的身份证明。位于容器内的 token 文件持有 SA 的认证 token，应用程序使用这个 token 连接 API 服务器时，身份认证插件会对 SA 进行身份认证，并将 SA 的用户名传回 API 服务器内部。SA 用户名的格式如下：<code>system:serviceaccount:&lt;namespace&gt;:&lt;service account name&gt;</code>。</p>
<p>API 服务器将这个用户名传递给已配置好的授权插件，来决定应用程序所尝试执行的操作是否被允许执行。</p>
<p>SA 只不过是一种运行在 pod 中的应用程序和 API 服务器身份认证的一种方式，应用程序通过在请求中传递 SA token 来实现这点。</p>
<h2 id="查看-sa"><a class="markdownIt-Anchor" href="#查看-sa"></a> 查看 SA</h2>
<p>SA 资源作用在单独的命名空间，每个命名空间会自动创建一个默认的 SA。可以通过 get 命令查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get sa
NAME      SECRETS   AGE
default   <span class="token number">1</span>         137d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 pod 的配置文件中，可以使用指定账户名称的方式将一个 SA 赋值给一个 pod。如果不指定，pod 会使用这个命名空间中的默认 SA。</p>
<p>SA 可以给多个 pod 关联使用，来控制每个 pod 可以访问的资源。但是 pod 不能使用跨命名空间的 SA。</p>
<h2 id="创建-sa"><a class="markdownIt-Anchor" href="#创建-sa"></a> 创建 SA</h2>
<p>可以使用 create 命令来创建 SA：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create sa foo
serviceaccount/foo created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe sa foo
Name:                foo
Namespace:           default
Labels:              <span class="token operator">&lt;</span>none<span class="token operator">></span>
Annotations:         <span class="token operator">&lt;</span>none<span class="token operator">></span>
Image pull secrets:  <span class="token operator">&lt;</span>none<span class="token operator">></span>
Mountable secrets:   foo-token-68qgz
Tokens:              foo-token-68qgz
Events:              <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示 SA 详细信息中，主要有三个参数：</p>
<ul>
<li>
<p>Image pull secrets（镜像拉取秘钥）</p>
<p>Image pull secrets 不仅给 pod 拉取镜像时使用，这个字段的秘钥会自动添加到所有使用这个 SA 的 pod 中，以此达到批量添加的操作。</p>
</li>
<li>
<p>Mountable secrets（可挂载的秘钥）</p>
<p>默认情况下，pod 可以挂载任何需要的秘钥，通过 Mountable secrets 配置可以让 pod 只允许挂载其中的 secrets。需要配合注解 <code>kubernetes.io/enforce-mountable-secrets=&quot;true&quot;</code> 来限制。</p>
</li>
<li>
<p>Tokens（身份认证令牌）</p>
<p>pod 认证时使用的 token。</p>
</li>
</ul>
<p>可以进一步查看自定义的 token 密钥内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe secrets foo-token-68qgz

Data
<span class="token operator">==</span><span class="token operator">==</span>
ca.crt:     <span class="token number">1099</span> bytes
namespace:  <span class="token number">7</span> bytes
token:      eyJhbGciOiJSUzI1NiI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中包括了和默认 SA 相同的条目：CA 证书、命名空间和 token。SA 中使用的身份认证 token 是 JWT（JSON Web Token）。</p>
<h2 id="配置-sa"><a class="markdownIt-Anchor" href="#配置-sa"></a> 配置 SA</h2>
<p>通过配置 pod 模板中 <code>spec.serviceAccountName</code> 字段来分配 SA。pod 创建之后不能被修改：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> curl-sa.yaml
apiVersion: v1
kind: Pod
metadata:
  name: curl-custom-sa
spec:
  serviceAccountName: foo
  containers:
  - name: main
    image: curlimages/curl
    command: <span class="token punctuation">[</span><span class="token string">"sleep"</span>, <span class="token string">"99999"</span><span class="token punctuation">]</span>
  - name: ambassador
    image: luksa/kubectl-proxy:1.6.2
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> curl-sa.yaml
pod/curl-custom-sa created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看容器内的 token：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> curl-custom-sa <span class="token parameter variable">-c</span> main -- <span class="token function">cat</span> /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6IlZDdEV4ZVNxWmNVVlNMS2lqRU5hM2NNVzBRSE54bHZsSzZucERQY3lzblEifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对比发现和 foo-token-llg77 完全相同。测试通过使用自定义 SA 的 token 和 API 服务器进行通信：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> curl-custom-sa <span class="token parameter variable">-c</span> main -- <span class="token function">curl</span> localhost:8001/api/v1/pods/
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Status"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"Failure"</span>,
  <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"pods is forbidden: User <span class="token entity" title="\&quot;">\"</span>system:serviceaccount:default:foo<span class="token entity" title="\&quot;">\"</span> cannot list resource <span class="token entity" title="\&quot;">\"</span>pods<span class="token entity" title="\&quot;">\"</span> in API group <span class="token entity" title="\&quot;">\"</span><span class="token entity" title="\&quot;">\"</span> at the cluster scope"</span>,
  <span class="token string">"reason"</span><span class="token builtin class-name">:</span> <span class="token string">"Forbidden"</span>,
  <span class="token string">"details"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"pods"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"code"</span><span class="token builtin class-name">:</span> <span class="token number">403</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果提示新建的 SA 没有列出 pod 列表的权限。SA 需要和 RBAC 授权插件配合使用，否则 SA 只起到提供镜像拉取秘钥的功能。</p>
<h1 id="podsecuritypolicy"><a class="markdownIt-Anchor" href="#podsecuritypolicy"></a> PodSecurityPolicy</h1>
<p>以下简称为 PSP。PSP 将在 k8s 1.25 版本中移除，后续可能使用 Kyverno 或 OPA（Open Policy Agent）。</p>
<p>PSP 默认为关闭状态，需要修改 API 服务器配置 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> 中，添加 <code>--enable-admission-plugins=NodeRestriction,PodSecurityPolicy</code> 来启用 PSP 控制器。</p>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<p>PSP 是一种集群级别（无命名空间）资源。它定义了用户能否在 pod 中使用各种安全相关的特性。维护 PSP 配置工作由集成在 API 服务器中的 PodSecurityPolicy 准入控制插件完成。</p>
<p>当向 API 服务器发送建立 pod 资源请求时，PSP 准入控制插件会将这个 pod 与已经配置的 PSP 进行校验。如果符合安全策略，则存入 etcd，否则会立即被拒绝。此插件也会根据安全策略中配置的默认值对 pod 进行修改。</p>
<p>PSP 资源主要定义以下规则：</p>
<ul>
<li>
<p>是否允许 pod 使用宿主节点的 PID，IPC，网络命名空间。</p>
</li>
<li>
<p>pod 允许绑定的宿主节点端口。</p>
</li>
<li>
<p>容器运行时允许使用的用户 ID。</p>
</li>
<li>
<p>是否允许拥有特权模式容器的 pod。</p>
</li>
<li>
<p>允许添加哪些内核功能，默认添加哪些内核功能，总是禁用哪些内核功能。</p>
</li>
<li>
<p>允许容器使用哪些 SELinux 选项。</p>
</li>
<li>
<p>容器是否允许使用可写的根文件系统。</p>
</li>
<li>
<p>允许容器在哪些文件系统组下运行。</p>
</li>
<li>
<p>允许 pod 使用哪些类型的储存卷。</p>
</li>
</ul>
<p>PSP 存在的主要问题是：</p>
<ul>
<li>
<p>授权模型存在缺陷。</p>
</li>
<li>
<p>功能易开难关。</p>
</li>
<li>
<p>API 接口缺乏一致性及扩展性，如 <code>MustRunAsNonRoot</code>，<code>AllowPrivilegeEscalation</code> 此类配置。</p>
</li>
<li>
<p>无法处理动态注入的 side-car（如 knative）。</p>
</li>
<li>
<p>在 CI/CD 场景难以落地。</p>
</li>
</ul>
<h2 id="建立-psp"><a class="markdownIt-Anchor" href="#建立-psp"></a> 建立 PSP</h2>
<p>下面定义一个 PSP 的示例，其作用是阻止 pod 使用宿主节点命名空间、不允许特权模式，并定义了能绑定节点端口的限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> psp-default.yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: default
spec:
  hostIPC: <span class="token boolean">false</span>
  hostPID: <span class="token boolean">false</span>
  hostNetwork: <span class="token boolean">false</span>
  hostPorts:
  - min: <span class="token number">10000</span>
    max: <span class="token number">11000</span>
  - min: <span class="token number">13000</span>
    max: <span class="token number">14000</span>
  privileged: <span class="token boolean">false</span>
  readOnlyRootFilesystem: <span class="token boolean">true</span>
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  seLinux:
    rule: RunAsAny
  volumes:
  - <span class="token string">'*'</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> psp-default.yaml 
Warning: policy/v1beta1 PodSecurityPolicy is deprecated <span class="token keyword">in</span> v1.21+, unavailable <span class="token keyword">in</span> v1.25+
podsecuritypolicy.policy/default created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建成功后，限制立即生效。</p>
<h2 id="用户和组限制"><a class="markdownIt-Anchor" href="#用户和组限制"></a> 用户和组限制</h2>
<p>当在 <code>runAsUser</code> 或类似字段中使用 <code>RunAsAny</code> 规则时，对容器运行时可使用的用户和用户组没有任何限制。如果规则改为 <code>MustRunAs</code>，可以限制容器能使用的用户和用户组。</p>
<p>例如，限制运行用户 ID 的范围在 2-10 或 20-30 范围内，限制组 ID 在 2-30 之间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">  runAsUser:
    rule: MustRunAs
    ranges:
    - min: <span class="token number">2</span>
      max: <span class="token number">10</span>
    - min: <span class="token number">20</span>
      max: <span class="token number">30</span>
  fsGroup:
    rule: MustRunAs
SYS_MODULE    ranges:
    - min: <span class="token number">2</span>
      max: <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有超过 ID 限制范围的创建请求都会被拒绝。修改策略对已经存在的 pod 无效，PSP 资源仅作用于创建和新升级的 pod。</p>
<p>假如镜像指定了运行用户 ID，并且 PSP 也使用了限制运行用户策略，最终只要镜像运行的用户 ID 在 PSP 限定范围内，实际运行的用户 ID 以 PSP 限制为准。</p>
<h2 id="配置内核功能"><a class="markdownIt-Anchor" href="#配置内核功能"></a> 配置内核功能</h2>
<p>在 PSP 中，分别配置 <code>spec</code> 下的 <code>allowedCapabilities</code>、<code>defaultAddCapabilities</code>、<code>requiredDropCapabilities</code> 三个字段，来实现允许容器添加内核功能、为容器自动添加功能以及禁止容器使用的内核功能。</p>
<p>例如，配置容器允许添加 <code>SYS_TIME</code> 功能、自动添加 <code>CHOWN</code> 功能，并禁止 <code>SYS_ADMIN</code> 和 <code>SYS_MODULE</code> 功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: default
spec:
  allowedCapabilities:
  - SYS_TIME
  defaultAddCapabilities:
  - CHOWN
  requiredDropCapabilities:
  - SYS_ADMIN
  - SYS_MODULE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>没有配置的内核功能默认禁止添加到 pod 中。如果 pod 配置文件和 PSP 中都定义了同样的字段，以 PSP 为准。试图在 pod 定义中加入禁止的功能会被 API 服务器拒绝创建 pod。</p>
<h2 id="限制储存卷类型"><a class="markdownIt-Anchor" href="#限制储存卷类型"></a> 限制储存卷类型</h2>
<p>使用 “*” 代表所有类型，也可以手动指定类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">volumes:
- emptyDir
- configMap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其他没有指定的存储卷类型将不被允许使用。如果存在多个 PSP，那么 pod 实际可以使用的存储卷类型是所有 PSP 中 volume 列表的并集。</p>
<h2 id="分配-psp"><a class="markdownIt-Anchor" href="#分配-psp"></a> 分配 PSP</h2>
<p>针对不同用户或组分配不同的 PSP 策略是通过 RBAC 机制实现的。实现方式是先创建需要的 PSP 资源，然后创建 ClusterRole 资源，并通过名称将它们指向不同的策略，以此使 PSP 资源中的策略对不同用户或组生效。通过 ClusterRoleBinding 资源将特定的用户或组绑定到 ClusterRole 上。当 PSP 访问控制插件需要决定是否接纳一个 pod 时，它只会考虑创建 pod 的用户可以访问到的 PSP 中的策略。</p>
<p>首先创建一个允许 <code>privileged</code> 权限的 PSP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> psp-privileged.yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: privileged
spec:
  privileged: <span class="token boolean">true</span>
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  seLinux:
    rule: RunAsAny
  volumes:
  - <span class="token string">'*'</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> psp-privileged.yaml
Warning: policy/v1beta1 PodSecurityPolicy is deprecated <span class="token keyword">in</span> v1.21+, unavailable <span class="token keyword">in</span> v1.25+
podsecuritypolicy.policy/privileged created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get psp
NAME                      PRIV    CAPS   SELINUX    RUNASUSER          FSGROUP     SUPGROUP    READONLYROOTFS   VOLUMES
default                   <span class="token boolean">false</span>          RunAsAny   RunAsAny           RunAsAny    RunAsAny    <span class="token boolean">true</span>             *
privileged                <span class="token boolean">true</span>           RunAsAny   RunAsAny           RunAsAny    RunAsAny    <span class="token boolean">false</span>            *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建两个 ClusterRole，一个使用 <code>default</code> 策略，一个使用 <code>privileged</code> 策略。需要使用动词 <code>use</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrole psp-default <span class="token parameter variable">--verb</span><span class="token operator">=</span>use <span class="token parameter variable">--resource</span><span class="token operator">=</span>podsecuritypolicies --resource-name<span class="token operator">=</span>default
clusterrole.rbac.authorization.k8s.io/psp-default created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrole psp-privileged <span class="token parameter variable">--verb</span><span class="token operator">=</span>use <span class="token parameter variable">--resource</span><span class="token operator">=</span>podsecuritypolicies --resource-name<span class="token operator">=</span>privileged
clusterrole.rbac.authorization.k8s.io/psp-privileged created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将默认权限绑定到认证账户组，允许 <code>privileged</code> 权限的 PSP 绑定到用户 Bob：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrolebinding psp-all-users <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>psp-default <span class="token parameter variable">--group</span><span class="token operator">=</span>system:authenticated
clusterrolebinding.rbac.authorization.k8s.io/psp-all-users created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrolebinding psp-bob <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>psp-privileged <span class="token parameter variable">--user</span><span class="token operator">=</span>bob
clusterrolebinding.rbac.authorization.k8s.io/psp-bob created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>kubectl config</code> 创建两个新用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl config set-credentials alice <span class="token parameter variable">--username</span><span class="token operator">=</span>alice <span class="token parameter variable">--password</span><span class="token operator">=</span>password
User <span class="token string">"alice"</span> set.
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl config set-credentials bob <span class="token parameter variable">--username</span><span class="token operator">=</span>bob <span class="token parameter variable">--password</span><span class="token operator">=</span>password
User <span class="token string">"bob"</span> set.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用不同用户创建带特权选项的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token parameter variable">--user</span> alice create <span class="token parameter variable">-f</span> pod-settime.yaml 
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: unknown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>API 服务器不允许 <code>alice</code> 创建特权 pod，但 <code>bob</code> 可以成功创建。</p>
<h1 id="rbac"><a class="markdownIt-Anchor" href="#rbac"></a> RBAC</h1>
<p>RBAC 授权插件将用户角色作为决定用户能否执行操作的关键因素。主体和一个或多个角色相关联，每个角色被允许在特定的资源上执行特定的动词。</p>
<p>RBAC 授权规则是通过四种资源进行配置，可以分为两组：</p>
<ul>
<li>Role（角色）和 ClusterRole（集群角色），它们指定了在资源上可以执行哪些动词。</li>
<li>RoleBinding（角色绑定）和 ClusterRoleBinding（集群角色绑定），它们将上述角色绑定到特定的用户、组或 SA 上。</li>
</ul>
<p>角色和集群角色与绑定之间的区别在于，角色绑定命名空间资源，集群角色绑定集群级别资源。</p>
<p>RBAC 除了可对全部资源类型应用安全权限，还可以应用于特定的资源实例。</p>
<h2 id="http-请求动作"><a class="markdownIt-Anchor" href="#http-请求动作"></a> HTTP 请求动作</h2>
<p>通过客户端发送 HTTP 请求到 RESTful API 服务器特定的 URL 可以执行相应的动作。它们的映射关系如下：</p>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>单一资源的动词</th>
<th>集合的动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET, HEAD</td>
<td>get（以及 watch 监听）</td>
<td>list（以及 watch)</td>
</tr>
<tr>
<td>POST</td>
<td>create</td>
<td>-</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
<td>-</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
<td>-</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
<td>deletecollection</td>
</tr>
</tbody>
</table>
<p>动词 <code>use</code> 用于 PodSecurityPolicy 资源。</p>
<h2 id="测试-rbac"><a class="markdownIt-Anchor" href="#测试-rbac"></a> 测试 RBAC</h2>
<p>通过一个运行 <code>kubectl-proxy</code> 的镜像，测试在容器中直接请求 API 服务器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create ns foo
namespace/foo created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create ns bar
namespace/bar created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl run <span class="token builtin class-name">test</span> <span class="token parameter variable">--image</span><span class="token operator">=</span>luksa/kubectl-proxy <span class="token parameter variable">-n</span> foo
pod/test created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl run <span class="token builtin class-name">test</span> <span class="token parameter variable">--image</span><span class="token operator">=</span>luksa/kubectl-proxy <span class="token parameter variable">-n</span> bar
pod/test created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api/v1/namespaces/foo/services
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Status"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"Failure"</span>,
  <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"services is forbidden: User <span class="token entity" title="\&quot;">\"</span>system:serviceaccount:foo:default<span class="token entity" title="\&quot;">\"</span> cannot list resource <span class="token entity" title="\&quot;">\"</span>services<span class="token entity" title="\&quot;">\"</span> in API group <span class="token entity" title="\&quot;">\"</span><span class="token entity" title="\&quot;">\"</span> in the namespace <span class="token entity" title="\&quot;">\"</span>foo<span class="token entity" title="\&quot;">\"</span>"</span>,
  <span class="token string">"reason"</span><span class="token builtin class-name">:</span> <span class="token string">"Forbidden"</span>,
  <span class="token string">"details"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"services"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"code"</span><span class="token builtin class-name">:</span> <span class="token number">403</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>响应表示 Service Account 不允许列出 foo 命名空间中的服务，RBAC 插件阻挡了请求。</p>
<h2 id="创建角色"><a class="markdownIt-Anchor" href="#创建角色"></a> 创建角色</h2>
<p>Role 资源定义了对指定命名空间内指定资源的可用操作。下面的配置允许用户获取并列出 foo 命名空间中的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: foo
  name: service-reader
rules:
- apiGroups: <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
  verbs: <span class="token punctuation">[</span><span class="token string">"get"</span>, <span class="token string">"list"</span><span class="token punctuation">]</span>
  resources: <span class="token punctuation">[</span><span class="token string">"services"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>定义参数说明如下：</p>
<ul>
<li><code>metadata.namespace</code>：指定 Role 所在的命名空间。如果未定义，则使用当前命名空间。</li>
<li><code>metadata.name</code>：指定 Role 的名称。</li>
<li><code>rules.apiGroups</code>：定义 apiGroup 名称。由于 Service 是核心资源，因此没有 apiGroup 名称。可以定义多种规则。</li>
<li><code>rules.verbs</code>：定义获取单个 Service（通过名称）并能使用 <code>get</code> 列出所有允许的服务。</li>
<li><code>rules.resources</code>：定义规则与服务相关联，必须使用复数形式的名称。</li>
<li><code>rules.resourceNames</code>：此处未定义，用于指定服务实例的名称以限制对服务实例的访问。</li>
</ul>
<p>在 foo 命名空间中创建此 Role 资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> role.yaml <span class="token parameter variable">-n</span> foo
role.rbac.authorization.k8s.io/service-reader created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以使用 <code>create role</code> 命令直接创建：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create role service-reader <span class="token parameter variable">--verb</span><span class="token operator">=</span>get <span class="token parameter variable">--verb</span><span class="token operator">=</span>list <span class="token parameter variable">--resource</span><span class="token operator">=</span>services <span class="token parameter variable">-n</span> bar
role.rbac.authorization.k8s.io/service-reader created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这两个角色允许在 Pod 中分别列出各自命名空间中的服务。</p>
<h2 id="绑定角色"><a class="markdownIt-Anchor" href="#绑定角色"></a> 绑定角色</h2>
<p>创建角色后，需要将角色绑定到一个主体上，该主体可以是用户、组或 Service Account（SA）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create rolebinding <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo <span class="token parameter variable">--role</span><span class="token operator">=</span>service-reader <span class="token parameter variable">--serviceaccount</span><span class="token operator">=</span>foo:default
rolebinding.rbac.authorization.k8s.io/test created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上述 RoleBinding 资源名为 <code>test</code>，它将 <code>service-reader</code> 角色绑定到 foo 命名空间中的 <code>default</code> SA。如果需要绑定到用户，则使用 <code>--user</code> 参数；如果绑定到组，则使用 <code>--group</code> 参数。</p>
<p>RoleBinding 只能指定一个角色，但角色可以绑定到多个主体。现在测试一下效果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api/v1/namespaces/foo/services
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"ServiceList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"1666771"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"items"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 foo 命名空间中的 Pod 已成功获取到 foo 命名空间中的 Service 信息，但现在尚未运行任何 Service，因此 <code>items</code> 项为空。</p>
<p>可以修改 foo 命名空间中的 RoleBinding，添加角色绑定到 bar 命名空间的默认 SA：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl edit rolebinding <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo
subjects:
- kind: ServiceAccount
  name: default
  namespace: foo
- kind: ServiceAccount
  name: default
  namespace: bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在可以在 bar 命名空间的 Pod 中也能列出 foo 命名空间中的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> bar -- <span class="token function">curl</span> localhost:8001/api/v1/namespaces/foo/services
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"ServiceList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"1667251"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"items"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="绑定集群角色"><a class="markdownIt-Anchor" href="#绑定集群角色"></a> 绑定集群角色</h2>
<p>当只有 Role 时，需要引用所有命名空间的资源时，必须逐个建立角色和角色绑定。而且，有些资源并不属于任何命名空间（如 Node、PV、NS 等），常规角色无法对这些资源进行授权。为了解决这个问题，引入了 ClusterRole。</p>
<p>ClusterRole 和 ClusterRoleBinding 都是集群级资源，可以访问没有命名空间的资源、非资源型 URL，或者作为单个命名空间内部绑定的公共角色，避免在每个命名空间中重新定义相同的角色。</p>
<p>首先，创建一个能够列出集群中 PV 的集群角色 pv-reader：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrole pv-reader <span class="token parameter variable">--verb</span><span class="token operator">=</span>get,list <span class="token parameter variable">--resource</span><span class="token operator">=</span>persistentvolumes
clusterrole.rbac.authorization.k8s.io/pv-reader created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>foo 命名空间的 Pod 上尝试获取 PV 列表会提示没权限。</p>
<p>接下来，使用 ClusterRoleBinding 将集群角色 pv-reader 绑定到 foo 命名空间的默认 SA：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrolebinding pv-test <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>pv-reader <span class="token parameter variable">--serviceaccount</span><span class="token operator">=</span>foo:default
clusterrolebinding.rbac.authorization.k8s.io/pv-test created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样，foo 命名空间的 Pod 就能成功列出 PV 资源列表了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api/v1/persistentvolumes
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"PersistentVolumeList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"1671344"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"items"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
        <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"mongodb-pv"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="访问非资源型-url"><a class="markdownIt-Anchor" href="#访问非资源型-url"></a> 访问非资源型 URL</h2>
<p>要访问 API 服务器对外暴露的非资源型 URL，也需要显式地进行授权，否则 API 服务器将拒绝客户端的请求。通常可以通过 <code>system:discovery</code> 这个集群角色和相同命名的集群角色绑定来完成。可以查看一下角色的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get clusterrole system:discovery <span class="token parameter variable">-o</span> yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: <span class="token string">"true"</span>
  creationTimestamp: <span class="token string">"2021-11-03T05:36:25Z"</span>
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:discovery
  resourceVersion: <span class="token string">"85"</span>
  uid: e1ff33b5-dc26-422e-8082-5def977e2e2a
rules:
- nonResourceURLs:
  - /api
  - /api/*
  - /apis
  - /apis/*
  - /healthz
  - /livez
  - /openapi
  - /openapi/*
  - /readyz
  - /version
  - /version/
  verbs:
  - get<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，rules 中定义的是 <code>nonResourceURLs</code> 而不是资源字段，方法只有 GET 请求可用。然后，查看角色绑定的详细信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get clusterrolebinding system:discovery <span class="token parameter variable">-o</span> yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: <span class="token string">"true"</span>
  creationTimestamp: <span class="token string">"2021-11-03T05:36:25Z"</span>
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:discovery
  resourceVersion: <span class="token string">"149"</span>
  uid: 98c8ddc8-e6eb-4b9f-8af2-c37e4804c0b3
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:discovery
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:authenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该角色绑定了两个组 <code>system:authenticated</code> 和 <code>system:unauthenticated</code>，这样所有人都可以访问 ClusterRole 中定义的 URL。</p>
<p>这些组位于身份认证插件的范围内。当 API 服务器接收到一个请求时，会调用身份认证插件来获取用户所属的组信息，并在授权过程中使用这些组信息。</p>
<p>可以在本地或 Pod 内尝试访问 <code>/api</code> 路径来进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api <span class="token parameter variable">-k</span>
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"APIVersions"</span>,
  <span class="token string">"versions"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"v1"</span>
  <span class="token punctuation">]</span>,
  <span class="token string">"serverAddressByClientCIDRs"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      <span class="token string">"clientCIDR"</span><span class="token builtin class-name">:</span> <span class="token string">"0.0.0.0/0"</span>,
      <span class="token string">"serverAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"192.168.2.204:6443"</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="集群角色配合角色绑定"><a class="markdownIt-Anchor" href="#集群角色配合角色绑定"></a> 集群角色配合角色绑定</h2>
<p>ClusterRole 不一定需要与 ClusterRoleBinding 捆绑使用，也可以与 RoleBinding 捆绑使用。首先，查看一个名为 <code>view</code> 的默认 ClusterRole：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get clusterrole view <span class="token parameter variable">-o</span> yaml
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.authorization.k8s.io/aggregate-to-view: <span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到该角色有很多规则，其中一些规则适用于具有命名空间的资源，如 ConfigMap、PersistentVolumeClaim 等，还有一些适用于无命名空间的资源。角色的权限取决于绑定方式：</p>
<ul>
<li>如果使用 ClusterRoleBinding 绑定 <code>view</code>，在绑定中列出的主体可以查看指定资源在所有命名空间中的信息。</li>
<li>如果使用 RoleBinding 绑定 <code>view</code>，那么只能查看 RoleBinding 所在命名空间中的资源。</li>
</ul>
<p>下面，使用 ClusterRoleBinding 将 ClusterRole <code>view</code> 绑定到命名空间 <code>foo</code> 的默认 SA 上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrolebinding view-test <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>view <span class="token parameter variable">--serviceaccount</span><span class="token operator">=</span>foo:default
clusterrolebinding.rbac.authorization.k8s.io/view-test created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api/v1/namespaces/bar/services
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"ServiceList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"1754935"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"items"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，foo 命名空间中的 Pod 就可以获取集群中所有其他命名空间的 Service 信息了。</p>
<p>如果删除集群绑定，并改为角色绑定：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete clusterrolebinding view-test
clusterrolebinding.rbac.authorization.k8s.io <span class="token string">"view-test"</span> deleted
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create rolebinding view-test <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>view <span class="token parameter variable">--serviceaccount</span><span class="token operator">=</span>foo:default <span class="token parameter variable">-n</span> foo
rolebinding.rbac.authorization.k8s.io/view-test created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-n</span> foo -- <span class="token function">curl</span> localhost:8001/api/v1/namespaces/bar/services
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Status"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"Failure"</span>,
  <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"services is forbidden: User <span class="token entity" title="\&quot;">\"</span>system:serviceaccount:foo:default<span class="token entity" title="\&quot;">\"</span> cannot list resource <span class="token entity" title="\&quot;">\"</span>services<span class="token entity" title="\&quot;">\"</span> in API group <span class="token entity" title="\&quot;">\"</span><span class="token entity" title="\&quot;">\"</span> in the namespace <span class="token entity" title="\&quot;">\"</span>bar<span class="token entity" title="\&quot;">\"</span>"</span>,
  <span class="token string">"reason"</span><span class="token builtin class-name">:</span> <span class="token string">"Forbidden"</span>,
  <span class="token string">"details"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"services"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"code"</span><span class="token builtin class-name">:</span> <span class="token number">403</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这次将返回 403 错误，拒绝列出集群中其他命名空间的 Service 列表。foo 命名空间中的 Pod 只能列出当前命名空间的 Service 列表。</p>
<h2 id="角色和绑定的组合"><a class="markdownIt-Anchor" href="#角色和绑定的组合"></a> 角色和绑定的组合</h2>
<p>下面的表格简单列举了访问需求和角色与绑定类型之间的搭配：</p>
<table>
<thead>
<tr>
<th><strong>访问的资源</strong></th>
<th><strong>角色类型</strong></th>
<th><strong>绑定类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>集群级别资源（Nodes, PV…）</td>
<td>集群</td>
<td>集群</td>
</tr>
<tr>
<td>非资源型 URL（/api, /healthz…）</td>
<td>集群</td>
<td>集群</td>
</tr>
<tr>
<td>在任何命名空间中的资源</td>
<td>集群</td>
<td>集群</td>
</tr>
<tr>
<td>在具体命名空间中的资源（可在多个命名空间中重用该角色）</td>
<td>集群</td>
<td>角色</td>
</tr>
<tr>
<td>在具体命名空间中的资源（角色需要在每个命名空间中都定义）</td>
<td>角色</td>
<td>角色</td>
</tr>
</tbody>
</table>
<h2 id="自带集群角色"><a class="markdownIt-Anchor" href="#自带集群角色"></a> 自带集群角色</h2>
<p>K8s 提供了一组默认的自定义角色（CR）和自定义角色绑定（CRB），每次 API 服务器启动时都会更新它们，以确保在误删或 K8s 版本更新后，所有默认角色和绑定都会被重新创建：</p>
<ul>
<li>
<p>view 角色</p>
<p>允许读取一个命名空间的大多数资源，除了 Role、RoleBinding 和 Secret。</p>
</li>
<li>
<p>edit 角色</p>
<p>允许修改一个命名空间中的资源，同时允许读取和修改 Secret，但不允许查看或修改 Role 和 RoleBinding。</p>
</li>
<li>
<p>admin 角色</p>
<p>可以读取和修改命名空间中的任何资源，除了 ResourceQuota 和命名空间资源本身。</p>
<p>API 服务器只允许用户在已经拥有一个角色中列出的所有权限的情况下创建和更新该角色。</p>
</li>
<li>
<p>cluster-admin 角色</p>
<p>拥有集群的完全控制权，包括命名空间的 ResourceQuota 和命名空间资源本身。</p>
</li>
<li>
<p>其他角色</p>
<p>默认角色以 “system:” 为前缀，这些角色用于各种组件中。</p>
</li>
</ul>
<p>.</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 基础概念</title>
    <url>/3341501969/</url>
    <content><![CDATA[<h1 id="虚拟化技术"><a class="markdownIt-Anchor" href="#虚拟化技术"></a> 虚拟化技术</h1>
<p>虚拟化技术是一种计算机资源管理技术，它控制计算机硬件资源并将其抽象化，以统一的形式呈现给应用程序。对于用户而言，虚拟化只是定义了隐藏真实环境的方式，而要实现虚拟化，还需要具体执行虚拟化过程的程序。</p>
<p>虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。</p>
<ul>
<li>
<p>硬件虚拟化需要使用专门的硬件平台，与普通硬件设备存在兼容性问题，但其优点是可以更高效地利用硬件资源。</p>
</li>
<li>
<p>软件虚拟化通常在应用程序和硬件资源之间建立一个 Hypervisor 层，应用程序通过该虚拟化环境中提供的调用接口来操作资源。例如，Java 虚拟机（JVM，Java Virtual Machine）通过这种方式实现了跨平台运行。</p>
</li>
</ul>
<p>从对象所在的层次来看，软件虚拟化又可分为应用虚拟化（如手机模拟器、Wine 等）和平台虚拟化。常见的平台虚拟化包括以下几类：</p>
<ul>
<li>
<p>完全虚拟化</p>
<p>虚拟机模拟了完整的底层硬件环境和特权指令的执行过程，例如 VMware Workstation、VirtualBox、QEMU 等。</p>
</li>
<li>
<p>硬件辅助虚拟化</p>
<p>利用 CPU 的辅助支持（如 Intel-VT、AMD-V）来处理敏感指令，实现完全虚拟化的功能，例如 VMware、Xen、KVM 等。</p>
</li>
<li>
<p>部分虚拟化</p>
<p>只对部分硬件资源进行虚拟化，需要修改客户操作系统。</p>
</li>
<li>
<p>超虚拟化（Paravirtualization）</p>
<p>以软件形式提供部分硬件接口给客户机操作系统，例如早期的 Xen。</p>
</li>
<li>
<p>操作系统级虚拟化</p>
<p>通过创建多个虚拟的操作系统实例来隔离不同的进程，例如容器相关技术。</p>
</li>
</ul>
<p>传统基于硬件层实现的虚拟化需要额外的虚拟机管理应用和虚拟机操作系统层。而 Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此被称为轻量级虚拟化。</p>
<h1 id="云服务类型"><a class="markdownIt-Anchor" href="#云服务类型"></a> 云服务类型</h1>
<p>提供云服务的公司总体可以归为以下几大类的一种或多种：</p>
<ul>
<li>
<p>IaaS</p>
<p>基础设施即服务（IaaS，Infrastructure as a Service）指在云端为用户提供基础设施，如虚拟机、服务器、存储、负载均衡和网络等，代表有 AWS 和阿里云。</p>
</li>
<li>
<p>PaaS</p>
<p>平台即服务（PaaS，Platform as a Service）指在云端为用户提供可执行环境、数据库、网站服务器和开发工具等，代表有 OpenShift、Google App Engine、dotCloud 等。</p>
</li>
<li>
<p>SaaS</p>
<p>软件即服务（SaaS，Software as a Service）指在云端为用户提供软件，如 CRM 系统、邮件系统、在线办公等。代表有微软 Office 365、有道、Tower 等。</p>
</li>
<li>
<p>CaaS</p>
<p>容器即服务（CaaS，Container as a Service）是虚拟云主机的升级版，使用容器替代虚拟机的服务模式。</p>
</li>
</ul>
<p>IaaS、PaaS 和 SaaS 是云计算最基本的三种服务模式，客户通过云客户端来访问上述服务。</p>
<h1 id="docker-运行基础"><a class="markdownIt-Anchor" href="#docker-运行基础"></a> Docker 运行基础</h1>
<p>Docker 主要使用的技术有 Libcontainer、Namespaces、CGroups 和 AUFS。</p>
<h2 id="namespaces"><a class="markdownIt-Anchor" href="#namespaces"></a> Namespaces</h2>
<p>内核命名空间（Namespaces）是 Linux 下的资源隔离机制。它从内核层面将进程、进程组、IPC、网络、内存等资源分属于某个特定的命名空间，不同命名空间之间的资源相互隔离且不可见。</p>
<p>Docker 使用以下 6 种类型的命名空间：</p>
<ul>
<li>PID Namespace：用于进程隔离，使容器具有独立的一套 PID。在宿主机上可以看到容器中的进程。</li>
<li>NET Namespace：用于虚拟网络环境，使容器拥有自己独立的网络协议栈视图，包括网卡、IP、路由、防火墙规则和套接字等。</li>
<li>IPC Namespace：用于隔离进程间的通信资源，使容器拥有自己的共享内存和 semaphore。</li>
<li>MNT Namespace：用于管理挂载点，使容器看起来拥有整个文件系统，类似于 chroot。</li>
<li>UTS Namespace：用于隔离主机名和域名，使容器拥有独立的主机名。</li>
<li>USER Namespace：用于隔离用户和组，使容器拥有独立于宿主机的用户和组。</li>
</ul>
<p>被隔离在命名空间中的程序虽然无法感知命名空间外的程序的存在，但仍可以直接访问宿主机系统内核的功能和部分内核文件，只是在程序看来自己是独占系统的。</p>
<h2 id="cgroups"><a class="markdownIt-Anchor" href="#cgroups"></a> CGroups</h2>
<p>控制组（CGroups, Control Groups）可以限制、记录和调整进程组所使用的物理资源，例如给某个进程分配更多的 CPU 资源或限制内存使用上限。它能确保各个容器可以公平地共享主机的物理资源，并在容器内部资源使用紧张时不会影响到宿主机。</p>
<p>控制组提供以下功能：</p>
<ul>
<li>资源限制（Resource Limiting）：可以为组设置一定的内存使用上限，超过限制时可能会出现 OOM（Out of Memory）。</li>
<li>优先级（Prioritization）：通过调整组的优先级来分配 CPU 资源。</li>
<li>资源审计（Accounting）：统计系统资源的使用情况。</li>
<li>隔离（Isolation）：为组隔离命名空间。</li>
<li>控制（Control）：执行挂起、恢复和重启等操作。</li>
</ul>
<p>Docker 中的控制组相关配置保存在 <code>/sys/fs/cgroup/</code> 目录下，该目录下有许多子目录，也称为子系统，如 <code>cpu</code>、<code>memory</code>、<code>blkio</code> 等。这些子系统是可以通过控制组进行资源限制的种类。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /sys/fs/cgroup/
blkio/            cpu,cpuacct/      freezer/          net_cls/          perf_event/       
cpu/              cpuset/           hugetlb/          net_cls,net_prio/ pids/             
cpuacct/          devices/          memory/           net_prio/         systemd/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个子系统对应的资源种类下，可以查看这些资源的具体限制方法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /sys/fs/cgroup/cpu/
cgroup.clone_children  cpuacct.usage          cpu.rt_runtime_us      system.slice/
cgroup.event_control   cpuacct.usage_percpu   cpu.shares             tasks
cgroup.procs           cpu.cfs_period_us      cpu.stat               user.slice/
cgroup.sane_behavior   cpu.cfs_quota_us       notify_on_release      
cpuacct.stat           cpu.rt_period_us       release_agent  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>cpu</code> 子系统下创建一个目录进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /sys/fs/cgroup/cpu/mytest
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /sys/fs/cgroup/cpu/mytest
cgroup.clone_children  cpuacct.stat          cpu.cfs_period_us  cpu.rt_runtime_us  notify_on_release
cgroup.event_control   cpuacct.usage         cpu.cfs_quota_us   cpu.shares         tasks
cgroup.procs           cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到目录中自动生成了一些资源限制文件，该目录也被称为一个控制组。</p>
<p>接下来，在后台执行一个会占满 CPU 的脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token keyword">while</span> <span class="token builtin class-name">:</span> <span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">:</span> <span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">4195</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">top</span>
   PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND             
  <span class="token number">4195</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">116208</span>   <span class="token number">1260</span>    <span class="token number">152</span> R  <span class="token number">92.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:31.78 <span class="token function">bash</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时系统已经负载满，因为默认情况下 CPU 的 quota（配额）没有任何限制，而 CPU 的 period（周期）默认为 100ms。它们组合起来用来限制进程可以分配到的 CPU 时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/mytest/cpu.cfs_quota_us 
<span class="token parameter variable">-1</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/mytest/cpu.cfs_period_us 
<span class="token number">100000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>手动将 <code>cpu.cfs_quota_us</code> 参数改为 20000（20ms）。这意味着在每个 100ms 的时间内，被该控制组限制的进程只能使用 20ms 的 CPU 时间，相当于 20% 的 CPU 使用率：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">20000</span> <span class="token operator">></span> /sys/fs/cgroup/cpu/mytest/cpu.cfs_quota_us <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，将被限制的进程的 PID 写入 <code>tasks</code> 文件来生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">4195</span> <span class="token operator">></span> /sys/fs/cgroup/cpu/mytest/tasks
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">top</span>
   PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND             
  <span class="token number">4195</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">116208</span>   <span class="token number">1260</span>    <span class="token number">152</span> R  <span class="token number">20.0</span>  <span class="token number">0.0</span>   <span class="token number">9</span>:06.83 <span class="token function">bash</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时再次使用 <code>top</code> 命令查看，可以看到进程的 CPU 使用率被限制在预期的范围内。</p>
<p>简而言之，控制组就是一个子系统目录加上一组资源限制文件的组合。Docker 在每个子系统下为每个容器创建一个控制组（即创建新目录），然后在启动容器进程后，将进程的 PID 写入相应控制组的 <code>tasks</code> 文件中，以实现资源的限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --cpu-period<span class="token operator">=</span><span class="token number">100000</span> --cpu-quota<span class="token operator">=</span><span class="token number">20000</span> ubuntu /bin/bash
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> ubuntu
root       <span class="token number">4297</span>  <span class="token number">0.0</span>  <span class="token number">0.5</span> <span class="token number">1359472</span> <span class="token number">46268</span> pts/1   Sl+  <span class="token number">14</span>:41   <span class="token number">0</span>:00 <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --cpu-period<span class="token operator">=</span><span class="token number">100000</span> --cpu-quota<span class="token operator">=</span><span class="token number">20000</span> ubuntu /bin/bash
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/cpu.cfs_period_us 
<span class="token number">100000</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/cpu.cfs_quota_us 
<span class="token number">20000</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/9c8d7b7f5f71198e07/tasks 
<span class="token number">4379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lxc"><a class="markdownIt-Anchor" href="#lxc"></a> LXC</h2>
<p>Linux 容器 (LXC, Linux Containers) 就是基于 Linux 内核通过调用 CGroups 和 Namespaces 来实现容器轻量级虚拟化的技术。同时，LXC 也是一组面向 Linux 内核容器的用户态 API 接口。用户通过 LXC 提供的功能可以创建一套完整且互相隔离的虚拟应用运行环境。</p>
<p>在 LXC 的实现中，运行在容器中的程序访问的是真实物理机系统，与通过虚拟机实现的虚拟化比，消除了 Hypervisor 层，大大提高了运行效率。</p>
<h2 id="libcontainer"><a class="markdownIt-Anchor" href="#libcontainer"></a> Libcontainer</h2>
<p>Docker 采用 libcontainer 作为默认容器，取代了之前的 LXC。libcontainer 的隔离性主要是内核的命名空间来实现的，具体有 pid、net、ipc、mnt 和 uts 等命名空间，它们将容器的进程、网络、消息、文件系统和主机名进行隔离。</p>
<h2 id="ufs"><a class="markdownIt-Anchor" href="#ufs"></a> UFS</h2>
<p>UnionFS（Union File System）是一个堆栈式的联合文件系统，能够把多个目录挂载成同一个目录的文件系统。</p>
<h1 id="docker-应用范围"><a class="markdownIt-Anchor" href="#docker-应用范围"></a> Docker 应用范围</h1>
<p>Docker 是基于 Go 语言实现的容器项目，由 dotCloud 于 2013 年正式开源，2015 年开始大规模应用。</p>
<h2 id="云平台"><a class="markdownIt-Anchor" href="#云平台"></a> 云平台</h2>
<p>目前，Docker 主要应用于云平台。在 Docker 出现之前，各个云平台之间存在不兼容性，而 Docker 则屏蔽了硬件层的差异，提供了统一的用户应用层。因此，企业产品可以自由迁移至各种云平台。</p>
<h2 id="devops"><a class="markdownIt-Anchor" href="#devops"></a> Devops</h2>
<p>Docker 的另一个应用领域是 DevOps。只需使用相同的数据镜像，就不需要考虑环境问题，减少了代码运行的差异，使开发团队能够专注于产品开发，而无需关注流程。</p>
<p>Docker 的标准化规范弥补了开发、业务和运维之间的需求差异，可以无缝地将产品在开发、测试和生产环境之间自由移动。</p>
<h1 id="docker-优缺点"><a class="markdownIt-Anchor" href="#docker-优缺点"></a> Docker 优缺点</h1>
<p>总的来看，Docker 的缺点暂不构成问题，可以放心使用。</p>
<h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2>
<p>使用 Docker 的优点有：</p>
<ul>
<li>
<p><strong>高资源利用率</strong></p>
<p>传统虚拟机的硬件资源独立不共享，而 Docker 中所有容器共享同一个系统内核和硬件资源，对资源的利用率比虚拟机高得多。在 Docker 容器中，CPU 的损耗为 0%，磁盘 IO 的损耗小于 5%，网络在使用桥接模式时损耗为 15%。</p>
</li>
<li>
<p><strong>支持跨节点部署</strong></p>
<p>借助 Docker 定义的标准镜像数据格式，可以在不同操作系统和物理硬件环境中使用。</p>
</li>
<li>
<p><strong>版本可控，组件可复用</strong></p>
<p>Docker 利用 AUFS 文件系统的特性，使得镜像与镜像之间可以互相借用组合，产生不同的镜像。并借助标签功能对镜像进行标注，实现版本控制。</p>
</li>
<li>
<p><strong>共享镜像</strong></p>
<p>Docker 作为开源软件，构建出的镜像可以自由分发和共享（主要通过 Docker Hub）。</p>
</li>
<li>
<p><strong>轻量级，易维护</strong></p>
<p>Docker 在 Linux 系统中表现为一个普通的进程，因此管理非常容易。</p>
</li>
</ul>
<h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2>
<p>Docker 的缺点有：</p>
<ul>
<li>
<p><strong>宿主资源没有完全做到隔离</strong></p>
<p>虽然容器使用的系统资源相互隔离，但仍有一些内核资源未被隔离开。例如 <code>/proc</code>、<code>/sys</code> 这些目录以及 SELinux、syslog 这些内核功能。因此，容器与宿主机共用内核版本，容器内无法升级内核，对内核版本有要求的应用可能与 Docker 不兼容。</p>
</li>
<li>
<p><strong>Go 语言尚不成熟</strong></p>
<p>由于 Docker 全部采用 Go 语言编写，而 Go 语言还比较年轻，难保不会发生大的变动。这可能对 Docker 产生连带影响。</p>
</li>
<li>
<p><strong>控制权问题</strong></p>
<p>虽然 Docker 现在是开源的，但实际上被一家公司所控制，并不像其他大型开源项目那样由公共基金会管理。因此，后续可能变为收费闭源项目。</p>
</li>
</ul>
<h1 id="docker-构架"><a class="markdownIt-Anchor" href="#docker-构架"></a> Docker 构架</h1>
<p>Docker 是一个客户端/服务器 (C/S) 架构的程序。客户端只需要通过 Socket 向服务器或守护进程（Docker 引擎）发送请求，服务器或守护进程将完成所有工作并返回结果。</p>
<p>Docker 提供了一个命令行工具 <code>docker</code> 以及一套 RESTful API 来与守护进程交互。用户可以在一台主机上运行 Docker 守护进程和客户端，也可以从本地 Docker 客户端连接到运行在另一台主机上的远程 Docker 守护进程。</p>
<h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2>
<p>Docker 服务端一般在宿主机后台运行，<code>dockerd</code> 作为服务端接收来自客户端的请求，并通过 <code>containerd</code> 具体处理与容器相关的请求。服务端主要包括四个组件：</p>
<ul>
<li>
<p><code>dockerd</code></p>
<p>为客户端提供 RESTful API，响应来自客户端的请求。采用模块化的架构，通过专门的 Engine 模块来分发管理各个来自客户端的任务。</p>
</li>
<li>
<p><code>docker-proxy</code></p>
<p><code>dockerd</code> 的子进程，配置容器端口映射功能。</p>
</li>
<li>
<p><code>containerd</code></p>
<p><code>dockerd</code> 的子进程，提供 gRPC 接口响应来自 <code>dockerd</code> 的请求，对底层管理 <code>runC</code> 镜像和容器环境。</p>
</li>
<li>
<p><code>containerd-shim</code></p>
<p><code>containerd</code> 的子进程，为 <code>runC</code> 容器提供支持，同时作为容器内进程的根进程。</p>
</li>
</ul>
<h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2>
<p>用户使用 Docker 可执行命令即为客户端程序，<code>docker</code> 程序能将命令转为 API 请求再发送到服务端。客户端在命令执行结束后会立即退出。</p>
<p>可以通过 <code>-H</code> 参数显式指定服务端地址，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token parameter variable">-H</span> tcp:192.168.2.241:5999 info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="docker-储存"><a class="markdownIt-Anchor" href="#docker-储存"></a> Docker 储存</h1>
<p>Docker 支持的存储文件系统如下：</p>
<ul>
<li>AUFS：最早支持的文件系统，对 Debian/Ubuntu 支持度好。</li>
<li>Btrfs：参考 ZFS 等特性设计的文件系统，试图用来取代 Device Mapper。</li>
<li>Device Mapper：RHEL 用来支持 Docker 开发的文件系统。</li>
<li>Overlay：类似 AUFS 的分层文件系统，性能更好。</li>
<li>Overlay 2：原生支持 128 层，效率比 Overlay 高。</li>
<li>VFS：基于普通文件系统（ext、nfs 等）的中间层抽象。</li>
<li>ZFS：为 Solaris 上专用的写时文件系统，在 Linux 上可以使用 ZFS on Linux。</li>
</ul>
<p>它们都能实现分层的架构，同时又有各自的特性。Docker 安装时会根据当前系统配置选择默认最适合的驱动。</p>
<h2 id="aufs"><a class="markdownIt-Anchor" href="#aufs"></a> AUFS</h2>
<p>AUFS（Another UnionFS 的简称）是对 UnionFS 的补充。随着 AUFS 的发展，它更名为 Advanced Multi Layered Unification Filesystem（高级多层次统一文件系统）。简单来说，AUFS 可以将分布在不同位置的目录挂载到同一个虚拟文件系统中。</p>
<p>Docker 参考 Linux 启动过程，首先将一个只读的 bootfs（虚拟文件系统）挂载到容器文件系统中，然后将只读的 rootfs（根目录文件系统）添加到 bootfs 之上。之后每次挂载一个只读的文件层（FS 文件层），将用户所需的文件内容挂载到 rootfs 之上。</p>
<p>这些文件层就是堆栈式文件系统中所保存的数据，在 AUFS 中，每个文件层被称为一个分支，整个文件系统称为联合文件系统。而 AUFS 则是用来管理和使用这些文件层的文件系统。</p>
<p>Docker 利用 AUFS 加载完最高层后，在顶部再添加一个具有读写权限的文件系统层。容器内部的应用对当前文件系统的所有写操作都会保存在这个文件系统层中。当使用 commit 命令后，Docker 将会将该文件系统层中的数据作为单独的一个文件层保存在 AUFS 中。</p>
<p>镜像（Image）可以理解为特定文件系统层的集合。从镜像启动容器（Container）时，Docker 会依次加载基础镜像（Base Image）及其上层镜像。通过将镜像划分为 AUFS 的文件层，使得所有容器可以共享文件层而不会发生写冲突。</p>
<p>当使用 AUFS 作为存储驱动时，镜像和容器都保存在宿主机的 <code>/var/lib/docker/aufs</code> 目录下：</p>
<ul>
<li>/var/lib/docker/aufs/diff：镜像层数据保存目录。</li>
<li>/var/lib/docker/aufs/layers：镜像层的元数据文件，其中的内容记录了该层之下所有镜像层的名称。</li>
<li>/var/lib/docker/aufs/mnt：容器运行时容器中的文件系统挂载目录。</li>
</ul>
<h2 id="device-mapper"><a class="markdownIt-Anchor" href="#device-mapper"></a> Device Mapper</h2>
<p>Device Mapper 是 Docker 中支持的第二种存储驱动，在 Red Hat 发行版中存在。其特点是对块设备进行操作，而不是整个文件，在宿主机上很难区分镜像层和容器层。</p>
<p>Device Mapper 使用的数据块大小为 64KB，在大量小数据写操作时性能不如 AUFS。</p>
<p>创建镜像的流程与 AUFS 有一些不同：</p>
<ol>
<li>创建一个 thin pool，该 pool 可以创建在块设备上，也可以创建在 sparse 文件上。</li>
<li>创建一个按需分配的基础设备，并在该设备上创建文件系统。</li>
<li>在创建镜像时，会在基础设备上进行快照，每创建一个镜像层，就会进行一次快照。在快照创建时不会占用空间，只有在内容发生变化时才会在 thin pool 中分配存储空间来保存数据。</li>
</ol>
<p>在容器中读取数据的流程如下：</p>
<ol>
<li>容器中的程序发起读请求，要访问指定地址的数据块。容器层只是镜像层的一个快照，它保存了数据块映射表，而不保存实际的数据。通过指针，它指向镜像层中真正的数据块。</li>
<li>程序通过映射表读取对应镜像层中的数据块，并将其复制到容器的内存区域。</li>
</ol>
<p>在容器中修改数据的流程与 AUFS 类似，不同之处在于 AUFS 会将整个文件复制到容器层，而 Device Mapper 通过定位需要修改的数据块并分配新的存储区域，将需要修改的数据块复制到新分配的存储区域，然后由程序进行更新。</p>
<h2 id="btrfs"><a class="markdownIt-Anchor" href="#btrfs"></a> Btrfs</h2>
<p>Docker 使用 Btrfs 中的子卷和快照技术来管理镜像和容器。Btrfs 中的子卷类似于 UNIX 文件系统，每个子卷都有自己的目录结构。</p>
<p>Btrfs 中的快照会复制整个子卷，并且快照是可读写的。快照保存在子卷中，也可以对快照进行递归的快照操作。</p>
<p>Btrfs 使用写时复制技术为子卷和快照分配底层存储空间，块大小通常为 1 GB。</p>
<p>Btrfs 将镜像的基础层作为一个子卷进行保存，其他镜像层和容器层则以快照的形式保存。</p>
<p>Btrfs 中的读写操作与 Device Mapper 类似，但是工作在文件层而不是数据块层。在修改文件时，Btrfs 不会直接修改原文件，而是在容器层中分配新的存储空间来保存修改后的数据，然后在元数据中更新数据的指向地址。</p>
<h2 id="zfs"><a class="markdownIt-Anchor" href="#zfs"></a> ZFS</h2>
<p>在 Docker 中使用了三种 ZFS DataSet，包括文件系统、快照和克隆。其中，快照是只读的，克隆是从快照上创建而来，可读写。</p>
<p>镜像的基础层是一个 ZFS 文件系统，其他镜像层是一个 ZFS 克隆。在启动容器后，会在顶部增加一个读写层。</p>
<h2 id="overlayoverlay2"><a class="markdownIt-Anchor" href="#overlayoverlay2"></a> Overlay/Overlay2</h2>
<p>OverlayFS 是一种联合文件系统，类似于 AUFS，使用两个目录进行分层，分别保存镜像层（lowerdir）和容器层（upperdir）。</p>
<p>在运行容器时，Overlay 会将所有镜像层对应的目录组合起来（merged/diff），并在顶层添加一个容器层。而 Overlay2 原生支持多个 lowerdir，因此在保存多层镜像时更具优势。</p>
<p>在 Overlay 中读取文件时，优先从容器层读取，如果容器层没有，则从镜像层读取。</p>
<p>在 Overlay 中修改文件时，会将文件从镜像层复制到容器层，并将所有的修改保存在容器层中。</p>
<p>在 Overlay 中删除文件时，会在容器层中新建一个 without（白障）文件，用于隐藏镜像层中的目标文件。删除目录时，会在容器层中新建一个 opaque 目录，用于隐藏镜像层中的目标目录。镜像层中的文件和目录不会被直接删除。</p>
<h1 id="docker-网络"><a class="markdownIt-Anchor" href="#docker-网络"></a> Docker 网络</h1>
<p>Docker 的本地网络实现利用了 Linux 上的网络命名空间和虚拟网络设备。</p>
<p>Docker 中的网络接口默认都是虚拟接口。它通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包直接被复制到接收接口缓存中，而无需通过外部物理网络设备进行交换。</p>
<h2 id="网络模型"><a class="markdownIt-Anchor" href="#网络模型"></a> 网络模型</h2>
<p>libnetwork 中的容器网络模型（CNM，Container Networking Model）非常简洁和抽象，可以让其上层使用网络功能的容器最大程度地忽略底层具体实现。</p>
<p>容器网络模型包括三种元素：</p>
<ul>
<li>沙盒（Sandbox）：代表容器的网络栈，包括网卡、路由和 DNS 设置。Linux 网络命名空间是沙盒的标准实现。沙盒可以包含来自不同网络的接入点。</li>
<li>接入点（Endpoint）：作用是将沙盒接入网络。代表网络上可以挂载容器的接口，例如 veth pair，会分配 IP 地址。</li>
<li>网络（Network）：可以连通多个接入点的一个子网，例如 Bridge 或 VLAN 等。</li>
</ul>
<p>对于 CNM 的容器管理系统来说，具体底层网络如何实现，不同子网如何隔离，都不关心。只要插件能提供网络和接入点，剩下的都是插件驱动的工作，这样就解耦了容器和网络功能。</p>
<h1 id="docker-镜像"><a class="markdownIt-Anchor" href="#docker-镜像"></a> Docker 镜像</h1>
<p>镜像类似于虚拟机的镜像，可以将其理解为一个只读模板，保存着容器需要的环境和应用的执行代码。</p>
<p>镜像是创建 Docker 容器的基础，不同的镜像对应着不同的应用程序或服务。</p>
<h2 id="镜像名称"><a class="markdownIt-Anchor" href="#镜像名称"></a> 镜像名称</h2>
<p>镜像名称的格式如下：<code>[命名空间|仓库地址]/镜像名:标签</code></p>
<ul>
<li>
<p>命名空间（Namespace）</p>
<p>用于区别构建镜像的组织或个人，一般为 Docker Hub 上的用户名。没有命名空间的镜像代表由官方提供，由可靠且权威的第三方组织或机构维护的官方镜像。</p>
</li>
<li>
<p>仓库地址（URL）</p>
<p>如果镜像放置在第三方或私有仓库中，命名空间部分使用仓库 URL 路径来命名。</p>
</li>
<li>
<p>镜像名（Repository）</p>
<p>通常采用镜像中所包含的应用程序或服务的名称作为镜像名。</p>
</li>
<li>
<p>标签（Tag）</p>
<p>习惯采用镜像包含的应用程序或服务的版本作为镜像标签。</p>
</li>
</ul>
<h2 id="镜像分层"><a class="markdownIt-Anchor" href="#镜像分层"></a> 镜像分层</h2>
<p>Docker 的镜像是一个多层结构，每一层都在原有层基础上进行改动，这称为镜像分层框架（image-layering framework）：</p>
<ul>
<li>镜像最底层为启动文件系统（bootfs）镜像。</li>
<li>往上一层是根镜像（rootfs），通常包含操作系统。它不包含内核，因此可以非常小。</li>
<li>用户镜像构建于根镜像之上，可以由多个层组成。</li>
<li>再往上一层是初始化（init）层，存放一些定制化文件，如 /etc/hosts 和 /etc/resolv.conf。</li>
<li>最后是用户可读写的操作层。</li>
</ul>
<p>类似于 Git 的原理，每一层镜像都可以视为一个提交，并拥有独立的 ID，最顶层的 ID 被视为镜像 ID（Image ID）。镜像 ID 使用 64 个十六进制字符串（256 比特）来表示。当不同的镜像包含相同的层时，本地仅保留一份相同内容的副本。</p>
<p>当上层和下层有相同的文件和配置时，上层会覆盖下层，以上层的数据为准。用户看到的是一个叠加之后的文件系统。</p>
<h2 id="写时复制"><a class="markdownIt-Anchor" href="#写时复制"></a> 写时复制</h2>
<p>写时复制指的是在复制某个数组或对象时，并不立即进行复制，而是先进行一些标记动作，只有在需要修改复制的数组或对象时，才真正复制出该变量的副本。</p>
<p>在 Docker 中，当通过镜像运行容器时，并不立即将镜像内容复制到沙盒环境，而是直接在镜像的基础上建立沙盒环境。容器运行的沙盒环境是位于镜像之上的一层临时可读写的镜像层，也被称为 thin 类型容器层。镜像层以只读方式堆叠在容器层的下方。</p>
<p>只有在发生文件修改时，才会将原始镜像中需要修改的文件复制到容器层中，并直接保存在容器层中。在 AUFS 文件系统中，删除文件是通过在容器层中生成一个空白文件来替代镜像层对应文件的方式，实现逻辑上的删除操作。</p>
<h1 id="docker-容器"><a class="markdownIt-Anchor" href="#docker-容器"></a> Docker 容器</h1>
<p>容器是从镜像创建的应用运行实例，包含独立运行的一个或一组应用，以及运行环境。可以在容器中装入任何应用，所有应用的运行方式都一样，可以启动、开始、停止、删除等。同时可以在任何环境中运行容器，容器之间互相隔离。</p>
<p>从操作系统角度看，容器是运行在操作系统上的一个特殊进程，只不过加入了对资源的隔离和限制。在 Windows 和 Mac 上的 Docker 实现基于虚拟化技术实现，和 Linux 容器不同。</p>
<h2 id="容器设计"><a class="markdownIt-Anchor" href="#容器设计"></a> 容器设计</h2>
<p>虽然容器中能运行多个进程或多个不同的程序，但容器只会绑定一个进程。所以容器设计上应该以一个应用程序为主体，其他程序作为主体程序的支援。</p>
<p>这样容器启动时，主体程序也会被启动，Docker 会监视这个程序的主进程。进程退出时，容器也会停止运行。同样通过命令停止容器运行时，Docker 会发送停止信号给主体程序，让程序结束。</p>
<h2 id="启动流程"><a class="markdownIt-Anchor" href="#启动流程"></a> 启动流程</h2>
<p>使用 <code>docker run</code> 命令创建启动容器的流程如下：</p>
<ol>
<li>执行 <code>docker run</code> 命令后，Docker 会在本地搜索所需镜像，如果没找到则从远程仓库中搜索并下载到本地，如果找到了，直接使用本地镜像。</li>
<li>Docker 使用指定镜像创建一个新容器并启动。启动后在只读镜像文件层上挂载一层可读写的容器层，用来记录改变的数据。</li>
<li>Docker 为容器分配一个虚拟网络接口，并通过网桥的方式将该网络接口桥接到宿主机上去。然后从网桥地址池取出一个 IP 地址分配给容器虚拟网络接口。</li>
<li>Docker 在新容器中运行指定的命令或程序，执行完毕后被自动终止。</li>
</ol>
<h1 id="docker-仓库"><a class="markdownIt-Anchor" href="#docker-仓库"></a> Docker 仓库</h1>
<p>Docker 仓库是集中存放镜像文件的场所。</p>
<p>仓库注册服务器（Registry）是存放仓库的地方，往往有多个仓库地址，用来存放不同类型的资源。</p>
<h2 id="仓库分类"><a class="markdownIt-Anchor" href="#仓库分类"></a> 仓库分类</h2>
<p>根据所在位置，仓库可以分为本地仓库和远程仓库。</p>
<p>根据储存镜像公开分享与否，仓库可以分为公开仓库（Public）和私有仓库（Private）。</p>
<h2 id="仓库组成"><a class="markdownIt-Anchor" href="#仓库组成"></a> 仓库组成</h2>
<p>镜像仓库主要由两部分组成：</p>
<ul>
<li>镜像管理系统为镜像仓库提供类似代码库式的镜像存取和管理方式。</li>
<li>用户系统为镜像仓库中的镜像管理操作的授权提供支持。</li>
</ul>
<h2 id="仓库角色"><a class="markdownIt-Anchor" href="#仓库角色"></a> 仓库角色</h2>
<p>一般网络上的镜像仓库包含三个角色：</p>
<ul>
<li>Index（索引）：负责维护用户账号、镜像校验及公共命名空间等信息。</li>
<li>Registry（库）：镜像和图标的仓库。</li>
<li>Client（客户端）：用户通过客户端与仓库进行通信、鉴权、推送和拉取。</li>
</ul>
<h2 id="下载流程"><a class="markdownIt-Anchor" href="#下载流程"></a> 下载流程</h2>
<p>以 Docker Hub 为例，下载镜像的流程如下：</p>
<ol>
<li>客户端向 Index 发送下载某个镜像的请求。</li>
<li>Index 返回三个信息：镜像位置、镜像所有层的校验信息、授权令牌。</li>
<li>用户使用授权 token 向目标 Registry 发出请求。</li>
<li>Registry 向 Index 核实 token 是否授权。</li>
<li>Index 返回授权验证结果，如果合法，则通过下载请求。</li>
</ol>
<h2 id="上传流程"><a class="markdownIt-Anchor" href="#上传流程"></a> 上传流程</h2>
<p>以 Docker Hub 为例，上传镜像的流程如下：</p>
<ol>
<li>用户发送带有证书的请求到 Index，要求分配库名。</li>
<li>在成功认证并确定命名空间和库名都能分配后，Index 返回一个临时 token。</li>
<li>镜像带着临时 token 向 Registry 发起推送请求。</li>
<li>Registry 向 Index 检验该 token 的有效性，认证成功后开始读取客户端的数据流。</li>
<li>Index 更新此次镜像的校验信息。</li>
</ol>
<h1 id="相关链接"><a class="markdownIt-Anchor" href="#相关链接"></a> 相关链接</h1>
<p>和 Docker 相关的资源网站：</p>
<ul>
<li><a href="https://www.docker.com/">Docker 官网</a></li>
<li><a href="https://docs.docker.com/">Docker 官方文档</a></li>
<li><a href="https://hub.docker.com/">Docker Hub</a></li>
<li><a href="https://github.com/docker">Docker 源码</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 系统介绍</title>
    <url>/376871778/</url>
    <content><![CDATA[<h1 id="系统构架简介"><a class="markdownIt-Anchor" href="#系统构架简介"></a> 系统构架简介</h1>
<p>系统架构根据不同的设计原则和需求，可以分为多种类型。</p>
<h2 id="单体应用"><a class="markdownIt-Anchor" href="#单体应用"></a> 单体应用</h2>
<p>单体应用由很多个组件组成，这些组件紧密地耦合在一起，由于它们在同一个操作系统进程中运行，所以在开发、部署和管理时必须以同一个实体进行。</p>
<p>对单体应用来说，即使是某个组件的一个小修改，都需要重新部署整个应用。组件之间缺乏严格边界，互相依赖，系统复杂度逐渐提升。</p>
<p>运行一个单体应用，通常需要一台能为整个应用提供足够资源的高性能服务器。为了应对不断增长的系统负荷，需要垂直扩展，对服务器硬件进行升级，或者增加更多服务器进行水平扩展。垂直扩展通常会遇到性能瓶颈，水平扩展可能需要对原本应用程序代码进行大量改动。</p>
<h2 id="微服务"><a class="markdownIt-Anchor" href="#微服务"></a> 微服务</h2>
<p>微服务架构旨在解决大型单体应用程序臃肿的问题，将单体应用拆分为小而可独立部署的微服务组件。每个微服务都以独立的进程运行，并通过简单且定义良好的 API 接口与其他微服务进行通信。</p>
<p>服务器之间使用类似 HTTP 的同步协议或者像 AMQP 这样的异步协议进行通信。使用这些标准化协议使得微服务可以使用任意开发语言进行实现。只要提供相对稳定的 API，对一个微服务进行修改不会对其他微服务产生影响。</p>
<p>使用微服务的另一个好处是可以根据需要针对单个组件进行水平扩展，对无法水平扩展的组件进行垂直扩展，灵活组合以适应不同的环境。</p>
<p>然而，微服务也存在一些缺点。随着组件数量的增加，组件部署和依赖的组合数也在增加，配置工作变得冗杂且容易出错。由于微服务涉及多个进程和服务器，调试代码和定位异常调用变得更加困难。</p>
<h2 id="k8s-系统"><a class="markdownIt-Anchor" href="#k8s-系统"></a> K8s 系统</h2>
<p>Kubernetes 源于谷歌内部的 Borg，是一个面向应用的容器集群部署和管理系统。Kubernetes 的目标是消除管理计算、网络和存储等基础设施的负担，通过对底层基础设施进行抽象，简化应用的开发、部署以及对开发和运维团队的管理。K8s 还提供基础平台，用于构建定制化的工作流程和高级的自动化任务。</p>
<p>从运维角度来看，只需在服务器上部署 K8s，就可以运行应用程序，无需安装其他依赖服务。Kubernetes 具有以下几个重要特性：</p>
<ul>
<li>
<p>自动装箱</p>
<p>构建于容器之上，基于资源依赖和其他约束自动完成容器部署，不影响容器的可用性。通过调度机制，将关键和非关键应用的工作负载混合在同一节点上，提高资源利用率。在 K8s 中，所有工作节点被公开为一个部署平台，开发人员无需了解组成集群的服务器。如果需要将程序运行在特定类型的节点上，可以通过节点标签进行选择。</p>
</li>
<li>
<p>健康检查和自我修复</p>
<p>K8s 监控应用程序组件和运行节点，支持容器故障后的自动重启、节点故障后的重新调度容器、健康状态检查失败后的重新创建等自愈机制。</p>
</li>
<li>
<p>水平扩展</p>
<p>支持通过简单的命令手动进行水平扩展，并且基于硬件资源负载率的自动水平扩展机制。如果 K8s 运行在云基础设施上，可以根据程序使用的资源情况和需求自动添加或缩减节点。</p>
</li>
<li>
<p>服务发现和负载均衡</p>
<p>K8s 通过 KubeDNS（或 CoreDNS）为系统内置了服务发现功能。它为每个服务配置了 DNS 名称，允许集群内的客户端直接使用名称进行访问，而服务则通过 iptables 或 ipvs 内置了负载均衡机制。</p>
</li>
<li>
<p>自动发布和回滚</p>
<p>K8s 支持灰度更新应用程序或配置信息。它确保实例不会同时停止，一旦发生故障，会立即自动执行回滚操作。</p>
</li>
<li>
<p>密钥和配置管理</p>
<p>K8s 的 ConfigMap 实现了配置数据与 Docker 镜像的分离，无需重构镜像即可对配置进行更改。此外，对于敏感数据如密码和密钥等，有专门的 Secret 对象用于存放。</p>
</li>
<li>
<p>存储编排</p>
<p>K8s 支持按需自动挂载不同类型的存储系统到 Pod 对象中，包括本地存储、云存储和网络存储系统。</p>
</li>
<li>
<p>批量处理执行</p>
<p>除了服务型应用，K8s 还支持批处理作业和持续集成。它提供了丰富的工具和功能，用于管理和执行大规模的数据处理和计算任务。</p>
</li>
</ul>
<p>通过这些特性和功能，Kubernetes 提供了一个强大而灵活的容器管理平台，为应用程序的部署、扩展、监控和管理提供了全面的解决方案。无论是在本地环境还是云环境中，K8s 都能够有效地管理和调度容器化的应用程序，提供稳定可靠的服务。</p>
<h1 id="资源对象-节点和组件"><a class="markdownIt-Anchor" href="#资源对象-节点和组件"></a> 资源对象、节点和组件</h1>
<p>在 Kubernetes（K8s）中，节点和组件共同协作，使得 Kubernetes 能够实现容器化应用程序的高效部署、自动伸缩和弹性管理。</p>
<h2 id="资源对象"><a class="markdownIt-Anchor" href="#资源对象"></a> 资源对象</h2>
<p>K8s 中的基本概念和术语大多围绕着资源对象（Resource Object）展开。资源对象可分为两类：</p>
<ul>
<li>某种资源的对象，例如 Node、Pod、Service、Volume 等。</li>
<li>与资源对象相关的事物和动作，例如 Label、Namespace、PVC、HPA 等。</li>
</ul>
<p>资源对象一般包括几个通用属性：</p>
<ul>
<li>版本：包括此对象所属的资源组信息，不同版本可能有不同的资源对象属性。</li>
<li>类别：定义资源对象的类型。</li>
<li>名称：资源对象的名称必须唯一。</li>
<li>标签：用于标识资源对象的特征类别，可以通过标签对不同的资源对象进行筛选和操作。</li>
<li>注解：一种特殊的标签，常用于自定义扩展资源对象的属性。</li>
</ul>
<h2 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h2>
<p>节点是集群的工作单元，用于运行容器化应用程序。每个节点都是一个独立的机器，可以是物理服务器或虚拟机。节点上安装了容器运行时环境，例如 Docker、containerd 等，以便运行和管理容器。</p>
<p>K8s 集群通常包含多个节点，它们协同工作以提供高可用性和可扩展性。以下是两种节点类型：</p>
<ul>
<li>
<p>主节点（Master）： 集群的控制节点，负责控制和管理整个集群系统。主节点承载任务如为用户暴露 API、跟踪其他服务器的健康状态、以最优的方式调度工作负载以及编排其他组件之间的通信等。可以运行多个主节点以提高可用性。</p>
</li>
<li>
<p>工作节点（Node）： 工作节点负责运行用户实际部署的应用，由主节点进行管理。它接收来自主节点的工作指令，并根据指令创建或销毁 Pod 对象，以及调整网络规划以合理地路由和转发流量。</p>
</li>
</ul>
<p>节点可以在运行期间动态加入到集群中，K8s 将所有节点的资源集结在一起，形成一台超级服务器。当用户将应用部署在集群上时，主节点会使用调度算法将其自动指派给某个特定的工作节点运行。</p>
<p>主节点和工作节点中的组件联系如下图所示：</p>
<p><img data-src="../../../images/%E8%8A%82%E7%82%B9%E7%BB%84%E4%BB%B6.jpg" alt="节点组件" /></p>
<h3 id="主节点"><a class="markdownIt-Anchor" href="#主节点"></a> 主节点</h3>
<p>主节点的控制面板负责控制并使整个集群正常运转。它包含多个组件，这些组件可以运行在单个主节点上，也可以通过副本部署在多个主节点上以确保高可用性。这些组件包括：</p>
<ul>
<li>API 服务器（kube-apiserver）： 负责控制面板组件之间的通信，提供关键的 HTTP REST 接口服务，是集群的前端接口。</li>
<li>Scheduler 调度器（kube-scheduler）： 负责调度应用程序，为每个可部署组件分配工作节点。</li>
<li>Controller Manager 控制器管理器（kube-controller-manager）： 执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等，以确保资源处于预期状态。</li>
<li>etcd 分布式持久化存储： 一个可靠的分布式数据存储，用于持久化存储群集配置和各种资源的状态信息。当数据发生变化时，etcd 会快速通知相关组件。</li>
</ul>
<p>可以通过 API 服务器暴露的 ComponentStatus 的 API 资源查询这些组件的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get componentstatuses
Warning: v1 ComponentStatus is deprecated <span class="token keyword">in</span> v1.19+
NAME                 STATUS      MESSAGE                         ERROR
scheduler            Healthy     ok 
controller-manager   Healthy     ok     
etcd-0               Healthy     <span class="token punctuation">&#123;</span><span class="token string">"health"</span><span class="token builtin class-name">:</span><span class="token string">"true"</span>,<span class="token string">"reason"</span><span class="token builtin class-name">:</span><span class="token string">""</span><span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="工作节点"><a class="markdownIt-Anchor" href="#工作节点"></a> 工作节点</h3>
<p>工作节点是运行容器化应用程序的机器。它负责运行、监控和管理应用服务，以下是工作节点中的组件：</p>
<ul>
<li>容器运行时（Container runtime）： 负责镜像管理以及 Pod 和容器的实际运行，使用容器运行时接口（CRI）。默认使用 Docker Engine，也可以使用其他类型的容器引擎。</li>
<li>Kubelet（kubelet）： 与 API 服务器通信，并管理所在节点的容器，与容器运行时进行交互，是工作节点的客户端。调度器确定在某个节点上运行 Pod 后，会将具体配置信息发送给 Kubelet，以创建和运行容器，并向主节点报告运行状态。同时，Kubelet 还负责卷（CSI）和网络（CNI）的管理。</li>
<li>代理服务（kube-proxy）： 每个节点上都运行代理服务，它负责将对服务的访问流量转发到后端容器（服务发现）。如果有多个 Pod 副本，代理服务还负责组件之间的负载均衡和网络流量转发。</li>
</ul>
<p>可以使用 <code>kubectl describe</code> 命令查询工作节点的详细信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master manifests<span class="token punctuation">]</span>$ kubectl describe <span class="token function">node</span> server4-master 
Name:               server4-master
Roles:              control-plane,master
Labels:             beta.kubernetes.io/arch<span class="token operator">=</span>amd64
                    beta.kubernetes.io/os<span class="token operator">=</span>linux
                    kubernetes.io/arch<span class="token operator">=</span>amd64
                    kubernetes.io/hostname<span class="token operator">=</span>server4-master
                    kubernetes.io/os<span class="token operator">=</span>linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h2>
<p>除了控制面板和运行在节点上的组件，K8s 集群还依赖第三方组件以提供完整的功能。以下是主要的组件：</p>
<ul>
<li>CoreDNS：提供集群的服务注册和服务发现的 DNS 解析服务。</li>
<li>Dashboard：用于通过 Web 用户界面管理集群中的应用程序和集群本身。</li>
<li>Heapster：已被弃用的容器和节点性能监控分析系统，现已由 Prometheus 结合其他组件取代。</li>
<li>Ingress：在应用层实现 HTTP 负载均衡机制，它是一组路由规则的集合，需要通过 Ingress Controller 来实现功能。</li>
<li>容器网络接口插件：常用的插件有 Flannel 和 Calico。</li>
</ul>
<p>K8s 系统组件之间的通信主要通过 API 服务器进行。API 服务器和其他组件的连接大多由组件发起。只有在使用 kubectl 获取日志、attach 到容器上（即连接到容器中运行的主进程）或者运行 kubectl 端口转发时，API 服务器才会与 Kubelet 建立连接。</p>
<p>控制面板的组件可以简单地部署在多台服务器上，多个实例可以并行工作以提高可用性。但是调度器和控制器管理器在任意时刻只能有一个实例起作用，其他实例处于待命状态。</p>
<p>控制面板的组件可以作为 Pod 运行，而 Kubelet 是唯一一个作为常规系统组件运行的组件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> custom-columns<span class="token operator">=</span>组件:metadata.name,节点:spec.nodeName --sort-by spec.nodeName <span class="token parameter variable">-n</span> kube-system 
组件                                       节点
coredns-7f6cbbb7b8-jtqxp                 server4-master
coredns-7f6cbbb7b8-vvtxz                 server4-master
etcd-server4-master                      server4-master
kube-apiserver-server4-master            server4-master
kube-controller-manager-server4-master   server4-master
kube-proxy-d455c                         server4-master
kube-scheduler-server4-master            server4-master
kube-proxy-fnvff                         server5-node1
kube-proxy-wkgjf                         server6-node2
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> custom-columns<span class="token operator">=</span>组件:metadata.name,节点:spec.nodeName --sort-by spec.nodeName <span class="token parameter variable">-n</span> calico-system
组件                                         节点
calico-kube-controllers-767ddd5576-b7dpp   server4-master
calico-node-qfsms                          server4-master
calico-typha-7b6f4887f8-mkf7m              server4-master
calico-node-2cp86                          server5-node1
calico-typha-7b6f4887f8-8755m              server5-node1
calico-node-gnfth                          server6-node2
calico-typha-7b6f4887f8-7qmzm              server6-node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上所示，所有控制面板组件作为 Pod 运行在主节点上。每个工作节点运行 kube-proxy，并使用 calico-system 命名空间的网络插件。</p>
<h1 id="k8s-网络"><a class="markdownIt-Anchor" href="#k8s-网络"></a> K8s 网络</h1>
<p>在 Kubernetes（K8s）集群中，网络是一个重要的组成部分，它允许不同的容器和节点之间进行通信，并提供应用程序之间的连接和负载均衡。</p>
<h2 id="网络插件"><a class="markdownIt-Anchor" href="#网络插件"></a> 网络插件</h2>
<p>在 K8s 中，网络由 CNI（Container Network Interface）插件建立。CNI 插件定义了容器如何加入和离开网络，以及如何与其他容器进行通信。这些插件可以部署在 K8s 集群之外。无论使用哪种网络技术，都要满足 Pod 之间可以跨工作节点进行通信，并且通信时会保留源和目标 IP 地址，不使用 NAT（网络地址转换）操作。</p>
<p>Pod 和节点之间的通信也采用了无 NAT 通信，只有 Pod 和互联网上的服务通信时，才会将发送包的源地址改为节点的 IP 地址。</p>
<p>常用的 CNI 插件包括 Calico、Flannel、Romana、Weave Net 等。要使用 CNI 插件，需要在启动 Kubelet 时添加 <code>--network-plugin=cni</code> 参数。</p>
<p>安装一个网络插件只需部署一个包含 DaemonSet 和其他支持资源的 YAML 文件。DaemonSet 会在所有集群节点上部署一个网络代理，并将 CNI 接口绑定到节点上。</p>
<h2 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h2>
<p>K8s 中存在三种网络地址，它们之间的通信采用特殊的路由规则：</p>
<ul>
<li>
<p>Node IP（节点 IP）</p>
<p>每个节点的物理网卡上都有一个 IP 地址。当 K8s 集群外的节点访问集群内的服务时，必须通过节点 IP 进行通信。</p>
</li>
<li>
<p>Pod IP</p>
<p>每个 Pod 都有一个 IP 地址，由 Docker 引擎根据 Docker0 网桥的 IP 地址段进行分配。这通常是一个虚拟的二层网络。</p>
<p>Pod 之间可以直接通信，而真实的流量通过节点 IP 所在的物理网卡流出。</p>
</li>
<li>
<p>Cluster IP（集群 IP）</p>
<p>Service 上的集群 IP 是一个虚拟 IP，来源于集群 IP 地址池，仅在 Service 对象上有效。</p>
<p>集群 IP 无法通过 PING 进行通信，因为没有实际的网络对象来响应。它只能与 Service 端口结合使用，形成一个具体的通信端口。单独的 IP 本身没有通信能力。</p>
</li>
</ul>
<h2 id="同节点-pod-通信"><a class="markdownIt-Anchor" href="#同节点-pod-通信"></a> 同节点 Pod 通信</h2>
<p>在基础容器（Pause 容器）启动之前，会为容器创建一对虚拟网络接口（veth pair），其中一个接口保留在主机的命名空间中（命名为 vethXXX，在节点上可直接查看），而另一个接口被移入容器的网络命名空间，并被重命名为 eth0。这两个虚拟接口就像管道的两端。</p>
<p>主机的网络命名空间接口会绑定到容器运行时配置使用的网络桥接上，从桥接的地址段中获取 IP 地址并赋值给容器内的 eth0 网络接口。所有容器的数据都通过 eth0 发送到桥接，然后再传递给目标 Pod。</p>
<p>如下图所示：</p>
<p><img data-src="../../../images/%E8%99%9A%E6%8B%9F%E6%8E%A5%E5%8F%A3%E5%AF%B9.jpg" alt="虚拟接口对" /></p>
<p>如果 Pod A 发送网络包给 Pod B，数据包将通过 Pod A 的 veth 对到达桥接，然后经过 Pod B 的 veth 对。所有节点上的容器都连接到同一个桥接上。</p>
<h2 id="跨节点-pod-通信"><a class="markdownIt-Anchor" href="#跨节点-pod-通信"></a> 跨节点 Pod 通信</h2>
<p>在连接不同节点的网桥方式中，可以使用覆盖网络（overlay）或底层网络（underlay），或者采用常规的三层路由。</p>
<p>跨整个集群的 Pod 的 IP 地址必须是唯一的，因此跨节点的网桥必须使用非重叠的地址段，以避免 IP 地址冲突。例如，节点 A 上的网桥可以使用 10.1.1.0/24 地址段，而节点 B 上的网桥可以使用 10.1.2.0/24 地址段。</p>
<p>通过三层网络来支持跨节点通信，两个节点的路由表会被配置成下图所示的方式：</p>
<p><img data-src="../../../images/%E8%B7%A8%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1.jpg" alt="跨节点通信" /></p>
<p>上述方案仅在节点之间连通到相同网关且没有其他路由时有效。否则，路由器会丢弃数据包，因为源和目标 IP 都是私有 IP 地址。</p>
<p>使用软件定义网络（SDN）技术可以简化问题，让节点忽略底层网络拓扑，就像连接到同一个网关。从 Pod 发出的报文会被封装，在网络上发送到其他 Pod 所在的网络，然后解封装以原始格式传递给目标 Pod。</p>
<h1 id="高可用集群"><a class="markdownIt-Anchor" href="#高可用集群"></a> 高可用集群</h1>
<p>高可用集群是指在计算机系统或网络中采用冗余设计和自动故障恢复机制，以提高系统的可用性和稳定性。在高可用集群中，多个节点协同工作，共同承担服务的负载和功能，并能够在节点故障或其他异常情况下自动进行故障转移，确保服务的持续可用性。</p>
<h2 id="应用高可用"><a class="markdownIt-Anchor" href="#应用高可用"></a> 应用高可用</h2>
<p>在 K8s 上运行应用的最重要目标是保证应用的持续运行，尽量减少由人工操作基础设置导致的宕机。</p>
<p>最常见的做法是使用 Deploy 资源来运行应用，配置适量的副本集，其余的交由 K8s 来处理。即使应用本身不支持水平扩展，仍然可以使用 Deploy 来发布单个副本。当应用不可用时，K8s 会快速替换为一个新的副本。</p>
<p>此外，还可以同时运行一个活跃的应用和一个附加的非活跃复制集，通过领导选举机制来确保只有一个副本处于活跃状态。这样，在领导者发生宕机时，非活跃复制集会立即接替领导者的角色。</p>
<h2 id="集群高可用性"><a class="markdownIt-Anchor" href="#集群高可用性"></a> 集群高可用性</h2>
<p>在整个 K8s 中，Master 控制节点的重要性不言而喻。如果 Master 所在的服务器宕机，将导致整个 K8s 集群不可用。因此，可以通过运行多个主节点来提高可用性。以下是三个主节点构成的高可用集群示意图：</p>
<p><img data-src="../../../images/%E4%B8%89%E4%B8%BB%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4.jpg" alt="三主节点集群" /></p>
<h2 id="etcd-集群"><a class="markdownIt-Anchor" href="#etcd-集群"></a> Etcd 集群</h2>
<p>由于 etcd 本身就是为分布式系统设计的，因此只需在适量的机器上运行 etcd，使它们能够相互感知即可。实现方法是修改每个实例的配置，包含其他实例的列表，etcd 会在实例之间进行数据复制。</p>
<p>3 个节点允许其中 1 个节点宕机，最佳实践是使用 5 到 7 个节点，这样集群可以容忍 2 或 3 个节点的宕机。超过 7 个节点的数量反而会影响性能。</p>
<h2 id="多实例-api-服务器"><a class="markdownIt-Anchor" href="#多实例-api-服务器"></a> 多实例 API 服务器</h2>
<p>API 服务器是无状态的，因为数据存储在 etcd 中，API 服务器不进行缓存。因此，可以运行任意数量的 API 服务器，它们之间不需要感知对方的存在。</p>
<p>通常，一个 API 服务器会与每个 etcd 实例配对，因为每个 API 服务器仅与本地的 etcd 实例通信。这样，etcd 实例就无需使用任何负载均衡器，只需要对 API 服务器进行负载均衡即可。</p>
<h2 id="控制器和调度器的高可用性"><a class="markdownIt-Anchor" href="#控制器和调度器的高可用性"></a> 控制器和调度器的高可用性</h2>
<p>由于控制器和调度器都会主动监听集群状态，并在发生变更时采取相应的操作，因此在多个实例中运行这些组件可能导致它们执行相同的操作并产生竞争状态，从而导致意外的影响。</p>
<p>因此，在运行这些组件的多个实例时，同一时间只有一个实例处于活动状态。它们通过选举机制确定活跃实例（默认情况下使用 <code>--leader-elect</code> 选项），其他实例处于待命状态。只有当领导者发生故障时，剩余的实例才会选举出新的领导者来接管工作。</p>
<p>控制器和调度器可以与 API 服务器和 etcd 配对运行。如果它们运行在不同的机器上，需要通过负载均衡器连接到 API 服务器。</p>
<h2 id="领导者选举机制"><a class="markdownIt-Anchor" href="#领导者选举机制"></a> 领导者选举机制</h2>
<p>控制平面组件使用的领导者选举机制不需要组件之间进行通信。其实现方式是在 API 服务器中创建一个资源，例如 Endpoint 资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ kubectl get endpoints kube-scheduler <span class="token parameter variable">-n</span> kube-system <span class="token parameter variable">-o</span> yaml
apiVersion: v1
kind: Endpoints
metadata:
  annotations:
    control-plane.alpha.kubernetes.io/leader: <span class="token string">'&#123;"holderIdentity":"server7-master_6725412a-94ed-4d16-ae7f-3f6cd7543c40","leaseDurationSeconds":15,"acquireTime":"2021-11-03T07:46:00Z","renewTime":"2021-11-03T08:09:49Z","leaderTransitions":1&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在资源的注解中，包含了一个名为 <code>control-plane.alpha.kubernetes.io/leader</code> 的字段，其中的 <code>holderIdentity</code> 字段包含了当前领导者的名称。</p>
<p>该机制的原理是通过乐观锁来确保如果多个实例尝试向资源中写入内容，只有一个实例会成功。第一个成功将自己的名称填入 <code>holderIdentity</code> 字段的实例将成为领导者。</p>
<p>一旦成为领导者，它默认每 2 秒必须更新 <code>holderIdentity</code> 字段，以便其他实例知道它仍在工作。一旦停止更新一段时间，其他实例将尝试将自己的名称写入资源中，以取代领导者的角色。</p>
<h1 id="k8s-中应用发布流程"><a class="markdownIt-Anchor" href="#k8s-中应用发布流程"></a> K8s 中应用发布流程</h1>
<p>在 Kubernetes（K8s）中，应用发布是一个关键的流程，它确保应用程序能够在集群中顺利运行并具备高可用性。</p>
<h2 id="应用发布流程"><a class="markdownIt-Anchor" href="#应用发布流程"></a> 应用发布流程</h2>
<p>在 Kubernetes 中发布应用的流程如下：</p>
<ul>
<li>打包应用：首先，需要将应用程序打包到一个或多个容器镜像中。</li>
<li>推送镜像：将打包好的镜像推送到镜像仓库中。</li>
<li>发布应用描述：将应用的描述发布到 API 服务器。</li>
<li>调度容器：API 服务器通过调度器，指示可用的工作节点上的 Kubelet 拉取镜像并运行容器。</li>
</ul>
<p>下图提供了一个简单的示例来说明该流程：</p>
<p><img data-src="../../../images/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.jpg" alt="发布流程" /></p>
<h2 id="事件链"><a class="markdownIt-Anchor" href="#事件链"></a> 事件链</h2>
<p>以一个包含 Deployment 清单的 YAML 文件举例，各控制器协同工作如下：</p>
<p><img data-src="../../../images/%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.jpg" alt="部署过程" /></p>
<ul>
<li>创建 Deployment 资源：kubectl 通过 HTTP POST 请求将清单发送到 API 服务器。API 服务器检查 Deployment 的定义，创建 Deployment 资源，并将其存储到 etcd，然后返回响应给 kubectl。</li>
<li>Deployment 控制器生成 ReplicaSet：当 Deployment 控制器监听到 API 服务器的新 Deployment 对象通知时，根据当前 Deployment 的定义，发送创建 ReplicaSet 的请求给 API 服务器，创建 ReplicaSet 资源。</li>
<li>ReplicaSet 控制器创建 Pod 资源：当 ReplicaSet 控制器接收到新的 ReplicaSet 对象通知时，根据 replica 数量和 Pod 选择器，检查是否有足够满足选择器的 Pod。然后，基于 ReplicaSet 的 Pod 模板，发送创建 Pod 的请求给 API 服务器，创建 Pod 资源。</li>
<li>调度器分配节点给新的 Pod：新创建的 Pod 目前保存在 etcd 中，没有关联的运行节点。调度器监控到这样的 Pod 后，为其选择最佳节点分配，并将该节点分配给 Pod。Pod 的定义现在包含了它应该运行在哪个节点上。</li>
<li>Kubelet 运行 Pod 容器：在节点上，Kubelet 通过 API 服务器监听 Pod 的变更。当发现有分配到本节点的 Pod 后，Kubelet 检查 Pod 的定义，然后命令容器运行时启动 Pod 容器。</li>
</ul>
<h2 id="集群事件"><a class="markdownIt-Anchor" href="#集群事件"></a> 集群事件</h2>
<p>在控制面板组件和 Kubelet 执行动作时，它们会向 API 服务器发送事件。通过创建事件资源来实现事件的发送。可以使用 <code>kubectl get events</code> 命令获取事件信息。</p>
<p>更常见的方式是使用 <code>--watch</code> 参数，在发布后持续观察事件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete <span class="token parameter variable">-f</span> kubia-st.yaml 
statefulset.apps <span class="token string">"kubia"</span> deleted
<span class="token punctuation">[</span>root@server4-master manifests<span class="token punctuation">]</span>$ kubectl get events <span class="token parameter variable">--watch</span>
LAST SEEN   TYPE     REASON    OBJECT        MESSAGE
0s          Normal   Killing   pod/kubia-0   Stopping container kubia
0s          Normal   Killing   pod/kubia-1   Stopping container kubia
0s          Normal   Killing   pod/kubia-2   Stopping container kubia
0s          Warning   FailedToUpdateEndpoint   endpoints/kubia-public   Failed to update endpoint default/kubia-public: Operation cannot be fulfilled on endpoints <span class="token string">"kubia-public"</span><span class="token builtin class-name">:</span> the object has been modified<span class="token punctuation">;</span> please apply your changes to the latest version and try again<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="发布后工作"><a class="markdownIt-Anchor" href="#发布后工作"></a> 发布后工作</h2>
<p>应用程序在 Kubernetes 中运行后，以下是 Kubernetes 的工作：</p>
<ul>
<li>API 服务器会持续确认应用的部署状态是否与描述一致。如果其中一个实例停止正常工作，例如进程崩溃或停止响应，Kubernetes 将自动重新启动该实例。</li>
<li>如果整个工作节点宕机无法访问，故障节点上运行的所有容器将被调度到新节点上运行。</li>
<li>在程序运行期间，可以手动随时调整副本数量，也可以根据节点的实时状态指标自动调整副本数。</li>
<li>当容器在集群中频繁调度时，服务代理将确保服务始终可用。</li>
</ul>
<h1 id="k8s-中应用更新流程"><a class="markdownIt-Anchor" href="#k8s-中应用更新流程"></a> K8s 中应用更新流程</h1>
<p>Kubernetes 提供多种灵活和可控的方式来更新应用，保证应用在更新过程中的可用性和稳定性。</p>
<h2 id="手动更新-pod-内应用"><a class="markdownIt-Anchor" href="#手动更新-pod-内应用"></a> 手动更新 Pod 内应用</h2>
<p>假设 Pod 使用 ReplicaSet（RS）控制器来创建和管理，并且客户端通过 Service 来访问 Pod。如果要对 Pod 内的镜像进行升级，可以采取以下方式。</p>
<h3 id="全量更新"><a class="markdownIt-Anchor" href="#全量更新"></a> 全量更新</h3>
<p>直接删除所有现有的 Pod，然后创建新的 Pod。流程图如下：</p>
<p><img data-src="../../../images/%E6%89%8B%E5%8A%A8%E5%8D%87%E7%BA%A7.jpg" alt="手动升级" /></p>
<p>当使用 RS 控制器时，通过修改 RS 内的 Pod 模板镜像，然后删除旧的 Pod 实例，RS 会使用修改后的镜像来创建新的实例。</p>
<p>这种方式会导致应用在一定的时间内不可用。</p>
<h3 id="蓝绿部署"><a class="markdownIt-Anchor" href="#蓝绿部署"></a> 蓝绿部署</h3>
<p>先创建新的 Pod，成功运行后再删除旧的 Pod。流程图如下：</p>
<p><img data-src="../../../images/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2.jpg" alt="蓝绿部署" /></p>
<p>同样，先修改 RS 内的 Pod 模板镜像，创建新版本的 Pod 并确保正常运行后，可以修改 Service 的标签选择器（使用命令 <code>kubectl set selector</code>），将流量切换到新的 Pod，最后再删除旧版本的 Pod。这也叫做蓝绿部署，适用于不能中断服务的场景。</p>
<p>这种方法需要应用程序支持同时提供两个版本的服务，并且新版本应用不应对原有的关键数据格式或数据本身进行修改，以免导致之前版本的程序运行异常。</p>
<h3 id="金丝雀发布"><a class="markdownIt-Anchor" href="#金丝雀发布"></a> 金丝雀发布</h3>
<p>执行滚动升级操作流程图如下：</p>
<p><img data-src="../../../images/%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7.jpg" alt="滚动升级" /></p>
<p>还可以执行滚动升级操作来逐步替代原有的 Pod，而不是同时创建新的 Pod 和删除旧的 Pod。具体操作是逐步缩减旧版本的 RS 控制器中的 Pod 数量，并扩展新版本的 RS 控制器中的 Pod 数量，以逐渐调整新旧版本 Pod 的比例。这就是金丝雀发布。同时，服务的选择器应包含两个版本的 Pod。</p>
<p>需要注意的是，手动执行滚动升级操作时容易出错，需要谨慎操作。</p>
<h2 id="使用-rc-自动滚动升级"><a class="markdownIt-Anchor" href="#使用-rc-自动滚动升级"></a> 使用 RC 自动滚动升级</h2>
<p>首先，创建一个 RC（Replication Controller）和服务，并使用 v1 版本的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-v1.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: kubia-v1
spec:
  replicas: <span class="token number">3</span>
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - image: luksa/kubia:v1
        name: nodejs
---
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  type: NodePort
  selector:
    app: kubia
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
    nodePort: <span class="token number">30002</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-v1.yaml
replicationcontroller/kubia-v1 created
service/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发布成功后，将有 3 个 v1 版本的 pod 和相应的服务开始运行。通过浏览器访问 30002 端口，并保持输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">curl</span> http://192.168.2.204:30002<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
This is v1 running <span class="token keyword">in</span> pod kubia-v1-9ql94
This is v1 running <span class="token keyword">in</span> pod kubia-v1-52pvf
You<span class="token string">'ve hit kubia-k2l4p
You'</span>ve hit kubia-k2l4p
This is v1 running <span class="token keyword">in</span> pod kubia-v1-52pvf
You've hit kubia-p9wp5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>kubectl rolling-update</code> 命令（已废弃）直接替换掉镜像，进行滚动更新：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">4</span><span class="token punctuation">]</span>$ kubectl rolling-update kubia-v1 kubia-v2 <span class="token parameter variable">--image</span><span class="token operator">=</span>luksa/kubia:v2
Command <span class="token string">"rolling-update"</span> is deprecated, use <span class="token string">"rollout"</span> instead
Created kubia-v2
Scaling up kubia-v2 from <span class="token number">0</span> to <span class="token number">3</span>, scaling down kubia-v1 from <span class="token number">3</span> to <span class="token number">0</span> <span class="token punctuation">(</span>keep <span class="token number">3</span> pods available, don't exceed <span class="token number">4</span> pods<span class="token punctuation">)</span>
Scaling kubia-v2 up to <span class="token number">1</span>
Scaling kubia-v1 down to <span class="token number">2</span>
Scaling kubia-v2 up to <span class="token number">2</span>
Scaling kubia-v1 down to <span class="token number">1</span>
Scaling kubia-v2 up to <span class="token number">3</span>
Scaling kubia-v1 down to <span class="token number">0</span>
Update succeeded. Deleting kubia-v1
replicationcontroller/kubia-v2 rolling updated to <span class="token string">"kubia-v2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在开发过程中，经常会推送修改后的应用到同一个镜像标签，这可能导致镜像不会被重新拉取。或者在没有拉取过旧版本镜像的节点上，会拉取新的镜像，因此可能会同时运行两个不同版本的 pod。</p>
<p>为了确保始终使用最新的镜像，可以将容器的 <code>imagePullPolicy</code> 属性设置为 <code>Always</code>。如果不指定镜像标签，即默认使用 <code>latest</code> 标签，则策略默认为 <code>Always</code>，但如果指定了其他标签，则策略默认为 <code>IfNotPresent</code>。</p>
<p>自动滚动升级的步骤如下：</p>
<ul>
<li>通过复制 RC 控制器 <code>kubia-v1</code> 创建一个名为 <code>kubia-v2</code> 的 RC 控制器，并在 <code>kubia-v2</code> 的模板中将镜像版本改为 <code>kubia:v2</code>。</li>
<li>立即创建 RC 控制器 <code>kubia-v2</code>，并将初始期望副本数设置为 0。</li>
<li>修改 <code>kubia-v1</code> 和 <code>kubia-v2</code> 的标签选择器，添加一个额外的 <code>deployment</code> 标签。</li>
<li>修改旧版本 pod 的标签，添加一个额外的 <code>deployment</code> 标签。</li>
<li>以每次 1 个单位的步长，缩减 <code>kubia-v1</code> 的 pod 数量，并同时扩展 <code>kubia-v2</code> 的 pod 数量，新的 pod 也带有一个额外的 <code>deployment</code> 标签。</li>
<li>最终，旧版本的 pod 数量被缩减到 0，全部被新版本的 pod 替代，旧的 RC 控制器 <code>kubia-v1</code> 被删除。</li>
</ul>
<p>通过这种滚动升级的方式，所有的伸缩请求都由 <code>kubectl</code> 客户端而不是主节点执行。一旦 <code>kubectl</code> 在执行升级时失去连接，升级过程将被中断，pod 和 RC 最终会处于中间状态。一种更先进的方式是使用 Deployment 资源进行部署。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>0.基本知识</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 组件介绍</title>
    <url>/1457906456/</url>
    <content><![CDATA[<h1 id="api-服务器"><a class="markdownIt-Anchor" href="#api-服务器"></a> API 服务器</h1>
<p>K8s API 服务器作为中心组件，其他组件或客户端都会调用它。API 服务器以 RESTful API 的形式提供了可以查询、修改集群状态的 CRUD (Create, Read, Update, Delete) 接口，并将状态存储到 etcd 中。</p>
<p>API 服务器除了提供一种一致的方式来存储对象，还对这些对象进行校验，以确保其合法性。除了校验之外，API 服务器还会处理乐观锁。</p>
<p>kubectl 是 API 服务的一个客户端之一。</p>
<h2 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h2>
<p>当 kubectl 通过一个 HTTP POST 请求将配置文件内容发布到 API 服务器后，API 处理的流程如下：</p>
<ul>
<li>
<p>通过认证插件认证客户端</p>
<p>首先，API 服务器需要对发送请求的客户端进行认证。通过依次调用配置在 API 服务器上的一个或多个认证插件，直到确认请求发送者的身份。根据认证方式，可以从客户端证书或 HTTP 标头中获取用户信息。插件提取客户端的用户名、用户 ID 和归属组信息。</p>
</li>
<li>
<p>通过授权插件为客户端授权</p>
<p>API 服务器还可以配置使用一个或多个授权插件，以决定认证用户是否可以对请求的资源执行请求操作。一旦确认用户拥有权限，API 服务器进入下一步操作。</p>
</li>
<li>
<p>通过准入控制插件验证并修改资源请求</p>
<p>如果请求尝试创建、修改或删除资源，则需要经过准入控制插件的验证。这些插件会验证资源请求，并根据不同的原因对资源进行修改。它们可能会将资源定义中未配置的字段初始化为默认值，可能会修改与请求相关的其他资源，同时也可能因为某些原因拒绝请求。</p>
<p>如果请求只是尝试读取数据，则不会进行准入控制的验证。</p>
<p>常用的准入控制插件包括：AlwaysPullImages、ServiceAccount、NamespaceLifecycle、ResourceQuota 等。</p>
</li>
<li>
<p>验证资源并进行持久化存储</p>
<p>请求通过了所有的准入控制插件后，API 服务器会验证存储在 etcd 中的对象，并向客户端返回响应。</p>
</li>
</ul>
<h2 id="资源变更"><a class="markdownIt-Anchor" href="#资源变更"></a> 资源变更</h2>
<p>API 服务器只负责启动控制器,以及其他一些组件来监控已部署资源的变更.控制面板可以请求订阅资源被创建,修改或删除的通知.</p>
<p>客户端通过创建到 API 服务器的 HTTP 连接来监听变更.每当更新对象,服务器把新版本对象发送至所有监听该对象的客户端.</p>
<p>kubectl 工具作为 API 服务器的客户端之一也支持监听资源.例如部署应用时,可以通过在 get 命令后加–watch 参数,每当有变化就会收到通知:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">--watch</span>
NAME      READY   STATUS    RESTARTS   AGE
kubia-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          19h
kubia-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          19h
kubia-2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          19h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="downward-api"><a class="markdownIt-Anchor" href="#downward-api"></a> Downward API</h2>
<p>对于无法预先知道的数据，K8s Downward API 允许我们通过环境变量或文件（downwardAPI 卷）将 Pod 的元数据公开给外部（传递给容器内的 Pod）。这种方式主要是将从 Pod 的定义和状态中获取的数据作为环境变量和文件的值传递。</p>
<p>目前可以传递给容器的数据包括：</p>
<ul>
<li>Pod 名称</li>
<li>Pod 的 IP 地址</li>
<li>Pod 所属的命名空间</li>
<li>Pod 运行的节点名称</li>
<li>Pod 运行的服务账户名称</li>
<li>每个容器请求的 CPU 和内存使用量</li>
<li>每个容器可使用的 CPU 和内存限制</li>
<li>Pod 的标签</li>
<li>Pod 的注解</li>
</ul>
<p>由于可以在 Pod 运行时修改 Pod 的标签和注解，因此无法通过环境变量来公开修改后的新值。</p>
<p>Downward API 在处理已在环境变量中的部分数据的现有应用程序时特别有用，无需修改应用程序或编写脚本来公开元数据。</p>
<h3 id="通过环境变量暴露"><a class="markdownIt-Anchor" href="#通过环境变量暴露"></a> 通过环境变量暴露</h3>
<p>创建一个简单的单容器来暴露 Pod 常见的 7 种数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> dow.yaml
apiVersion: v1
kind: Pod
metadata:
  name: downward
spec:
  containers:
  - name: main
    image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"sleep"</span>, <span class="token string">"9999"</span><span class="token punctuation">]</span>
    resources:
      requests:
        cpu: 15m
        memory: 500Ki
      limits:
        cpu: 100m
        memory: 8Mi
    env:
    - name: POD_NAME
      valueFrom:
        fieldRef:
          fieldPath: metadata.name
    - name: POD_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    - name: POD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    - name: NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName
    - name: SERVICE_ACCOUNT
      valueFrom:
        fieldRef:
          fieldPath: spec.serviceAccountName
    - name: CONTAINER_CPU_REQUEST_MILLICORES
      valueFrom:
        resourceFieldRef:
          resource: requests.cpu
          divisor: 1m
    - name: CONTAINER_MEMORY_LIMIT_KIBIBYTES
      valueFrom:
        resourceFieldRef:
          resource: limits.memory
          divisor: 1Ki<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，fieldRef 参考的数据来自使用 <code>kubectl get po downward -o yaml</code> 展示的结果，<code>resourceFieldRef</code> 参考的是 <code>spec.containers</code> 中的 <code>resources</code>。如下图所示：</p>
<p><img data-src="../../../images/%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9A%B4%E9%9C%B2pod%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E5%B1%9E%E6%80%A7.jpg" alt="通过环境变量暴露pod元数据和属性" /></p>
<p>对于暴露的资源请求和限制变量，通过 divisor 设置了一个基数单位，最后暴露的是实际数据除以基数单位得到的值。例如，CPU 请求基数为 1 millicore，环境变量展示的值为 15，内存限制基数为 1 Kibibyte，环境变量展示的值为 8192。</p>
<p>创建完 Pod 后，查询容器中的所有环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> downward -- <span class="token function">env</span>
<span class="token assign-left variable">SERVICE_ACCOUNT</span><span class="token operator">=</span>default
<span class="token assign-left variable">CONTAINER_CPU_REQUEST_MILLICORES</span><span class="token operator">=</span><span class="token number">15</span>
<span class="token assign-left variable">CONTAINER_MEMORY_LIMIT_KIBIBYTES</span><span class="token operator">=</span><span class="token number">8192</span>
<span class="token assign-left variable">POD_NAME</span><span class="token operator">=</span>downward
<span class="token assign-left variable">POD_NAMESPACE</span><span class="token operator">=</span>default
<span class="token assign-left variable">POD_IP</span><span class="token operator">=</span><span class="token number">10.244</span>.244.211
<span class="token assign-left variable">NODE_NAME</span><span class="token operator">=</span>server6-node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有在该容器中运行的进程都可以读取并使用所需的变量。</p>
<h3 id="通过-downward-api-卷传递"><a class="markdownIt-Anchor" href="#通过-downward-api-卷传递"></a> 通过 Downward API 卷传递</h3>
<p>使用卷来暴露元数据需要显式地指定元数据字段：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> dow-v.yaml
apiVersion: v1
kind: Pod
metadata:
  name: downward
  labels:
    foo: bar
  annotations:
    key1: value1
    key2: <span class="token operator">|</span>
      multi
      line
      value
spec:
  containers:
  - name: main
    image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"sleep"</span>, <span class="token string">"9999"</span><span class="token punctuation">]</span>
    resources:
      requests:
        cpu: 15m
        memory: 500Ki
      limits:
        cpu: 100m
        memory: 8Mi
    volumeMounts:
    - name: downward
      mountPath: /etc/downward
  volumes:
  - name: downward
    downwardAPI:
      items:
      - path: <span class="token string">"podName"</span>
        fieldRef:
          fieldPath: metadata.name
      - path: <span class="token string">"podNamespace"</span>
        fieldRef:
          fieldPath: metadata.namespace
      - path: <span class="token string">"labels"</span>
        fieldRef:
          fieldPath: metadata.labels
      - path: <span class="token string">"annotations"</span>
        fieldRef:
          fieldPath: metadata.annotations
      - path: <span class="token string">"containerCpuRequestMilliCores"</span>
        resourceFieldRef:
          containerName: main
          resource: requests.cpu
          divisor: 1m
      - path: <span class="token string">"containerMemoryLimitBytes"</span>
        resourceFieldRef:
          containerName: main
          resource: limits.memory
          divisor: <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Downward API 卷被挂载到 <code>/etc/downward/</code> 目录下，卷类型为 DownwardAPI，卷包含的文件会通过卷定义中的 <code>downwardAPI.items</code> 属性来定义。如下图所示：</p>
<p><img data-src="../../../images/%E4%BD%BF%E7%94%A8downwardAPI%E5%8D%B7%E4%BC%A0%E9%80%92%E5%85%83%E6%95%B0%E6%8D%AE.jpg" alt="使用downwardAPI卷传递元数据" /></p>
<p>在容器中查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> downward -- <span class="token function">ls</span> <span class="token parameter variable">-lL</span> /etc/downward
total <span class="token number">24</span>
-rw-r--r--    <span class="token number">1</span> root     root           <span class="token number">337</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 annotations
-rw-r--r--    <span class="token number">1</span> root     root             <span class="token number">2</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 containerCpuRequestMilliCores
-rw-r--r--    <span class="token number">1</span> root     root             <span class="token number">7</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 containerMemoryLimitBytes
-rw-r--r--    <span class="token number">1</span> root     root             <span class="token number">9</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 labels
-rw-r--r--    <span class="token number">1</span> root     root             <span class="token number">8</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 podName
-rw-r--r--    <span class="token number">1</span> root     root             <span class="token number">7</span> Mar <span class="token number">15</span> <span class="token number">22</span>:12 podNamespace
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> downward -- <span class="token function">cat</span> /etc/downward/labels
<span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">"bar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当暴露容器级的元数据时，如资源限制或请求，必须指定容器名称。虽然方式稍微复杂一些，但可以将一个容器的资源字段传递给同一 Pod 中的另一个容器。</p>
<h2 id="kubernetes-api"><a class="markdownIt-Anchor" href="#kubernetes-api"></a> Kubernetes API</h2>
<p>通过 Downward API 的方式获取的元数据相当有限。如果需要了解其他 Pod 或其他资源的信息，只能通过直接与 API 服务器进行交互。</p>
<h3 id="k8s-rest-api"><a class="markdownIt-Anchor" href="#k8s-rest-api"></a> K8s REST API</h3>
<p>可以通过 <code>kubectl cluster-info</code> 命令获取服务器的地址，但无法直接使用 <code>curl</code> 进行交互：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl cluster-info 
Kubernetes control plane is running at https://192.168.2.204:6443
CoreDNS is running at https://192.168.2.204:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> https://192.168.2.204:6443 <span class="token parameter variable">-k</span>
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Status"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"Failure"</span>,
  <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"forbidden: User <span class="token entity" title="\&quot;">\"</span>system:anonymous<span class="token entity" title="\&quot;">\"</span> cannot get path <span class="token entity" title="\&quot;">\"</span>/<span class="token entity" title="\&quot;">\"</span>"</span>,
  <span class="token string">"reason"</span><span class="token builtin class-name">:</span> <span class="token string">"Forbidden"</span>,
  <span class="token string">"details"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"code"</span><span class="token builtin class-name">:</span> <span class="token number">403</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当返回代码为 403 时表示未授权访问，可以通过启动代理 proxy 与服务器进行交互：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl proxy
Starting to serve on <span class="token number">127.0</span>.0.1:8001
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8001
<span class="token punctuation">&#123;</span>
  <span class="token string">"paths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"/.well-known/openid-configuration"</span>,
    <span class="token string">"/api"</span>,
    <span class="token string">"/api/v1"</span>,
    <span class="token string">"/apis/batch"</span>,
    <span class="token string">"/apis/batch/v1"</span>,
    <span class="token string">"/apis/batch/v1beta1"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器会返回一组路径清单，即 REST endpoint 清单。这些路径对应了 apiVersion 定义的路径。以 Job 资源 API 组 <code>/apis/batch</code> 为例，下面列出了两个版本，其中常用的是 v1 版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8001/apis/batch/v1
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"APIResourceList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"groupVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"batch/v1"</span>,
  <span class="token string">"resources"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"cronjobs"</span>,
      <span class="token string">"singularName"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
      <span class="token string">"namespaced"</span><span class="token builtin class-name">:</span> true,
      <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"CronJob"</span>,
      <span class="token string">"verbs"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"create"</span>,
        <span class="token string">"delete"</span>,
        <span class="token string">"deletecollection"</span>,
        <span class="token string">"get"</span>,
        <span class="token string">"list"</span>,
        <span class="token string">"patch"</span>,
        <span class="token string">"update"</span>,
        <span class="token string">"watch"</span>
      <span class="token punctuation">]</span>,
      <span class="token string">"shortNames"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"cj"</span>
      <span class="token punctuation">]</span>,
      <span class="token string">"categories"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"all"</span>
      <span class="token punctuation">]</span>,
      <span class="token string">"storageVersionHash"</span><span class="token builtin class-name">:</span> <span class="token string">"sd5LIXh4Fjs="</span>
    <span class="token punctuation">&#125;</span>,
    <span class="token punctuation">&#123;</span>
      <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"cronjobs/status"</span>,
      <span class="token string">"singularName"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
      <span class="token string">"namespaced"</span><span class="token builtin class-name">:</span> true,
      <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"CronJob"</span>,
      <span class="token string">"verbs"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"get"</span>,
        <span class="token string">"patch"</span>,
        <span class="token string">"update"</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>,
    <span class="token punctuation">&#123;</span>
      <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"jobs"</span>,
      <span class="token string">"singularName"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
      <span class="token string">"namespaced"</span><span class="token builtin class-name">:</span> true,
      <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Job"</span>,
      <span class="token string">"verbs"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"create"</span>,
        <span class="token string">"delete"</span>,
        <span class="token string">"deletecollection"</span>,
        <span class="token string">"get"</span>,
        <span class="token string">"list"</span>,
        <span class="token string">"patch"</span>,
        <span class="token string">"update"</span>,
        <span class="token string">"watch"</span>
      <span class="token punctuation">]</span>,
      <span class="token string">"categories"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"all"</span>
      <span class="token punctuation">]</span>,
      <span class="token string">"storageVersionHash"</span><span class="token builtin class-name">:</span> <span class="token string">"mudhfqk/qZY="</span>
    <span class="token punctuation">&#125;</span>,
    <span class="token punctuation">&#123;</span>
      <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"jobs/status"</span>,
      <span class="token string">"singularName"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
      <span class="token string">"namespaced"</span><span class="token builtin class-name">:</span> true,
      <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Job"</span>,
      <span class="token string">"verbs"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">"get"</span>,
        <span class="token string">"patch"</span>,
        <span class="token string">"update"</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>resources</code> 内包含了这个组中所有资源类型，每个资源对应可使用的操作（如创建、删除、获取等），以及其他一些资源的信息。其中，<code>jobs/status</code> 是用于专门修改状态（恢复、打补丁、修改）的资源。</p>
<p>可以向 <code>/apis/batch/v1/jobs</code> 路径发送 GET 请求，以获取集群中所有 Job 的清单：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8001/apis/batch/v1/jobs
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"JobList"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"batch/v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"656352"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"items"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
        <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"batch-job"</span>,
        <span class="token string">"namespace"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,
        <span class="token string">"uid"</span><span class="token builtin class-name">:</span> <span class="token string">"dfcb1eda-55fc-4a30-ad7c-4769d5baebc4"</span>,
        <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"656319"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取到的清单包括所有命名空间中的 Job。如果要返回指定的 Job，需要在请求 URL 中指定名称和命名空间。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8001/apis/batch/v1/namespaces/default/jobs/batch-job
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Job"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"batch/v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"batch-job"</span>,
    <span class="token string">"namespace"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这种方式获得的结果与执行 <code>kubectl get job batch-job -o json</code> 命令得到的结果相同。</p>
<h3 id="从-pod-内与-api-服务器交互"><a class="markdownIt-Anchor" href="#从-pod-内与-api-服务器交互"></a> 从 Pod 内与 API 服务器交互</h3>
<p>一般情况下，Pod 内没有可用的 kubectl，与 API 服务器进行交互需要解决认证问题。这里使用一个安装了 <code>curl</code> 的镜像，在容器内使用 <code>curl</code> 来测试与 API 服务器的交互结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> curl.yaml
apiVersion: v1
kind: Pod
metadata:
  name: <span class="token function">curl</span>
spec:
  containers:
  - name: main
    image: curlimages/curl
    command: <span class="token punctuation">[</span><span class="token string">"sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> curl.yaml
pod/curl created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token function">curl</span> -- <span class="token function">sh</span>
/ $ <span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> KUBERNETES_SERVICE
<span class="token assign-left variable">KUBERNETES_SERVICE_PORT</span><span class="token operator">=</span><span class="token number">443</span>
<span class="token assign-left variable">KUBERNETES_SERVICE_PORT_HTTPS</span><span class="token operator">=</span><span class="token number">443</span>
<span class="token assign-left variable">KUBERNETES_SERVICE_HOST</span><span class="token operator">=</span><span class="token number">10.96</span>.0.1
/ $ <span class="token function">curl</span> https://kubernetes
curl: <span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> SSL certificate problem: unable to get <span class="token builtin class-name">local</span> issuer certificate
More details here: https://curl.se/docs/sslcerts.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在容器内查询 API 服务器的地址后，尝试访问时会提示证书问题。虽然可以通过 <code>-k</code> 选项来绕过 HTTPS 证书验证，但为了安全起见，应该检查证书以验证 API 服务器的身份，以避免中间人攻击，并防止将应用的验证凭证暴露给攻击者。</p>
<p>可以查看每个容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 目录下默认的 Secret（token），其中包含的 <code>ca.crt</code> 可用于对 API 服务器证书进行签名。<code>curl</code> 允许使用 <code>-cacert</code> 选项来指定 CA 证书路径：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ <span class="token function">ls</span> /var/run/secrets/kubernetes.io/serviceaccount
ca.crt     namespace  token
/ $ <span class="token function">curl</span> <span class="token parameter variable">--cacert</span> /var/run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes
<span class="token punctuation">&#123;</span>
  <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"Status"</span>,
  <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
  <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"status"</span><span class="token builtin class-name">:</span> <span class="token string">"Failure"</span>,
  <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"forbidden: User <span class="token entity" title="\&quot;">\"</span>system:anonymous<span class="token entity" title="\&quot;">\"</span> cannot get path <span class="token entity" title="\&quot;">\"</span>/<span class="token entity" title="\&quot;">\"</span>"</span>,
  <span class="token string">"reason"</span><span class="token builtin class-name">:</span> <span class="token string">"Forbidden"</span>,
  <span class="token string">"details"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"code"</span><span class="token builtin class-name">:</span> <span class="token number">403</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这次 <code>curl</code> 验证通过了服务器的身份，但提示匿名用户没有查询权限。可以通过设置 CURL_CA_BUNDLE 环境变量来简化 <code>curl</code> 指定 CA 证书的选项：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ <span class="token builtin class-name">export</span> <span class="token assign-left variable">CURL_CA_BUNDLE</span><span class="token operator">=</span>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来需要获取 API 服务器的授权，以进一步修改或删除部署在集群中的 API 对象。认证凭证可以使用默认的 token 来生成：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ <span class="token assign-left variable">TOKEN</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /var/run/secrets/kubernetes.io/serviceaccount/token<span class="token variable">)</span></span>
/ $ <span class="token function">curl</span> <span class="token parameter variable">-k</span> <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Bearer <span class="token variable">$TOKEN</span>"</span> https://10.96.0.1 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由于服务器使用 RBAC 机制，服务账户依然没有被授权（或部分授权）访问 API 服务器。可以通过修改角色绑定来临时赋予所有服务账户集群管理员权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create clusterrolebinding permissive-binding <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>cluster-admin <span class="token parameter variable">--group</span><span class="token operator">=</span>system:serviceaccounts
clusterrolebinding.rbac.authorization.k8s.io/permissive-binding created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Secret 卷中还包含一个命名空间的文件，其中包含了当前运行的 Pod 所在的命名空间。在请求中加入命名空间后再次访问，正常情况下会返回当前 Pod 所在命名空间的所有 Pod 清单：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ <span class="token assign-left variable">NS</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /var/run/secrets/kubernetes.io/serviceaccount/namespace<span class="token variable">)</span></span>
/ $ <span class="token function">curl</span> <span class="token parameter variable">-k</span> <span class="token parameter variable">-H</span> <span class="token string">"Authorization: Bearer <span class="token variable">$TOKEN</span>"</span> https://kubernetes/api/v1/namespaces/<span class="token variable">$NS</span>/pods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时，Pod 与 API 服务器的交互已经没有阻碍，其他的 PUT 或 PATCH 请求同样可以操作。示意图如下：</p>
<p>![通过 default token 与 API 服务器交互](…/…/…/images/通过 default token 与 API 服务器交互.jpg)</p>
<p>总结一下 Pod 与 Kubernetes 交互的要点如下：</p>
<ul>
<li>应用程序应验证 API 服务器的证书是否由受信任的证书机构签发，证书位于 <code>ca.crt</code> 文件中。</li>
<li>应用程序应使用它在 <code>token</code> 文件中持有的凭证来获取 API 服务器的授权。</li>
<li>当对 Pod 所在命名空间的 API 对象进行 CRUD（创建、读取、修改、删除）操作时，应使用 <code>namespace</code> 文件来将命名空间信息传递到 API 服务器。</li>
</ul>
<h3 id="通过-ambassador-容器与-api-服务器交互"><a class="markdownIt-Anchor" href="#通过-ambassador-容器与-api-服务器交互"></a> 通过 ambassador 容器与 API 服务器交互</h3>
<p>还有一种更简便与 API 服务器交互的方法，可以在 pod 中增加一个 ambassador 容器，其中运行着 <code>kubectl proxy</code> 命令，通过它来实现与 API 服务器的交互。如下图所示：</p>
<p><img data-src="../../../images/%E9%80%9A%E8%BF%87ambassador%E5%AE%B9%E5%99%A8%E4%B8%8EAPI%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92-1684141737776-22.jpg" alt="通过ambassador容器与API服务器交互" /></p>
<p>这种模式下，运行在主容器中的应用通过 HTTP 协议与 ambassador 连接，并由 ambassador 通过 HTTPS 协议来连接 API 服务器，对应用透明地处理安全问题，其同样使用默认凭证 Secret 卷中的文件来认证。</p>
<p>pod 配置在原先 <code>curl</code> 的基础上增加一个 kubectl-proxy 镜像，启动后进入到 curl 容器中的 shell 环境：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> curl-am.yaml
apiVersion: v1
kind: Pod
metadata:
  name: curl-am
spec:
  containers:
  - name: main
    image: curlimages/curl
    command: <span class="token punctuation">[</span><span class="token string">"sleep"</span>, <span class="token string">"999999"</span><span class="token punctuation">]</span>
  - name: ambassador
    image: luksa/kubectl-proxy:1.6.2
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> curl-am.yaml 
pod/curl-am created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> curl-am <span class="token parameter variable">-c</span> main -- <span class="token function">sh</span>
/ $ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来试着通过 ambassador 容器来连接 API 服务器。kubectl proxy 默认绑定 8001 端口，由于在同 pod 中可以直接访问本地回环地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ <span class="token function">curl</span> localhost:8001
<span class="token punctuation">&#123;</span>
  <span class="token string">"paths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"/.well-known/openid-configuration"</span>,
    <span class="token string">"/api"</span>,
    <span class="token string">"/api/v1"</span>,
    <span class="token string">"/apis"</span>,
    <span class="token string">"/apis/"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示 ambassador 容器已经帮忙处理好了凭证和授权问题。</p>
<p>虽然 ambassador 容器已经足够简便，且能跨多个应用复用，但负面因素是需要运行额外的进程，消耗更多资源。</p>
<h3 id="使用客户端与-api-服务器交互"><a class="markdownIt-Anchor" href="#使用客户端与-api-服务器交互"></a> 使用客户端与 API 服务器交互</h3>
<p>如果应用仅仅需要在 API 服务器执行一些简单操作，可以使用一个标准的客户端库来执行简单的 HTTP 请求。但对于执行更复杂的 API 请求，使用某个已有的 K8s API 客户端库会更好。可以到 GitHub 社区查询到<a href="https://github.com/kubernetes/community/blob/master/sig-list.md">具体清单</a>。</p>
<p>另外，如果选择的开发语言没有可用的客户端，可以使用 Swagger API 框架生成客户端库和文档。具体内容可访问<a href="https://swagger.io/">官网</a>。</p>
<h1 id="控制器管理器"><a class="markdownIt-Anchor" href="#控制器管理器"></a> 控制器管理器</h1>
<p>控制器主要工作是通过标签管理 pod，确保系统真实状态朝 API 服务器定义的期望状态收敛。</p>
<p>它们是 K8s 上的一类对象，包括 ReplicationController、ReplicaSet、Deployment、StatefulSet、Job 等。控制器的定义通常由期望的副本数量、pod 模板和标签选择器组成。</p>
<h2 id="控制器工作"><a class="markdownIt-Anchor" href="#控制器工作"></a> 控制器工作</h2>
<p>控制器通过 API 服务器监听资源（部署、服务等）变更，并执行相应操作。将实际状态调整为期望状态（资源 spec 部分定义）后，将新的实际状态写入资源的 status 部分。</p>
<p>控制器利用监听机制来订阅变更，但仍然会定期执行重列举操作来确保不会漏掉请求。</p>
<p>生命周期功能包括命名空间创建、事件垃圾回收、pod 终止相关垃圾回收、级联垃圾回收及节点垃圾回收等。</p>
<p>通过源码分析，控制器工作原理如下：</p>
<ul>
<li>每个控制器一般有一个构造器，内部会创建一个 Informer，也就是监听器，每次 API 对象有更新就会被调用。</li>
<li>通常 Informer 会监听特定类型的资源变更事件。</li>
<li>控制器需要工作的时候会调用 worker() 方法，实际函数通常保存在一个叫 syncHandler 或类似字段里。该字段也在构造器里初始化，可以在那找到被调用函数名。</li>
</ul>
<h2 id="控制器类型"><a class="markdownIt-Anchor" href="#控制器类型"></a> 控制器类型</h2>
<p>Kubernetes 中有多种类型的控制器，每种控制器都有不同的作用和特点。以下是一些常用的控制器类型。</p>
<h3 id="replicationcontroller-控制器"><a class="markdownIt-Anchor" href="#replicationcontroller-控制器"></a> ReplicationController 控制器</h3>
<p>启动 ReplicationController（复制控制器）的控制器称为 ReplicationManager（复制管理器）。ReplicationManager 通过监听机制订阅可能影响复制集数量或符合条件的 pod 数量的变更事件。</p>
<p>任何变化都会触发 ReplicationController 控制器重新检查期望的复制集数量与实际数量，然后采取相应的操作。它不直接操作 pod，而是通过向 API 服务器创建新的 pod 清单，由 API 服务器通知调度器和 Kubelet 执行 pod 管理操作。其他控制器的工作流程也类似。</p>
<h3 id="replicaset-daemonset-和-job-控制器"><a class="markdownIt-Anchor" href="#replicaset-daemonset-和-job-控制器"></a> ReplicaSet、DaemonSet 和 Job 控制器</h3>
<p>这些控制器的工作原理与 ReplicationController 控制器基本相同。</p>
<h3 id="deployment-控制器"><a class="markdownIt-Anchor" href="#deployment-控制器"></a> Deployment 控制器</h3>
<p>Deployment 控制器负责同步 Deployment 的实际状态与对应的 Deployment API 对象的期望状态。每次修改 Deployment 对象后，控制器会进行滚动升级到新版本，通过创建一个 ReplicaSet（副本集）来调整 pod 的数量，直到升级完成。</p>
<h3 id="statefulset-控制器"><a class="markdownIt-Anchor" href="#statefulset-控制器"></a> StatefulSet 控制器</h3>
<p>StatefulSet 控制器类似于 ReplicaSet 控制器，根据定义创建和管理 pod，但同时还会初始化和管理每个 pod 实例的持久卷声明。</p>
<h3 id="node-控制器"><a class="markdownIt-Anchor" href="#node-控制器"></a> Node 控制器</h3>
<p>Node 控制器负责管理 Node 资源，描述集群的工作节点，并确保节点对象列表的正确性。同时监控每个节点的健康状态，删除不可达节点上的 pod。</p>
<h3 id="service-控制器"><a class="markdownIt-Anchor" href="#service-控制器"></a> Service 控制器</h3>
<p>Service 控制器用于提供稳定的对 pod 的访问服务。</p>
<h3 id="endpoint-控制器"><a class="markdownIt-Anchor" href="#endpoint-控制器"></a> Endpoint 控制器</h3>
<p>Endpoint 控制器负责维护端点列表。控制器同时监听 Service 和 pod，当 Service 或 pod 被添加或修改时，控制器会选择与 Service 中的 pod 选择器匹配的 pod，并将其 IP 和端口添加到 Endpoint 资源中。</p>
<p>Endpoint 对象是独立的对象，因此在需要时控制器会创建它，并在删除 Service 时一同删除。</p>
<h3 id="namespace-控制器"><a class="markdownIt-Anchor" href="#namespace-控制器"></a> Namespace 控制器</h3>
<p>Namespace 控制器负责删除 Namespace 资源时，清除所有属于该命名空间的资源。</p>
<h3 id="persistentvolume-控制器"><a class="markdownIt-Anchor" href="#persistentvolume-控制器"></a> PersistentVolume 控制器</h3>
<p>当用户创建 PersistentVolumeClaim（持久卷声明）时，控制器负责找到合适的 PersistentVolume（持久卷）与声明进行绑定。</p>
<p>查找的方式是保存一个有序的持久卷列表，按容量升序排列，返回列表中的第一个卷。</p>
<p>当用户删除持久卷声明时，控制器会解绑卷，并根据卷的回收策略进行处理。</p>
<h1 id="调度器"><a class="markdownIt-Anchor" href="#调度器"></a> 调度器</h1>
<p>调度器的角色比较简单，就是利用 API 服务器的监听机制等待新创建的 pod，然后给新建的 pod 分配节点。</p>
<p>调度器不会指示选中的节点运行 pod，而是通过 API 服务器更新 pod 的定义，然后由 API 服务器通知节点上的 Kubelet，告知该 pod 已被调度到此节点，并由目标节点上的 Kubelet 创建并运行 pod 的容器。</p>
<p>Kubernetes 还支持用户自定义调度器。</p>
<h2 id="默认的调度算法"><a class="markdownIt-Anchor" href="#默认的调度算法"></a> 默认的调度算法</h2>
<p>调度器的默认调度算法选择节点的操作可以分为两部分：首先过滤所有节点，找出可分配给 pod 的可用节点列表；然后对可用节点按优先级排序，找出最优节点。如果多个节点的优先级相同，则循环分配，确保 pod 平均分配。</p>
<h2 id="查找可用节点"><a class="markdownIt-Anchor" href="#查找可用节点"></a> 查找可用节点</h2>
<p>为了找出可用节点，调度器会对每个节点下发一组配置好的预选函数，检查节点信息：</p>
<ul>
<li>节点是否能满足 pod 对硬件资源的请求；</li>
<li>节点是否耗尽资源；</li>
<li>pod 是否有节点选择器；</li>
<li>节点是否符合 pod 中的节点选择器；</li>
<li>pod 请求绑定的主机端口是否已被占用；</li>
<li>pod 请求的存储卷是否能加载，是否可用；</li>
<li>pod 是否能够容忍节点的污点；</li>
<li>pod 是否定义了节点，以及 pod 的亲和性和反亲和性规则。</li>
</ul>
<p>只有当所有的测试都通过时，节点才有资格被调度给 pod。</p>
<h2 id="高级调度"><a class="markdownIt-Anchor" href="#高级调度"></a> 高级调度</h2>
<p>默认情况下，属于同一服务和 ReplicaSet 的 pod 会分散在尽可能多的节点上，但可以通过定义 pod 的亲和性或反亲和性规则，强制 pod 在集群内分散或集中在一起。</p>
<h2 id="多个调度器"><a class="markdownIt-Anchor" href="#多个调度器"></a> 多个调度器</h2>
<p>可以在集群中运行多个调度器，然后在 pod 的属性中设置 <code>schedulerName</code> 属性来指定调度器来调度它。如果未设置此属性的 pod，则由默认调度器（default-scheduler）进行调度。</p>
<h1 id="etcd"><a class="markdownIt-Anchor" href="#etcd"></a> etcd</h1>
<p>etcd 是一个分布式的键值存储数据库，Kubernetes 使用 etcd 来持久化存储集群状态和元数据。API 服务器是与 etcd 通信的唯一组件，所有其他组件通过 API 服务器间接地读写数据到 etcd。</p>
<h2 id="etcdctl"><a class="markdownIt-Anchor" href="#etcdctl"></a> etcdctl</h2>
<p>要访问 etcd 数据库，需要在主节点上安装 etcdctl 客户端：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-L</span> https://github.com/etcd-io/etcd/releases/download/v3.5.2/etcd-v3.5.2-linux-amd64.tar.gz <span class="token parameter variable">-o</span> etcd-v3.5.2-linux-amd64.tar.gz
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zxf</span> etcd-v3.5.2-linux-amd64.tar.gz
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> etcd-v3.5.2-linux-amd64/etcdctl /usr/local/bin
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl version
etcdctl version: <span class="token number">3.5</span>.2
API version: <span class="token number">3.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置好数据库地址、证书路径等到本地变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> ~/.bashrc
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_ENDPOINTS</span><span class="token operator">=</span>https://127.0.0.1:2379
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_CACERT</span><span class="token operator">=</span>/etc/kubernetes/pki/etcd/ca.crt
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_CERT</span><span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.crt
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_KEY</span><span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.key
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_API</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后就可以直接通过命令来访问 etcd：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl get --keys-only <span class="token parameter variable">--prefix</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="乐观并发控制"><a class="markdownIt-Anchor" href="#乐观并发控制"></a> 乐观并发控制</h2>
<p>乐观并发控制，也称为乐观锁，指的是一段数据包含一个版本数字，而不是锁住该段数据阻止读写操作。</p>
<p>每当更新数据时，版本数就会增加。当更新数据时，会检查版本值是否在客户端读取数据时间和提交时间之间被增加过。如果有增加过，更新会被拒绝，客户端必须重新读取新数据，重新尝试更新。</p>
<p>当两个客户端尝试更新同一个数据条目时，只有第一个会成功。</p>
<p>所有的 Kubernetes 对象都包含一个 <code>metadata.resourceVersion</code> 字段用来保存版本数字。在更新对象时，客户端需要返回该值到 API 服务器，服务器检查版本值与 etcd 中存储的是否匹配。如果不匹配，服务器会拒绝更新。</p>
<h2 id="资源储存"><a class="markdownIt-Anchor" href="#资源储存"></a> 资源储存</h2>
<p>etcd 的版本 v2 和 v3 对资源存储格式有所不同。v2 版本将键存储在一个层级键空间中，使得键值对类似于文件系统的文件。每个键可以是一个目录，包含其他键，或者是一个常规键，对应一个值。v3 版本不支持目录，但由于键格式保持不变，键可以包含斜杠，仍然可以将它们组织成目录结构。</p>
<p>Kubernetes 将所有数据存储到 etcd 的 <code>/registry</code> 下，可以使用 etcdctl 来查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl get --keys-only <span class="token parameter variable">--prefix</span> /registry <span class="token operator">|</span> <span class="token function">less</span>
/registry/apiextensions.k8s.io/customresourcedefinitions/apiservers.operator.tigera.io
/registry/apiextensions.k8s.io/customresourcedefinitions/bgpconfigurations.crd.projectcalico.org
/registry/apiextensions.k8s.io/customresourcedefinitions/bgppeers.crd.projectcalico.org
/registry/apiextensions.k8s.io/customresourcedefinitions/blockaffinities.crd.projectcalico.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>会发现键与资源名称相对应。还可以单独查看特定命名空间下的 Pod 列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl get --keys-only <span class="token parameter variable">--prefix</span> /registry/pods/default
/registry/pods/default/kubia-0
/registry/pods/default/kubia-1
/registry/pods/default/kubia-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要查看特定 Pod 在 etcd 中存储的内容，可以执行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl get /registry/pods/default/kubia-1
kube-controller-managerUpdatevFieldsV1:f:metadata<span class="token string">":&#123;"</span>f:generateName<span class="token string">":&#123;&#125;,"</span>f:labels<span class="token string">":&#123;"</span><span class="token builtin class-name">.</span><span class="token string">":&#123;&#125;,"</span>f:app<span class="token string">":&#123;&#125;,"</span>f:controller-revision-hash<span class="token string">":&#123;&#125;,"</span>f:statefulset.kubernetes.io/pod-name<span class="token string">":&#123;&#125;&#125;,"</span>f:ownerReferences<span class="token string">":&#123;"</span><span class="token builtin class-name">.</span><span class="token string">":&#123;&#125;,"</span>k:<span class="token punctuation">&#123;</span><span class="token punctuation">\</span>"uid<span class="token punctuation">\</span>":<span class="token punctuation">\</span>"4142df85-4fb1-4b09-84ab-24ad2d1c309e<span class="token punctuation">\</span>"<span class="token punctuation">&#125;</span><span class="token string">":&#123;&#125;&#125;&#125;,"</span>f:spec<span class="token string">":&#123;"</span>f:containers<span class="token string">":&#123;"</span>k:<span class="token punctuation">&#123;</span><span class="token punctuation">\</span>"name<span class="token punctuation">\</span>":<span class="token punctuation">\</span>"kubia<span class="token punctuation">\</span>"<span class="token punctuation">&#125;</span><span class="token string">":&#123;"</span><span class="token builtin class-name">.</span><span class="token string">":&#123;&#125;,"</span>f:image<span class="token string">":&#123;&#125;,"</span>f:imagePullPolicy<span class="token string">":&#123;&#125;,"</span>f:name<span class="token string">":&#123;&#125;,"</span>f:ports<span class="token string">":&#123;"</span><span class="token builtin class-name">.</span><span class="token string">":&#123;&#125;,"</span>k:<span class="token punctuation">&#123;</span><span class="token punctuation">\</span>"containerPort<span class="token punctuation">\</span>":8080,<span class="token punctuation">\</span>"protocol<span class="token punctuation">\</span>":<span class="token punctuation">\</span>"TCP<span class="token punctuation">\</span>"<span class="token punctuation">&#125;</span><span class="token string">":&#123;"</span><span class="token builtin class-name">.</span><span class="token string">":&#123;&#125;,"</span>f:containerPort<span class="token string">":&#123;&#125;,"</span>f:name<span class="token string">":&#123;&#125;,"</span>f:protocol<span class="token string">":&#123;&#125;&#125;&#125;,"</span>f:resources<span class="token string">":&#123;&#125;,"</span>f:terminati<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这将返回  JSON 格式的 Pod 定义。</p>
<h2 id="etcd-集群"><a class="markdownIt-Anchor" href="#etcd-集群"></a> etcd 集群</h2>
<p>为了保证高可用性，etcd 集群通常会部署多个（奇数个）etcd 实例。etcd 使用 Raft 一致性算法来确保系统达到一致的实际状态。</p>
<p>该算法要求大部分节点参与才能进行下一个状态的提交，否则集群将分裂成两个不互联的节点组。如果一个组的成员数超过另一个组，大组可以更改集群状态，而小组则不能。当两个组重新恢复连接时，小组的节点会将状态更新为大组节点的状态。下图展示了这个过程：</p>
<p><img data-src="../../../images/%E8%84%91%E8%A3%82%E5%9C%BA%E6%99%AF.jpg" alt="脑裂场景" /></p>
<h1 id="kubelet"><a class="markdownIt-Anchor" href="#kubelet"></a> Kubelet</h1>
<p>Kubelet 是 Kubernetes 中的一个核心组件，它运行在每个节点上，负责管理节点上的容器和与主控组件的通信。</p>
<h2 id="工作内容"><a class="markdownIt-Anchor" href="#工作内容"></a> 工作内容</h2>
<p>Kubelet 负责所有运行在工作节点上的内容组件。</p>
<p>其工作内容是：</p>
<ul>
<li>在 API 服务器中创建一个 Node 资源来注册 Kubelet 所在节点。</li>
<li>持续监控 API 服务器是否将该节点分配给 pod。</li>
<li>告知节点上的容器运行时拉取镜像，启动容器。</li>
<li>持续监控运行的容器，向 API 服务器报告它们的状态、事件和资源消耗。</li>
<li>在 pod 被从 API 服务器删除时，Kubelet 终止容器并通知服务器 pod 已被终止。</li>
</ul>
<h2 id="运行静态-pod"><a class="markdownIt-Anchor" href="#运行静态-pod"></a> 运行静态 pod</h2>
<p>Kubelet 还可以基于本地指定目录下的 pod 清单来运行 pod，主要用于运行容器化版本的控制面板组件。</p>
<p>静态 pod 总由 Kubelet 创建在 Kubelet 所在的 Node 上运行，由 Kubelet 管理。不能通过 API Server 进行管理，不能与控制器进行关联，Kubelet 也无法对它们进行健康检查。</p>
<p>启动静态 pod 需要设置 Kubelet 的启动参数 <code>--config</code>，指定需要监控的配置文件所在目录，并根据 YAML 进行创建操作。例如配置 <code>--config=/etc/kubelet.d/</code>，然后重启 Kubelet 服务。在目录下写入 <code>static-web.yaml</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> static-web.yaml
apiVersion: v1
kind: Pod
metadata:
  name: static-web
  labels:
    name: static-web
  namespace: default
spec:
  containers:
  - name: static-web
    image: nginx
    ports:
    - name: web
      containerPort: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等待一段时间可以看到 pod 被创建出来。假如在 Master 节点删除 pod，会使其变为 Pending 状态且不会被删除。</p>
<p>还可以通过设置 Kubelet 的启动参数 <code>--manifest-url</code>，Kubelet 将会定期从指定 URL 地址下载定义文件创建 pod。</p>
<h1 id="proxy"><a class="markdownIt-Anchor" href="#proxy"></a> Proxy</h1>
<p>Proxy 是一种核心组件，它用于在集群内部提供网络代理服务。它负责处理集群内部各个节点上的网络请求，并将其转发到适当的目标。</p>
<h2 id="代理作用"><a class="markdownIt-Anchor" href="#代理作用"></a> 代理作用</h2>
<p>除了 Kubelet，每个工作节点都会运行 kube-proxy，用于确保客户端通过 API 服务器对服务 IP 和端口的连接最终能够到达支持服务（或其他非 Pod 服务终端）的某个 Pod。</p>
<p>如果一个服务由多个 Pod 支持，那么代理将对 Pod 进行负载均衡。</p>
<h2 id="代理实现"><a class="markdownIt-Anchor" href="#代理实现"></a> 代理实现</h2>
<p>kube-proxy 最初被称为 userspace 代理，它利用实际的服务器集成接收连接，并将其代理给 Pod。为了拦截发往服务 IP 的连接，代理配置了 iptables 规则，将连接重定向到代理服务器。如下图所示：</p>
<p><img data-src="../../../images/userspace%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="userspace代理模式" /></p>
<p>当前的 kube-proxy 仅通过 iptables 或 ipvs 规则将数据包重定向到一个随机选择的后端 Pod，不再需要一个实际的代理服务器。这种模式也被称为 iptables 代理模式。如下图所示：</p>
<p><img data-src="../../../images/iptables%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="iptables代理模式" /></p>
<p>这两种模式的主要区别在于数据包是否传递给 kube-proxy、是否需要在用户空间进行处理，或者数据包是否仅在内核空间进行处理。这两种模式的性能有很大差异。</p>
<p>另一个区别是，userspace 代理模式使用轮询模式对连接进行负载均衡，而 iptables 代理模式随机选择 Pod，在客户端连接较少时可能无法平均分配流量。</p>
<h1 id="其他组件"><a class="markdownIt-Anchor" href="#其他组件"></a> 其他组件</h1>
<p>除了 Kubernetes 核心组件之外，还有许多第三方组件可以扩展和增强 Kubernetes 的功能。这些组件通常被称为“附加组件”或“扩展组件”，它们提供了各种功能，如网络、存储、监控、日志记录等。</p>
<p>以下是一些常见的第三方组件，可以根据需求选择和部署：</p>
<ol>
<li>容器网络接口（Container Networking Interface，CNI）：CNI 是一个规范，用于定义容器和宿主机之间的网络连接。它允许不同的网络插件与 Kubernetes 集成，并提供容器之间的网络通信。</li>
<li>存储插件：存储插件用于将外部存储系统与 Kubernetes 集群集成。这些插件可以提供持久化存储解决方案，如网络存储、分布式存储和块存储。</li>
<li>监控和日志组件：监控和日志组件用于收集、分析和可视化 Kubernetes 集群的监控数据和日志。一些常见的监控和日志工具包括 Prometheus、Grafana、Elasticsearch 和 Fluentd。</li>
<li>Ingress 控制器：Ingress 控制器是一个负载均衡器，用于将外部流量路由到 Kubernetes 集群内部的服务。它可以提供 HTTP 和 HTTPS 等应用层协议的路由功能。</li>
<li>安全组件：安全组件用于增强 Kubernetes 集群的安全性。它们可以提供认证、授权、身份管理和访问控制等功能，以保护集群中的资源和敏感数据。</li>
</ol>
<h2 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h2>
<p>集群中所有的 Pod 默认配置使用集群内部的 DNS 服务器。Pod 可以通过名称轻松查询集群内的服务，甚至是无头服务的 Pod IP 地址。</p>
<p>DNS 服务的 Pod 通过 kube-dns 服务对外暴露，DNS 服务的 IP 地址在集群中每个容器的 <code>/etc/resolv.conf</code> 文件中都有定义。</p>
<p>kube-dns Pod 利用 API 服务器的监控机制来订阅 Service 和 Endpoint 的变动，以及 DNS 记录的变更，从而确保客户端始终获取到最新的 DNS 信息。</p>
<h2 id="ingress-控制器"><a class="markdownIt-Anchor" href="#ingress-控制器"></a> Ingress 控制器</h2>
<p>Ingress 控制器运行一个反向代理服务器，类似于 Nginx。它根据集群中定义的 Ingress、Service 和 Endpoint 资源来配置该控制器。因此，需要订阅这些资源，并在发生变化时更新代理服务器的配置。</p>
<p>尽管 Ingress 资源的定义指向一个 Service，但是 Ingress 控制器会直接将流量转发到服务的 Pod，而不经过服务的 IP。当外部客户端通过 Ingress 控制器连接时，会保存客户端的 IP，而 Service 本身无法实现这一点。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>0.基本知识</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 储存资源</title>
    <url>/1711004813/</url>
    <content><![CDATA[<h1 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义</h1>
<p>Pod 内的进程共享计算资源，但不包括磁盘。Kubernetes 通过定义存储卷来满足磁盘共享的需求，常用于扩展容器的存储空间并为其提供持久存储能力。</p>
<p>存储卷分为临时卷、本地卷和网络卷。临时卷和本地卷都位于工作节点，一旦 Pod 被调度到其他工作节点，这些类型的存储卷将无法访问。因此，临时卷和本地卷通常用于数据缓存，而持久化的数据需要放置于持久卷上。</p>
<p>卷是 Pod 的一个组成部分，因此像容器一样在 Pod 的配置中进行定义。它们不是独立的 Kubernetes 对象，不能单独创建或删除。Pod 中的所有容器都可以使用卷，但必须先将其挂载到容器中。</p>
<p>有多种可用的卷可以使用，单个容器可以同时使用不同类型的多个卷。可用的卷类型如下：</p>
<ul>
<li>
<p>emptyDir：用于存储临时数据的简单空目录。</p>
</li>
<li>
<p>hostPath：用于将工作节点文件系统中的目录挂载到 Pod 中。</p>
</li>
<li>
<p>gitRepo：通过检出 Git 仓库的内容来初始化的卷。</p>
</li>
<li>
<p>nfs：挂载到 Pod 中的 NFS 共享卷。</p>
</li>
<li>
<p>gcePersistentDisk、awsElasticBlockStore、azureDisk：用于挂载云服务提供的特定存储类型。</p>
</li>
<li>
<p>ConfigMap、Secret、DownwardAPI：用于将 Kubernetes 部分资源和集群信息公开给 Pod 的特殊类型卷。</p>
</li>
<li>
<p>PersistentVolumeClaim：一种使用预配置或动态配置的持久存储类型。</p>
</li>
<li>
<p>cinder、Cephas、iscsi、flocker、glusterfs、quobyte、rbd、flexVolume、vsphere-Volume、photoPersistentDisk：用于挂载其他类型的网络存储。</p>
</li>
</ul>
<h1 id="emptydir-卷"><a class="markdownIt-Anchor" href="#emptydir-卷"></a> emptyDir 卷</h1>
<p>emptyDir 卷是一个空目录，Pod 内的程序可以写入所需的任何文件。当删除 Pod 时，卷的内容会丢失。它主要用于在 Pod 中运行的容器之间临时共享文件。</p>
<h2 id="使用-emptydir-卷"><a class="markdownIt-Anchor" href="#使用-emptydir-卷"></a> 使用 emptyDir 卷</h2>
<p>下面使用 Nginx 作为服务器和 <code>fortune</code> 命令来生成 HTML 内容。<code>fortune</code> 命令每次运行都会输出一个随机引用。我们可以创建一个脚本，每 10 秒运行一次，并将其储存在 <code>index.html</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> fortune-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: fortune
spec:
  containers:
  - image: luksa/fortune
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: <span class="token boolean">true</span>
    ports:
    - containerPort: <span class="token number">80</span>
      protocol: TCP
  volumes:
  - name: html
    emptyDir: <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                                 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> fortune-pod.yaml 
pod/fortune created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个容器 <code>html-generator</code> 用于将生成的 HTML 文件保存到 <code>/var/htdocs</code> 目录中，并将卷 <code>html</code> 挂载到该目录。</p>
<p>第二个容器 <code>web-server</code> 用于运行 Web 服务，并将卷 <code>html</code> 挂载到 <code>/usr/share/nginx/html</code> 目录中，设置为只读权限。</p>
<p>最后，我们定义了一个名为 <code>html</code> 的独立 emptyDir 卷，供上述容器挂载使用。</p>
<h2 id="查看-pod-状态"><a class="markdownIt-Anchor" href="#查看-pod-状态"></a> 查看 Pod 状态</h2>
<p>为了测试访问，我们可以直接设置端口转发来访问 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl port-forward fortune <span class="token number">8080</span>:80
Forwarding from <span class="token number">127.0</span>.0.1:8080 -<span class="token operator">></span> <span class="token number">80</span>
Forwarding from <span class="token punctuation">[</span>::1<span class="token punctuation">]</span>:8080 -<span class="token operator">></span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在新终端中，通过 <code>curl</code> 命令来访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8080
Few things are harder to put up with than the annoyance of a good example.
                -- <span class="token string">"Mark Twain, Pudd'nhead Wilson's Calendar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="指定储存介质"><a class="markdownIt-Anchor" href="#指定储存介质"></a> 指定储存介质</h2>
<p>可以将 emptyDir 卷创建在 tmpfs，也就是内存中。空间受限于内存大小，但性能非常好。需要同时设置 sizeLimit 来限制使用的空间大小。</p>
<p>下面创建一个 Pod 进行测试，包含 Tomcat 和 Busybox 两个容器。Tomcat 向挂载的卷中写入日志，而 Busybox 读取日志内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> empty-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: volume-pod
  namespace: default
spec:
  containers:
  - name: tomcat
    image: tomcat
    ports:
    - containerPort: <span class="token number">8080</span>
    volumeMounts:
    - name: app-logs
      mountPath: /usr/local/tomcat/logs
  - name: busybox
    image: busybox
    command: <span class="token punctuation">[</span><span class="token string">"sh"</span>, <span class="token string">"-c"</span>, <span class="token string">"tail -f /logs/catalina*.log"</span><span class="token punctuation">]</span>
    volumeMounts:
    - name: app-logs
      mountPath: /logs
  volumes:
  - name: app-logs
    emptyDir:
      medium: Memory
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> empty-pod.yaml 
pod/volume-pod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以下命令查看日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl logs volume-pod <span class="token parameter variable">-c</span> busybox
<span class="token number">14</span>-Mar-2022 03:49:09.120 INFO <span class="token punctuation">[</span>main<span class="token punctuation">]</span> org.apache.catalina.startup.VersionLoggerListener.log Command line argument: <span class="token parameter variable">-Djava.io.tmpdir</span><span class="token operator">=</span>/usr/local/tomcat/temp
<span class="token number">14</span>-Mar-2022 03:49:09.128 INFO <span class="token punctuation">[</span>main<span class="token punctuation">]</span> org.apache.catalina.core.AprLifecycleListener.lifecycleEvent Loaded Apache Tomcat Native library <span class="token punctuation">[</span><span class="token number">1.2</span>.31<span class="token punctuation">]</span> using APR version <span class="token punctuation">[</span><span class="token number">1.7</span>.0<span class="token punctuation">]</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="gitrepo-卷"><a class="markdownIt-Anchor" href="#gitrepo-卷"></a> gitRepo 卷</h1>
<p>gitRepo 卷基本上也是一个 emptyDir 卷，通过在 Pod 启动时克隆 Git 仓库来填充数据。创建完成后，gitRepo 卷不会随着远程 Git 仓库的更新而更新。如果使用 ReplicationSet 进行管理，在删除 Pod 后会创建新的 Pod，再次触发 git clone 可以获取最新的文件。</p>
<p>一个典型的应用场景是存放网站的静态 HTML 文件，并创建一个包含 Web 服务器容器和 gitRepo 卷的 Pod。当 Pod 创建时，会拉取网站的最新版本并启动 Web 服务。不过，每次有新版本时需要删除 Pod 才能更新。</p>
<h2 id="使用-gitrepo-卷"><a class="markdownIt-Anchor" href="#使用-gitrepo-卷"></a> 使用 gitRepo 卷</h2>
<p>下面是一个使用 Nginx 容器和 gitRepo 卷的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> gitrepo-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-volume-pod
spec:
  containers:
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: <span class="token boolean">true</span>
    ports:
    - containerPort: <span class="token number">80</span>
      protocol: TCP
  volumes:
  - name: html
    gitRepo:
      repository: https://github.com/luksa/kubia-wesite-example.git
      revision: master
      directory: <span class="token builtin class-name">.</span>
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> gitrepo-pod.yaml 
pod/gitrepo-volume-pod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述示例中，gitRepo 卷需要指定 <code>revision</code> 来指定 master 分支，并将仓库克隆到根目录。也可以指定其他文件夹名称。</p>
<h2 id="私有仓库"><a class="markdownIt-Anchor" href="#私有仓库"></a> 私有仓库</h2>
<p>gitRepo 卷无法直接克隆私有 Git 仓库，例如需要账号密码验证的 GitLab。如果需要添加支持，可以在 Pod 中添加额外的 sidecar 容器，例如 gitsync sidecar，用于对主容器进行操作，以同步仓库的版本等。</p>
<p>需要注意的是，gitRepo 卷现已被官方废弃，官方建议使用初始化容器将仓库中的数据复制到 emptyDir 储存卷上。</p>
<h1 id="configmap-资源"><a class="markdownIt-Anchor" href="#configmap-资源"></a> ConfigMap 资源</h1>
<p>应用配置的关键在于能够在多个环境中区分配置选项，将配置从应用程序源码中分离。Kubernetes 允许将配置选项分离到单独的资源对象 ConfigMap 中。ConfigMap 本质上是一个键值对映射，值可以是字符串，也可以是完整的配置文件。示例图如下所示：</p>
<p><img data-src="../../../images/ConfigMap%E8%83%BD%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9.jpg" alt="ConfigMap能包含的内容" /></p>
<p>应用程序无需直接读取 ConfigMap，而是通过环境变量或卷文件的形式将映射的内容传递给容器。在命令行参数的定义中，可以使用变量语法引用环境变量，从而将 ConfigMap 的条目作为命令行参数传递给进程。</p>
<p>Pod 通过名称引用 ConfigMap，因此可以在多个环境中使用相同的 Pod 定义来描述，并根据不同的环境使用不同的配置值。</p>
<h2 id="指定容器环境变量"><a class="markdownIt-Anchor" href="#指定容器环境变量"></a> 指定容器环境变量</h2>
<p>如果 Docker 镜像有自定义参数可以配置，可以按照下面的 Dockerfile 进行设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">trap</span> <span class="token string">"exit"</span> SIGINT
<span class="token builtin class-name">echo</span> Fortune <span class="token function">sleep</span> every <span class="token variable">$INTERVAL</span> seconds
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /bar/htdocs
<span class="token keyword">while</span> <span class="token builtin class-name">:</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span> Writing fortune to /var/htdocs/index.html
  /usr/games/fortune <span class="token operator">></span> /var/htdocs/index.html
  <span class="token function">sleep</span> <span class="token variable">$INTERVAL</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>想要在 Kubernetes 中设置自定义参数，可以在 <code>spec.containers.env</code> 中声明：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> fortune
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> INTERVAL
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"30"</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> html<span class="token punctuation">-</span>generator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>$(VAR)</code> 语法在环境变量值中引用其他环境变量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> fortune
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> FIRST_VAR
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"foobar"</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SECOND_VAR
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"$(FIRST_VAR)2000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建-configmap"><a class="markdownIt-Anchor" href="#创建-configmap"></a> 创建 ConfigMap</h2>
<p>可以直接通过命令行来创建一个最简单的 ConfigMap：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create configmap fortune-config --from-literal<span class="token operator">=</span>sleep-interval<span class="token operator">=</span><span class="token number">5</span>
configmap/fortune-config created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这条指令创建了名为 <code>fortune-config</code> 的 ConfigMap，仅包含单映射条目 <code>sleep-interval=5</code>。可以通过添加多个 <code>--from-literal</code> 参数创建包含多条目的 ConfigMap：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create configmap fortune-config --from-literal<span class="token operator">=</span>one<span class="token operator">=</span><span class="token number">1</span> --from-literal<span class="token operator">=</span>two<span class="token operator">=</span><span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过观察 YAML 格式的定义描述，可以自定义配置文件，然后通过 <code>create -f</code> 来创建 ConfigMap。</p>
<p>可以直接从硬盘中读取文件，并将文件内容单独存储为 ConfigMap 中的值。例如，将当前目录下的 <code>my.config</code> 文件内容存为键名为 <code>devconfig</code> 的值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ kubectl create configmap my-config --from-file<span class="token operator">=</span>devconfig<span class="token operator">=</span>my.config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过多次使用 <code>--from-file</code> 参数可以增加多个文件条目。另外，还可以使用 <code>--from-file</code> 指定目录，<code>kubectl</code> 会为文件夹中的每个文件单独创建条目，键名为文件名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create configmap my-config-dir --from-file<span class="token operator">=</span>k8s
configmap/my-config-dir created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ConfigMap 可以混合使用多种类型的配置，例如一个 <code>my-config</code> 同时包含键值对和文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create configmap my-config --from-file<span class="token operator">=</span>foo.json --from-file<span class="token operator">=</span>bar<span class="token operator">=</span>foobar.conf --from-file<span class="token operator">=</span>config-opts/ --from-literal<span class="token operator">=</span>some<span class="token operator">=</span>thing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="传递-configmap"><a class="markdownIt-Anchor" href="#传递-configmap"></a> 传递 ConfigMap</h2>
<p>将值传递给 Pod 中的容器有三种方式。如果引用的 ConfigMap 不存在，容器会启动失败。也可以设置 <code>optional: true</code> 对引用进行可选设置。</p>
<ul>
<li>
<p>通过环境变量传递键值</p>
<p>需要在 <code>spec.containers.env.valueFrom</code> 字段中指定：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> fortune
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> INTERVAL
      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>
        <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>
          <span class="token key atrule">name</span><span class="token punctuation">:</span> fortune<span class="token punctuation">-</span>config
          <span class="token key atrule">key</span><span class="token punctuation">:</span> sleep<span class="token punctuation">-</span>interval<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里传递了一个环境变量 <code>INTERVAL</code>，值取自 <code>fortune-config</code> 中键 <code>sleep-interval</code> 的值，然后由容器内的进程读取。</p>
</li>
<li>
<p>传递整个 ConfigMap 中的键值</p>
<p>在 <code>spec.containers</code> 中加入 <code>envFrom</code> 字段来传递整个 ConfigMap 中的键值对：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> fortune
    <span class="token key atrule">envFrom</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">prefix</span><span class="token punctuation">:</span> CONFIG_
      <span class="token key atrule">configMapRef</span><span class="token punctuation">:</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>cofig<span class="token punctuation">-</span>map<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面设置了所有导入的环境变量包含前缀 <code>CONFIG_</code>，若不设置前缀，环境变量的名称与 ConfigMap 中的键名相同。若键名不合法时不会自动转换。</p>
</li>
<li>
<p>传递 ConfigMap 条目作为命令行参数</p>
<p>在字段 <code>spec.containers.args</code> 中无法直接引用 ConfigMap 的条目，但可以利用 ConfigMap 条目初始化某个环境变量，然后再在参数字段中引用该变量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> fortune
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> INTERVAL
      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>
        <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>
          <span class="token key atrule">name</span><span class="token punctuation">:</span> fortune<span class="token punctuation">-</span>config
          <span class="token key atrule">key</span><span class="token punctuation">:</span> sleep<span class="token punctuation">-</span>interval
    <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"$(INTERVAL)"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="使用-configmap-卷"><a class="markdownIt-Anchor" href="#使用-configmap-卷"></a> 使用 ConfigMap 卷</h2>
<p>由于 ConfigMap 中可以包含完整的配置文件内容，想要将其暴露给容器时可以借助 ConfigMap 卷。ConfigMap 卷会将 ConfigMap 中的每个条目暴露为一个文件，运行在容器中的进程通过读取文件内容获得对应的条目值。</p>
<p>例如，将目录中的 Nginx 配置文件和 <code>interval</code> 文件一起创建名为 <code>fortune-config</code> 的 ConfigMap：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master configmap-files<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"25"</span> <span class="token operator">></span> interval
<span class="token punctuation">[</span>root@server4-master configmap-files<span class="token punctuation">]</span>$ <span class="token function">vi</span> advertise-task.iot.com.conf 
server <span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    server_name advertise-task.iot.com<span class="token punctuation">;</span>
    location / <span class="token punctuation">&#123;</span>
        proxy_pass http://advertise-task.iot.com.dev<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4-master configmap-files<span class="token punctuation">]</span>$ kubectl create configmap fortune-config --from-file<span class="token operator">=</span><span class="token punctuation">..</span>/configmap-files/
configmap/fortune-config created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get configmaps fortune-config <span class="token parameter variable">-o</span> yaml
apiVersion: v1
data:
  interval: <span class="token operator">|</span>
    <span class="token number">25</span>
  advertise-task.iot.com.conf: <span class="token operator">|</span>
    server <span class="token punctuation">&#123;</span>
        listen <span class="token number">80</span><span class="token punctuation">;</span>
        server_name advertise-task.iot.com<span class="token punctuation">;</span>
        location / <span class="token punctuation">&#123;</span>
            proxy_pass http://advertise-task.iot.com.dev<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
kind: ConfigMap
metadata:
  creationTimestamp: <span class="token string">"2022-03-15T14:01:15Z"</span>
  name: fortune-config
  namespace: default
  resourceVersion: <span class="token string">"580367"</span>
  uid: 9a4c9cb4-c2d2-424c-9d57-ac3fe1851260<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 ConfigMap 卷内的文件挂载到 <code>/etc/nginx/conf.d/</code> 目录下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token punctuation">-</span>server
	<span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config
	  <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/nginx/conf.d
	  <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config
	  <span class="token key atrule">configMap</span><span class="token punctuation">:</span>
	    <span class="token key atrule">name</span><span class="token punctuation">:</span> fortune<span class="token punctuation">-</span>config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以单独指定需要挂载的 ConfigMap 卷内文件。这里将 ConfigMap 卷内的配置文件 <code>advertise-task.iot.com.conf</code> 重命名为 <code>at.conf</code> 并挂载到指定目录下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config
	  <span class="token key atrule">configMap</span><span class="token punctuation">:</span>
	    <span class="token key atrule">name</span><span class="token punctuation">:</span> fortune<span class="token punctuation">-</span>config
	    <span class="token key atrule">items</span><span class="token punctuation">:</span>
	    <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> advertise<span class="token punctuation">-</span>task.iot.com.conf
	      <span class="token key atrule">path</span><span class="token punctuation">:</span> at.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用上述方法挂载卷时，容器内原有的同名目录会被隐藏，被挂载的目录会替代之。如果想要单独挂载文件而不是目录，需要在 <code>spec.containers.volumeMounts</code> 下面加入 <code>subPath</code> 字段：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token punctuation">-</span>server
	<span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config
	  <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/nginx/conf.d/advertise<span class="token punctuation">-</span>task.iot.com.conf
	  <span class="token key atrule">subPath</span><span class="token punctuation">:</span> advertise<span class="token punctuation">-</span>task.iot.com.conf
	  <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ConfigMap 卷中所有文件的默认权限是 644，可以在 <code>spec.volumes.configMap</code> 中加入 <code>defaultMode</code> 来改变默认权限：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config
	  <span class="token key atrule">configMap</span><span class="token punctuation">:</span>
	    <span class="token key atrule">name</span><span class="token punctuation">:</span> fortune<span class="token punctuation">-</span>config
	    <span class="token key atrule">defaultMod</span><span class="token punctuation">:</span> <span class="token string">"6600"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 ConfigMap 作为卷挂载可以实现配置的热更新效果，无需重启或重建 Pod。在修改了 ConfigMap 的配置后，可以通过 <code>kubectl exec</code> 命令来手动载入更新的配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl edit configmap fortune-config
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> fortune <span class="token parameter variable">-c</span> web-server -- nginx <span class="token parameter variable">-s</span> reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但如果挂载的单个文件，ConfigMap 更新后对应的文件不会被更新。</p>
<h1 id="secret-资源"><a class="markdownIt-Anchor" href="#secret-资源"></a> Secret 资源</h1>
<p>Secret 的结构和使用方法与 ConfigMap 相同，也是键值对的映射，主要用来保存敏感信息，例如账号和证书。</p>
<p>Kubernetes 通过将 Secret 分发到 Pod 所在的节点来保障安全性，Secret 只会存储在节点的内存中，从而无法被窃取。</p>
<h2 id="默认令牌"><a class="markdownIt-Anchor" href="#默认令牌"></a> 默认令牌</h2>
<p>在 Kubernetes 安装完成后，会生成一个以 default-token 开头的默认 Secret，它会挂载到所有容器中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get secrets 
NAME                  TYPE                                  DATA   AGE
default-token-vqjsw   kubernetes.io/service-account-token   <span class="token number">3</span>      132d
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe secrets default-token-vqjsw
Name:         default-token-vqjsw
Namespace:    default
Labels:       <span class="token operator">&lt;</span>none<span class="token operator">></span>
Annotations:  kubernetes.io/service-account.name: default
              kubernetes.io/service-account.uid: ae0b90b8-1323-42a2-990b-a18d4bfb7da8

Type:  kubernetes.io/service-account-token

Data
<span class="token operator">==</span><span class="token operator">==</span>
ca.crt:     <span class="token number">1099</span> bytes
namespace:  <span class="token number">7</span> bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IlZDd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认的 Secret 包含三个条目：ca.crt、namespace 和 token，其中包含了访问 API 服务器所需的安全信息。</p>
<p>可以在 Pod 信息的 Mount 栏中看到 Secret 卷挂载的位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po dnsutils 
Containers:
  dnsutils:
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-5ghsj <span class="token punctuation">(</span>ro<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认的挂载行为可以通过在 Pod 定义中设置 <code>automountServiceAccountToken</code> 字段为 <code>false</code> 来关闭。</p>
<h2 id="创建-secret"><a class="markdownIt-Anchor" href="#创建-secret"></a> 创建 Secret</h2>
<p>使用命令行创建一个名为 ngx-https 的 Secret，用于存储 Nginx 所需的私钥和证书：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create secret generic ngx-https --from-file<span class="token operator">=</span>https.cert --from-file<span class="token operator">=</span>https.key --from-file<span class="token operator">=</span>foo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Secret 条目的内容会以 Base64 格式编码，而 ConfigMap 则直接以纯文本形式显示。因此，Secret 还可以用于存储最大为 1MB 的二进制数据。</p>
<p>通过 <code>stringData</code> 字段设置条目的纯文本值，该值不会被编码为 Base64：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> secret-test.yaml
apiVersion: v1
kind: Secret
stringData:
  foo: ymfyc
data:
  https.cert: Ls-3lcc
  https.key: Lsv9elx
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> secret-test.yaml <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，<code>stringData</code> 字段只可写入。</p>
<h2 id="使用-secret"><a class="markdownIt-Anchor" href="#使用-secret"></a> 使用 Secret</h2>
<p>将 Secret 通过 Secret 卷暴露给容器后，Secret 条目的值将解码为实际形式（纯文本或二进制），并写入相应的文件中。同样，通过环境变量暴露 Secret 条目也是如此。在这两种情况下，应用程序无需手动解码，可以直接读取文件内容或查找环境变量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
	<span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> certs
	  <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/nginx/certs/
	  <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> certs
	  <span class="token key atrule">secret</span><span class="token punctuation">:</span>
	    <span class="token key atrule">secretame</span><span class="token punctuation">:</span> ngx<span class="token punctuation">-</span>https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与 ConfigMap 卷相同，Secret 卷同样支持使用 <code>defaultModes</code> 属性指定卷中文件的默认权限。</p>
<p>Secret 条目也可以暴露为环境变量：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> INTERVAL
      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>
	    <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>
		  <span class="token key atrule">name</span><span class="token punctuation">:</span> ngx<span class="token punctuation">-</span>https
		  <span class="token key atrule">key</span><span class="token punctuation">:</span> foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以创建一个类型为 <code>docker-registry</code> 的 Secret，名称为 <code>dockerhubsecret</code>，其中包含 Docker 镜像仓库证书，并在拉取镜像时进行引用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ kubectl create secret docker-registry dockerhubsecret <span class="token punctuation">\</span>
 --docker-username<span class="token operator">=</span>myusername --docker-password<span class="token operator">=</span>mypasswd <span class="token punctuation">\</span>
 --docker-email<span class="token operator">=</span>my@email.com
<span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">vi</span> dockerhub.yaml
apiVersion: v1
kind: Pod
metadata:
  name: privae-pod
spec:
  imagePullSecrets:
  - name: dockerhubsecret
  containers:
  - image: assassing/av:v1
    name: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="底层持久化储存"><a class="markdownIt-Anchor" href="#底层持久化储存"></a> 底层持久化储存</h1>
<p>在 Kubernetes 中，底层持久化存储是一个重要的组件，用于存储应用程序的持久化数据，并确保数据的安全性和持久性。</p>
<h2 id="hostpath-卷"><a class="markdownIt-Anchor" href="#hostpath-卷"></a> hostPath 卷</h2>
<p>hostPath 卷用于指向节点文件系统中的特定文件或目录。由于文件存储在特定节点的文件系统中，因此当 Pod 被重新调度到另一个节点时，可能无法访问数据。在 Kubernetes 的系统级服务 Pod 中，通常使用 hostPath 卷来访问节点的日志、配置文件或 CA 证书，但不推荐将其用于存储数据：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"hostpath"</span>
  <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/data"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，还可以使用 <code>type</code> 参数来指定卷的类型：</p>
<ul>
<li><code>DirectoryOrCreate</code>：如果指定的路径不存在，则自动创建一个权限为 0755 的空目录，所有者为 kubelet。</li>
<li><code>Directory</code>：必须存在的目录路径。</li>
<li><code>FileOrCreate</code>：如果指定的路径不存在，则自动创建一个权限为 0644 的空文件，所有者为 kubelet。</li>
<li><code>File</code>：必须存在的文件路径。</li>
<li><code>Socket</code>：必须存在的 Socket 文件路径。</li>
<li><code>CharDevice</code>：必须存在的字符设备文件路径。</li>
<li><code>BlockDevice</code>：必须存在的块设备文件路径。</li>
</ul>
<p>根据实际需求选择合适的 <code>type</code> 参数来配置 hostPath 卷。请注意，使用 hostPath 卷时需要谨慎，确保数据的可靠性和安全性。</p>
<h2 id="gce-持久储存"><a class="markdownIt-Anchor" href="#gce-持久储存"></a> GCE 持久储存</h2>
<p>如果集群运行在 Google Kubernetes Engine 中，你可以选择使用 GCE 持久化磁盘作为底层存储机制。首先，在同一区域的 Kubernetes 集群中创建一个 GCE 持久化磁盘，例如在 “europe-west” 区域，然后创建一个带有 GCE 持久化磁盘卷的 Pod：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> mongo
    <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">-</span>data
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data.db
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">27017</span>
      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">-</span>data
    <span class="token key atrule">gcePersistentDisk</span><span class="token punctuation">:</span>
      <span class="token key atrule">pdName</span><span class="token punctuation">:</span> mongodb
      <span class="token key atrule">fsType</span><span class="token punctuation">:</span> ext4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>定义名称和文件系统类型为 ext4，接着向 mongodb 写入数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mongodb mongo
<span class="token punctuation">[</span>root@mongodb ~<span class="token punctuation">]</span>use mystore
<span class="token punctuation">[</span>root@mongodb ~<span class="token punctuation">]</span>db.foo.insert<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>name:<span class="token string">'foo'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@mongodb ~<span class="token punctuation">]</span>db.foo.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>重建 Pod 后读取上一个 Pod 保存的数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>kubectl delete pod mongodb
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>kubectl create <span class="token parameter variable">-f</span> mongodb.yaml
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mongodb mongo
<span class="token punctuation">[</span>root@mongodb ~<span class="token punctuation">]</span>use mystore
<span class="token punctuation">[</span>root@mongodb ~<span class="token punctuation">]</span>db.foo.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果数据仍然存在，则说明持久化成功。</p>
<h2 id="其他持久化储存卷"><a class="markdownIt-Anchor" href="#其他持久化储存卷"></a> 其他持久化储存卷</h2>
<p>根据不同的基础设施，可以选择使用不同类型的持久化存储卷。例如，在 Amazon 上可以使用 awsElasticBlockStore 卷，在 Microsoft Azure 上可以使用 azureFile 或 azureDisk 卷。下面是一个使用 AWS 的示例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">-</span>data
    <span class="token key atrule">awsElasticBlockStore</span><span class="token punctuation">:</span>
      <span class="token key atrule">volumeID</span><span class="token punctuation">:</span> mongodb
      <span class="token key atrule">fsType</span><span class="token punctuation">:</span> ext4
<span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 NFS 共享，只需要指定 NFS 服务器的 IP 地址和共享路径即可：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">-</span>data
    <span class="token key atrule">nfs</span><span class="token punctuation">:</span>
      <span class="token key atrule">server</span><span class="token punctuation">:</span> 1.2.3.4
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /some/path
<span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要了解每种卷类型所需的属性设置，可以查询 Kubernetes API 文档，或使用 <code>kubectl explain</code> 命令。</p>
<p>需要注意的是，将这些基础设施类型放在 Pod 的配置中意味着该 Pod 的设置与特定集群强耦合，这样无法在另一个 Pod 中重复使用相同的设置。因此，在设计和配置持久化存储时需要谨慎考虑。</p>
<h1 id="持久卷和持久卷声明"><a class="markdownIt-Anchor" href="#持久卷和持久卷声明"></a> 持久卷和持久卷声明</h1>
<p>在集群中为了使应用正常请求储存资源，同时避免处理基础设施细节，引入了两个新资源，分别是持久卷（PersistentVolume，PV）和持久卷声明（PersistentVolumeClaim，PVC）。</p>
<p>当集群用户需要在其 pod 中使用持久化储存时，首先创建持久卷声明清单，指定所需最低容量要求和访问模式，由 API 服务器分配持久卷并绑定到持久卷声明中。</p>
<p>持久卷声明可以当做 pod 中的一个卷来使用，其他用户不能使用相同的持久卷，除非先通过删除持久卷声明释放。</p>
<p>下图展示了 PV 和 PVC 的关系:</p>
<p><img data-src="../../../images/PV%E5%92%8CPVC.jpg" alt="PV和PVC" /></p>
<p>下面用 NFS 文件系统做示例。</p>
<h2 id="安装-nfs-文件系统"><a class="markdownIt-Anchor" href="#安装-nfs-文件系统"></a> 安装 NFS 文件系统</h2>
<p>在所有节点上进行安装 NFS 套件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> nfs-utils rpcbind <span class="token parameter variable">-y</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> nfs
Created symlink from /etc/systemd/system/multi-user.target.wants/nfs-server.service to /usr/lib/systemd/system/nfs-server.service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 NFS 服务器上启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> rpcbind<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>配置服务器上的共享目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /srv/pv
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> nfsnobody:nfsnobody /srv/pv
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">755</span> /srv/pv
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"/srv/pv *(rw,no_root_squash,sync)"</span><span class="token operator">></span>/etc/exports
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-r</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ exportfs
/srv/pv         <span class="token operator">&lt;</span>world<span class="token operator">></span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ showmount <span class="token parameter variable">-e</span> <span class="token number">192.168</span>.2.204
Export list <span class="token keyword">for</span> <span class="token number">192.168</span>.2.204:
/srv/pv *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改最大同时连接用户数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"options sunrpc tcp_slot_table_entries=128"</span> <span class="token operator">>></span> /etc/modprobe.d/sunrpc.conf
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"options sunrpc tcp_max_slot_table_entries=128"</span> <span class="token operator">>></span>  /etc/modprobe.d/sunrpc.conf
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">sysctl</span> <span class="token parameter variable">-w</span> <span class="token assign-left variable">sunrpc.tcp_slot_table_entries</span><span class="token operator">=</span><span class="token number">128</span>
sunrpc.tcp_slot_table_entries <span class="token operator">=</span> <span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建新的挂载点：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /srv/pv/pv001 /srv/pv/pv002
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"/srv/pv/pv001 *(rw,no_root_squash,sync)"</span><span class="token operator">>></span>/etc/exports
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"/srv/pv/pv002 *(rw,no_root_squash,sync)"</span><span class="token operator">>></span>/etc/exports
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-r</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ systemctl restart rpcbind <span class="token operator">&amp;&amp;</span> systemctl restart nfs
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ showmount <span class="token parameter variable">-e</span> <span class="token number">192.168</span>.2.204
Export list <span class="token keyword">for</span> <span class="token number">192.168</span>.2.204:
/srv/pv/pv002 *
/srv/pv/pv001 *
/srv/pv       *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建持久卷"><a class="markdownIt-Anchor" href="#创建持久卷"></a> 创建持久卷</h2>
<p>配置一个 1 GB 大小的持久卷，供 MongoDB 使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> mongodb-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mongodb-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteOnce
  - ReadOnlyMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /srv/pv
    server: <span class="token number">192.168</span>.2.204
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> mongodb-pv.yaml 
persistentvolume/mongodb-pv created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">pv</span>
NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
mongodb-pv   1Gi        RWO,ROX        Retain           Available                                   4s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>持久卷不属于任何命名空间，它和节点一样是集群层面的资源。</p>
<h2 id="创建持久卷声明"><a class="markdownIt-Anchor" href="#创建持久卷声明"></a> 创建持久卷声明</h2>
<p>如果 Pod 需要使用之前创建的持久卷，需要创建一个持久卷声明：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> mongodb-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
spec:
  resources:
    requests:
      storage: 1Gi
  accessModes:
  - ReadWriteOnce
  storageClassName: <span class="token string">""</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> mongodb-pvc.yaml
persistentvolumeclaim/mongodb-pvc created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pvc
NAME          STATUS   VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mongodb-pvc   Bound    mongodb-pv   1Gi        RWO,ROX                       4s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过查看 PVC（持久卷声明）状态，可以确认 PVC 已经与相应的 PV（持久卷）绑定。其中访问模式的简写含义如下：</p>
<ul>
<li>
<p>RWO（ReadWriteOnce）：仅允许单个节点挂载读写。</p>
</li>
<li>
<p>ROX（ReadOnlyMany）：允许多个节点挂载只读。</p>
</li>
<li>
<p>RWX（ReadWriteMany）：允许多个节点挂载读写。</p>
</li>
</ul>
<p>这里的节点指的是 Kubernetes 节点，而不是 Pod 的数量。</p>
<p>再次查看 PV 的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">pv</span>
NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                 STORAGECLASS   REASON   AGE
mongodb-pv   1Gi        RWO,ROX        Retain           Bound    default/mongodb-pvc                           12m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到它已经被绑定到 PVC 的声明中。其中 CLAIM 中的 default 表示默认命名空间。虽然持久卷属于整个集群，但持久卷声明只能在特定的命名空间内创建。因此，持久卷和持久卷声明只能由同一命名空间内的 Pod 创建和使用。还可以使用选择器来为 PV 应用标签选择器。</p>
<h2 id="使用持久卷声明"><a class="markdownIt-Anchor" href="#使用持久卷声明"></a> 使用持久卷声明</h2>
<p>在 Pod 中使用持久卷时，需要在 Pod 的卷中引用 PVC 的名称：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> mongodb-pod.yaml
apiVersion: v1
kind: Service
metadata:
  name: mongodb
spec:
  type: NodePort
  ports:
  - port: <span class="token number">27017</span>
    targetPort: <span class="token number">27017</span>
    nodePort: <span class="token number">30000</span>
  selector:
    app: kubia
---
apiVersion: v1
kind: Pod
metadata:
  name: mongodb
  labels:
    app: mongo
spec:
  containers:
  - image: mongo
    name: mongodb
    volumeMounts:
    - name: mongodb-data
      mountPath: /data/db
    ports:
    - containerPort: <span class="token number">27017</span>
      protocol: TCP
  volumes:
  - name: mongodb-data
    persistentVolumeClaim:
      claimName: mongodb-pvc
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> mongodb-pod.yaml 
pod/mongodb created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，虽然 PV 是全局资源，但 PVC 属于特定命名空间，只有同一命名空间内的 Pod 才能调用。</p>
<h2 id="删除持久卷"><a class="markdownIt-Anchor" href="#删除持久卷"></a> 删除持久卷</h2>
<p>在持久卷正在被使用时，不能直接删除它，需要先删除使用该持久卷的 Pod 和 PVC。持久卷的空间释放处理机制有三种：</p>
<ul>
<li>
<p>Retain（保留）</p>
<p>删除 PV 后，根据设置的释放规则（Retain），硬盘中的文件仍然存在。重新创建 PV、PVC 和 Pod 后，文件内容和上一次运行时一样。使用 Retain 手动回收策略只能通过删除和重建持久卷来恢复可用状态。</p>
</li>
<li>
<p>Recycle（回收）</p>
<p>删除 PVC 后，会删除卷的内容，并使卷可用于再次声明。</p>
</li>
<li>
<p>Delete（删除）</p>
<p>删除底层存储。</p>
</li>
</ul>
<h2 id="动态化持久卷"><a class="markdownIt-Anchor" href="#动态化持久卷"></a> 动态化持久卷</h2>
<p>在 Kubernetes 中，可以通过创建持久卷配置并定义一个或多个 StorageClass 对象，实现每次通过持久卷声明请求时自动创建一个新的持久卷。获取动态持久卷的步骤如下图所示：</p>
<p><img data-src="../../../images/%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E6%8C%81%E4%B9%85%E5%8D%B7.jpg" alt="获取动态持久卷" /></p>
<p>不同的后端存储需要不同的置备程序（provisioner）。以 NFS 文件系统为例，首先需要部署 nfs-client：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master html<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/root/3/html *(rw,sync,no_root_squash)"</span> <span class="token operator">>></span> /etc/exports
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> nfs-dp.yaml
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: <span class="token number">1</span>
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccount: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: jmgao1983/nfs-client-provisioner
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: mynfs
            - name: NFS_SERVER
              value: <span class="token number">192.168</span>.2.113
            - name: NFS_PATH
              value: /srv/pv
      volumes:
        - name: nfs-client-root
          nfs:
            server: <span class="token number">192.168</span>.2.113
            path: /srv/pv
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> nfs-dp.yaml
deployment.extensions/nfs-provisioner created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get deployment
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
nfs-provisioner   <span class="token number">1</span>/1     <span class="token number">1</span>            <span class="token number">1</span>           29s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后创建 StorageClass 资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> mongodb-pv-sc.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: mynfs
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> mongodb-pv-sc.yaml
storageclass.storage.k8s.io/fast created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get sc
NAME   PROVISIONER   AGE
fast   mynfs         9s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一个 Pod 引用 StorageClass：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> nginx.yaml
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: <span class="token string">"nginx1"</span>
  replicas: <span class="token number">2</span>
  template:
    metadata:
      labels:
        app: nginx1
    spec:
      containers:
      - name: nginx1
        image: nginx:latest
        volumeMounts:
        - mountPath: <span class="token string">"/mnt"</span>
          name: <span class="token builtin class-name">test</span>
  volumeClaimTemplates:
  - metadata:
      name: <span class="token builtin class-name">test</span>
      annotations:
        volume.beta.kubernetes.io/storage-class: <span class="token string">"fast"</span>
    spec:
      accessModes: <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>
      resources:
        requests:
          storage: 1Gi
<span class="token string">"nginx.yaml"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 28L, 556C written
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> nginx.yaml
statefulset.apps/web created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 ServiceAccount 和角色：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> serviceaccount.yaml
serviceaccount/nfs-client-provisioner created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get sa
NAME                     SECRETS   AGE
default                  <span class="token number">1</span>         3d14h
nfs-client-provisioner   <span class="token number">1</span>         16s
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> clusterrole.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: nfs-provisioner-runner
rules:
  - apiGroups: <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"persistentvolumes"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"get"</span>, <span class="token string">"list"</span>, <span class="token string">"watch"</span>, <span class="token string">"create"</span>, <span class="token string">"delete"</span><span class="token punctuation">]</span>
  - apiGroups: <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"persistentvolumeclaims"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"get"</span>, <span class="token string">"list"</span>, <span class="token string">"watch"</span>, <span class="token string">"update"</span><span class="token punctuation">]</span>
  - apiGroups: <span class="token punctuation">[</span><span class="token string">"storage.k8s.io"</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"storageclasses"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"get"</span>, <span class="token string">"list"</span>, <span class="token string">"watch"</span><span class="token punctuation">]</span>
  - apiGroups: <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"events"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"watch"</span>, <span class="token string">"create"</span>, <span class="token string">"update"</span>, <span class="token string">"patch"</span><span class="token punctuation">]</span>
  - apiGroups: <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"services"</span>, <span class="token string">"endpoints"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">]</span>
  - apiGroups: <span class="token punctuation">[</span><span class="token string">"extensions"</span><span class="token punctuation">]</span>
    resources: <span class="token punctuation">[</span><span class="token string">"podsecuritypolicies"</span><span class="token punctuation">]</span>
    resourceNames: <span class="token punctuation">[</span><span class="token string">"nfs-provisioner"</span><span class="token punctuation">]</span>
    verbs: <span class="token punctuation">[</span><span class="token string">"use"</span><span class="token punctuation">]</span>
<span class="token string">"clusterrole.yaml"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 24L, 735C written
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> clusterrolebinding.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: run-nfs-provisioner
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
    namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-provisioner-runner
  apiGroup: rbac.authorization.k8s.io
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> clusterrole.yaml <span class="token parameter variable">-f</span> clusterrolebinding.yaml
clusterrole.rbac.authorization.k8s.io/nfs-provisioner-runner created
clusterrolebinding.rbac.authorization.k8s.io/run-nfs-provisioner created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，验证是否会自动创建新的 PV：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">pv</span> <span class="token operator">|</span><span class="token function">grep</span> web
pvc-d2423554-6b6e-4c65-9209-e739abe7c653   1Gi        RWO            Delete           Bound       default/test-web-0   fast                    2m28s
pvc-d430fa25-d4e4-4971-961f-80be40b8d9dc   1Gi        RWO            Delete           Bound       default/test-web-1   fast                    2m12s
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pvc <span class="token operator">|</span><span class="token function">grep</span> web
test-web-0   Bound    pvc-d2423554-6b6e-4c65-9209-e739abe7c653   1Gi        RWO            fast           13m
test-web-1   Bound    pvc-d430fa25-d4e4-4971-961f-80be40b8d9dc   1Gi        RWO            fast           2m36s
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get storageclass
NAME   PROVISIONER   AGE
fast   mynfs         19m
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pod <span class="token operator">|</span><span class="token function">grep</span> web
web-0                                    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          8m43s
web-1                                    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m29s

<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl scale statefulset web <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">3</span>
statefulset.apps/web scaled
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pod <span class="token operator">|</span><span class="token function">grep</span> web
web-0                                    <span class="token number">1</span>/1     Running             <span class="token number">0</span>          9m32s
web-1                                    <span class="token number">1</span>/1     Running             <span class="token number">0</span>          4m18s
web-2                                    <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          4s
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ ll /srv/pv/
total <span class="token number">0</span>
drwxrwxrwx <span class="token number">2</span> root root <span class="token number">6</span> Jul <span class="token number">22</span> <span class="token number">17</span>:34 default-test-web-0-pvc-d2423554-6b6e-4c65-9209-e739abe7c653
drwxrwxrwx <span class="token number">2</span> root root <span class="token number">6</span> Jul <span class="token number">22</span> <span class="token number">17</span>:35 default-test-web-1-pvc-d430fa25-d4e4-4971-961f-80be40b8d9dc
drwxrwxrwx <span class="token number">2</span> root root <span class="token number">6</span> Jul <span class="token number">22</span> <span class="token number">17</span>:39 default-test-web-2-pvc-ffc2b763-2dd8-4a5b-a565-86dd416eba36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 部署指南</title>
    <url>/1488965608/</url>
    <content><![CDATA[<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<p>通过 Minikube 快速体验 Kubernetes 系统。</p>
<h2 id="系统安装"><a class="markdownIt-Anchor" href="#系统安装"></a> 系统安装</h2>
<p>要部署 Kubenetes 系统，操作系统优先选择 CentOS 7 和 Ubuntu Server 版本。下面简单叙述系统安装流程。</p>
<h3 id="安装-centos"><a class="markdownIt-Anchor" href="#安装-centos"></a> 安装 CentOS</h3>
<p>先按照以下步骤来制作 CentOS 启动 U 盘：</p>
<ol>
<li>从<a href="http://mirrors.163.com/centos/7.9.2009/isos/x86_64/">网易镜像</a>站点下载 CentOS 7.9 x64 镜像文件 CentOS-7-x86_64-DVD-2009.iso。</li>
<li>从 <a href="https://github.com/FedoraQt/MediaWriter/releases">GitHub</a> 上下载 CentOS 启动 U 盘制作工具。下载完成后，安装并打开 Fedora Media Writer。</li>
<li>在 Fedora Media Writer 中，选择自定义镜像，并选择要写入的 U 盘。</li>
<li>使用 Fedora Media Writer 或其他 U 盘制作工具重新初始化 U 盘，使其成为 CentOS 启动 U 盘。</li>
</ol>
<p>再按照下面步骤进行 CentOS 的安装：</p>
<ol>
<li>将 U 盘插入主机，并启动进入 BIOS 设置界面。选择 UEFI 优先作为引导方式，并将 U 盘设置为第一引导设备。</li>
<li>在安装选择界面上选择 “Install CentOS 7”。</li>
<li>在安装信息摘要页面上，选择系统安装位置并进行硬盘分区：
<ul>
<li>选择手动配置分区，然后点击 “完成”。</li>
<li>点击 “自动创建挂载点”，然后删除 <code>/home</code> 和 <code>swap</code> 挂载点，并将剩余容量添加到根目录 <code>/</code> 下。</li>
<li>点击 “开始安装”。</li>
</ul>
</li>
<li>设置 root 密码，并等待安装完成。</li>
</ol>
<h3 id="安装-ubuntu"><a class="markdownIt-Anchor" href="#安装-ubuntu"></a> 安装 Ubuntu</h3>
<p>Ubuntu 有分为 Desktop 和 Server 两个版本，其中 Server 版本对硬件兼容性较好且更新支持时间长。如果硬件兼容性较差，或者需要图形界面，可以选择 Desktop 版本。</p>
<p>安装 Ubuntu 22.04.2 Server 的步骤：</p>
<ol>
<li>
<p>首先从官网下载 Ubuntu 22.04.2 Server 镜像，并使用 balenaEtcher 将其烧录到 U 盘。</p>
</li>
<li>
<p>在安装 Ubuntu Server 版本时，分区步骤非常复杂。如果不打算安装双系统，建议在 PE 环境下使用 DiskGenius 工具删除目标磁盘上的所有分区，然后再进行安装。</p>
</li>
<li>
<p>安装时大概率会碰到显卡驱动缺失问题，安装时或安装后可能会出现黑屏情况。可以在 grub 启动界面按下 <code>e</code> 键进行编辑，在 <code>Linux</code> 那行的末尾添加参数 <code>nomodeset</code>，然后按下 <code>Ctrl+X</code> 进行启动。</p>
</li>
<li>
<p>成功启动系统后，可以通过远程连接的方式修改 grub 配置。在 <code>/etc/default/grub</code> 文件中找到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 。在后面添加参数 <code>nomodeset</code>，然后更新 grub：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/default/grub
<span class="token function">sudo</span> <span class="token function">update-grub</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样，在启动系统后就不会再出现黑屏问题了。</p>
</li>
<li>
<p>在安装过程中，对于没有明确说明的选项，一律选择 <code>done</code> 或 <code>continue</code> 进入下一步。安装步骤如下：</p>
<ul>
<li>用 U 盘引导启动后，选择安装系统。</li>
<li>修改网卡的 IP 为静态，配置好 IP 地址。</li>
<li>将系统安装到整个磁盘上，并将挂载点 <code>/</code> 的大小调整为最大，文件系统格式选择 xfs。</li>
<li>配置用户名为 <code>assassing</code> ，主机名为 <code>ubuntu22</code>。</li>
<li>选择安装 SSH 服务。</li>
<li>等待安装完成后重新启动系统。</li>
</ul>
</li>
</ol>
<h3 id="虚拟机安装"><a class="markdownIt-Anchor" href="#虚拟机安装"></a> 虚拟机安装</h3>
<p>如果在虚拟机进行系统安装，可以省略掉制作启动 U 盘的步骤，其他步骤基本一致。</p>
<p>在网络配置方面，可以使用桥接模式，让虚拟机同宿主机在一个子网下，虚拟机无需特别设置即可访问外网和局域网内其他主机。但要注意的是，国内网络运营商在光猫上对连接的客户端数量有限制，连接超过 5 个设备会随机选取设备断网。如果同时开了很多台虚拟机，会出现部分虚拟机网络不正常，部分又正常的情况。</p>
<p>行之有效的解决方法有三个：</p>
<ul>
<li>找运营商上门技术支持，将限制去除。或者用自己的设备替代运营商送的光猫，作为拨号连接设备。这可能需要很多扯皮。</li>
<li>在光猫后接一个自己的路由器，客户端都接到路由器上。路由器和光猫不是一个网段，在光猫上只能看到路由器一个客户端，自然不存在限制。</li>
<li>不使用桥接网络模式，采用 NAT 模式来转发虚拟机流量。</li>
</ul>
<p>如果采用 NAT 网络模式，还需要对网络进行手动配置。下面以配置成 192.168.1.0.24 网段为例：</p>
<ul>
<li>将 NAT 网段设为 192.168.1.0/24，网关设为 192.168.1.1。</li>
<li>将 NAT 虚拟网卡（VM 中默认名 VMnet8）的 IP 设为 192.168.1.100，子网掩码 255.255.255.0，网关地址 192.168.1.1。</li>
<li>将能通外网的真实网卡属性配置成共享式，选择 NAT 虚拟网卡，这样虚拟机也能连通外网。</li>
<li>还可以配置 NAT 端口转发，例如将虚拟机的端口 22 转发到宿主机 10101 端口上，这样外部服务器可以用 ssh 通过宿主机 IP 地址加上 10101 端口连接虚拟机。</li>
</ul>
<h2 id="docker-基础"><a class="markdownIt-Anchor" href="#docker-基础"></a> Docker 基础</h2>
<p>首先需要在主机上安装好 Docker，然后创建一个简单的 Node.js 镜像并运行。</p>
<h3 id="安装-docker"><a class="markdownIt-Anchor" href="#安装-docker"></a> 安装 Docker</h3>
<p>安装 Docker-CE 20.10.10 版本参考步骤如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y yum-utils</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum makecache fast</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y docker-ce-20.10.10 docker-ce-cli-20.10.10 containerd.io docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Ubuntu 中安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span>
root@ubuntu22:~<span class="token comment"># add-apt-repository -y "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span>
root@ubuntu22:~<span class="token comment"># apt install -y docker-ce=5:20.10.17~3-0~ubuntu-jammy docker-ce-cli=5:20.10.17~3-0~ubuntu-jammy containerd.io docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="配置-docker"><a class="markdownIt-Anchor" href="#配置-docker"></a> 配置 Docker</h3>
<p>通过新增配置文件 <code>/etc/docker/daemon.json</code> 来设置 Docker 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /etc/docker/ ; tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span>
<span class="token punctuation">&#123;</span>
  <span class="token string">"exec-opts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
      <span class="token string">"native.cgroupdriver=systemd"</span>
      <span class="token punctuation">]</span>,
  <span class="token string">"log-driver"</span><span class="token builtin class-name">:</span> <span class="token string">"json-file"</span>,
  <span class="token string">"log-opts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"max-size"</span><span class="token builtin class-name">:</span> <span class="token string">"10m"</span>,
    <span class="token string">"max-file"</span><span class="token builtin class-name">:</span> <span class="token string">"3"</span>
  <span class="token punctuation">&#125;</span>,
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
      <span class="token string">"http://192.168.1.253:10007"</span>,
      <span class="token string">"https://m9f30s9x.mirror.aliyuncs.com"</span>
      <span class="token punctuation">]</span>,
  <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
      <span class="token string">"192.168.1.253:10007"</span>,
      <span class="token string">"192.168.1.253:10008"</span>
      <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置参数的解释如下：</p>
<ul>
<li><code>exec-opts</code>：设置 cgroup 驱动方式，与 Kubernetes 中 kubelet 使用的方式匹配。</li>
<li><code>log-driver</code>、<code>log-opts</code>：设置 Docker 容器的日志格式和限制，日志文件最大为 10M，最多保留 3 个文件，以避免容器日志过大占用硬盘空间。</li>
<li><code>registry-mirrors</code>：镜像仓库地址，使用阿里云仓库和 Nexus 私服仓库进行加速。</li>
<li><code>insecure-registries</code>：设置私有仓库地址，忽略对强制 HTTPS 认证的要求。</li>
</ul>
<h3 id="启动-docker"><a class="markdownIt-Anchor" href="#启动-docker"></a> 启动 Docker</h3>
<p>配置完毕后，启动并设置 Docker 自启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now docker</span>
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># docker -v</span>
Docker version <span class="token number">20.10</span>.10, build b485636
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># docker-compose -v</span>
<span class="token function">docker-compose</span> version <span class="token number">1.18</span>.0, build 8dd22a9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="创建-nodejs-应用"><a class="markdownIt-Anchor" href="#创建-nodejs-应用"></a> 创建 Node.js 应用</h3>
<p>创建一个简单的 Node.js Web 应用，并打包成容器镜像。应用会接受 HTTP 请求并响应应用运行的主机名。</p>
<p>新建一个 app.js 文件，内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># vi app.js</span>
const http <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const os <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console.log<span class="token punctuation">(</span><span class="token string">"Runing..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

var handle <span class="token operator">=</span> function<span class="token punctuation">(</span>request, response<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        console.log<span class="token punctuation">(</span><span class="token string">"Request IP: "</span> + request.connection.remoteAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
        response.writeHead<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response.end<span class="token punctuation">(</span><span class="token string">"Hostname: "</span> + os.hostname<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

var www <span class="token operator">=</span> http.createServer<span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
www.listen<span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>应用在 8080 端口启动一个 HTTP 服务器，服务器会以状态码 200 和输出消息来响应每个请求。请求处理程序会将客户端 IP 打印到标准输出。</p>
<h3 id="创建-dockerfile"><a class="markdownIt-Anchor" href="#创建-dockerfile"></a> 创建 Dockerfile</h3>
<p>Dockerfile 文件需要和 <code>app.js</code> 文件放在同一目录，内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># vi Dockerfile</span>
FROM node:7
ADD app.js /app.js
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"node"</span>, <span class="token string">"app.js"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里使用 Node 7 版本的基础镜像，然后将 <code>app.js</code> 文件添加到镜像根目录，最后执行 <code>node app.js</code> 命令。</p>
<h3 id="构建容器镜像"><a class="markdownIt-Anchor" href="#构建容器镜像"></a> 构建容器镜像</h3>
<p>构建不是由 Docker 客户端进行的，而是将整个目录的文件上传到 Docker 守护进程并在那里进行。因此，在守护进程运行在另外一个服务器时，不要在构建目录中包含不需要的文件。</p>
<p>使用 docker build 构建名为 kubia 的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># docker build -t kubia .</span>
Sending build context to Docker daemon  <span class="token number">14</span>.34kB
Step <span class="token number">1</span>/3 <span class="token builtin class-name">:</span> FROM node:7
 ---<span class="token operator">></span> d9aed20b68a4
Step <span class="token number">2</span>/3 <span class="token builtin class-name">:</span> ADD app.js /app.js
 ---<span class="token operator">></span> aa745953f3ae
Step <span class="token number">3</span>/3 <span class="token builtin class-name">:</span> ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"node"</span>, <span class="token string">"app.js"</span><span class="token punctuation">]</span>
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> 76a3951dc11c
Removing intermediate container 76a3951dc11c
 ---<span class="token operator">></span> cdd0c7614e03
Successfully built cdd0c7614e03
Successfully tagged kubia:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dockerfile 中每一条指令都会创建一个新层。上面的例子中，有一层用来添加 <code>app.js</code>，另外一层运行 <code>node app.js</code> 命令，最后一层会被标记为 kubia:latest。构建完成后镜像会存储在本地。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># docker images kubia</span>
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
kubia        latest    cdd0c7614e03   <span class="token number">30</span> seconds ago   660MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="运行容器镜像"><a class="markdownIt-Anchor" href="#运行容器镜像"></a> 运行容器镜像</h3>
<p>指定容器名为 kubia-container，暴露端口 8080，在后台运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># docker run --name kubia-container -p 8080:8080 -d kubia</span>
c971ba30949f2b1dbca90a96274a3a06a577d33f981e9bc82f327fbdb7010277<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动后在浏览器通过 8080 端口访问服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># curl 127.0.0.1:8080</span>
Hostname: f4c9088f3b28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时容器主机名就是 Docker 容器短 ID。可以查询容器日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># docker logs kubia-container</span>
Runing<span class="token punctuation">..</span>.
Request IP: ::ffff:192.168.2.101
Request IP: ::ffff:192.168.2.205<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="搭建-minikube"><a class="markdownIt-Anchor" href="#搭建-minikube"></a> 搭建 Minikube</h2>
<p>Minikube 是一个构建单节点集群的工具，具体使用可以参考 <a href="https://github.com/kubernetes/minikube">GitHub</a>。</p>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<p>下面通过下载 RPM 包的方式安装 Minikube：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm</span>
<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># rpm -Uvh minikube-latest.x86_64.rpm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还需要安装 Kubectl 客户端来与 Minikube 进行交互：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</span>
<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># chmod +x ./kubectl &amp;&amp; mv ./kubectl /usr/local/bin/kubectl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3>
<p>如果不带参数启动，会报错说不能使用 root 权限运行。这里使用一个加入了 docker 组的 user1 来运行。</p>
<p>另外经常会碰到镜像拉取失败的情况，可以加入 <code>--image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</code> 参数指定镜像仓库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-G</span> <span class="token function">docker</span> user1
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-l</span> user1
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ minikube start
* minikube v1.23.2 on Centos <span class="token number">7.9</span>.2009
* Automatically selected the <span class="token function">docker</span> driver
* Using image repository registry.cn-hangzhou.aliyuncs.com/google_containers
* Starting control plane <span class="token function">node</span> minikube <span class="token keyword">in</span> cluster minikube
* Pulling base image <span class="token punctuation">..</span>.
* Creating <span class="token function">docker</span> container <span class="token punctuation">(</span>CPUs<span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">Memory</span><span class="token operator">=</span>2200MB<span class="token punctuation">)</span> <span class="token punctuation">..</span>.
* Verifying Kubernetes components<span class="token punctuation">..</span>.
* Enabled addons: storage-provisioner, default-storageclass
* kubectl not found. If you need it, try: <span class="token string">'minikube kubectl -- get pods -A'</span>
* Done<span class="token operator">!</span> kubectl is now configured to use <span class="token string">"minikube"</span> cluster and <span class="token string">"default"</span> namespace by default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>遇到其他报错可以删除文件后，重新运行启动命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ minikube delete
* Deleting <span class="token string">"minikube"</span> <span class="token keyword">in</span> <span class="token function">docker</span> <span class="token punctuation">..</span>.
* Removed all traces of the <span class="token string">"minikube"</span> cluster.
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> .minikube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查看"><a class="markdownIt-Anchor" href="#查看"></a> 查看</h3>
<p>安装好以后可以使用 <code>kubectl</code> 命令查看集群工作状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl cluster-info 
Kubernetes control plane is running at https://192.168.49.2:8443
CoreDNS is running at https://192.168.49.2:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get nodes
NAME       STATUS   ROLES                  AGE     VERSION
minikube   Ready    control-plane,master   8m40s   v1.22.2
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl describe <span class="token function">node</span> minikube 
Name:               minikube
Roles:              control-plane,master
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="建立-pod"><a class="markdownIt-Anchor" href="#建立-pod"></a> 建立 Pod</h3>
<p>使用 <code>kubectl run</code> 命令可以创建所有必要组件而无需使用 JSON 或 YAML 文件。其中使用 <code>--image</code> 指定镜像，使用 <code>--port</code> 说明容器监听端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl run kubia <span class="token parameter variable">--image</span><span class="token operator">=</span>assassing/kubia <span class="token parameter variable">--port</span><span class="token operator">=</span><span class="token number">8080</span>
pod/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不能用 <code>kubectl</code> 直接列出容器，因为 Pod 才是操作对象。一个 Pod 包含一个或多个容器，每个容器都运行一个应用进程，它们总是运行在同一个工作节点及命名空间中。查看 Pod 运行状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pod
NAME    READY   STATUS    RESTARTS   AGE
kubia   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          58s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="暴露端口"><a class="markdownIt-Anchor" href="#暴露端口"></a> 暴露端口</h3>
<p>每个 Pod 都有自己的 IP，Pod 分布在不同的工作节点上。它们不能被外部访问，需要通过服务对象来公开：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl expose pod kubia <span class="token parameter variable">--type</span><span class="token operator">=</span>NodePort 
service/kubia exposed
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ minikube <span class="token function">service</span> kubia <span class="token parameter variable">--url</span>
http://192.168.49.2:32556
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl expose pod kubia <span class="token parameter variable">--type</span><span class="token operator">=</span>LoadBalancer <span class="token parameter variable">--name</span> kubia-http
service/kubia-http exposed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看刚刚新建的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get services
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE
kubernetes   ClusterIP      <span class="token number">10.96</span>.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP          42m
kubia        NodePort       <span class="token number">10.107</span>.120.56   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">8080</span>:32556/TCP   3m22s
kubia-http   LoadBalancer   <span class="token number">10.108</span>.108.14   <span class="token operator">&lt;</span>pending<span class="token operator">></span>     <span class="token number">8080</span>:31003/TCP   56s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示 pending 是因为 Minikube 不支持 LoadBalancer 类型的服务，可以用另外一个命令查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ minikube <span class="token function">service</span> kubia-http
<span class="token operator">|</span>-----------<span class="token operator">|</span>------------<span class="token operator">|</span>-------------<span class="token operator">|</span>---------------------------<span class="token operator">|</span>
<span class="token operator">|</span> NAMESPACE <span class="token operator">|</span>    NAME    <span class="token operator">|</span> TARGET PORT <span class="token operator">|</span>            URL            <span class="token operator">|</span>
<span class="token operator">|</span>-----------<span class="token operator">|</span>------------<span class="token operator">|</span>-------------<span class="token operator">|</span>---------------------------<span class="token operator">|</span>
<span class="token operator">|</span> default   <span class="token operator">|</span> kubia-http <span class="token operator">|</span>        <span class="token number">8080</span> <span class="token operator">|</span> http://192.168.49.2:31003 <span class="token operator">|</span>
<span class="token operator">|</span>-----------<span class="token operator">|</span>------------<span class="token operator">|</span>-------------<span class="token operator">|</span>---------------------------<span class="token operator">|</span>
* Opening <span class="token function">service</span> default/kubia-http <span class="token keyword">in</span> default browser<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>切换回 root 账号，试着访问一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># curl http://192.168.49.2:31401</span>
Hostname: kubia
<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># curl http://192.168.49.2:32050</span>
Hostname: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="系统配置"><a class="markdownIt-Anchor" href="#系统配置"></a> 系统配置</h1>
<p>主要以 CentOS 7 系统作为例子。其他发行版在安装工具步骤和自带工具使用上可能有差别，只要达成目标即可。</p>
<h2 id="修改-ip-地址"><a class="markdownIt-Anchor" href="#修改-ip-地址"></a> 修改 IP 地址</h2>
<p>安装完系统之后，第一件事就是修改好 IP 地址，然后通过 ssh 远程来连接系统。</p>
<h3 id="centos"><a class="markdownIt-Anchor" href="#centos"></a> CentOS</h3>
<p>要修改 IP 地址可通过 <code>nmcli</code> 命令，或者修改 <code>/etc/sysconfig/network-scripts/</code> 下面的网卡配置文件都可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nmcli connection modify ens32 connection.autoconnect yes ipv4.method manual ipv4.addresses 192.168.1.101/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nmcli connection up ens32</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nmcli</span>
ens32: connected to ens32
        <span class="token string">"Intel 82545EM"</span>
        ethernet <span class="token punctuation">(</span>e1000<span class="token punctuation">)</span>, 00:0C:29:DB:DA:56, hw, mtu <span class="token number">1500</span>
        ip4 default, ip6 default
        inet4 <span class="token number">192.168</span>.1.101/24
        route4 <span class="token number">192.168</span>.1.0/24
        route4 <span class="token number">0.0</span>.0.0/0
        inet6 240e:383:419:201:f417:1a97:df8f:9932/64
        inet6 fe80::5f5c:196b:8e66:a650/64
        route6 fe80::/64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面修改网卡 <code>ens32</code> 的 IP 地址为 <code>192.168.1.101</code>，网关地址 <code>192.168.1.1</code>，DNS 地址 <code>8.8.8.8</code>。并立即生效。</p>
<h3 id="ubuntu"><a class="markdownIt-Anchor" href="#ubuntu"></a> Ubuntu</h3>
<p>Ubuntu 中默认不带 <code>nmcli</code> ，可以通过修改配置文件 <code>/etc/netplan/00-installer-config.yaml</code> 来修改网卡配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">assassing@ubuntu22:~$ <span class="token function">sudo</span> <span class="token function">vi</span> /etc/netplan/00-installer-config.yaml
assassing@ubuntu22:~$ <span class="token function">sudo</span> netplan apply<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>设置 DNS 服务器地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># sed -i "s/#DNS=/DNS=8.8.8.8 114.114.114.114/g" /etc/systemd/resolved.conf</span>
root@ubuntu22:~<span class="token comment"># systemctl restart systemd-resolved</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="账户配置"><a class="markdownIt-Anchor" href="#账户配置"></a> 账户配置</h2>
<p>如果对操作系统不熟练，不建议使用 root 账户作为日常用户。下面是配置使用 root 账户的方法。</p>
<h3 id="阿里云"><a class="markdownIt-Anchor" href="#阿里云"></a> 阿里云</h3>
<p>刚刚开通的阿里云服务器，无法通过 <code>ssh</code> 直接连接。可以通过阿里云管理平台，点击远程连接，选择发送命令来配置主机。</p>
<p>例如修改 <code>ssh</code> 默认端口由 22 改为 2222，并允许使用账号密码登录。重启 sshd 服务来生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/#Port 22/Port 2222/g"</span> /etc/ssh/sshd_config
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/PasswordAuthentication no/PasswordAuthentication yes/g"</span> /etc/ssh/sshd_config
systemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过发送脚本的方式修改 root 账号密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token string">"qv4YB7#x9WhPj?i4E1DRgu1dlOWR"</span> <span class="token operator">|</span> <span class="token function">passwd</span> root <span class="token parameter variable">--stdin</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>添加用户 alice 并设置密码。密码是 <code>/etc/shadow</code> 中哈希值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">useradd</span> <span class="token parameter variable">-p</span> <span class="token punctuation">\</span><span class="token variable">$6</span><span class="token punctuation">\</span><span class="token variable">$YVLnCcQL</span><span class="token punctuation">\</span><span class="token variable">$NlbdFMzHHzw9Byk2EFjl4BNCm0riq22HnJKTVcccZv</span>/FQ/Y2HgvSeavPCUbdgzTmA3T3ksn7SYkq96An12oBW0 alice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后要记得调整安全组策略。在云服务器 ECS 的安全组中，为自定义的 sshd 端口 2222 设置白名单，这样才能使用 <code>ssh</code> 远程连接。</p>
<h3 id="ubuntu-2"><a class="markdownIt-Anchor" href="#ubuntu-2"></a> Ubuntu</h3>
<p>在 Ubuntu 中，默认情况下是没有开启 root 用户登录。首先需要使用普通用户登录，并设置 root 账号的密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">assassing@ubuntu22:~$ <span class="token function">sudo</span> <span class="token function">passwd</span> root
New password: 
Retype new password: 
passwd: password updated successfully
assassing@ubuntu22:~$ <span class="token function">su</span> <span class="token parameter variable">-l</span>
Password: 
root@ubuntu22:~<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，修改 SSH 服务的配置文件，允许 root 用户使用 SSH 连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># sed -i "s/#PermitRootLogin prohibit-password/PasswordAuthentication yes/g" /etc/ssh/sshd_config</span>
root@ubuntu22:~<span class="token comment"># sed -i '85a\PermitRootLogin yes' /etc/ssh/sshd_config</span>
root@ubuntu22:~<span class="token comment"># systemctl restart sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在可以使用 root 用户直接连接到 22 端口，并删除普通用户 “assassing”：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># userdel -r assassing</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="登录限制"><a class="markdownIt-Anchor" href="#登录限制"></a> 登录限制</h2>
<p>可以设置一台服务器作为跳板机，只能通过它连接其他服务器。</p>
<h3 id="主节点"><a class="markdownIt-Anchor" href="#主节点"></a> 主节点</h3>
<p>跳板机 ssh 连接端口是 2222，修改 sshd 配置来禁止 root 用户登录。只能通过 普通 用户登录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/PermitRootLogin yes/PermitRootLogin no/g" /etc/ssh/sshd_config</span>
<span class="token punctuation">[</span>root@k8s-s1 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安装 <code>Fail2ban</code> 来阻止恶意登录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># yum install -y fail2ban</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改配置启用通过 iptables 防护非法 sshd 登录。规则为在 300 秒内输错 5 次密码，IP 被禁止连接 2222 端口 1 个小时：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/fail2ban/jail.conf</span>
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>sshd<span class="token punctuation">]</span>

<span class="token comment"># To use more aggressive sshd modes set filter parameter "mode" in jail.local:</span>
<span class="token comment"># normal (default), ddos, extra or aggressive (combines all).</span>
<span class="token comment"># See "tests/files/logs/sshd" or "filter.d/sshd.conf" for usage example and details.</span>
<span class="token comment">#mode   = normal</span>
enabled <span class="token operator">=</span> <span class="token boolean">true</span>
filter <span class="token operator">=</span> sshd
port    <span class="token operator">=</span> <span class="token number">2222</span>
action <span class="token operator">=</span> iptables<span class="token punctuation">[</span>name<span class="token operator">=</span>SSH, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">2222</span>, <span class="token assign-left variable">protocol</span><span class="token operator">=</span>tcp<span class="token punctuation">]</span>
logpath <span class="token operator">=</span> %<span class="token punctuation">(</span>sshd_log<span class="token punctuation">)</span>s
backend <span class="token operator">=</span> %<span class="token punctuation">(</span>sshd_backend<span class="token punctuation">)</span>s
bantime <span class="token operator">=</span> <span class="token number">3600</span>
findtime <span class="token operator">=</span> <span class="token number">300</span>
maxretry <span class="token operator">=</span> <span class="token number">5</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now fail2ban</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要限制 Nginx 访问可以参考<a href="https://zhuanlan.zhihu.com/p/71911717/">这里</a>。</p>
<h3 id="其他节点"><a class="markdownIt-Anchor" href="#其他节点"></a> 其他节点</h3>
<p>除了跳板机外，修改系统 <code>/etc/hosts.deny</code> 和 <code>/etc/hosts.allow</code> 文件内容，只允许通过内网 ssh 连接，其他地址拒绝：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "sshd:ALL:deny" >> /etc/hosts.deny</span>
<span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># echo "sshd:172.16.0.0/255.255.0.0:allow" >> /etc/hosts.allow</span>
<span class="token punctuation">[</span>root@k8s-w2-pro ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart sshd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="查询异常登录"><a class="markdownIt-Anchor" href="#查询异常登录"></a> 查询异常登录</h3>
<p><code>/var/log/secure</code> 文件记录有异常登录信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># tail -n 30 /var/log/secure</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在跳板机上可以通过 <code>fail2ban-client</code> 命令查看被 ban 列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client status</span>
<span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client status sshd</span>
<span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>解除被 ban 的 IP 地址操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro fail2ban<span class="token punctuation">]</span><span class="token comment"># fail2ban-client set sshd unbanip 47.101.138.100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="镜像仓库"><a class="markdownIt-Anchor" href="#镜像仓库"></a> 镜像仓库</h2>
<p>修改 <code>yum</code> 仓库地址为阿里云镜像仓库，提升软件安装和更新速度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum install -y wget</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cd /etc/yum.repos.d/ &amp;&amp; wget http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo &amp;&amp; cd -</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum clean all</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum makecache</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然阿里云镜像仓库下载速度被限制成 500 kB/s，但胜在稳定。</p>
<h2 id="内核升级"><a class="markdownIt-Anchor" href="#内核升级"></a> 内核升级</h2>
<p>CentOS 7 安装镜像自带的 3.10 内核已太旧，很多应用需要的内核功能支持不了。装好后第一时间升级内核。</p>
<h3 id="查看内核"><a class="markdownIt-Anchor" href="#查看内核"></a> 查看内核</h3>
<p>查看当前运行的内核版本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># uname -sr</span>
Linux <span class="token number">3.10</span>.0-1160.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="安装内核"><a class="markdownIt-Anchor" href="#安装内核"></a> 安装内核</h3>
<p>导入 ELRepo 软件仓库的公共秘钥，安装 yum 源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>列出当前最新内核版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum --disablerepo="*" --enablerepo="elrepo-kernel" list available</span>
Available Packages
kernel-lt.x86_64    <span class="token number">5.4</span>.242-1.el7.elrepo   elrepo-kernel
kernel-ml-devel.x86 <span class="token number">5.4</span>.242-1.el7.elrepo   elrepo-kernel
kernel-ml.x86_64    <span class="token number">6.3</span>.2-1.el7.elrepo     elrepo-kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>kernel-lt</code> 表示 long-term（长期支持版本）,<code>kernel-ml</code> 表示 latest mainline（最新主线版本）。选择安装 <code>kernel-lt.x86_64</code> 版本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum install -y kernel-lt-5.4.242-1.el7.elrepo --enablerepo=elrepo-kernel</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="修改引导"><a class="markdownIt-Anchor" href="#修改引导"></a> 修改引导</h3>
<p>查看已安装系统内核。正常情况下会保留旧内核，升级失败时可以回滚：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg</span>
<span class="token number">0</span> <span class="token builtin class-name">:</span> CentOS Linux <span class="token punctuation">(</span><span class="token number">5.4</span>.242-1.el7.elrepo.x86_64<span class="token punctuation">)</span> <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token builtin class-name">:</span> CentOS Linux <span class="token punctuation">(</span><span class="token number">3.10</span>.0-1160.el7.x86_64<span class="token punctuation">)</span> <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
<span class="token number">2</span> <span class="token builtin class-name">:</span> CentOS Linux <span class="token punctuation">(</span><span class="token number">0</span>-rescue-e175a587657a4fae8ab45bb178e24c22<span class="token punctuation">)</span> <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果引导方式是 UEFI，则需要查看 <code>/etc/grub2-efi.cfg</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2-efi.cfg</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置内核启动顺序，需要重新生成引导文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grub2-set-default 0</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span>
Generating grub configuration <span class="token function">file</span> <span class="token punctuation">..</span>.
Found linux image: /boot/vmlinuz-5.4.242-1.el7.elrepo.x86_64
Found initrd image: /boot/initramfs-5.4.242-1.el7.elrepo.x86_64.img
Found linux image: /boot/vmlinuz-3.10.0-1160.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1160.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-e175a587657a4fae8ab45bb178e24c22
Found initrd image: /boot/initramfs-0-rescue-e175a587657a4fae8ab45bb178e24c22.img
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UEFI 启动配置文件位置的位置不同：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grub2-set-default 0</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="降级内核"><a class="markdownIt-Anchor" href="#降级内核"></a> 降级内核</h3>
<p>内核降级和升级步骤一样，用 <code>yum</code> 安装指定内核版本后，修改引导配置文件并重启。</p>
<h3 id="删除内核"><a class="markdownIt-Anchor" href="#删除内核"></a> 删除内核</h3>
<p>重启后如果新内核运作正常，可以删除旧内核：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum remove -y kernel-lt-3.10.0-1160.el7.elrepo.x86_64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="驱动问题"><a class="markdownIt-Anchor" href="#驱动问题"></a> 驱动问题</h3>
<p>如果旧网卡驱动识别不了，需要手动载入驱动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># rmmod r8169 &amp;&amp; modprobe r8169 &amp;&amp; systemctl restart network</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置为系统启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 /<span class="token punctuation">]</span><span class="token comment"># tee /etc/systemd/system/load-realtek-driver.service&lt;&lt;EOF</span>
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>Load Realtek drivers.
<span class="token assign-left variable">Before</span><span class="token operator">=</span>network-online.target

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>simple
<span class="token assign-left variable">ExecStartPre</span><span class="token operator">=</span>/usr/sbin/rmmod r8169
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/sbin/modprobe r8169

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
EOF
<span class="token punctuation">[</span>root@k8s-250 /<span class="token punctuation">]</span><span class="token comment"># systemctl enable load-realtek-driver.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="内核功能调整"><a class="markdownIt-Anchor" href="#内核功能调整"></a> 内核功能调整</h2>
<p>需要修改内核参数,否则安装运行 K8s 会失败.</p>
<h3 id="禁用虚拟内存"><a class="markdownIt-Anchor" href="#禁用虚拟内存"></a> 禁用虚拟内存</h3>
<p>虽然安装系统时已经去除了 swap 分区，但保险起见，还是对开机挂载配置文件 <code>/etc/fstab</code> 进行重写。然后重新挂载根目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># swapoff -a</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yes | cp /etc/fstab /etc/fstab_bak</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/fstab_bak |grep -v swap > /etc/fstab</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mount -n -o remount,rw /</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "vm.swappiness = 0" >> /etc/sysctl.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="开启端口转发"><a class="markdownIt-Anchor" href="#开启端口转发"></a> 开启端口转发</h3>
<p>首先要确认网卡 MAC 地址没有冲突，然后确保 <code>br_netfilter</code> 和 <code>overlay</code> 模块被加载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "br_netfilter" >> /etc/modules-load.d/k8s.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "overlay" >> /etc/modules-load.d/k8s.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe br_netfilter</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe overlay</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># lsmod | grep 'br_netfilter\|overlay'</span>
br_netfilter           <span class="token number">28672</span>  <span class="token number">0</span> 
overlay               <span class="token number">114688</span>  <span class="token number">35</span> 
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe ip_vs</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe ip_vs_rr</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe ip_vs_wrr</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># modprobe ip_vs_sh</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_nonlocal_bind = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.ipv4.ip_local_port_range = 1024 65535" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.bridge.bridge-nf-call-ip6tables = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.bridge.bridge-nf-call-iptables = 1" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "net.core.rmem_max=2500000" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "10000 65535" > /proc/sys/net/ipv4/ip_local_port_range</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="去除文件系统限制"><a class="markdownIt-Anchor" href="#去除文件系统限制"></a> 去除文件系统限制</h3>
<p>根据硬件情况，对文件系统限制调大。最后使用 <code>sysctl --system</code> 命令来使配置生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ulimit -SHn 65536</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "* soft nofile 655350" >> /etc/security/limits.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "* hard nofile 655350" >> /etc/security/limits.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "vm.max_map_count = 524288" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "fs.file-max = 655350" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "fs.inotify.max_user_instances=8192" >> /etc/sysctl.conf</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sysctl --system</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="关闭防火墙"><a class="markdownIt-Anchor" href="#关闭防火墙"></a> 关闭防火墙</h2>
<p>关闭防火墙和 SELinux，否则容器访问主机文件系统会不正常：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># service iptables stop</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># chkconfig iptables off</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl stop firewalld</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># systemctl disable firewalld</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># setenforce 0</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -i 's/^SELINUX=enforcing$/SELINUX=disabled/' /etc/selinux/config</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># getenforce #</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="个性化设置"><a class="markdownIt-Anchor" href="#个性化设置"></a> 个性化设置</h2>
<p>一些按照喜好来设置的系统调整。</p>
<h3 id="修改系统语言"><a class="markdownIt-Anchor" href="#修改系统语言"></a> 修改系统语言</h3>
<p>修改系统语言为英语：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo 'LANG="en_US.UTF-8"' > /etc/locale.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="修改主机名"><a class="markdownIt-Anchor" href="#修改主机名"></a> 修改主机名</h3>
<p>修改节点上的主机名，例如 k8s-master-1、k8s-m1-pro、k8s-250 等，尽量取有意义的名字：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># hostnamectl set-hostname k8s-101</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将主机名添加到本地域名解析 <code>/etc/hosts</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "127.0.0.1   $(hostname)" >> /etc/hosts</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="时间同步"><a class="markdownIt-Anchor" href="#时间同步"></a> 时间同步</h3>
<p>设置网络时间同步。若服务器时间不对，可能会遇到一些莫名其妙的验证方面问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># timedatectl set-timezone "Asia/Shanghai"</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum -y install ntp ntpdate</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ntpdate cn.pool.ntp.org</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># hwclock --systohc</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># hwclock -w</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="安装工具"><a class="markdownIt-Anchor" href="#安装工具"></a> 安装工具</h3>
<p>安装一些常用系统维护工具：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># yum install -y git wget net-tools bind-utils vim bash-completion nfs-utils jq nc telnet lvm2 unzip iftop lsof</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Ubuntu 中 <code>bind-utils</code> 替换为 <code>bind9-utils</code>，<code>nfs-utils</code> 替换为 <code>nfs-kernel-server</code>，<code>nc</code> 已经自带。安装命令改为这样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># apt-get update</span>
root@ubuntu22:~<span class="token comment"># apt install -y git wget net-tools bind9-utils vim bash-completion jq telnet lvm2 nfs-kernel-server</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="限制日志大小"><a class="markdownIt-Anchor" href="#限制日志大小"></a> 限制日志大小</h3>
<p>限制系统 journal 日志保留时常为 1 周，免得磁盘被大量日志挤占空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># journalctl --vacuum-time=1w</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="设置变量"><a class="markdownIt-Anchor" href="#设置变量"></a> 设置变量</h3>
<p>修改 <code>/etc/profile</code> 文件，添加一些常用变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "export HISTTIMEFORMAT='`whoami` : %F %T :'" >> /etc/profile</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># echo "export NFS_SERVER=192.168.1.253" >> /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>NFS 服务器地址变量按实际情况填写。</p>
<h3 id="免密登录"><a class="markdownIt-Anchor" href="#免密登录"></a> 免密登录</h3>
<p>可以在特定服务器上设置免密登录别的服务器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># ssh-keygen</span>
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span><span class="token comment"># ssh-copy-id root@192.168.1.248</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="编辑器配置"><a class="markdownIt-Anchor" href="#编辑器配置"></a> 编辑器配置</h3>
<p>在 Ubuntu 中，<code>vi</code> 需要设置粘贴模式，禁止粘贴文本时，可能会出现自动缩进或添加额外的空格和制表符的情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># echo "set paste" >> /etc/vim/vimrc </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理"></a> 磁盘管理</h2>
<p>一般建议把容器工作目录和数据储存同系统根目录分开挂载，免得影响系统运行稳定性。下面以新增一块储存盘为例，演示磁盘管理操作。</p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>服务器上新增一块固态硬盘 sdb，需要初始化后才能使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment"># lsblk</span>
NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda               <span class="token number">8</span>:0    <span class="token number">0</span> <span class="token number">223</span>.6G  <span class="token number">0</span> disk 
├─sda1            <span class="token number">8</span>:1    <span class="token number">0</span>   200M  <span class="token number">0</span> part /boot/efi
├─sda2            <span class="token number">8</span>:2    <span class="token number">0</span>     1G  <span class="token number">0</span> part /boot
└─sda3            <span class="token number">8</span>:3    <span class="token number">0</span> <span class="token number">222</span>.4G  <span class="token number">0</span> part 
  └─centos-root <span class="token number">253</span>:0    <span class="token number">0</span> <span class="token number">222</span>.4G  <span class="token number">0</span> lvm  /
sdb               <span class="token number">8</span>:16   <span class="token number">0</span> <span class="token number">931</span>.5G  <span class="token number">0</span> disk <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>fdisk</code> 命令来管理磁盘：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment"># fdisk /dev/sdb</span>
Welcome to <span class="token function">fdisk</span> <span class="token punctuation">(</span>util-linux <span class="token number">2.23</span>.2<span class="token punctuation">)</span>.

Changes will remain <span class="token keyword">in</span> memory only, <span class="token keyword">until</span> you decide to <span class="token function">write</span> them.
Be careful before using the <span class="token function">write</span> command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x50398e42.

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: p

Disk /dev/sdb: <span class="token number">1000.2</span> GB, <span class="token number">1000204886016</span> bytes, <span class="token number">1953525168</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos
Disk identifier: 0x50398e42

   Device Boot      Start         End      Blocks   Id  System<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先使用初始化并分区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition type:
   p   primary <span class="token punctuation">(</span><span class="token number">0</span> primary, <span class="token number">0</span> extended, <span class="token number">4</span> <span class="token function">free</span><span class="token punctuation">)</span>
   e   extended
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: p
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-4, default <span class="token number">1</span><span class="token punctuation">)</span>: 
First sector <span class="token punctuation">(</span><span class="token number">2048</span>-1953525167, default <span class="token number">2048</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">2048</span>
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">2048</span>-1953525167, default <span class="token number">1953525167</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">1953525167</span>
Partition <span class="token number">1</span> of <span class="token builtin class-name">type</span> Linux and of size <span class="token number">931.5</span> GiB is <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改分区 <code>system ID</code> 为 <code>lvm</code> ：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: t
Selected partition <span class="token number">1</span>
Hex code <span class="token punctuation">(</span>type L to list all codes<span class="token punctuation">)</span>: 8e
Changed <span class="token builtin class-name">type</span> of partition <span class="token string">'Linux'</span> to <span class="token string">'Linux LVM'</span>
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered<span class="token operator">!</span>

Calling ioctl<span class="token punctuation">(</span><span class="token punctuation">)</span> to re-read partition table.
Syncing disks.
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment"># partprobe</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="创建-pv"><a class="markdownIt-Anchor" href="#创建-pv"></a> 创建 PV</h3>
<p>使用 <code>pvcreate</code> 命令来创建 PV：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># pvcreate /dev/sdb1</span>
  Physical volume <span class="token string">"/dev/sdb1"</span> successfully created.
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># pvscan</span>
  PV /dev/sda2   VG centos          lvm2 <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">49.00</span> GiB / <span class="token number">0</span>    free<span class="token punctuation">]</span>
  PV /dev/sdb1                      lvm2 <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">200.00</span> GiB<span class="token punctuation">]</span>
  Total: <span class="token number">2</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">249.00</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> use: <span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">49.00</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> no VG: <span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">200.00</span> GiB<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询刚创建的 PV 详细信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># pvdisplay</span>
  --- Physical volume ---
  PV Name               /dev/sda2
  VG Name               centos
  PV Size               <span class="token operator">&lt;</span><span class="token number">49.00</span> GiB / not usable <span class="token number">3.00</span> MiB
  Allocatable           <span class="token function">yes</span> <span class="token punctuation">(</span>but full<span class="token punctuation">)</span>
  PE Size               <span class="token number">4.00</span> MiB
  Total PE              <span class="token number">12543</span>
  Free PE               <span class="token number">0</span>
  Allocated PE          <span class="token number">12543</span>
  PV UUID               FOgL5t-v6EE-neHA-Kdpy-ynt0-yzXr-Tin7Am
   
  <span class="token string">"/dev/sdb1"</span> is a new physical volume of <span class="token string">"&lt;200.00 GiB"</span>
  --- NEW Physical volume ---
  PV Name               /dev/sdb1
  VG Name               
  PV Size               <span class="token operator">&lt;</span><span class="token number">200.00</span> GiB
  Allocatable           NO
  PE Size               <span class="token number">0</span>   
  Total PE              <span class="token number">0</span>
  Free PE               <span class="token number">0</span>
  Allocated PE          <span class="token number">0</span>
  PV UUID               rxkppt-GxSK-igDI-NgI1-3CZw-F3r2-YtXIU9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="创建-vg"><a class="markdownIt-Anchor" href="#创建-vg"></a> 创建 VG</h3>
<p>声明变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># export DIR=ssd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>新建 VG：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># vgcreate $&#123;DIR&#125; /dev/sdb1</span>
  Volume group <span class="token string">"ssd"</span> successfully created
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># vgscan</span>
  Reading volume <span class="token function">groups</span> from cache.
  Found volume group <span class="token string">"centos"</span> using metadata <span class="token builtin class-name">type</span> lvm2
  Found volume group <span class="token string">"ssd"</span> using metadata <span class="token builtin class-name">type</span> lvm2
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># vgdisplay</span>
  --- Volume group ---
  VG Name               centos
  System ID             
  Format                lvm2
  Metadata Areas        <span class="token number">1</span>
  Metadata Sequence No  <span class="token number">2</span>
  VG Access             read/write
  VG Status             resizable
  MAX LV                <span class="token number">0</span>
  Cur LV                <span class="token number">1</span>
  Open LV               <span class="token number">1</span>
  Max PV                <span class="token number">0</span>
  Cur PV                <span class="token number">1</span>
  Act PV                <span class="token number">1</span>
  VG Size               <span class="token operator">&lt;</span><span class="token number">49.00</span> GiB
  PE Size               <span class="token number">4.00</span> MiB
  Total PE              <span class="token number">12543</span>
  Alloc PE / Size       <span class="token number">12543</span> / <span class="token operator">&lt;</span><span class="token number">49.00</span> GiB
  Free  PE / Size       <span class="token number">0</span> / <span class="token number">0</span>   
  VG UUID               xuRCcF-ROBb-5OhK-4BAY-fuBi-EvlU-uqxs9T
   
  --- Volume group ---
  VG Name               ssd
  System ID             
  Format                lvm2
  Metadata Areas        <span class="token number">1</span>
  Metadata Sequence No  <span class="token number">1</span>
  VG Access             read/write
  VG Status             resizable
  MAX LV                <span class="token number">0</span>
  Cur LV                <span class="token number">0</span>
  Open LV               <span class="token number">0</span>
  Max PV                <span class="token number">0</span>
  Cur PV                <span class="token number">1</span>
  Act PV                <span class="token number">1</span>
  VG Size               <span class="token operator">&lt;</span><span class="token number">200.00</span> GiB
  PE Size               <span class="token number">4.00</span> MiB
  Total PE              <span class="token number">51199</span>
  Alloc PE / Size       <span class="token number">0</span> / <span class="token number">0</span>   
  Free  PE / Size       <span class="token number">51199</span> / <span class="token operator">&lt;</span><span class="token number">200.00</span> GiB
  VG UUID               yq6LIQ-D4Xm-hPGZ-2Zqi-Bdsc-vz3Y-cvuAmC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="创建-lv"><a class="markdownIt-Anchor" href="#创建-lv"></a> 创建 LV</h3>
<p>建立名为 ssd 的 LV，使用参数 <code>-l</code> 指定分配 free PE 数量:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># lvcreate -l +100%FREE -n $&#123;DIR&#125; $&#123;DIR&#125;</span>
  Logical volume <span class="token string">"ssd"</span> created.
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># lvdisplay</span>
  --- Logical volume ---
  LV Path                /dev/centos/root
  LV Name                root
  VG Name                centos
  LV UUID                GySaQs-a1ni-kiUg-Ys86-j287-Sqpu-9PWECL
  LV Write Access        read/write
  LV Creation host, <span class="token function">time</span> localhost, <span class="token number">2023</span>-05-17 08:02:19 +0800
  LV Status              available
  <span class="token comment"># open                 1</span>
  LV Size                <span class="token operator">&lt;</span><span class="token number">49.00</span> GiB
  Current LE             <span class="token number">12543</span>
  Segments               <span class="token number">1</span>
  Allocation             inherit
  Read ahead sectors     auto
  - currently <span class="token builtin class-name">set</span> to     <span class="token number">8192</span>
  Block device           <span class="token number">253</span>:0
   
  --- Logical volume ---
  LV Path                /dev/ssd/ssd
  LV Name                ssd
  VG Name                ssd
  LV UUID                EkAIWn-ad01-3nsX-cfBN-rpgV-dSwk-Pc1MJI
  LV Write Access        read/write
  LV Creation host, <span class="token function">time</span> k8s-103, <span class="token number">2023</span>-05-17 02:28:34 +0800
  LV Status              available
  <span class="token comment"># open                 0</span>
  LV Size                <span class="token operator">&lt;</span><span class="token number">200.00</span> GiB
  Current LE             <span class="token number">51199</span>
  Segments               <span class="token number">1</span>
  Allocation             inherit
  Read ahead sectors     auto
  - currently <span class="token builtin class-name">set</span> to     <span class="token number">8192</span>
  Block device           <span class="token number">253</span>:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h3>
<p>格式化成 xfs 格式，并挂载到指定目录下面：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># mkfs.xfs /dev/$&#123;DIR&#125;/$&#123;DIR&#125;</span>
meta-data<span class="token operator">=</span>/dev/ssd/ssd           <span class="token assign-left variable">isize</span><span class="token operator">=</span><span class="token number">512</span>    <span class="token assign-left variable">agcount</span><span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">agsize</span><span class="token operator">=</span><span class="token number">13106944</span> blks
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">attr</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">projid32bit</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">crc</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token assign-left variable">finobt</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">sparse</span><span class="token operator">=</span><span class="token number">0</span>
data     <span class="token operator">=</span>                       <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">52427776</span>, <span class="token assign-left variable">imaxpct</span><span class="token operator">=</span><span class="token number">25</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span>      <span class="token assign-left variable">swidth</span><span class="token operator">=</span><span class="token number">0</span> blks
naming   <span class="token operator">=</span>version <span class="token number">2</span>              <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   ascii-ci<span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ftype</span><span class="token operator">=</span><span class="token number">1</span>
log      <span class="token operator">=</span>internal log           <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">25599</span>, <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token number">2</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span> blks, lazy-count<span class="token operator">=</span><span class="token number">1</span>
realtime <span class="token operator">=</span>none                   <span class="token assign-left variable">extsz</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">rtextents</span><span class="token operator">=</span><span class="token number">0</span>         <span class="token assign-left variable">extsz</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">rtextents</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /$&#123;DIR&#125;</span>
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># mount /dev/$&#123;DIR&#125;/$&#123;DIR&#125; /$&#123;DIR&#125;/</span>
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># echo "/dev/mapper/$&#123;DIR&#125;-$&#123;DIR&#125; /$&#123;DIR&#125; xfs defaults 0 0" >> /etc/fstab</span>
<span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># df -hT</span>
Filesystem              Type      Size  Used Avail Use% Mounted on
devtmpfs                devtmpfs  <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /dev
tmpfs                   tmpfs     <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /dev/shm
tmpfs                   tmpfs     <span class="token number">3</span>.9G  <span class="token number">9</span>.0M  <span class="token number">3</span>.9G   <span class="token number">1</span>% /run
tmpfs                   tmpfs     <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /sys/fs/cgroup
/dev/mapper/centos-root xfs        49G  <span class="token number">2</span>.2G   47G   <span class="token number">5</span>% /
/dev/sda1               xfs      1014M  184M  831M  <span class="token number">19</span>% /boot
tmpfs                   tmpfs     793M     <span class="token number">0</span>  793M   <span class="token number">0</span>% /run/user/0
/dev/mapper/ssd-ssd     xfs       200G   33M  200G   <span class="token number">1</span>% /ssd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="删除磁盘"><a class="markdownIt-Anchor" href="#删除磁盘"></a> 删除磁盘</h3>
<p>删除磁盘则是逆序操作。下面使删除挂载卷例子：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/fstab</span>
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># umount /databases</span>
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># yes | lvremove /dev/databases/databases</span>
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># vgremove databases</span>
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># pvremove /dev/sdb1</span>
<span class="token punctuation">[</span>root@k8s-248 ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload </span>
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart proc-fs-nfsd.mount</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="重启"><a class="markdownIt-Anchor" href="#重启"></a> 重启</h2>
<p>最后重启服务器，让改动生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="高可用集群部署"><a class="markdownIt-Anchor" href="#高可用集群部署"></a> 高可用集群部署</h1>
<p>以部署三主节点高可用集群示例，系统为 CentOS 7，K8s 版本为 1.22.3。集群构架图如下：</p>
<p><img data-src="../../../images/%E9%9B%86%E7%BE%A4%E6%9E%84%E6%9E%B6%E5%9B%BE.png" alt="集群构架图" /></p>
<h2 id="kubeadm"><a class="markdownIt-Anchor" href="#kubeadm"></a> Kubeadm</h2>
<p>Kubeadm 是由志愿者开发的专门用于部署 K8s 的工具。自 K8s 1.14 版本以后，Kubeadm 项目已经正式宣布 GA（General Availability），可以在<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/">官方文档</a>中查看详细的使用说明。</p>
<h3 id="kubeadm-init"><a class="markdownIt-Anchor" href="#kubeadm-init"></a> kubeadm init</h3>
<p>初始化的大致过程如下：</p>
<ol>
<li>kubeadm 执行初始化检查。</li>
<li>生成 token 和证书。</li>
<li>生成 KubeConfig 文件，kubelet 需要使用该文件与 Master 进行通信。</li>
<li>安装 Master 组件，从镜像仓库下载组件和 Docker 镜像。</li>
<li>安装附加组件 kube-proxy 和 kube-dns。</li>
<li>Kubernetes Master 初始化成功。</li>
<li>提示如何配置 kubectl，安装 pod 网络，以及其他节点注册到集群的方法。</li>
</ol>
<p>执行 <code>kubeadm init</code> 指令后，kubeadm 首先会进行一系列的检查工作，以确定本机是否适用于部署 K8s。这一步的检查被称为 Preflight Checks，其主要目的是检查内核版本、CGroups 模块、kubelet 版本、网络端口等必要的配置是否正确。</p>
<p>默认情况下，与 API 服务器的通信必须使用 HTTPS 方式，因此需要证书文件。在完成系统检查后，kubeadm 开始生成 K8s 对外提供服务所需的各种证书和目录。kubeadm 生成的证书存放在主节点的 <code>/etc/kubernetes/pki/</code> 目录下，其中最重要的文件是 <code>ca.crt</code> 和 <code>ca.key</code>。也可以将现有的证书复制到证书目录中，这样 kubeadm 就不会生成证书：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /etc/kubernetes/pki
apiserver.crt              apiserver.key                 ca.crt  front-proxy-ca.crt      front-proxy-client.key
apiserver-etcd-client.crt  apiserver-kubelet-client.crt  ca.key  front-proxy-ca.key      sa.key
apiserver-etcd-client.key  apiserver-kubelet-client.key  etcd    front-proxy-client.crt  sa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成证书之后，kubeadm 接下来会创建用于访问 API 服务器的配置文件，并存放在 <code>/etc/kubernetes/</code> 目录下。这些文件记录了主节点的服务器地址、端口和证书位置等信息，客户端可以直接使用这些信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /etc/kubernetes/
admin.conf  controller-manager.conf  kubeadm-master.config  kubelet.conf  manifests  pki  scheduler.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>随后，kubeadm 会为 Master 组件生成 pod 的配置文件，并以静态 pod 的形式运行。这种容器启动的方式允许将要部署的 pod 的 YAML 文件放在一起，当 Kubelet 启动时，会自动加载这些文件并启动 pod。这些配置文件默认存放在 <code>/etc/kubernetes/manifests/</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ ll /etc/kubernetes/manifests/
total <span class="token number">16</span>
-rw------- <span class="token number">1</span> root root <span class="token number">2258</span> Apr <span class="token number">20</span> <span class="token number">22</span>:19 etcd.yaml
-rw------- <span class="token number">1</span> root root <span class="token number">3424</span> Apr <span class="token number">20</span> <span class="token number">22</span>:29 kube-apiserver.yaml
-rw------- <span class="token number">1</span> root root <span class="token number">2906</span> Apr <span class="token number">20</span> <span class="token number">22</span>:30 kube-controller-manager.yaml
-rw------- <span class="token number">1</span> root root <span class="token number">1492</span> Apr <span class="token number">20</span> <span class="token number">22</span>:30 kube-scheduler.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，kubeadm 会为集群生成一个用于加入集群的 bootstrap token。其他证书等信息通过 ConfigMap 的方式保存在 etcd 中。</p>
<p>最后是安装默认插件，包括 kube-proxy 和 DNS 插件，用于提供整个集群的服务发现和 DNS 功能。</p>
<h3 id="kubeadm-join"><a class="markdownIt-Anchor" href="#kubeadm-join"></a> kubeadm join</h3>
<p>加入集群时，需要使用主节点初始化时生成的令牌（token），该令牌用于进行一次性身份验证。工作节点在获取 ConfigMap 中的证书后，将使用证书进行安全通信。</p>
<h2 id="安装组件"><a class="markdownIt-Anchor" href="#安装组件"></a> 安装组件</h2>
<p>kubelet 是唯一没有以容器形式运行的 K8s 组件，它通过 systemd 服务运行。kubeadm 用来创建 K8s 集群，kubectl 是用来执行 K8s 命令的工具。其他 K8s 的系统组件都以容器化运行，并被放到 kube-system namespaces 中，例如 coredns、etcd、apiserver、controller-manager。</p>
<p>在所有要加入 K8s 集群的主机中安装 kubelet、kubeadm 和 kubectl 1.22.3 版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /etc/yum.repos.d/kubernetes.repo&lt;&lt;EOF</span>
<span class="token punctuation">[</span>kubernetes<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>Kubernetes
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">repo_gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y kubelet-1.22.3 kubeadm-1.22.3 kubectl-1.22.3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改 Kubelet 配置文件，设置 cgroup 驱动为 systemd，镜像 pause 使用阿里云的源，然后启动 Kubelet：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /etc/sysconfig/kubelet&lt;&lt;EOF</span>
<span class="token assign-left variable">KUBELET_EXTRA_ARGS</span><span class="token operator">=</span><span class="token string">"--cgroup-driver=systemd --runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.2"</span>
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl daemon-reload</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now kubelet</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="主节点配置"><a class="markdownIt-Anchor" href="#主节点配置"></a> 主节点配置</h2>
<p>主节点上部署 HAProxy 和 keepalived 来保证主节点高可用。</p>
<h3 id="部署-haproxy"><a class="markdownIt-Anchor" href="#部署-haproxy"></a> 部署 HAProxy</h3>
<p>HAProxy 提供高可用性、负载均衡、基于 TCP 和 HTTP 的代理，支持数以万记的并发连接。此处 HAProxy 为 apiserver 提供反向代理，HAProxy 将所有请求轮询转发到每个 master 节点上。</p>
<p>在所有主节点上安装 HAProxy：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum install -y haproxy</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>HAProxy 的配置文件内容相同，前台监听 16443 端口，转发请求到后台 6443 端口上。主要是设置 <code>backend kubernetes-apiserver</code> 中 server 的地址列表，负载均衡模式 <code>balance</code> 默认为轮询的负载算法 roundrobin：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /etc/haproxy/haproxy.cfg&lt;&lt;EOF</span>
<span class="token comment">#---------------------------------------------------------------------</span>
<span class="token comment"># Global settings</span>
<span class="token comment">#---------------------------------------------------------------------</span>
global
    log         <span class="token number">127.0</span>.0.1 local2

    <span class="token function">chroot</span>      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     <span class="token number">4000</span>
    user        haproxy
    group       haproxy
    daemon

    stats socket /var/lib/haproxy/stats

<span class="token comment">#---------------------------------------------------------------------</span>
<span class="token comment"># common defaults that all the 'listen' and 'backend' sections will</span>
<span class="token comment"># use if not designated in their block</span>
<span class="token comment">#---------------------------------------------------------------------</span>
defaults
    mode                    http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except <span class="token number">127.0</span>.0.0/8
    option                  redispatch
    retries                 <span class="token number">3</span>
    <span class="token function">timeout</span> http-request    10s
    <span class="token function">timeout</span> queue           1m
    <span class="token function">timeout</span> connect         10s
    <span class="token function">timeout</span> client          1m
    <span class="token function">timeout</span> server          1m
    <span class="token function">timeout</span> http-keep-alive 10s
    <span class="token function">timeout</span> check           10s
    maxconn                 <span class="token number">3000</span>

<span class="token comment">#---------------------------------------------------------------------</span>
<span class="token comment"># kubernetes apiserver frontend which proxys to the backends</span>
<span class="token comment">#---------------------------------------------------------------------</span>
frontend kubernetes-apiserver
    mode                 tcp
    <span class="token builtin class-name">bind</span>                 *:16443
    option               tcplog
    default_backend      kubernetes-apiserver

<span class="token comment">#---------------------------------------------------------------------</span>
<span class="token comment"># round robin balancing between the various backends</span>
<span class="token comment">#---------------------------------------------------------------------</span>
backend kubernetes-apiserver
    mode        tcp
    balance     roundrobin
    server  k8s-101 <span class="token number">192.168</span>.1.101:6443 check
    server  k8s-102 <span class="token number">192.168</span>.1.102:6443 check
    server  k8s-103 <span class="token number">192.168</span>.1.103:6443 check

<span class="token comment">#---------------------------------------------------------------------</span>
<span class="token comment"># collection haproxy statistics message</span>
<span class="token comment">#---------------------------------------------------------------------</span>
listen stats
    <span class="token builtin class-name">bind</span>                 *:10001
    stats auth           admin:4we50meP455w0rd
    stats refresh        5s
    stats realm          HAProxy<span class="token punctuation">\</span> Statistics
    stats uri            /
EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动后服务后，在浏览器访问任意一台主节点 10001 端口来查询状态。登录使用配置文件中的账号 <code>admin</code> 密码 <code>4we50meP455w0rd</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now haproxy.service</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl status haproxy</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># netstat -ntulp |grep "16443\|10001"</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:10001           <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">28052</span>/haproxy       
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:16443           <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">28052</span>/haproxy    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="部署-keepalived"><a class="markdownIt-Anchor" href="#部署-keepalived"></a> 部署 Keepalived</h3>
<p>Keepalived 以 VRRP（虚拟路由冗余协议）协议为基础，包括一个 master 和多个 backup。master 劫持 VIP 对外提供服务。master 发送组播，backup 节点收不到 VRRP 包时认为 master 宕机，此时选出剩余优先级最高的节点作为新 master 劫持 VIP。</p>
<p>此处的 Keepalived 的主要作用是为 haproxy 提供 VIP（192.168.1.253）。在 3 个 HAProxy 实例之间提供主备，降低当其中一个 HAProxy 失效时对服务的影响。</p>
<p>先在所有主节点上安装 Keepalived：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># yum -y install keepalived psmisc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>选主节点 k8s-101 作为 Keepalived 的 <code>MASTER</code> ，配置文件内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/keepalived/keepalived.conf</span>
global_defs <span class="token punctuation">&#123;</span>
    router_id LVS_DEVEL
    script_user root
    enable_script_security
<span class="token punctuation">&#125;</span>
vrrp_script check_haproxy <span class="token punctuation">&#123;</span>
script <span class="token string">"/bin/bash -c 'if [[ <span class="token variable"><span class="token variable">$(</span><span class="token function">netstat</span> <span class="token parameter variable">-nlp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">16443</span><span class="token variable">)</span></span> ]]; then exit 0; else exit 1; fi'"</span>
interval <span class="token number">2</span>
weight <span class="token parameter variable">-11</span>
<span class="token punctuation">&#125;</span>
vrrp_instance VI_1 <span class="token punctuation">&#123;</span>
    state MASTER
    interface ens32
    virtual_router_id <span class="token number">51</span>
    priority <span class="token number">100</span>
    advert_int <span class="token number">1</span>
    authentication <span class="token punctuation">&#123;</span>
        auth_type PASS
        auth_pass 2G4phJHIK27jPXq2HJs4BG
    <span class="token punctuation">&#125;</span>
    virtual_ipaddress <span class="token punctuation">&#123;</span>
        <span class="token number">192.168</span>.1.253
    <span class="token punctuation">&#125;</span>
track_script <span class="token punctuation">&#123;</span>
check_haproxy
<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他节点的配置修改 <code>vrrp_instance VI_1</code> 中角色 <code>state</code> 为 <code>BACKUP</code>，优先级 <code>priority</code> 为 90：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-102 ~<span class="token punctuation">]</span><span class="token comment"># vi /etc/keepalived/keepalived.conf</span>
global_defs <span class="token punctuation">&#123;</span>
    router_id LVS_DEVEL
    script_user root
    enable_script_security
<span class="token punctuation">&#125;</span>
vrrp_script check_haproxy <span class="token punctuation">&#123;</span>
script <span class="token string">"/bin/bash -c 'if [[ <span class="token variable"><span class="token variable">$(</span><span class="token function">netstat</span> <span class="token parameter variable">-nlp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">16443</span><span class="token variable">)</span></span> ]]; then exit 0; else exit 1; fi'"</span>
interval <span class="token number">2</span>
weight <span class="token parameter variable">-11</span>
<span class="token punctuation">&#125;</span>
vrrp_instance VI_1 <span class="token punctuation">&#123;</span>
    state BACKUP
    interface ens32
    virtual_router_id <span class="token number">51</span>
    priority <span class="token number">90</span>
    advert_int <span class="token number">1</span>
    authentication <span class="token punctuation">&#123;</span>
        auth_type PASS
        auth_pass 2G4phJHIK27jPXq2HJs4BG
    <span class="token punctuation">&#125;</span>
    virtual_ipaddress <span class="token punctuation">&#123;</span>
        <span class="token number">192.168</span>.1.253
    <span class="token punctuation">&#125;</span>
track_script <span class="token punctuation">&#123;</span>
check_haproxy
<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件中主要配置项有：</p>
<ul>
<li><code>vrrp_script check_haproxy&#123;&#125;</code>：检测 HAProxy 进程是否存活脚本。每 2 秒检测本地 HAProxy 监听端口 16443。如果端口没响应，优先级分数会被减去 11，VIP 地址会转移到更高优先级的节点。</li>
<li><code>state MASTER</code>：指定节点角色。</li>
<li><code>interface ens32</code>：指定 VIP 地址绑定网卡名称。</li>
<li><code>virtual_router_id 51</code>：虚拟路由组的 ID。</li>
<li><code>priority 100</code>：节点优先级。</li>
<li><code>authentication</code>：节点之间认证密码。</li>
<li><code>virtual_ipaddress&#123;&#125;</code>：VIP 虚拟 IP 地址。</li>
</ul>
<p>配置好后，在所有主节点启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl enable --now keepalived.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意，重启网络服务后，必须连带重启 Keepalived 服务，否则 VIP 地址会失效。</p>
<h3 id="测试故障转移"><a class="markdownIt-Anchor" href="#测试故障转移"></a> 测试故障转移</h3>
<p>使用 <code>ip a s</code> 查看当前 VIP 绑定的主机，并在停止绑定主机上停止 Keepalived 或 HAProxy 服务后，观察 VIP 的漂移：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># ip a s</span>
<span class="token number">2</span>: ens32: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UP group default qlen <span class="token number">1000</span>
    link/ether 00:0c:29:f3:57:42 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">192.168</span>.1.101/24 brd <span class="token number">192.168</span>.1.255 scope global noprefixroute ens32
       valid_lft forever preferred_lft forever
    inet <span class="token number">192.168</span>.1.253/32 scope global ens32
       valid_lft forever preferred_lft forever
    inet6 fe80::e99f:f473:5c6b:60e9/64 scope <span class="token function">link</span> noprefixroute 
       valid_lft forever preferred_lft forever
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl stop haproxy</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># netstat -ntulp |grep 16443</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># ip a s</span>
<span class="token number">2</span>: ens32: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UP group default qlen <span class="token number">1000</span>
    link/ether 00:0c:29:f3:57:42 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">192.168</span>.1.101/24 brd <span class="token number">192.168</span>.1.255 scope global noprefixroute ens32
       valid_lft forever preferred_lft forever
    inet6 fe80::e99f:f473:5c6b:60e9/64 scope <span class="token function">link</span> noprefixroute 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 k8s-101 上关闭 HAProxy 服务后，VIP 地址已经转移到别的节点上面。即使 k8s-101 节点重新启动也不会转移回去：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-103 ~<span class="token punctuation">]</span><span class="token comment"># ip a s</span>
<span class="token number">2</span>: ens32: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UP group default qlen <span class="token number">1000</span>
    link/ether 00:50:56:22:32:88 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">192.168</span>.1.103/24 brd <span class="token number">192.168</span>.1.255 scope global noprefixroute ens32
       valid_lft forever preferred_lft forever
    inet <span class="token number">192.168</span>.1.253/32 scope global ens32
       valid_lft forever preferred_lft forever
    inet6 fe80::2526:9131:23cc:8de8/64 scope <span class="token function">link</span> noprefixroute 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立集群"><a class="markdownIt-Anchor" href="#建立集群"></a> 建立集群</h2>
<p>为了组成高可用集群，至少需要 3 个主节点，否则会出现脑裂现象。</p>
<h3 id="初始化主节点"><a class="markdownIt-Anchor" href="#初始化主节点"></a> 初始化主节点</h3>
<p>采用 kubeadm 来部署集群，首先需要初始化一个主节点。</p>
<p>可以生成默认的 <code>kubeadm-master.config</code> 配置文件，并在修改后指定使用该配置运行命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm config print init-defaults > /etc/kubernetes/kubeadm-master.config</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm init --config=/etc/kubernetes/kubeadm-master.config --upload-certs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>或者，可以使用指定的参数来初始化主节点：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm init --apiserver-advertise-address=192.168.1.101 --image-repository=registry.aliyuncs.com/google_containers --kubernetes-version=v1.22.3 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>常见参数配置说明如下：</p>
<ul>
<li><code>--apiserver-advertise-address</code>：第一个主节点的 IP 地址，一般为内网地址。</li>
<li><code>--image-repository</code>：设置镜像仓库地址。</li>
<li><code>--kubernetes-version</code>：设置 Kubernetes 版本。版本高于 1.23 无法使用 Docker 容器运行时。</li>
<li><code>--service-cidr</code>：设置服务器通信使用的 IP 网段。默认为 <code>10.96.0.0/12</code></li>
<li><code>--pod-network-cidr</code>：设置内部的 Pod 节点之间网络可以使用的 IP 段。对于使用不同的网络插件，默认值有所不同。常见的网络插件默认值配置如下：
<ul>
<li>Calico 网络插件：默认为 <code>192.168.0.0/16</code>。</li>
<li>Flannel 网络插件：默认为 <code>10.244.0.0/16</code>。</li>
<li>Weave 网络插件：默认为 <code>10.32.0.0/12</code>。</li>
</ul>
</li>
<li><code>--upload-certs</code>：上传证书到 <code>kubeadm-certs</code> Secret。</li>
<li><code>--control-plane-endpoint</code>：设置控制节点主机地址。</li>
</ul>
<p>下面使用声明的变量来生成配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># export APISERVER_ADVERTISE_ADDRESS=192.168.1.101</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># export KUBERNETES_VERSION=v1.22.3</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># export SERVICE_CIDR=10.96.0.0/16</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># export POD_NETWORK_CIDR=10.244.0.1/16</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># export CONTROL_PLANE_ENDPOINT=192.168.1.253:16443</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /hxz393/local/k8s/config/</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cat &lt;&lt;EOF > /hxz393/local/k8s/config/kubeadm-config.yaml</span>
apiVersion: kubeadm.k8s.io/v1beta3
kind: ClusterConfiguration
kubernetesVersion: <span class="token string">"<span class="token variable">$&#123;KUBERNETES_VERSION&#125;</span>"</span>
imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers
controlPlaneEndpoint: <span class="token string">"<span class="token variable">$&#123;CONTROL_PLANE_ENDPOINT&#125;</span>"</span>
networking:
  serviceSubnet: <span class="token string">"<span class="token variable">$&#123;SERVICE_CIDR&#125;</span>"</span>
  podSubnet: <span class="token string">"<span class="token variable">$&#123;POD_NETWORK_CIDR&#125;</span>"</span>
  dnsDomain: <span class="token string">"cluster.local"</span>
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm init --config=/hxz393/local/k8s/config/kubeadm-config.yaml --upload-certs</span>
Your Kubernetes control-plane has initialized successfully<span class="token operator">!</span>

To start using your cluster, you need to run the following as a regular user:

  <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube
  <span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config
  <span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config

Alternatively, <span class="token keyword">if</span> you are the root user, you can run:

  <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run <span class="token string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now <span class="token function">join</span> any number of the control-plane <span class="token function">node</span> running the following <span class="token builtin class-name">command</span> on each as root:

  kubeadm <span class="token function">join</span> k8s-250:6443 <span class="token parameter variable">--token</span> 66e1on.yh84w71x6mauu6em <span class="token punctuation">\</span>
        --discovery-token-ca-cert-hash sha256:5849bdad8508feeb3b40e634f7c97f074eb79705d365d097ee75a44374545715 <span class="token punctuation">\</span>
        --control-plane --certificate-key 337bb228b52a88c297d72102652834aeef9666b847247b2b17471a78236af909

Please note that the certificate-key gives access to cluster sensitive data, keep it secret<span class="token operator">!</span>
As a safeguard, uploaded-certs will be deleted <span class="token keyword">in</span> two hours<span class="token punctuation">;</span> If necessary, you can use
<span class="token string">"kubeadm init phase upload-certs --upload-certs"</span> to reload certs afterward.

Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:

kubeadm <span class="token function">join</span> k8s-250:6443 <span class="token parameter variable">--token</span> 66e1on.yh84w71x6mauu6em <span class="token punctuation">\</span>
        --discovery-token-ca-cert-hash sha256:5849bdad8508feeb3b40e634f7c97f074eb79705d365d097ee75a44374545715 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面是主节点搭建成功后，输出后续操作提示。如果因为拉取镜像时间太长导致失败，可以用下面命令提前拉取镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm config images pull --image-repository=registry.aliyuncs.com/google_containers</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="配置-kubectl"><a class="markdownIt-Anchor" href="#配置-kubectl"></a> 配置 Kubectl</h3>
<p>按照提示，将变量声明写入到 <code>.bashrc</code> 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "export KUBECONFIG=/etc/kubernetes/admin.conf" >>~/.bashrc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者，将 <code>admin.conf</code> 放入 <code>$HOME/.kube</code> 目录中，才能使用 <code>kubectl</code> 命令操作集群：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config &amp;&amp; cp -i /etc/kubernetes/admin.conf /hxz393/local/k8s/config/admin.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样地，可以将 <code>admin.conf</code> 放入其他用户的家目录或其他主机上，以赋予其集群管理权限。请注意修改配置文件的所有者和权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ <span class="token function">scp</span> /etc/kubernetes/admin.conf shareuser@192.168.1.248:/home/shareuser/.kube/config
<span class="token punctuation">[</span>root@k8s-248 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token parameter variable">-R</span> shareuser:shareuser /home/shareuser/.kube
<span class="token punctuation">[</span>root@k8s-248 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span> /home/shareuser/.kube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>配置 <code>kubectl</code> 命令的自动补全：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "source &lt;(kubectl completion bash)" >>~/.bashrc</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># source ~/.bashrc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="部署网络"><a class="markdownIt-Anchor" href="#部署网络"></a> 部署网络</h3>
<p>可以选择安装高性能的 Underlay 网络，如 Flannel 或 Calico。只能安装其中一种网络。</p>
<ul>
<li>
<p><strong>Flannel</strong></p>
<p>官方网站提供的安装 Flannel 网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span>
Warning: policy/v1beta1 PodSecurityPolicy is deprecated <span class="token keyword">in</span> v1.21+, unavailable <span class="token keyword">in</span> v1.25+
podsecuritypolicy.policy/psp.flannel.unprivileged created
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 <code>githubusercontent.com</code> 经常连接不通，可以手动将 <code>kube-flannel.yml</code> 下载下来后部署：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/k8s/apply/kube-flannel.yml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><strong>Calico</strong></p>
<p>使用以下方式安装 Calico 网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># wget https://kuboard.cn/install-script/calico/calico-3.9.2.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s#192\.168\.0\.0/16#$&#123;pod_SUBNET&#125;#" calico-3.9.2.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f calico-3.9.2.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>根据官方网站提供的安装方式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl create -f https://docs.projectcalico.org/manifests/custom-resources.yaml</span>
installation.operator.tigera.io/default created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="完成部署"><a class="markdownIt-Anchor" href="#完成部署"></a> 完成部署</h3>
<p>等待网络部署完成，所有 8 个容器都部署完毕后，主节点就搭建好了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod -n kube-system -o wide --watch</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># journalctl -u kubelet -f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>添加 Node 标签，其中 NodeRole 角色名可以是 master（主节点）或 worker（从节点）。NodeName 是主机名，NodeEnv 可以是 base（基础服务）或 app（应用）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-101 NodeRole=master</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-101 NodeName=k8s-101</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-101 NodeEnv=local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="加入集群"><a class="markdownIt-Anchor" href="#加入集群"></a> 加入集群</h2>
<p>加入集群按照以下步骤进行操作。加入失败时，可以在加入命令加上 <code>--v=5</code> 来显示详细错误日志。</p>
<h3 id="获取参数"><a class="markdownIt-Anchor" href="#获取参数"></a> 获取参数</h3>
<p>加入集群所需的 3 个参数如下：</p>
<ul>
<li>
<p><strong>Token</strong></p>
<p>token 的有效期为 1 天。在失效后，可以使用 <code>kubeadm token create</code> 命令重新创建：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm token create</span>
xjp771.yrjc4oe1thjjt112
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm token list</span>
TOKEN                     TTL         EXPIRES                USAGES                   DESCRIPTION                                                EXTRA <span class="token environment constant">GROUPS</span>
xjp771.yrjc4oe1thjjt112   23h         <span class="token number">2022</span>-04-21T02:14:35Z   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                     system:bootstrappers:kubeadm:default-node-token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><strong>Discovery Token CA Cert Hash</strong></p>
<p>获得 discovery-token-ca-cert-hash 参数的方法如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'</span>
1499ca908be1d430887b67d4dbfff06a5374cf3d340d3c0ba9db1aa51ad9ddfb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p><strong>Certificate Key</strong></p>
<p>直接更新证书来获取 certificate-key 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm init phase upload-certs --upload-certs</span>
I0420 <span class="token number">10</span>:15:58.086168    <span class="token number">6701</span> version.go:255<span class="token punctuation">]</span> remote version is much newer: v1.23.5<span class="token punctuation">;</span> falling back to: stable-1.22
<span class="token punctuation">[</span>upload-certs<span class="token punctuation">]</span> Storing the certificates <span class="token keyword">in</span> Secret <span class="token string">"kubeadm-certs"</span> <span class="token keyword">in</span> the <span class="token string">"kube-system"</span> Namespace
<span class="token punctuation">[</span>upload-certs<span class="token punctuation">]</span> Using certificate key:
937bf7194bd6e346e177f3a64de9ec01e9043828cb263f0ed80bddc359a351e2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="加入从节点"><a class="markdownIt-Anchor" href="#加入从节点"></a> 加入从节点</h3>
<p>加入从节点只需要使用 <code>token</code> 和 <code>discovery-token-ca-cert-hash</code> 参数。指定集群的 Control Plane 地址（192.168.1.253:16443）或单个主节点的 IP 地址加端口号 6443（192.168.1.101:6443），并使用 <code>kubeadm join</code> 命令将从节点加入集群：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "192.168.1.101   k8s-101" >> /etc/hosts</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm join k8s-101:6443 --token xjp771.yrjc4oe1thjjt112 --discovery-token-ca-cert-hash sha256:1499ca908be1d430887b67d4dbfff06a5374cf3d340d3c0ba9db1aa51ad9ddfb</span>
This <span class="token function">node</span> has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run <span class="token string">'kubectl get nodes'</span> on the control-plane to see this <span class="token function">node</span> <span class="token function">join</span> the cluster.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加入成功后，在主节点给新节点标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-104 NodeRole=worker</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-104 NodeName=k8s-104</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-104 NodeEnv=local</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-104 node-role.kubernetes.io/worker=app</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="加入主节点"><a class="markdownIt-Anchor" href="#加入主节点"></a> 加入主节点</h3>
<p>加入主节点的步骤与加入从节点类似，多需要提供一个 <code>--certificate-key</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "192.168.1.101   k8s-101" >> /etc/hosts</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm join k8s-101:644 --token 4sz9hf.dwt05n1ohpb772au \</span>
        --discovery-token-ca-cert-hash sha256:864ee6f29ac83d7ec0db3e75c2b54a70ac7622c8c82e52cc71511255febf5b28 <span class="token punctuation">\</span>
        --control-plane --certificate-key af928d1032d723ae3f16c7218b07afb41b4d588d746bbeb6ed9c657a460591cd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加集群控制权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># echo "source &lt;(kubectl completion bash)" >>~/.bashrc</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># source ~/.bashrc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>添加节点标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-249 NodeRole=master</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-249 NodeName=k8s-249</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl label node k8s-249 NodeEnv=base</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="等待完成"><a class="markdownIt-Anchor" href="#等待完成"></a> 等待完成</h3>
<p>查看已加入的节点：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get node</span>
NAME      STATUS     ROLES                  AGE   VERSION
k8s-101   Ready      control-plane,master   25m   v1.22.3
k8s-104   NotReady   <span class="token operator">&lt;</span>none<span class="token operator">></span>                 95s   v1.22.3
k8s-105   NotReady   <span class="token operator">&lt;</span>none<span class="token operator">></span>                 95s   v1.22.3
k8s-106   NotReady   <span class="token operator">&lt;</span>none<span class="token operator">></span>                 87s   v1.22.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>--all-namespaces</code> 参数来查看所有节点上的容器运行信息，确保所有的 Pod 都处于运行状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod --all-namespaces -o wide</span>
NAMESPACE     NAME                              READY   STATUS    AGE     IP              NODE      
kube-system   coredns-7d89d9b6b8-6p4wt          <span class="token number">1</span>/1     Running   26m     <span class="token number">10.244</span>.0.2      k8s-101   
kube-system   coredns-7d89d9b6b8-dd5h6          <span class="token number">1</span>/1     Running   26m     <span class="token number">10.244</span>.0.3      k8s-101   
kube-system   etcd-k8s-101                      <span class="token number">1</span>/1     Running   26m     <span class="token number">192.168</span>.1.101   k8s-101   
kube-system   kube-apiserver-k8s-101            <span class="token number">1</span>/1     Running   26m     <span class="token number">192.168</span>.1.101   k8s-101   
kube-system   kube-controller-manager-k8s-101   <span class="token number">1</span>/1     Running   26m     <span class="token number">192.168</span>.1.101   k8s-101   
kube-system   kube-flannel-ds-bhck2             <span class="token number">1</span>/1     Running   2m17s   <span class="token number">192.168</span>.1.105   k8s-105   
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get all --all-namespaces </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="移除节点"><a class="markdownIt-Anchor" href="#移除节点"></a> 移除节点</h2>
<p>如果想从集群中移除节点，首先使用 <code>drain</code> 命令驱逐节点上运行的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl drain k8s-249 --ignore-daemonsets
node/k8s-249 cordoned
WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-flannel-ds-8rfqm, kube-system/kube-proxy-qnxcw
evicting pod base/zookeeper-2
evicting pod base/zookeeper-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在所有的 Pod 转移完成后，可以运行以下命令删除节点（主节点还需要手动修改 <code>etcd</code> 数据库）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl delete <span class="token function">node</span> k8s-249
<span class="token function">node</span> <span class="token string">"k8s-249"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后在要移除的节点上运行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">yes</span> <span class="token operator">|</span> kubeadm reset
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/cni/ /etc/cni/net.d <span class="token environment constant">$HOME</span>/.kube/config /var/lib/etcd
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> cni0 down
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> <span class="token function">link</span> delete cni0
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> flannel.1 down
<span class="token punctuation">[</span>root@k8s-249 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> <span class="token function">link</span> delete flannel.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="节点配置"><a class="markdownIt-Anchor" href="#节点配置"></a> 节点配置</h2>
<p>安装完毕后还需要做一些配置修改和初始化工作。</p>
<h3 id="主节点配置-2"><a class="markdownIt-Anchor" href="#主节点配置-2"></a> 主节点配置</h3>
<p>开发环境下，为了允许在主节点上部署应用程序，需要移除主节点上的污点（去除 <code>taint</code> 命令最后的减号 <code>-</code> 则是重新加入污点）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl taint nodes --all node-role.kubernetes.io/master=true:NoSchedule-</span>
node/k8s-101 untainted
node/k8s-102 untainted
node/k8s-103 untainted
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get no -o yaml | grep taint -A 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改 <code>NodePort</code> 端口范围为无限制。在 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> 文件中加入一行配置 <code>- --service-node-port-range=1-65535</code> ，配置会自动更新:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i '40a\    - --service-node-port-range=1-65535' /etc/kubernetes/manifests/kube-apiserver.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/kubernetes/manifests/kube-apiserver.yaml</span>
    - --tls-cert-file<span class="token operator">=</span>/etc/kubernetes/pki/apiserver.crt
    - --tls-private-key-file<span class="token operator">=</span>/etc/kubernetes/pki/apiserver.key
    - --service-node-port-range<span class="token operator">=</span><span class="token number">1</span>-65535
    image: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.22.3
    imagePullPolicy: IfNotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注释掉 <code>/etc/kubernetes/manifests/kube-controller-manager.yaml</code> 和 <code>/etc/kubernetes/manifests/kube-scheduler.yaml</code> 文件中的端口绑定，免得健康检查一直报错：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/    - --port=0/#    - --port=0/g" /etc/kubernetes/manifests/kube-controller-manager.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/    - --port=0/#    - --port=0/g" /etc/kubernetes/manifests/kube-scheduler.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/    - --bind-address=127.0.0.1/    - --bind-address=0.0.0.0/g" /etc/kubernetes/manifests/kube-controller-manager.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i "s/    - --bind-address=127.0.0.1/    - --bind-address=0.0.0.0/g" /etc/kubernetes/manifests/kube-scheduler.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart kubelet.service</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get cs</span>
Warning: v1 ComponentStatus is deprecated <span class="token keyword">in</span> v1.19+
NAME                 STATUS    MESSAGE                         ERROR
scheduler            Healthy   ok                              
controller-manager   Healthy   ok                              
etcd-0               Healthy   <span class="token punctuation">&#123;</span><span class="token string">"health"</span><span class="token builtin class-name">:</span><span class="token string">"true"</span>,<span class="token string">"reason"</span><span class="token builtin class-name">:</span><span class="token string">""</span><span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改节点预留服务器资源，预留 1 核 CPU 加 1 GB 内存：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># sed -i '38a\systemReserved:\n  cpu: "500m"\n  memory: "500Mi"\nkubeReserved:\n  cpu: "500m"\n  memory: "500Mi"' /var/lib/kubelet/config.yaml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart kubelet.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="从节点配置"><a class="markdownIt-Anchor" href="#从节点配置"></a> 从节点配置</h3>
<p>修改节点预留服务器资源:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-104 ~<span class="token punctuation">]</span><span class="token comment"># sed -i '38a\systemReserved:\n  cpu: "500m"\n  memory: "500Mi"\nkubeReserved:\n  cpu: "500m"\n  memory: "500Mi"' /var/lib/kubelet/config.yaml</span>
<span class="token punctuation">[</span>root@k8s-104 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart kubelet.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="集群配置"><a class="markdownIt-Anchor" href="#集群配置"></a> 集群配置</h2>
<p>以下是一些常见的配置项目。</p>
<h3 id="建立命名空间"><a class="markdownIt-Anchor" href="#建立命名空间"></a> 建立命名空间</h3>
<p>可依据需要建立多命名空间，来区分不同的环境。例如：用 <code>dev</code> 表示开发环境、用 <code>test</code> 表示测试环境、用 <code>base</code> 表示基础服务环境：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /hxz393/local/k8s/apply/kube-namespaces.yml&lt;&lt;EOF</span>
apiVersion: v1
kind: Namespace
metadata:
  name: <span class="token builtin class-name">local</span>
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /hxz393/local/k8s/apply/kube-namespaces.yml</span>
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl get namespaces </span>
NAME              STATUS   AGE
default           Active   69m
kube-node-lease   Active   69m
kube-public       Active   69m
kube-system       Active   69m
<span class="token builtin class-name">local</span>             Active   23m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="绑定权限"><a class="markdownIt-Anchor" href="#绑定权限"></a> 绑定权限</h3>
<p>有时为了测试目的，需要将集群管理员角色绑定到对应命名空间默认 <code>sa</code>（service account）账号上。这样默认命名空间中应用可以访问其他命名空间的资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># tee /nanruan/test/k8s/apply/kube-crb.yml&lt;&lt;EOF</span>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: default
  namespace: <span class="token builtin class-name">local</span>
EOF
<span class="token punctuation">[</span>root@k8s-101 ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f /nanruan/test/k8s/apply/test-crb.yml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="阿里云部署"><a class="markdownIt-Anchor" href="#阿里云部署"></a> 阿里云部署</h2>
<p>在阿里云上部署 Kubernetes 时，ECS 不支持自建 VIP。但将 SLB 的 VIP 指定为高可用地址时，初始化主节点会失败。这是因为 4 层 SLB 不支持其调度的后端服务器访问其 VIP，也就是服务器不能同时充当服务端和客户端。</p>
<p>解决方法如下：</p>
<ul>
<li>在从节点部署 <code>HAProxy</code>，并监听 <code>16443</code> 端口，后端服务器指向主节点 <code>6443</code> 端口。</li>
<li>在 CLB（传统型负载均衡，原 SLB）上新建虚拟服务器组 <code>k8s-haproxy</code>，将安装有 <code>HAProxy</code> 的从节点加进去，监听端口为 <code>16443</code>。</li>
<li>在监听页新建监听配置 <code>k8s_haproxy</code>，选择监听 <code>TCP/6443</code> 端口，后端服务器选择虚拟服务器组 <code>k8s-haproxy</code>，开启健康检查，提交。</li>
<li>如果不需要通过外网来管理集群，可以修改监听 <code>k8s_haproxy</code> 的访问控制。例如添加内网 IP 地址段 <code>172.16.0.0/16</code> 到白名单，这样可以防止集群对外暴露。</li>
<li>在建立集群时，配置 <code>controlPlaneEndpoint</code> 的值为 <code>&lt;CLB内网IP地址&gt;:6443</code>。例如：<code>--control-plane-endpoint=172.16.17.100:6443</code>。</li>
<li>加入集群时，使用<code>controlPlaneEndpoint</code> 的值。例如：<code>kubeadm join 172.16.17.100:6443</code>。</li>
</ul>
<p>如果需要通过外网来管理集群，可在主节点上将 CLB 的外网 IP 地址更新进去，重新生成证书：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master1-pro ~<span class="token punctuation">]</span><span class="token comment"># mkdir -pv /opt/cert &amp;&amp; mv /etc/kubernetes/pki/apiserver.* /opt/cert</span>
<span class="token punctuation">[</span>root@k8s-master1-pro ~<span class="token punctuation">]</span><span class="token comment"># kubeadm init phase certs apiserver --apiserver-advertise-address 172.16.17.100 --apiserver-cert-extra-sans 110.112.110.102 --apiserver-cert-extra-sans 172.16.17.99 --apiserver-cert-extra-sans 80.114.163.80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其他关于解决此问题的参考连接：</p>
<p><a href="https://www.cnblogs.com/gmmy/p/12372805.html">https://www.cnblogs.com/gmmy/p/12372805.html</a></p>
<p><a href="https://www.cnblogs.com/noah-luo/p/13218837.html">https://www.cnblogs.com/noah-luo/p/13218837.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107703112">https://zhuanlan.zhihu.com/p/107703112</a></p>
<p><a href="https://blog.51cto.com/caiyuanji/2405434">https://blog.51cto.com/caiyuanji/2405434</a></p>
<p><a href="https://www.jianshu.com/p/ba94db1c3599">https://www.jianshu.com/p/ba94db1c3599</a></p>
<p><a href="https://blog.csdn.net/weixin_44334279/article/details/119355653">https://blog.csdn.net/weixin_44334279/article/details/119355653</a></p>
<p><a href="https://www.jianshu.com/p/d645bbe8e621">https://www.jianshu.com/p/d645bbe8e621</a></p>
<p><a href="https://www.kubernetes.org.cn/7033.html">https://www.kubernetes.org.cn/7033.html</a></p>
<h1 id="单点集群部署"><a class="markdownIt-Anchor" href="#单点集群部署"></a> 单点集群部署</h1>
<p>这里以一主一从的方式，搭建单主节点集群。主节点系统为 Ubuntu。</p>
<h2 id="安装组件-2"><a class="markdownIt-Anchor" href="#安装组件-2"></a> 安装组件</h2>
<p>在所有节点安装基础组件 Kubectl、Kubelet 和 Kubeadm，版本选择为 1.23.17：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - </span>
root@ubuntu22:~<span class="token comment"># apt-add-repository -y "deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main"</span>
root@ubuntu22:~<span class="token comment"># apt install -y kubelet=1.23.17-00 kubeadm=1.23.17-00 kubectl=1.23.17-00</span>
root@ubuntu22:~<span class="token comment"># tee /etc/sysconfig/kubelet&lt;&lt;EOF</span>
<span class="token assign-left variable">KUBELET_EXTRA_ARGS</span><span class="token operator">=</span><span class="token string">"--cgroup-driver=systemd --runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.2"</span>
EOF
root@ubuntu22:~<span class="token comment"># systemctl daemon-reload</span>
root@ubuntu22:~<span class="token comment"># systemctl enable --now kubelet</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立集群-2"><a class="markdownIt-Anchor" href="#建立集群-2"></a> 建立集群</h2>
<p>首先初始化一个主节点。</p>
<h3 id="声明变量"><a class="markdownIt-Anchor" href="#声明变量"></a> 声明变量</h3>
<p>设置的控制中心地址本机 IP 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># export APISERVER_ADVERTISE_ADDRESS=192.168.0.102</span>
root@ubuntu22:~<span class="token comment"># export KUBERNETES_VERSION=v1.23.17</span>
root@ubuntu22:~<span class="token comment"># export SERVICE_CIDR=10.96.0.0/12</span>
root@ubuntu22:~<span class="token comment"># export POD_NETWORK_CIDR=10.244.0.0/16</span>
root@ubuntu22:~<span class="token comment"># export CONTROL_PLANE_ENDPOINT=192.168.0.102:6443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="初始化-2"><a class="markdownIt-Anchor" href="#初始化-2"></a> 初始化</h3>
<p>使用 <code>kubeadm init</code> 命令执行初始化：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># mkdir -p /hxz393/pre/k8s/&#123;apply,config&#125;</span>
root@ubuntu22:~<span class="token comment"># cat &lt;&lt;EOF > /hxz393/pre/k8s/config/kubeadm-config.yaml</span>
apiVersion: kubeadm.k8s.io/v1beta3
kind: ClusterConfiguration
kubernetesVersion: <span class="token string">"<span class="token variable">$&#123;KUBERNETES_VERSION&#125;</span>"</span>
imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers
controlPlaneEndpoint: <span class="token string">"<span class="token variable">$&#123;CONTROL_PLANE_ENDPOINT&#125;</span>"</span>
networking:
  serviceSubnet: <span class="token string">"<span class="token variable">$&#123;SERVICE_CIDR&#125;</span>"</span>
  podSubnet: <span class="token string">"<span class="token variable">$&#123;POD_NETWORK_CIDR&#125;</span>"</span>
  dnsDomain: <span class="token string">"cluster.local"</span>
EOF
root@ubuntu22:~<span class="token comment"># kubeadm init --config=/hxz393/pre/k8s/config/kubeadm-config.yaml --upload-certs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>成功后输出后续操作提示，可以记一下加入集群命令。</p>
<h3 id="获取权限"><a class="markdownIt-Anchor" href="#获取权限"></a> 获取权限</h3>
<p>获取 root 用户集群管理权：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># mkdir -p $HOME/.kube &amp;&amp; cp -i /etc/kubernetes/admin.conf $HOME/.kube/config &amp;&amp; cp -i /etc/kubernetes/admin.conf /hxz393/pre/k8s/config/admin.conf</span>
root@ubuntu22:~<span class="token comment"># echo "source &lt;(kubectl completion bash)" >>~/.bashrc</span>
root@ubuntu22:~<span class="token comment"># source ~/.bashrc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="部署网络-2"><a class="markdownIt-Anchor" href="#部署网络-2"></a> 部署网络</h3>
<p>部署 flannel 网络插件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># kubectl apply -f /hxz393/pre/k8s/apply/kube-flannel.yml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="完成部署-2"><a class="markdownIt-Anchor" href="#完成部署-2"></a> 完成部署</h3>
<p>给主节点添加标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># kubectl label node ubuntu22 NodeRole=master</span>
root@ubuntu22:~<span class="token comment"># kubectl label node ubuntu22 NodeName=ubuntu22</span>
root@ubuntu22:~<span class="token comment"># kubectl label node ubuntu22 NodeEnv=pre</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="加入集群-2"><a class="markdownIt-Anchor" href="#加入集群-2"></a> 加入集群</h2>
<p>加入从节点只需要运行集群建立后的提示命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># echo "192.168.0.102   ubuntu22" >> /etc/hosts</span>
<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm join 192.168.0.102:6443 --token 8owkqz.jopga29w7j9f8q6k \</span>
        --discovery-token-ca-cert-hash sha256:1f796318f606fafa7aa1e8429707c752533b5d534da0108f30b5a423bd386215 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>添加从节点标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># kubectl label node centos7 NodeName=centos7</span>
root@ubuntu22:~<span class="token comment"># kubectl label node centos7 NodeEnv=pre</span>
root@ubuntu22:~<span class="token comment"># kubectl label node centos7 node-role.kubernetes.io/worker=app</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="主节点配置-3"><a class="markdownIt-Anchor" href="#主节点配置-3"></a> 主节点配置</h2>
<p>视需要移除主节点上的污点来允许部署：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># kubectl taint nodes --all node-role.kubernetes.io/master=true:NoSchedule-</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改静态配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># sed -i '40a\    - --service-node-port-range=1-65535' /etc/kubernetes/manifests/kube-apiserver.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i '40a\    - --service-node-port-range=1-65535' /etc/kubernetes/manifests/kube-apiserver.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i "s/    - --port=0/#    - --port=0/g" /etc/kubernetes/manifests/kube-controller-manager.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i "s/    - --port=0/#    - --port=0/g" /etc/kubernetes/manifests/kube-scheduler.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i "s/    - --bind-address=127.0.0.1/    - --bind-address=0.0.0.0/g" /etc/kubernetes/manifests/kube-controller-manager.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i "s/    - --bind-address=127.0.0.1/    - --bind-address=0.0.0.0/g" /etc/kubernetes/manifests/kube-scheduler.yaml</span>
root@ubuntu22:~<span class="token comment"># sed -i '38a\systemReserved:\n  cpu: "500m"\n  memory: "500Mi"\nkubeReserved:\n  cpu: "500m"\n  memory: "500Mi"' /var/lib/kubelet/config.yaml</span>
root@ubuntu22:~<span class="token comment"># systemctl restart kubelet.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立命名空间-2"><a class="markdownIt-Anchor" href="#建立命名空间-2"></a> 建立命名空间</h2>
<p>建立命名空间 pre 表示预发布环境：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu22:~<span class="token comment"># tee /hxz393/pre/k8s/apply/kube-namespaces.yml&lt;&lt;EOF</span>
apiVersion: v1
kind: Namespace
metadata:
  name: pre
EOF
root@ubuntu22:~<span class="token comment"># kubectl apply -f /hxz393/pre/k8s/apply/kube-namespaces.yml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="集群升级"><a class="markdownIt-Anchor" href="#集群升级"></a> 集群升级</h1>
<p>整个集群升级需要分三步进行：</p>
<ul>
<li>第一步是主节点升级 <code>kubeadm</code> 和 <code>kubectl</code>。</li>
<li>第二步是主节点升级 <code>kubelet</code>。</li>
<li>第三步是从节点升级 <code>kubelet</code>。</li>
</ul>
<p>主节点升级 <code>kubeadm</code> 和 <code>kubectl</code> 不会对集群的运行产生影响：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ yum list <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'kubeadm\|kubectl\|kubelet'</span>
kubeadm.x86_64                           <span class="token number">1.22</span>.3-0                      @kubernetes
kubectl.x86_64                           <span class="token number">1.22</span>.3-0                      @kubernetes
kubelet.x86_64                           <span class="token number">1.22</span>.3-0                      @kubernetes
kubeadm.x86_64                           <span class="token number">1.23</span>.5-0                      kubernetes
kubectl.x86_64                           <span class="token number">1.23</span>.5-0                      kubernetes
kubelet.x86_64                           <span class="token number">1.23</span>.5-0                      kubernetes
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> kubeadm-1.23.5-0 kubectl-1.23.5-0
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubeadm upgrade plan
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubeadm upgrade apply v1.23.5-0 <span class="token parameter variable">--config</span> /nanruan/base/k8s/kubeadm/kubeadm-config.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主节点和从节点升级 <code>kubelet</code> 的步骤是一样的。首先禁用调度，然后升级并重启 <code>kubelet</code>，最后恢复允许调度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl drain k8s-250 --ignore-daemonsets
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> kubelet-1.23.5-0
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ systemctl daemon-reload
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ systemctl restart kubelet
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ systemctl status kubelet
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl uncordon k8s-250
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl get nodes
<span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ kubectl get all --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="故障处理"><a class="markdownIt-Anchor" href="#故障处理"></a> 故障处理</h1>
<p>一些集群组建时遇到的问题。</p>
<h2 id="没有-pod-network-cidr"><a class="markdownIt-Anchor" href="#没有-pod-network-cidr"></a> 没有 pod-network-cidr</h2>
<p>在安装 Flannel 时，出现错误提示缺少分配的 Pod CIDR。这可能是因为在使用 kubeadm 初始化时没有指定 <code>--pod-network-cidr</code> 参数，或者 <code>kube-flannel.yml</code> 文件中的 “Network” 字段与 <code>--pod-network-cidr</code> 参数不一致：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl logs <span class="token parameter variable">-n</span> kube-system kube-flannel-ds-7xp24 
I1103 04:42:22.796211       <span class="token number">1</span> vxlan.go:137<span class="token punctuation">]</span> VXLAN config: <span class="token assign-left variable">VNI</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">Port</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">GBP</span><span class="token operator">=</span>false <span class="token assign-left variable">Learning</span><span class="token operator">=</span>false <span class="token assign-left variable">DirectRouting</span><span class="token operator">=</span>false
E1103 04:42:22.797028       <span class="token number">1</span> main.go:325<span class="token punctuation">]</span> Error registering network: failed to acquire lease: <span class="token function">node</span> <span class="token string">"server4-master"</span> pod cidr not assigned
I1103 04:42:22.797248       <span class="token number">1</span> main.go:439<span class="token punctuation">]</span> Stopping shutdownHandler<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要解决此问题，可以修改 <code>kube-controller-manager.yaml</code> 配置文件，在其中添加 <code>- --allocate-node-cidrs=true</code> 和 <code>- --cluster-cidr=10.244.0.0/16</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/kubernetes/manifests/kube-controller-manager.yaml
spec:
  containers:
  - command:
    - kube-controller-manager
    - --allocate-node-cidrs<span class="token operator">=</span>true
    - --cluster-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，删除错误的 Flannel 容器并重新创建，这样就可以使用正确的配置了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete pod <span class="token parameter variable">-n</span> kube-system kube-flannel-*
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl cluster-info dump <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-m</span> <span class="token number">1</span> cluster-cidr
                            <span class="token string">"--cluster-cidr=10.244.0.0/16"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="没有-controlplaneendpoint"><a class="markdownIt-Anchor" href="#没有-controlplaneendpoint"></a> 没有 controlPlaneEndpoint</h2>
<p>在将第二个主节点加入已存在的单节点集群过程中，预检阶段会报错缺少 controlPlaneEndpoint。这是因为在初始化时没有指定 <code>--control-plane-endpoint</code> 参数导致的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.2.204:6443 <span class="token parameter variable">--token</span> nre8hl.4awo2mnyxr5l0tsu      --discovery-token-ca-cert-hash sha256:8055ad40e280bc4b48b0c3b4daea9aa3f515d3b2fea5fb3ae3fcad398c325a52      --control-plane --certificate-key 5ac22cea4cfc19753cd289c96b968957554b4e4204fe47fc3f56a53dded96716
error execution phase preflight: 
One or <span class="token function">more</span> conditions <span class="token keyword">for</span> hosting a new control plane instance is not satisfied.

unable to <span class="token function">add</span> a new control plane instance a cluster that doesn't have a stable controlPlaneEndpoint address

Please ensure that:
* The cluster has a stable controlPlaneEndpoint address.
* The certificates that must be shared among control plane instances are provided.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要解决此问题，可以使用 <code>kubectl edit</code> 命令编辑 <code>kubeadm-config</code> 配置文件，并将 <code>controlPlaneEndpoint</code> 地址添加为虚拟 IP 或正在运行的主节点的 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl edit cm kubeadm-config <span class="token parameter variable">-n</span> kube-system
    imageRepository: registry.aliyuncs.com/google_containers
    kind: ClusterConfiguration
    controlPlaneEndpoint: <span class="token number">192.168</span>.2.204:6443
    kubernetesVersion: v1.22.3
    networking:
      dnsDomain: cluster.local
      podSubnet: <span class="token number">10.244</span>.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>保存并退出编辑器。然后，重新执行 <code>kubeadm join</code> 命令将第二个主节点加入集群。这样就能成功添加第二个主节点，完成集群的扩容。</p>
<h2 id="token-过期"><a class="markdownIt-Anchor" href="#token-过期"></a> Token 过期</h2>
<p>当加入集群时出现错误：</p>
<blockquote>
<p>x509: certificate has expired or is not yet valid</p>
</blockquote>
<p>可以重新生成令牌：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubeadm token create
87668a.lfvdqsr3l5ijlode
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubeadm token list
TOKEN                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA <span class="token environment constant">GROUPS</span>
1yrznt.lzj1kl0qecosl4es   23h       <span class="token number">2019</span>-07-21T13:14:33+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>        system:bootstrappers:kubeadm:default-node-token
87668a.lfvdqsr3l5ijlode   23h       <span class="token number">2019</span>-07-21T13:24:28+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>        system:bootstrappers:kubeadm:default-node-token
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ kubeadm init phase upload-certs --upload-certs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在客户端同步时间，并再次尝试加入集群：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span>$ ntpdate cn.pool.ntp.org
<span class="token number">20</span> Jul <span class="token number">13</span>:25:59 ntpdate<span class="token punctuation">[</span><span class="token number">118642</span><span class="token punctuation">]</span>: step <span class="token function">time</span> server <span class="token number">199.182</span>.204.197 offset <span class="token number">137559.272548</span> sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="证书过期"><a class="markdownIt-Anchor" href="#证书过期"></a> 证书过期</h2>
<p>可以使用以下命令查看证书的有效期：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubeadm certs check-expiration
<span class="token punctuation">[</span>check-expiration<span class="token punctuation">]</span> Reading configuration from the cluster<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>check-expiration<span class="token punctuation">]</span> FYI: You can <span class="token function">look</span> at this config <span class="token function">file</span> with <span class="token string">'kubectl -n kube-system get cm kubeadm-config -o yaml'</span>

CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
admin.conf                 Nov 03, <span class="token number">2022</span> 05:36 UTC   217d                                    no      
apiserver                  Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            ca                      no      
apiserver-etcd-client      Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            etcd-ca                 no      
apiserver-kubelet-client   Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            ca                      no      
controller-manager.conf    Nov 03, <span class="token number">2022</span> 05:36 UTC   217d                                    no      
etcd-healthcheck-client    Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            etcd-ca                 no      
etcd-peer                  Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            etcd-ca                 no      
etcd-server                Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            etcd-ca                 no      
front-proxy-client         Nov 03, <span class="token number">2022</span> 05:36 UTC   217d            front-proxy-ca          no      
scheduler.conf             Nov 03, <span class="token number">2022</span> 05:36 UTC   217d                                    no      

CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
ca                      Nov 01, <span class="token number">2031</span> 05:36 UTC   9y              no      
etcd-ca                 Nov 01, <span class="token number">2031</span> 05:36 UTC   9y              no      
front-proxy-ca          Nov 01, <span class="token number">2031</span> 05:36 UTC   9y              no   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重新生成所有证书：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubeadm certs renew all
<span class="token punctuation">[</span>renew<span class="token punctuation">]</span> Reading configuration from the cluster<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>renew<span class="token punctuation">]</span> FYI: You can <span class="token function">look</span> at this config <span class="token function">file</span> with <span class="token string">'kubectl -n kube-system get cm kubeadm-config -o yaml'</span>

certificate embedded <span class="token keyword">in</span> the kubeconfig <span class="token function">file</span> <span class="token keyword">for</span> the admin to use and <span class="token keyword">for</span> kubeadm itself renewed
certificate <span class="token keyword">for</span> serving the Kubernetes API renewed
certificate the apiserver uses to access etcd renewed
certificate <span class="token keyword">for</span> the API server to connect to kubelet renewed
certificate embedded <span class="token keyword">in</span> the kubeconfig <span class="token function">file</span> <span class="token keyword">for</span> the controller manager to use renewed
certificate <span class="token keyword">for</span> liveness probes to healthcheck etcd renewed
certificate <span class="token keyword">for</span> etcd nodes to communicate with each other renewed
certificate <span class="token keyword">for</span> serving etcd renewed
certificate <span class="token keyword">for</span> the front proxy client renewed
certificate embedded <span class="token keyword">in</span> the kubeconfig <span class="token function">file</span> <span class="token keyword">for</span> the scheduler manager to use renewed

Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据提示分别在所有主节点上重启组件容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'k8s_kube-apiserver|k8s_kube-controller-manager|k8s_kube-scheduler|k8s_etcd_etcd'</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token parameter variable">-F</span> <span class="token string">' '</span> <span class="token string">'&#123;print $1&#125;'</span> <span class="token operator">|</span><span class="token function">xargs</span> <span class="token function">docker</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="证书不符"><a class="markdownIt-Anchor" href="#证书不符"></a> 证书不符</h2>
<p>如果在加入集群时出现错误：</p>
<blockquote>
<p>x509: certificate is valid for 10.96.0.1, 192.168.2.204, not 192.168.2.199</p>
</blockquote>
<p>提示证书的 IP 地址不符合要求，这通常在更新节点的 <code>apiserver-advertise-address</code> 或 <code>controlPlaneEndpoint</code> 时会发生。解决方法是删除当前集群下 <code>apiserver</code> 的证书和密钥，然后重新生成：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> /etc/kubernetes/pki/apiserver.*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置原先主机的 IP 地址为 192.168.2.204，现在的虚拟 IP 地址为 192.168.2.199：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ kubeadm init phase certs apiserver --apiserver-advertise-address <span class="token number">192.168</span>.2.204 --apiserver-cert-extra-sans <span class="token number">192.168</span>.2.199
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ kubeadm alpha certs renew admin.conf
Kubeadm experimental sub-commands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>重启 API Server，然后查看证书：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ kubectl <span class="token parameter variable">-n</span> kube-system delete pod kube-apiserver-server4 kube-apiserver-server6
pod <span class="token string">"kube-apiserver-server4"</span> deleted
pod <span class="token string">"kube-apiserver-server6"</span> deleted
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ openssl x509 <span class="token parameter variable">-in</span> /etc/kubernetes/pki/apiserver.crt <span class="token parameter variable">-noout</span> <span class="token parameter variable">-text</span>
Certificate:
    Data:
        Version: <span class="token number">3</span> <span class="token punctuation">(</span>0x2<span class="token punctuation">)</span>
        Serial Number: <span class="token number">2687592491658220129</span> <span class="token punctuation">(</span>0x254c3f21b64b9261<span class="token punctuation">)</span>
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: <span class="token assign-left variable">CN</span><span class="token operator">=</span>kubernetes
        Validity
            Not Before: Apr  <span class="token number">4</span> <span class="token number">16</span>:21:14 <span class="token number">2022</span> GMT
            Not After <span class="token builtin class-name">:</span> Apr <span class="token number">19</span> <span class="token number">13</span>:48:19 <span class="token number">2023</span> GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将新的 <code>admin.conf</code> 文件复制到其他需要访问集群的主节点上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">scp</span> /etc/kubernetes/admin.conf root@192.168.2.206:./.kube<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在可以加入新的主节点了。</p>
<h2 id="cni0-地址错误"><a class="markdownIt-Anchor" href="#cni0-地址错误"></a> cni0 地址错误</h2>
<p>在重新构建 Kubernetes 集群后，由于节点上残留了未删除的虚拟网卡，导致创建 Pod 失败，提示 cni0 地址冲突：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ kubectl describe po kubia-74967b5695-ftk77
  Warning  FailedCreatePodSandBox  56s <span class="token punctuation">(</span>x4 over 59s<span class="token punctuation">)</span>   kubelet            <span class="token punctuation">(</span>combined from similar events<span class="token punctuation">)</span>: Failed to create pod sandbox: rpc error: code <span class="token operator">=</span> Unknown desc <span class="token operator">=</span> failed to <span class="token builtin class-name">set</span> up sandbox container <span class="token string">"18dd9bc5076666ed605b2d3331864859454878d7e1f9fae2160f1be71c59c48f"</span> network <span class="token keyword">for</span> pod <span class="token string">"kubia-74967b5695-ftk77"</span><span class="token builtin class-name">:</span> networkPlugin cni failed to <span class="token builtin class-name">set</span> up pod <span class="token string">"kubia-74967b5695-ftk77_default"</span> network: failed to delegate add: failed to <span class="token builtin class-name">set</span> bridge addr: <span class="token string">"cni0"</span> already has an IP address different from <span class="token number">10.100</span>.4.1/24
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> a
<span class="token number">5</span>: cni0: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state DOWN group default qlen <span class="token number">1000</span>
    link/ether <span class="token number">92</span>:1d:b1:d9:ba:19 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">10.100</span>.9.1/24 brd <span class="token number">10.100</span>.9.255 scope global cni0
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法是手动删除网卡，让它重新创建：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> cni0 down
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> <span class="token function">link</span> delete cni0
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> a
<span class="token number">926</span>: cni0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1450</span> qdisc noqueue state UP group default qlen <span class="token number">1000</span>
    link/ether <span class="token number">92</span>:6a:c8:8b:2c:5b brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">10.100</span>.4.1/24 brd <span class="token number">10.100</span>.4.255 scope global cni0
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="etcd-错误"><a class="markdownIt-Anchor" href="#etcd-错误"></a> etcd 错误</h2>
<p>在 etcd 中存在已被删除的节点记录时，当节点重新加入集群时会报错：</p>
<blockquote>
<p>etcd cluster is not healthy: failed to dial endpoint</p>
</blockquote>
<p>这时需要手动维护 etcd 数据库。</p>
<p>进入节点的 etcd 容器内部，查询 etcd 集群的成员列表，然后删除错误的成员，这样集群就恢复正常了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ kubectl <span class="token parameter variable">-n</span> kube-system <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> etcd-k8s-239 -- <span class="token function">sh</span>
sh-5.0<span class="token comment"># export ETCDCTL_API=3</span>
sh-5.0<span class="token comment"># alias etcdctl='etcdctl --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key'</span>
sh-5.0<span class="token comment"># etcdctl member list</span>
2e1d3dc8363ee756, started, server5, https://192.168.2.205:2380, https://192.168.2.205:2379, <span class="token boolean">false</span>
4b8b623fba4c1f57, started, server6, https://192.168.2.206:2380, https://192.168.2.206:2379, <span class="token boolean">false</span>
ad703513a2c4e54a, started, server4, https://192.168.2.204:2380, https://192.168.2.204:2379, <span class="token boolean">false</span>
sh-5.0<span class="token comment"># etcdctl member remove 63bfe05c4646fb08</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="没找到-resolvconf-文件"><a class="markdownIt-Anchor" href="#没找到-resolvconf-文件"></a> 没找到 resolv.conf 文件</h2>
<p>如果主节点为 Ubuntu，从节点为 CentOS，从节点加入集群后，kube-flannel 容器报错：</p>
<blockquote>
<p>Failed to create pod sandbox: open /run/systemd/resolve/resolv.conf: no such file or directory</p>
</blockquote>
<p>这是由于 CentOS 和 Ubuntu 系统 DNS 服务器配置文件 <code>resolv.conf</code> 所在位置不同导致。</p>
<p>可以在 CentOS 上创立一个软链接，将 <code>/etc/resolv.conf</code> 文件链接到 <code>/run/systemd/resolve/resolv.conf</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># mkdir /run/systemd/resolve/</span>
<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># ln -s /etc/resolv.conf /run/systemd/resolve/resolv.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>重启 kubelet 服务以使更改生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span><span class="token comment"># systemctl restart kubelet</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此报错解决。</p>
<h1 id="备份恢复"><a class="markdownIt-Anchor" href="#备份恢复"></a> 备份恢复</h1>
<p>单主节点集群一定要做好备份工作。</p>
<h2 id="查看-etcd-配置"><a class="markdownIt-Anchor" href="#查看-etcd-配置"></a> 查看 etcd 配置</h2>
<p>在使用 kubeadm 部署的 Kubernetes 集群中，etcd 作为容器运行，并通过本地挂载来存储数据库和配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ ll /var/lib/etcd/member/snap
total <span class="token number">5124</span>
-rw-r--r--  <span class="token number">1</span> root root    <span class="token number">9851</span> Apr  <span class="token number">1</span> 03:37 0000000000000012-00000000000222f1.snap
-rw-r--r--  <span class="token number">1</span> root root    <span class="token number">9851</span> Apr  <span class="token number">1</span> 04:46 0000000000000012-0000000000024a02.snap
-rw-r--r--  <span class="token number">1</span> root root    <span class="token number">9851</span> Apr  <span class="token number">1</span> 05:55 0000000000000012-0000000000027113.snap
-rw-r--r--  <span class="token number">1</span> root root    <span class="token number">9851</span> Apr  <span class="token number">1</span> 07:04 0000000000000012-0000000000029824.snap
-rw-r--r--  <span class="token number">1</span> root root    <span class="token number">9851</span> Apr  <span class="token number">1</span> 08:14 0000000000000012-000000000002bf35.snap
-rw-------. <span class="token number">1</span> root root <span class="token number">5185536</span> Apr  <span class="token number">1</span> 08:58 db
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ ll /etc/kubernetes/pki/etcd
total <span class="token number">32</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1086</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 ca.crt
-rw-------. <span class="token number">1</span> root root <span class="token number">1679</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 ca.key
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1159</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 healthcheck-client.crt
-rw-------. <span class="token number">1</span> root root <span class="token number">1675</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 healthcheck-client.key
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1212</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 peer.crt
-rw-------. <span class="token number">1</span> root root <span class="token number">1679</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 peer.key
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1212</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 server.crt
-rw-------. <span class="token number">1</span> root root <span class="token number">1675</span> Mar <span class="token number">31</span> <span class="token number">11</span>:49 server.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，以 “.snap” 结尾的文件是快照文件。</p>
<h2 id="安装-etcd-客户端"><a class="markdownIt-Anchor" href="#安装-etcd-客户端"></a> 安装 etcd 客户端</h2>
<p>在主节点上安装 etcd 客户端：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> etcd
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ etcdctl <span class="token parameter variable">--version</span>
etcdctl version: <span class="token number">3.3</span>.11
API version: <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看-etcd-数据库"><a class="markdownIt-Anchor" href="#查看-etcd-数据库"></a> 查看 etcd 数据库</h2>
<p>首先尝试连接到本地 etcd 数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCDCTL_API</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ etcdctl version
etcdctl version: <span class="token number">3.3</span>.11
API version: <span class="token number">3.3</span>
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">ETCD</span><span class="token operator">=</span><span class="token string">"etcdctl --endpoints https://127.0.0.1:2379 --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key --cacert=/etc/kubernetes/pki/etcd/ca.crt"</span>
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token variable">$ETCD</span> member list
273040abda86d599, started, server9-node1, https://192.168.2.209:2380, https://192.168.2.209:2379
4c80ad008d949110, started, server8-node1, https://192.168.2.208:2380, https://192.168.2.208:2379
dcddbc08262b69e1, started, server7-master, https://192.168.2.207:2380, https://192.168.2.207:2379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看所有 Pod 对象的存储名称：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token variable">$ETCD</span> get /registry/pods <span class="token parameter variable">--prefix</span> --keys-only
/registry/pods/default/kubia-74967b5695-bzxtf
/registry/pods/default/kubia-74967b5695-vhjkz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="使用命令备份恢复"><a class="markdownIt-Anchor" href="#使用命令备份恢复"></a> 使用命令备份恢复</h2>
<p>使用 <code>etcdctl snapshot save</code> 命令将 etcd 数据库备份到当前目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token variable">$ETCD</span> snapshot save snap.db
Snapshot saved at snap.db
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token variable">$ETCD</span> snapshot status snap.db
c477d6ef, <span class="token number">144130</span>, <span class="token number">1216</span>, <span class="token number">5.2</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先对一个正在运行的服务进行缩容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME                     READY   STATUS    RESTARTS        AGE
kubia-74967b5695-bzxtf   <span class="token number">1</span>/1     Running   <span class="token number">2</span> <span class="token punctuation">(</span>7h19m ago<span class="token punctuation">)</span>   20h
kubia-74967b5695-vhjkz   <span class="token number">1</span>/1     Running   <span class="token number">2</span> <span class="token punctuation">(</span>7h19m ago<span class="token punctuation">)</span>   20h
kubia-74967b5695-wsd5c   <span class="token number">1</span>/1     Running   <span class="token number">2</span> <span class="token punctuation">(</span>7h19m ago<span class="token punctuation">)</span>   20h
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ kubectl scale deployment kubia <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">1</span>
deployment.apps/kubia scaled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后暂停 API Server 和 etcd 容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ systemctl stop kubelet
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> stop <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span> <span class="token operator">&amp;</span> <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span>
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token function">mv</span> /etc/kubernetes/manifests /etc/kubernetes/manifests.bak
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token function">mv</span> /var/lib/etcd/ /var/lib/etcd.bak<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>恢复 etcd 数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token variable">$ETCD</span> snapshot restore snap.db --data-dir<span class="token operator">=</span>/var/lib/etcd
<span class="token number">2022</span>-04-01 09:40:54.304594 I <span class="token operator">|</span> mvcc: restore compact to <span class="token number">143285</span>
<span class="token number">2022</span>-04-01 09:40:54.315885 I <span class="token operator">|</span> etcdserver/membership: added member 8e9e05c52164694d <span class="token punctuation">[</span>http://localhost:2380<span class="token punctuation">]</span> to cluster cdf818194e3a8c32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>恢复运行 API Server 和 etcd 容器后，再次验证数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ <span class="token function">mv</span> /etc/kubernetes/manifests.bak /etc/kubernetes/manifests
<span class="token punctuation">[</span>root@server7-master ~<span class="token punctuation">]</span>$ systemctl start kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="使用文件备份恢复"><a class="markdownIt-Anchor" href="#使用文件备份恢复"></a> 使用文件备份恢复</h2>
<p>由于版本问题，使用 <code>etcdctl</code> 备份恢复的数据库经常出错，因此可以使用备份文件夹的方式来备份数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> <span class="token parameter variable">-r</span> /var/lib/etcd/ /root/etcd/
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ ll /root/etcd/
total <span class="token number">0</span>
drwx------. <span class="token number">4</span> root root <span class="token number">29</span> Apr  <span class="token number">5</span> 02:08 member<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进行一系列操作后：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ kubectl scale deployment kubia <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">11</span>
deployment.apps/kubia scaled
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ kubectl create ns pro
namespace/pro created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>停止 kubelet，删除所有 Docker 容器，删除原数据库文件，然后将备份文件夹复制回来，启动 kubelet：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl stop kubelet
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> stop <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span> <span class="token operator">&amp;</span> <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-aq</span><span class="token variable">)</span></span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/etcd/ 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> <span class="token parameter variable">-r</span> /root/etcd/ /var/lib/etcd/
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl start kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>恢复的数据将回到备份时的状态。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>0.基本知识</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 基本资源</title>
    <url>/4120596009/</url>
    <content><![CDATA[<h1 id="pod-详解"><a class="markdownIt-Anchor" href="#pod-详解"></a> Pod 详解</h1>
<p>一个 Kubernetes（K8s）中的 Pod 是一个部署的最小单位，它是由一个或多个容器组成的，这些容器共享网络和存储资源。Pod 可以包含多个相关联的容器，它们在同一主机上运行并具有共享的网络命名空间。</p>
<h2 id="pod-定义"><a class="markdownIt-Anchor" href="#pod-定义"></a> Pod 定义</h2>
<p>Pod 是 Kubernetes（K8s）中的一个基本构建模块，代表一组并置的容器。它是一个应用程序的单一运行实例，由共享资源且关系紧密的一个或多个应用容器组成，为它们提供相同的环境。这些容器共享相同的网络命名空间，它们可以通过 IPC（Inter-Process Communication）进行通信，并共享相同的主机名和网络接口。尽管容器在逻辑上运行在同一个 Pod 内，但它们之间仍然保持着一定的隔离性。</p>
<p>在实际应用中，我们往往会部署一组相关的 Pod，而不是单独部署容器。当一个 Pod 包含多个容器时，这些容器总是运行在同一个工作节点上，一个 Pod 不会跨越多个工作节点。</p>
<p>Pod 具有以下特点：</p>
<ul>
<li>容器部分隔离：Kubernetes 通过配置 Docker，使同一个 Pod 内的所有容器共享相同的 Linux 命名空间。它们共享相同的主机名和网络接口，容器之间可以通过 IPC 进行通信。其他的 MNT（Mount），USR（User），和 PID（Process ID）命名空间是独立的。</li>
<li>容器共享网络命名空间：在同一个 Pod 中的容器处于相同的网络命名空间中，意味着它们共享 Pod 的 IP 地址和端口。需要注意的是，容器绑定的端口号不能相同，否则会导致端口冲突。同一个 Pod 中的容器可以直接通过回环口（loopback）进行通信。</li>
<li>平坦的 Pod 间网络：Kubernetes 集群中的所有 Pod 都处于同一个共享网络地址空间中，Pod 之间可以直接通过 Pod 的 IP 地址来相互访问。不管实际节点的网络拓扑结构如何，都不需要进行网络地址转换（NAT），就像在局域网中一样。</li>
</ul>
<h2 id="组织-pod"><a class="markdownIt-Anchor" href="#组织-pod"></a> 组织 Pod</h2>
<p>尽管 Pod 看起来像一个独立的机器，但不应该将多个应用程序填充到一个 Pod 中。每个 Pod 应该只包含紧密相关的组件或进程，保持 Pod 的轻量级。这样可以最大限度地创建更多的 Pod：</p>
<ul>
<li>
<p>将多层应用程序分散到多个 Pod 中</p>
<p>一个典型的应用程序由前端和后端数据库组成。如果将它们放在同一个 Pod 中，它们作为整体只能在一个节点上运行，无法利用其他节点的计算资源。将它们拆分后，可以在不同的节点上分别部署前端和后端应用程序，提高基础架构的利用率。</p>
</li>
<li>
<p>基于扩缩容的考虑</p>
<p>Pod 是扩缩容的基本单位，通常前端和后端组件具有不同的扩缩容需求。后端数据库相对于无状态的前端更难以扩展，因此需要将它们分开部署到单独的 Pod 中。</p>
</li>
<li>
<p>使用 Sidecar 容器</p>
<p>将多个容器添加到单个 Pod 的主要原因是应用程序可能由一个主进程和多个辅助进程组成。辅助进程所在的容器被称为 Sidecar 容器，通常用于日志收集、数据处理、存储和通信等功能。</p>
</li>
<li>
<p>Pod 中使用多个容器</p>
<p>当多个容器作为一个整体不可分离且需要一起进行扩缩容时，考虑将它们放入同一个 Pod 中。</p>
</li>
</ul>
<h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2>
<p>Pod 对象有 5 种状态：</p>
<ul>
<li>
<p>Pending（等待中）</p>
<p>API Server 创建了 Pod 资源对象并已存储在 etcd 中，但它尚未完成调度，或者仍在下载镜像中。</p>
</li>
<li>
<p>Running（运行中）</p>
<p>Pod 已被调度到某个节点，并且所有容器都已由 Kubelet 创建完成。</p>
</li>
<li>
<p>Succeeded（已成功）</p>
<p>Pod 中的所有容器都已成功终止，并且不会重新启动。</p>
</li>
<li>
<p>Failed（失败）</p>
<p>所有容器都已终止，但至少有一个容器终止失败，返回了非零的退出状态。</p>
</li>
<li>
<p>Unknown（未知）</p>
<p>API Server 无法正常获取 Pod 对象的状态信息，通常是由于节点失联造成的。</p>
</li>
</ul>
<h2 id="pause-容器"><a class="markdownIt-Anchor" href="#pause-容器"></a> Pause 容器</h2>
<p>每个 Pod 都有一个特殊的被称为根容器的 Pause 容器，Pause 容器对应的镜像属于 Kubernetes 平台的一部分，而其他容器则是用户业务容器。</p>
<p>在启动一个 Pod 资源后，可以查看运行中的节点 Docker 进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server5-node1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID   IMAGE                                                                 COMMAND                  CREATED              STATUS              PORTS     NAMES
e9d77706b60a   luksa/kubia-pet-peers                                                 <span class="token string">"node app.js"</span>            About a minute ago   Up About a minute             k8s_kubia_kubia-2_default_49130122-540c-4c8b-98aa-23c84e9bfc9a_0
fe1980dc3fb7   registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.2   <span class="token string">"/pause"</span>                 About a minute ago   Up About a minute             k8s_POD_kubia-2_default_49130122-540c-4c8b-98aa-23c84e9bfc9a_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>附加 Pause 容器会先于应用容器创建，它不执行任何操作，只运行一个 pause 命令。</p>
<p>由于 Pod 内的容器共享同一个网络和 Linux 命名空间，将与业务无关且不易终止的 Pause 容器作为 Pod 的根容器，可以通过它的状态来代表整个容器组的状态，从而更简单地判断 Pod 的运行状态。Pause 容器的生命周期与 Pod 绑定，如果基础 Pod 在此期间被关闭，Kubelet 会重新创建它以及 Pod 中的所有容器。</p>
<p>另一方面，如果 Pod 中有多个容器，可以通过 Pause 容器挂载外部卷并共享 Pause 容器的 IP，从而简化了业务容器之间的通信问题。</p>
<h2 id="描述文件"><a class="markdownIt-Anchor" href="#描述文件"></a> 描述文件</h2>
<p>创建 Pod 或其他资源通常需要提供 JSON 或 YAML 描述文件来向 REST API 提供信息。可以使用 <code>kubectl get</code> 命令加上 <code>-o yaml</code> 参数来查看 YAML 定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pod kubia <span class="token parameter variable">-o</span> yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: <span class="token string">"2021-11-02T21:50:57Z"</span>
  labels:
    run: kubia
  name: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>几乎所有的 Kubernetes 资源中都可以找到 Pod 定义文件的结构：</p>
<ul>
<li><code>apiVersion</code>：Kubernetes API 的版本。可以使用 <code>kubectl api-resources</code> 命令查找当前资源所使用的 API 版本。</li>
<li><code>kind</code>：资源类型。</li>
<li><code>metadata</code>：元数据，包括名称、命名空间、标签和其他容器相关信息。</li>
<li><code>spec</code>：实际描述 Pod 内容的规范，例如容器和卷。</li>
<li><code>status</code>：包含当前运行的 Pod 的信息，例如容器状态和内部 IP 信息。</li>
</ul>
<p>可以使用 <code>kubectl explain pods</code> 命令查看关于 YAML 文件中各属性的说明。如果需要了解更详细的信息，可以直接查看属性，例如使用 <code>kubectl explain pod.status</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl explain pod.status

FIELDS:
   conditions   <span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Object<span class="token operator">></span>
     Current <span class="token function">service</span> state of pod. More info:
     https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle<span class="token comment">#pod-conditions</span>

   containerStatuses    <span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Object<span class="token operator">></span>
     The list has one entry per container <span class="token keyword">in</span> the manifest. Each entry is
     currently the output of <span class="token variable"><span class="token variable">`</span><span class="token function">docker</span> inspect<span class="token variable">`</span></span><span class="token builtin class-name">.</span> More info:
     https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle<span class="token comment">#pod-and-container-status</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下是一个基本的 Pod YAML 描述文件示例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ vi kubia<span class="token punctuation">-</span>pod.yaml
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> alice<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> assassing/kubia
    <span class="token key atrule">name</span><span class="token punctuation">:</span> assassing
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Pod 定义中指定的端口只是为了可读性，并没有实际作用。如果容器绑定到地址为 <code>0.0.0.0</code> 的端口以接收连接，即使端口没有在 Pod spec 中指定，其他 Pod 仍然可以连接到该端口。</p>
<h2 id="创建-pod"><a class="markdownIt-Anchor" href="#创建-pod"></a> 创建 Pod</h2>
<p>可以使用 <code>kubectl create</code> 命令根据 YAML 文件创建包括 Pod 在内的任何资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-pod.yaml 
pod/alice-pod created
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pod
NAME        READY   STATUS    RESTARTS   AGE
alice-pod   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          12s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了 YAML 格式，还可以使用 JSON 文件来创建资源。</p>
<h2 id="查看-pod-详情"><a class="markdownIt-Anchor" href="#查看-pod-详情"></a> 查看 Pod 详情</h2>
<p>可以将详细信息输出为 JSON 格式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get po alice-pod <span class="token parameter variable">-o</span> json
<span class="token punctuation">&#123;</span>
    <span class="token string">"apiVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"v1"</span>,
    <span class="token string">"kind"</span><span class="token builtin class-name">:</span> <span class="token string">"pod"</span>,
    <span class="token string">"metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
        <span class="token string">"creationTimestamp"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-11-02T23:37:42Z"</span>,
        <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"alice-pod"</span>,
        <span class="token string">"namespace"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,
        <span class="token string">"resourceVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"6027"</span>,
        <span class="token string">"uid"</span><span class="token builtin class-name">:</span> <span class="token string">"de10a52f-d380-4341-9c11-2bd516cf0a02"</span>
    <span class="token punctuation">&#125;</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看-pod-日志"><a class="markdownIt-Anchor" href="#查看-pod-日志"></a> 查看 Pod 日志</h2>
<p>使用 <code>kubectl logs</code> 命令查看日志，无需像 <code>docker logs</code> 命令一样在容器所在的主机上查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl logs alice-pod 
Runing<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果 Pod 中包含多个容器，则必须通过 <code>-c</code> 参数指定容器名称：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost flannel<span class="token punctuation">]</span>$ kubectl logs httpd-app-5bc589d9f7-ggmwq <span class="token parameter variable">-c</span> httpd-app
AH00558: httpd: Could not reliably determine the server<span class="token string">'s fully qualified domain name, using 10.244.1.5. Set the '</span>ServerName<span class="token string">' directive globally to suppress this message
AH00558: httpd: Could not reliably determine the server'</span>s fully qualified domain name, using <span class="token number">10.244</span>.1.5. Set the <span class="token string">'ServerName'</span> directive globally to suppress this message
<span class="token punctuation">[</span>Thu Jul <span class="token number">18</span> <span class="token number">16</span>:28:44.242092 <span class="token number">2019</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>mpm_event:notice<span class="token punctuation">]</span> <span class="token punctuation">[</span>pid <span class="token number">1</span>:tid <span class="token number">139744563483776</span><span class="token punctuation">]</span> AH00489: Apache/2.4.39 <span class="token punctuation">(</span>Unix<span class="token punctuation">)</span> configured -- resuming normal operations
<span class="token punctuation">[</span>Thu Jul <span class="token number">18</span> <span class="token number">16</span>:28:44.242331 <span class="token number">2019</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>core:notice<span class="token punctuation">]</span> <span class="token punctuation">[</span>pid <span class="token number">1</span>:tid <span class="token number">139744563483776</span><span class="token punctuation">]</span> AH00094: Command line: <span class="token string">'httpd -D FOREGROUND'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每当日志文件达到 10 MB 大小时，容器日志会自动进行轮替。同时，当 Pod 被删除时，日志也会被删除。</p>
<h2 id="执行命令"><a class="markdownIt-Anchor" href="#执行命令"></a> 执行命令</h2>
<p>使用类似 Docker 命令的格式 <code>kubectl exec -it</code> 来进入容器，尽管这样做是可行的，但会提示该命令已被废弃：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubiaex-f4wkw /bin/bash
kubectl <span class="token builtin class-name">exec</span> <span class="token punctuation">[</span>pod<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> is DEPRECATED and will be removed <span class="token keyword">in</span> a future version. Use kubectl <span class="token builtin class-name">exec</span> <span class="token punctuation">[</span>pod<span class="token punctuation">]</span> -- <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> instead.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这是因为当要在容器中运行带有空格的命令时，kubectl 会将空格后面的内容作为 kubectl 的参数进行解析。正确的用法是在容器命令之前使用两个减号 <code>--</code> 进行分隔：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubiaex-f4wkw -- <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="转发-pod-端口"><a class="markdownIt-Anchor" href="#转发-pod-端口"></a> 转发 Pod 端口</h2>
<p>除了使用 Service 的方式，还可以通过端口转发来连接 Pod。命令是 <code>kubectl port-forward &lt;pod名称&gt; 本地端口:pod端口</code>。</p>
<p>例如，将 alice-pod 的 8080 端口转发到本地的 8888 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl port-forward alice-pod <span class="token number">8888</span>:8080
Forwarding from <span class="token number">127.0</span>.0.1:8888 -<span class="token operator">></span> <span class="token number">8080</span>
Forwarding from <span class="token punctuation">[</span>::1<span class="token punctuation">]</span>:8888 -<span class="token operator">></span> <span class="token number">8080</span>
Handling connection <span class="token keyword">for</span> <span class="token number">8888</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8888
Hostname: alice-pod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种方法可以用于调试应用程序。</p>
<h2 id="删除-pod"><a class="markdownIt-Anchor" href="#删除-pod"></a> 删除 Pod</h2>
<p>当 API 服务器接收到删除 Pod 的请求后，它首先修改了 etcd 中的状态，并将事件通知给 Kubelet 和端点控制器（Endpoint Controller）：</p>
<ul>
<li>当 Kubelet 接收到 Pod 终止通知时，会执行停止前钩子，发送 SIGTERM 信号，最后完成杀死容器。</li>
<li>端点控制器则负责从 Pod 对应的服务中移除这个 Pod 的地址，主要通过向 API 服务器发送 REST 请求来修改 Endpoint API 对象。然后 API 服务器会通知所有的客户端，特别是 kube-proxy 服务在节点上更新 iptables 规则，以阻止新的连接被转发到停止状态的 Pod 上。</li>
</ul>
<p>使用 <code>kubectl delete</code> 命令来删除 Pod，可以用空格分隔要删除的多个 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl delete pod alice-pod alice-pod-v1
pod <span class="token string">"alice-pod"</span> deleted
pod <span class="token string">"alice-pod-v1"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在删除 Pod 的过程中，实际上是请求终止该 Pod 中的所有容器。Kubernetes 向进程发送一个 SIGTERM 信号，默认等待 30 秒使其正常关闭。如果超过 30 秒，则通过 SIGKILL 终止进程。</p>
<p>通过 <code>-l</code> 参数来通过标签选择 Pod 并删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl delete pod <span class="token parameter variable">-l</span> <span class="token assign-left variable">run</span><span class="token operator">=</span>assassing
pod <span class="token string">"assassing-5c54d7b988-76kdz"</span> deleted
pod <span class="token string">"assassing-5c54d7b988-hbxtp"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>删除当前命名空间内所有 Pod，但保留命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl delete pod <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除当前命名空间内的所有资源，但保留命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl delete all <span class="token parameter variable">--all</span>
<span class="token function">service</span> <span class="token string">"kubernetes"</span> deleted
<span class="token function">service</span> <span class="token string">"kubia"</span> deleted
<span class="token function">service</span> <span class="token string">"kubia-http"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="初始化容器"><a class="markdownIt-Anchor" href="#初始化容器"></a> 初始化容器</h2>
<p>可以在 Pod 中加入一个 init 容器来检查依赖服务的请求是否被响应，获得响应后再让主容器启动。</p>
<p>初始化容器运行失败会重启，直到成功完成。如果 <code>spec.restartPolicy</code> 字段为 <code>Never</code> 时不会重启。</p>
<p>初始化容器通过 <code>spec.initContainers</code> 来定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spec:
  containers:
  - name: nodejs
    image: luksa/kubia
    ports:
    - name: http
      containerPort: <span class="token number">8080</span>
    resources:
      requests:
        cpu: 100m
  initContainers:
  - name: init
    image: busybox
    command:
    - <span class="token function">sh</span>
    - <span class="token parameter variable">-C</span>
    - <span class="token string">'while true; do echo "waiting"; wget http://fortune -q -T 1 -O /dev/null > /dev/null 2>/dev/null &amp;&amp; break; sleep 5; done; echo "Done"'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="终止宽限期"><a class="markdownIt-Anchor" href="#终止宽限期"></a> 终止宽限期</h2>
<p>Pod 的关闭是通过 API 服务器删除 Pod 的对象来触发的。当服务器接收到 HTTP DELETE 请求后，API 服务器并没有立即删除对象，而是给 Pod 设置一个 <code>deletionTimestamp</code> 值，Pod 开始停止运行。</p>
<p>节点上的 Kubelet 会开始终止 Pod 中的每个容器。Pod 向容器的主进程发送 SIGTERM 信号，等待容器自行关闭。若等待终止宽限期（Termination Grace Period）超时，Kubelet 会使用 SIGKILL 信号强制关闭进程。</p>
<p>终止宽限期可以通过 Pod spec 中的 <code>terminationGracePeriodSeconds</code> 字段来设置，其默认值为 30 秒。</p>
<p>也可以在删除 Pod 时指定宽限时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">6</span><span class="token punctuation">]</span>$ kubectl delete po kubia --grace-period<span class="token operator">=</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用强制删除 <code>--force</code> 选项时要注意 StatefulSet 管理的 Pod。强制删除 Pod 会导致控制器不等待被删除 Pod 中的容器完成关闭，而直接创建一个替代的 Pod，可能会导致相同 Pod 的两个实例同时运行，从而造成集群服务工作异常。因此，只有在 Pod 无法与集群中的其他成员通信的情况下，才应该使用强制删除。</p>
<p>一种更好的解决方法是使用一个专门持续运行的 Pod，来持续检查是否存在孤立的数据。</p>
<h1 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h1>
<p>K8s 的命名空间（Namespace）与用于互相隔离进程的 Linux 命名空间不同，它并不提供对正在运行的对象的任何隔离，只是简单地为对象名称提供一个作用域，从逻辑上进行隔离。这样，在不同的命名空间中可以多次使用相同的资源名称。</p>
<p>命名空间为资源名称提供了一个作用域。可以通过命名空间将资源分配到生产、开发和测试环境。资源名称只需要在命名空间内保持唯一即可。</p>
<p>在 K8s 集群安装完成后，会自动创建两个命名空间：一个是默认的 default 空间，另一个是系统级的 kube-system。当创建资源对象时没有指定命名空间时，默认会将其存放到 default 命名空间中。</p>
<h2 id="查看命名空间"><a class="markdownIt-Anchor" href="#查看命名空间"></a> 查看命名空间</h2>
<p>默认情况下，在 default 命名空间中进行操作。可以使用 <code>kubectl get namespace</code> 或 <code>kubectl get ns</code> 来查看所有命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get namespace
NAME                   STATUS   AGE
default                Active   4h12m
kube-node-lease        Active   4h12m
kube-public            Active   4h12m
kube-system            Active   4h12m
kubernetes-dashboard   Active   4h11m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建命名空间"><a class="markdownIt-Anchor" href="#创建命名空间"></a> 创建命名空间</h2>
<p>可以通过 YAML 文件创建命名空间。命名空间的名称不能包含点号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> my-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> my-namespace.yaml 
namespace/my-namespace created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以直接使用 <code>create namespace</code> 命令来创建命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl create namespace my-ns
namespace/my-ns created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="使用命名空间"><a class="markdownIt-Anchor" href="#使用命名空间"></a> 使用命名空间</h2>
<p>可以在创建 Pod 的 YAML 文件中，在 metadata 字段中添加 <code>namespace:</code> 来指定命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-ns.yaml
apiVersion: v1
kind: Pod
metadata:
  name: alice-ns
  namespace: my-namespace
spec:
  containers:
  - image: assassing/kubia
    name: assassing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以在使用 <code>kubectl create</code> 命令创建资源时，通过添加 <code>-n</code> 参数来指定命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-ns.yaml <span class="token parameter variable">-n</span> my-namespace 
pod/alice-ns created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="查询命名空间"><a class="markdownIt-Anchor" href="#查询命名空间"></a> 查询命名空间</h2>
<p>要查看命名空间下的 Pod，可以在查询命令后添加 <code>-n</code> 选项来指定命名空间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pod <span class="token parameter variable">-n</span> my-namespace
NAME       READY   STATUS    RESTARTS   AGE
alice-ns   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          45s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>--all-namespaces</code> 参数来查看所有命名空间下的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pod --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除命名空间"><a class="markdownIt-Anchor" href="#删除命名空间"></a> 删除命名空间</h2>
<p>可以直接删除整个命名空间，命名空间下的 Pod 将会随之删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl delete ns my-namespace
namespace <span class="token string">"my-namespace"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="标签和注解"><a class="markdownIt-Anchor" href="#标签和注解"></a> 标签和注解</h1>
<p>在 Kubernetes 中，标签注解是用于给资源对象添加元数据的机制。</p>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<p>标签是可以附加到资源上的任意键值对，通过标签选择器可以选择具有特定标签的资源，从而能够一次性操作所有具有相同标签的资源。在资源内，一个标签的键（key）必须是唯一的，因此一个资源可以拥有多个标签，并且可以随时修改和添加标签。</p>
<p>通过给指定的资源对象绑定一个或多个不同的标签，可以实现多维度的资源分组管理。常见的标签包括版本标签（release:stable）、环境标签（environment:dev）、架构标签（tier:frontend）、区域标签（partition:HK）和质量控制标签（track:daily）等。这些标签可以根据实际需求来定义和使用，以实现更灵活的资源管理和操作。</p>
<h2 id="指定标签"><a class="markdownIt-Anchor" href="#指定标签"></a> 指定标签</h2>
<p>创建一个新的 <code>kubia-label.yaml</code> 文件，添加 <code>labels</code> 字段：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ vi kubia<span class="token punctuation">-</span>label.yaml
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> alice<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>v1
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">creation_method</span><span class="token punctuation">:</span> manual
    <span class="token key atrule">env</span><span class="token punctuation">:</span> prod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> assassing/kubia
    <span class="token key atrule">name</span><span class="token punctuation">:</span> assassing
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl create <span class="token punctuation">-</span>f kubia<span class="token punctuation">-</span>label.yaml 
pod/alice<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>v1 created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看标签"><a class="markdownIt-Anchor" href="#查看标签"></a> 查看标签</h2>
<p>使用 <code>--show-labels</code> 参数来查看标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pods --show-labels
NAME           READY   STATUS    RESTARTS   AGE   LABELS
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          32m   <span class="token operator">&lt;</span>none<span class="token operator">></span>
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          53s   <span class="token assign-left variable">creation_method</span><span class="token operator">=</span>manual,env<span class="token operator">=</span>prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>-L</code> 来显示指定的标签而不是显示所有标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pods <span class="token parameter variable">-L</span> env,creation_method
NAME           READY   STATUS    RESTARTS   AGE     ENV    CREATION_METHOD
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          34m            
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m55s   prod   manual<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修改标签"><a class="markdownIt-Anchor" href="#修改标签"></a> 修改标签</h2>
<p>要为现有的 Pod 添加标签，可以使用 <code>kubectl label</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl label pod alice-pod <span class="token assign-left variable">env</span><span class="token operator">=</span>test
pod/alice-pod labeled
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pods <span class="token parameter variable">-L</span> <span class="token function">env</span>
NAME           READY   STATUS    RESTARTS   AGE     ENV
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          36m     <span class="token builtin class-name">test</span>
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m29s   prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要修改已存在的标签，需要使用 <code>--overwrite</code> 参数，以防止在添加新标签时无意中更改现有标签的值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl label pod alice-pod <span class="token assign-left variable">env</span><span class="token operator">=</span>prod <span class="token parameter variable">--overwrite</span> 
pod/alice-pod labeled
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get pods <span class="token parameter variable">-L</span> <span class="token function">env</span>
NAME           READY   STATUS    RESTARTS   AGE     ENV
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          37m     prod
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          5m47s   prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个标签可以附加于多个对象。</p>
<h2 id="删除标签"><a class="markdownIt-Anchor" href="#删除标签"></a> 删除标签</h2>
<p>例如，要删除名为 <code>alice-pod-v1</code> 上的 <code>creation_method</code> 标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl label pod alice-pod-v1 creation_method-
pod/alice-pod-v1 labeled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意，在删除标签时要在标签名后添加 <code>-</code> 符号。</p>
<h2 id="标签选择器"><a class="markdownIt-Anchor" href="#标签选择器"></a> 标签选择器</h2>
<p>标签选择器允许选择标记有特定标签的 Pod 子集并进行操作。可以使用以下条件：</p>
<ul>
<li>
<p>包含（或不包含）使用特定键的标签。</p>
<p>例如选择所有不存在 <code>env</code> 键的标签的资源：<code>!env</code></p>
</li>
<li>
<p>包含具有特定键和值的标签。</p>
<p>同时选择两个标签，标签之间用逗号分开。例如：<code>app=pc,rel=beta</code></p>
<p>选择带有 <code>env</code> 标签且值为 <code>prod</code> 或 <code>dev</code> 的 Pod：<code>env in (prod,dev)</code></p>
</li>
<li>
<p>包含具有特定键的标签，但值与指定的不同。</p>
<p>选择带有 <code>env</code> 标签且值不等于 <code>prod</code> 的 Pod：<code>env!=prod</code></p>
<p>选择 <code>env</code> 标签且值不为 <code>prod</code> 或 <code>dev</code> 的 Pod：<code>env notin (prod,dev)</code></p>
</li>
</ul>
<p>例如，列出标签 <code>env=prod</code> 的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-l</span> <span class="token assign-left variable">env</span><span class="token operator">=</span>prod
NAME           READY   STATUS    RESTARTS   AGE
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          53m
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          21m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>!</code> 做选择时，必须将条件用单引号括起来，否则会被 Bash 解释。例如，列出标签 <code>key</code> 不存在 <code>env</code> 的 Pod：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-l</span> <span class="token string">'!env'</span>
NAME           READY   STATUS    RESTARTS   AGE
alice-pod      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          54m
alice-pod-v1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          23m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在金丝雀发布时，可以使用标签选择器一次删除所有金丝雀 Pod。</p>
<h2 id="节点标签"><a class="markdownIt-Anchor" href="#节点标签"></a> 节点标签</h2>
<p>标签可以附加到任何 Kubernetes 对象上，包括节点。因此，在添加新节点时，可以使用标签对节点进行分类。例如，一组美国服务器的节点，可以添加标签 <code>location=US</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> k8s-node1 <span class="token assign-left variable">location</span><span class="token operator">=</span>US
node/k8s-node1 labeled
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl get nodes <span class="token parameter variable">-l</span> <span class="token assign-left variable">location</span><span class="token operator">=</span>US
NAME        STATUS   ROLES    AGE   VERSION
k8s-node1   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   85m   v1.15.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要将 Pod 部署到美国服务器，可以在 YAML 文件中添加一个节点选择器 <code>nodeSelector</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-US.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: alice-pod-us
spec:
  nodeSelector:
    location: <span class="token string">"US"</span>
  containers:
  - image: assassing/kubia
    name: assassing
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl get pod --all-namespaces <span class="token parameter variable">-o</span> wide
NAMESPACE  NAME         READY  STATUS RESTARTS AGE IP          NODE       NOMINATED NODE
default    alice-pod-us <span class="token number">1</span>/1    Running <span class="token number">0</span>       32s <span class="token number">10.244</span>.1.6  k8s-node1  <span class="token operator">&lt;</span>none<span class="token operator">></span>      
default    alice-pod-v1 <span class="token number">1</span>/1    Running <span class="token number">0</span>       26m <span class="token number">10.244</span>.2.5  k8s-node2  <span class="token operator">&lt;</span>none<span class="token operator">></span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="添加注解"><a class="markdownIt-Anchor" href="#添加注解"></a> 添加注解</h2>
<p>注解只是为了保存标识信息而存在，不能像标签一样进行分组，但可以容纳更多信息，主要用于工具使用。</p>
<p>可以在描述文件中或使用 <code>kubectl annotate</code> 命令来添加注解：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl annotate pod alice-pod <span class="token assign-left variable">build</span><span class="token operator">=</span><span class="token string">"20160602"</span>
pod/alice-pod annotated
<span class="token punctuation">[</span>user1@server6 ~<span class="token punctuation">]</span>$ kubectl describe pod alice-pod
Labels:       <span class="token assign-left variable">env</span><span class="token operator">=</span>prod
Annotations:  build: <span class="token number">20160602</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="探针和钩子"><a class="markdownIt-Anchor" href="#探针和钩子"></a> 探针和钩子</h1>
<p>探针和钩子是容器化应用程序中常用的两种机制，用于增强应用程序的可靠性和健壮性。</p>
<h2 id="存活探针"><a class="markdownIt-Anchor" href="#存活探针"></a> 存活探针</h2>
<p>Kubernetes 可以通过存活探针（Liveness Probe）检查容器是否仍在运行。可以为 Pod 中的每个容器单独指定存活探针，如果探测失败，Kubernetes 将定期执行探测并重新启动容器。</p>
<p>Kubernetes 提供了三种探测容器的机制：</p>
<ul>
<li>ExecAction：在容器内执行一个命令，并根据返回的状态码进行诊断。状态码为 0 表示成功，否则表示容器不健康。</li>
<li>TCPSocketAction：通过尝试与容器的特定 TCP 端口建立连接进行诊断，如果端口能够打开，则表示容器正常。</li>
<li>HTTPGetAction：通过向容器的 IP 地址的指定端口和路径发起 HTTP GET 请求进行诊断。响应码为 2xx 或 3xx 时表示成功，其他任何响应码表示失败。</li>
</ul>
<p>存活探针由各个节点上的 Kubelet 服务负责执行，而主节点上的控制组件不参与此过程。</p>
<h3 id="http-探针"><a class="markdownIt-Anchor" href="#http-探针"></a> HTTP 探针</h3>
<p>HTTP 探针用于检测 Web 服务器是否正常响应请求，非常有用。在这里，我们使用一个 Node.js 程序，该程序在第 5 次请求后返回状态码 500：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> os <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Kubia server starting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> requestCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Received request from "</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>remoteAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  requestCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>requestCount <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">"I'm not well. Please restart me!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">"You've hit "</span> <span class="token operator">+</span> os<span class="token punctuation">.</span><span class="token function">hostname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> www <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
www<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构建镜像的方法可以参考快速入门中的内容。下面是用于创建 Pod 的 YAML 文件示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-live.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-liveness
spec:
  containers:
  - image: luksa/kubia-unhealthy
    name: kubia
    livenessProbe:
      httpGet:
        path: /
        port: <span class="token number">8080</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-live.yaml <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述配置定义了一个使用 HTTP GET 方法的存活探针，它会检查 Pod 的 8080 端口以确定容器的健康状态。</p>
<p>启动 Pod 后，观察 Pod 的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">watch</span> kubectl get po
NAME             READY   STATUS    RESTARTS      AGE       
kubia-liveness   <span class="token number">1</span>/1     Running   <span class="token number">2</span> <span class="token punctuation">(</span>12h ago<span class="token punctuation">)</span>   4m8s  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>大约两分钟后，存活探针检测到返回码为 500，即会重新启动容器，并增加重启计数。如此循环。</p>
<p>可以使用以下命令查看 Pod 的日志。由于 <code>kubectl logs</code> 命令只会打印当前容器的日志，如果想查看之前容器的日志，需要使用 <code>--previous</code> 选项：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl logs kubia-liveness <span class="token parameter variable">--previous</span>
Kubia server starting<span class="token punctuation">..</span>.
Received request from ::ffff:192.168.2.206
Received request from ::ffff:192.168.2.206
Received request from ::ffff:192.168.2.206
Received request from ::ffff:192.168.2.206<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>日志显示的请求访问都来自存活探针。再次查看 Pod 的描述：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po kubia-liveness
    Last State:     Terminated
      Reason:       Error
      Exit Code:    <span class="token number">137</span>
      Started:      Wed, 03 Nov <span class="token number">2021</span> <span class="token number">14</span>:38:46 +0800
      Finished:     Wed, 03 Nov <span class="token number">2021</span> <span class="token number">14</span>:40:33 +0800
Events:
  Type     Reason     Age                From               Message
  ----     ------     ----               ----               -------
  Normal   Pulled     12h                kubelet            Successfully pulled image <span class="token string">"luksa/kubia-unhealthy"</span> <span class="token keyword">in</span> <span class="token number">40</span>.786546605s
  Normal   Pulled     12h                kubelet            Successfully pulled image <span class="token string">"luksa/kubia-unhealthy"</span> <span class="token keyword">in</span> <span class="token number">3</span>.188020575s
  Normal   Created    12h <span class="token punctuation">(</span>x3 over 12h<span class="token punctuation">)</span>  kubelet            Created container kubia
  Normal   Pulled     12h                kubelet            Successfully pulled image <span class="token string">"luksa/kubia-unhealthy"</span> <span class="token keyword">in</span> <span class="token number">3</span>.281767877s
  Normal   Started    12h <span class="token punctuation">(</span>x3 over 12h<span class="token punctuation">)</span>  kubelet            Started container kubia
  Warning  Unhealthy  12h <span class="token punctuation">(</span>x9 over 12h<span class="token punctuation">)</span>  kubelet            Liveness probe failed: HTTP probe failed with statuscode: <span class="token number">500</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以清楚地看到上次退出代码为 137 = 128 + 9，表示进程由外部信号终止，其中 9 代表 SIGKILL 强制终止信号。当容器被强制终止时，会创建一个全新的容器而不是重启原先的容器。</p>
<h3 id="exec-探针"><a class="markdownIt-Anchor" href="#exec-探针"></a> Exec 探针</h3>
<p>Exec 探针只有一个可用属性 <code>command</code>，用于指定要执行的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">livenessProbe:
  exec:
    command: <span class="token punctuation">[</span><span class="token string">"test"</span>, <span class="token string">"-e"</span>, <span class="token string">"/tmp/healthy"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="tcp-探针"><a class="markdownIt-Anchor" href="#tcp-探针"></a> TCP 探针</h3>
<p>相比于 HTTP 探测，TCP 探针更高效且节约资源，但精确度稍低。毕竟连接建立成功并不意味着页面资源可用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">livenessProbe:
  tcpSocket:
    port: <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="附加属性"><a class="markdownIt-Anchor" href="#附加属性"></a> 附加属性</h3>
<p>可以给存活探针增加附加属性，可设置以下五个属性：</p>
<ul>
<li><code>initialDelaySeconds</code>：表示容器启动后等待多少秒开始探测，默认为 0 秒。</li>
<li><code>timeoutSeconds</code>：表示响应时间超过多少秒为失败，默认为 1 秒。</li>
<li><code>periodSeconds</code>：表示探针探测周期的时间间隔，以秒为单位，默认为 10 秒。</li>
<li><code>successThreshold</code>：表示探测成功几次后将 Pod 的状态恢复为正常，默认为 1 次。</li>
<li><code>failureThreshold</code>：表示连续探测失败几次后重启容器，默认为 3 次。</li>
</ul>
<p>其中，最常用的是设置初始化等待时间，将默认的立即开始探测改为 15 秒：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-http-liveness-probe.yaml 
    livenessProbe:
      httpGet:
        path: /
        port: <span class="token number">8080</span>
      initialDelaySeconds: <span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="就绪探针"><a class="markdownIt-Anchor" href="#就绪探针"></a> 就绪探针</h2>
<p>就绪探针用于定期调用并确定特定的 Pod 是否已准备好接收客户端请求。当容器的就绪探针返回成功时，表示容器已经准备好接收请求。Kubernetes 只能检查在容器中运行的应用程序是否响应一个简单的 GET 请求，或者响应特定的 URL 路径。因此，在开发应用程序时需要添加就绪探针的逻辑。</p>
<p>就绪探针有三种类型，与存活探针相同。与存活探针的目的不同，就绪探针用于确保 Pod 已准备好接收请求。</p>
<p>就绪探针的工作原理如下：在启动容器时配置一个等待时间，等待时间过后开始执行第一次就绪检查。之后，会定期（默认为每 10 秒）调用就绪探针，并根据结果采取相应的操作。如果容器未通过就绪检查，Pod 不会被终止或重新启动，只是从服务的终端点（endpoints）中移除，等待下一次探测检查。当再次就绪时，将重新添加该 Pod，以确保客户端只与正常的 Pod 进行交互。</p>
<h3 id="添加就绪探针"><a class="markdownIt-Anchor" href="#添加就绪探针"></a> 添加就绪探针</h3>
<p>修改已存在的 Replication Controller 对象 kubia，并添加就绪探针的配置，可以执行以下操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl edit rc kubia
<span class="token punctuation">..</span>.
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: kubia
    spec:
      containers:
      - image: luksa/kubia
        readinessProbe:
          exec:
            command:
            - <span class="token function">ls</span>
            - /var/ready
        imagePullPolicy: Always
        name: kubia
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述的 Exec 类型就绪探针将定期在容器内执行 <code>ls /var/ready</code> 命令，如果文件存在则返回退出码 0，否则探测失败。</p>
<h3 id="测试效果"><a class="markdownIt-Anchor" href="#测试效果"></a> 测试效果</h3>
<p>由于并不存在 <code>/var/ready</code> 文件，因此删除容器后自动创建的容器会一直失败，READY 项显示为 0/1：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pod
NAME                             READY   STATUS    RESTARTS   AGE
kubia-2vvrx                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          108m
kubia-6j8vf                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          108m
kubia-fq6lt                      <span class="token number">0</span>/1     Running   <span class="token number">0</span>          64s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直到手动添加 <code>ready</code> 文件，使就绪探针返回成功，容器的状态才会变为运行中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> kubia-fq6lt -- <span class="token function">touch</span> /var/ready
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pod
NAME                             READY   STATUS    RESTARTS   AGE
kubia-2vvrx                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          110m
kubia-6j8vf                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          110m
kubia-fq6lt                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m40s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="周期钩子"><a class="markdownIt-Anchor" href="#周期钩子"></a> 周期钩子</h2>
<p>周期钩子是 Kubernetes 中的一种机制，用于在 Pod 的生命周期事件发生时执行特定的操作。它可以在 Pod 的不同阶段（如启动前、启动后、终止前）触发预定义的脚本或命令。周期钩子可以用于执行初始化操作、配置设置、资源准备、清理等任务。</p>
<p>周期钩子主要包括以下三种类型：</p>
<ol>
<li><strong>容器生命周期钩子（Container Lifecycle Hook）</strong>：在容器的生命周期事件中触发钩子操作。可以在容器启动前（PreStart）或容器终止前（PostStart）执行自定义的脚本或命令。例如，可以在容器启动前等待其他服务可用，或在容器终止前进行资源清理操作。</li>
<li><strong>初始化容器（Init Container）</strong>：在 Pod 中的一个或多个初始化容器在主容器启动之前执行。初始化容器可以用于进行初始化设置、数据加载、依赖检查等任务。只有当所有初始化容器成功完成后，主容器才会启动。</li>
<li><strong>Pod 生命周期钩子（Pod Lifecycle Hook）</strong>：在整个 Pod 的生命周期事件中触发钩子操作。可以在 Pod 启动前（PostStart）或 Pod 终止前（PreStop）执行自定义的脚本或命令。例如，可以在 Pod 启动前进行资源注册、配置加载等操作，或在 Pod 终止前进行清理、数据保存等操作。</li>
</ol>
<p>生命周期钩子和探针相似，都可以在容器内部执行命令或发送 GET 请求到指定的 URL。但是，生命周期钩子是针对容器而不是 Pod 的。</p>
<p>钩子处理可以使用 HTTP 或 Exec 方式进行实现。</p>
<h3 id="启动后钩子"><a class="markdownIt-Anchor" href="#启动后钩子"></a> 启动后钩子</h3>
<p>启动后钩子是在容器的主进程启动之后立即执行的。可以利用该钩子在应用程序启动时执行额外的工作，例如向外部监听器发送应用程序已启动的信号。启动后钩子和主进程并行执行，直到钩子执行完毕之前，容器将一直处于等待状态。此时，Pod 的状态将显示为 Pending。如果钩子执行失败或返回非零状态码，主容器将被终止：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">containers:
- name: nodejs
  image: luksa/kubia
  lifecycle:
    postStart:
      exec:
        command:
        - <span class="token function">sh</span>
        - <span class="token parameter variable">-C</span>
        - <span class="token string">"echo 'failed'; sleep 5; exit 250"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的示例中，echo、sleep 和 exit 是与容器的主进程一起执行的。通常情况下，可以通过在容器镜像中存储的 shell 脚本或可执行二进制文件来运行这些钩子。</p>
<p>如果钩子程序执行失败，可以在 Pod 的事件中看到 FailedPostStartHook 的警告信息。</p>
<h3 id="停止前钩子"><a class="markdownIt-Anchor" href="#停止前钩子"></a> 停止前钩子</h3>
<p>停止前钩子是在容器被终止之前立即执行的。当一个容器需要停止运行时，在发送 SIGTERM 信号给容器进程之前，将执行钩子程序。</p>
<p>添加停止前钩子与添加启动后钩子类似：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">containers:
- name: nodejs
  image: luksa/kubia
  lifecycle:
    preStop:
      httpGet:
        port: <span class="token number">8080</span>
        path: <span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述命令会向 <code>http://POD_IP:8080/shutdown</code> 这个 URL 发送 HTTP GET 请求。</p>
<p>还可以设置 scheme（HTTP 或 HTTPS）、host 和请求的 httpHeaders。默认情况下，host 的值为 Pod 的 IP 地址。</p>
<p>与启动后钩子不同的是，无论停止前钩子的执行结果如何，容器都将被终止。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 服务资源</title>
    <url>/3045985343/</url>
    <content><![CDATA[<h1 id="服务概念"><a class="markdownIt-Anchor" href="#服务概念"></a> 服务概念</h1>
<p>在 K8s 中，不再使用记录 pod IP 的方式来实现 pod 之间的通信，因为 pod 是活动的，会随着调度分配而更换 IP 地址。K8s 提供了一种名为服务（Service）的资源，用于解决 pod 之间的通信问题。每个服务实际上就是微服务架构中的一个微服务。</p>
<p>服务的主要工作是通过标签选择器选取一组 pod 对象，并为这组 pod 提供一个固定的入口点（固定 IP），客户端通过访问该地址来访问这组 pod 中的任意一个对象。</p>
<p>如果集群中存在 DNS 服务，它会在创建服务时为其自动配置一个 DNS 名称，该名称对应服务的 ClusterIP 地址，以便客户端进行服务发现。实质上，服务充当了一个四层代理服务器。</p>
<h2 id="服务原理"><a class="markdownIt-Anchor" href="#服务原理"></a> 服务原理</h2>
<p>每个 Service 都有自己稳定的 IP 地址和端口，客户端通过连接该 IP 和端口来使用服务。IP 地址是虚拟的，没有分配给任何网络接口，并且当数据包离开节点时，也不会被标记为数据包的源或目的地 IP 地址，因此无法使用 ping 命令连接到 Service 的 IP。</p>
<p>与 Service 相关的所有事情都由运行在每个节点上的 kube-proxy 处理。在最初的实现中，代理模式采用用户空间代理，对于每个传入的连接，连接到一个 pod。</p>
<p>现在采用的是 iptables 代理模式，具有更好的性能。当在 API 服务器中创建一个 Service 时，会立即分配虚拟 IP 地址。然后，API 服务器会通知所有节点上的 proxy 客户端有关新服务的信息。每个 proxy 都会在自己所在的节点上建立可寻址的服务。这是通过建立 iptables 规则来实现的，确保目标为服务的 IP/端口对的数据包被解析，目的地址被修改，从而将数据包重定向到支持该服务的一个 pod 上。</p>
<p>除了监视 Service 的更改，proxy 还监视 Endpoint 对象的更改。Endpoint 对象会在每次新创建或删除 pod 时发生变化，以及 pod 的就绪状态或标签发生变化时，将其纳入或移出服务范畴。</p>
<p>如下图所示，proxy 在 Service 中的作用：</p>
<p><img data-src="../../../images/proxy%E7%9A%84%E4%BD%9C%E7%94%A8.jpg" alt="proxy的作用" /></p>
<p>上述示例中，一个数据包从节点 A 的 pod A 发送到服务 B。节点 A 的 iptables 规则将数据包的目标地址设置为服务的 IP 和端口（172.30.0.1:80），根据规则匹配，将匹配到的地址和端口（172.30.0.1:80）替换为随机选中的 pod B2 的 IP 和端口，就好像客户端的 pod A 直接将数据包发送给 pod B，而不经过 Service。</p>
<p>运行在每个节点上的 Proxy 进程实际上是一个智能的软件负载均衡器，内部实现了服务的负载均衡和会话保持机制。</p>
<h2 id="外部连接的特性"><a class="markdownIt-Anchor" href="#外部连接的特性"></a> 外部连接的特性</h2>
<p>当客户端通过节点端口连接到服务时，随机选择的 pod 并不一定在接收连接的同一节点上运行。例如，接收服务的 pod 运行在 node1，而服务在 node2，这会导致不必要的跳转。可以通过将服务配置为仅将外部通信重定向到接收连接的节点上运行的 pod。</p>
<p>具体操作是将服务的 <code>spec.externalTrafficPolicy</code> 修改为 <code>Local</code>。如果节点上没有本地 pod 存在，则连接将挂起，因此需要确保负载均衡器将连接转发给至少具有一个 pod 的节点。</p>
<p>然而，这种配置会引发一个问题，即原本均匀分配给 pod 的流量将按节点平均分配。例如，一个节点有一个 pod，另一个节点有两个 pod，原本每个 pod 接收的流量占比为 1/3。设置流量不转发后，一个 pod 承担了 1/2 的流量，而另外两个 pod 分别承担了 1/4 的流量。</p>
<p>在没有配置流量不转发的情况下，当通过节点端口接收连接时，会对数据包执行源网络地址转换（SNAT），因此数据包的源 IP 地址会发生改变，后端的 pod 无法看到实际的客户端 IP 地址。而使用上述配置可以保留客户端 IP，因为接收连接的节点和目标 pod 节点之间没有额外的跳转。</p>
<h2 id="排除连接故障"><a class="markdownIt-Anchor" href="#排除连接故障"></a> 排除连接故障</h2>
<p>首先，确保从集群内部连接到服务时使用的是集群 IP，而不是从外部进行连接。</p>
<p>请避免使用 ping 来判断服务是否可访问，因为服务的集群 IP 是虚拟的。</p>
<p>如果已经定义了就绪探针，请确保探针返回成功，否则该 pod 将不会被视为服务的一部分。</p>
<p>要确认某个容器是否属于服务，请使用 <code>get endpoints</code> 命令来检查相应的端点对象。</p>
<p>如果通过完全限定域名（FQDN）无法访问服务，请尝试使用集群 IP 进行访问。</p>
<p>可以尝试直接连接到 pod 的 IP 地址，以确认该 pod 是否正在正确的端口上接收连接。</p>
<p>如果甚至无法通过 pod 的 IP 访问应用程序，请确保应用程序没有仅绑定到本地主机。</p>
<h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1>
<p>服务（Services）使用标签（Labels）来选择 Pod。以下简称 SVC。</p>
<h2 id="创建-svc"><a class="markdownIt-Anchor" href="#创建-svc"></a> 创建 SVC</h2>
<p>假设已经启动了一组 Pod，其标签为 <code>app=kubia</code>，可以通过命令 <code>kubectl expose</code> 来创建服务。不过更推荐使用 YAML 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
  selector:
    app: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 80 端口用于对外访问，8080 映射到容器端口，并通过标签 <code>app=kubia</code> 选择 Pod。</p>
<p>创建并查看服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-svc.yaml 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get svc
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP   17h
kubia        ClusterIP   <span class="token number">10.107</span>.244.106   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP    8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到服务已经分配了一个内部集群 IP 地址 <code>10.107.244.106</code>，访问端口为 80。</p>
<h2 id="测试服务"><a class="markdownIt-Anchor" href="#测试服务"></a> 测试服务</h2>
<p>由于是内部集群地址，只有集群中的 Pod 可以访问。可以使用 <code>kubectl exec</code> 命令在 Pod 中执行 <code>curl</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> kubiaex-f4wkw -- <span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token number">10.107</span>.244.106
You<span class="token string">'ve hit kubiaex-nj968
[root@server4-master ~]$ kubectl exec kubiaex-f4wkw -- curl -s 10.107.244.106
You'</span>ve hit kubiaex-ptws9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看到请求连接到后端的随机一个 Pod。</p>
<h2 id="亲和性"><a class="markdownIt-Anchor" href="#亲和性"></a> 亲和性</h2>
<p>可以配置服务的会话亲和性，这样会使服务代理将同一 IP 的请求转发到同一个 Pod 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc.yaml
spec:
  sessionAffinity: ClientIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>亲和性配置 <code>sessionAffinity</code> 值默认为 <code>None</code>。由于 Kubernetes 服务不是在 HTTP 层面上工作，它只处理 TCP 和 UDP 包，所以会话亲和性不能基于 cookie。</p>
<h2 id="暴露多端口"><a class="markdownIt-Anchor" href="#暴露多端口"></a> 暴露多端口</h2>
<p>可以在服务中暴露多个端口。必须设置端口名称：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc.yaml
spec:
  ports:
  - name: http
    port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
  - name: https
    port: <span class="token number">443</span>
    targetPort: <span class="token number">8443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="命名引用"><a class="markdownIt-Anchor" href="#命名引用"></a> 命名引用</h2>
<p>如果 Pod 配置中对端口取了名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-rs.yaml
spec:
  containers:
    ports: 
    - name: http
      containerPort: <span class="token number">8080</span>
    - name: https
      containerPort: <span class="token number">8443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么在服务配置中可以直接引用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc.yaml
spec:
  ports:
  - name: http
    port: <span class="token number">80</span>
    targetPort: http
  - name: https
    port: <span class="token number">443</span>
    targetPort: https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样做的好处是，当容器更换端口号时，无须更改服务的配置。</p>
<h1 id="服务发现"><a class="markdownIt-Anchor" href="#服务发现"></a> 服务发现</h1>
<p>服务可以提供稳定的 IP 地址来访问 Pod，只要服务存在， IP 就不会变化。但客户端 Pod 要获得服务的 IP 和端口需要进行配置。</p>
<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2>
<p>如果服务先于 Pod 创建，Pod 创建时 Kubernetes 会初始化一系列环境变量，指向已存在的服务。Pod 上的进程可以根据环境变量获取服务的 IP 地址和端口号。</p>
<p>重新运行 Pod 后再查看环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete <span class="token parameter variable">-f</span> kubia-rs.yaml 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-rs.yaml 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> kubiaex-5s68q -- <span class="token function">env</span>
<span class="token assign-left variable">KUBIA_PORT</span><span class="token operator">=</span>tcp://10.107.244.106:80
<span class="token assign-left variable">KUBIA_SERVICE_HOST</span><span class="token operator">=</span><span class="token number">10.107</span>.244.106
<span class="token assign-left variable">KUBIA_SERVICE_PORT</span><span class="token operator">=</span><span class="token number">80</span>
<span class="token assign-left variable">KUBIA_PORT_80_TCP_PROTO</span><span class="token operator">=</span>tcp
<span class="token assign-left variable">KUBIA_PORT_80_TCP_ADDR</span><span class="token operator">=</span><span class="token number">10.107</span>.244.106
<span class="token assign-left variable">KUBIA_PORT_80_TCP</span><span class="token operator">=</span>tcp://10.107.244.106:80
<span class="token assign-left variable">KUBIA_PORT_80_TCP_PORT</span><span class="token operator">=</span><span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面显示的环境变量是创建服务后才有的，它们指向了服务 <code>kubia</code> 的 IP 地址和端口。此外，还有 Kubernetes 服务的环境变量。</p>
<h2 id="通过-dns-发现"><a class="markdownIt-Anchor" href="#通过-dns-发现"></a> 通过 DNS 发现</h2>
<p>Kubernetes 使用 CoreDNS 作为默认的 DNS 服务。每个运行的 Pod 都会在 <code>/etc/resolv.conf</code> 中写入 DNS 服务的地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token parameter variable">-n</span> kube-system describe service/kube-dns
IP:                <span class="token number">10.96</span>.0.10
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$  kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubiaex-5s68q -- <span class="token function">cat</span> /etc/resolv.conf 
nameserver <span class="token number">10.96</span>.0.10
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Pod 是否使用内部 DNS 策略由 <code>spec.dnsPolicy</code> 来决定：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po kubiaex-5s68q <span class="token parameter variable">-o</span> yaml
spec:
  dnsPolicy: ClusterFirst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>客户端的 Pod 在知道服务名称的情况下，可以通过全限定域名（Fully Qualified Domain Name，FQDN）来访问，而不用依靠环境变量。例如，服务的全名是 <code>kubia.default.svc.cluster.local</code>，通过 Pod 中的容器访问这个地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kubiaex-5s68q:/<span class="token comment"># curl http://kubia.default.svc.cluster.local</span>
You've hit kubiaex-bwzb9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>FQDN 分为三部分：<code>kubia</code> 为主机名，<code>default</code> 为对应的命名空间，<code>svc.cluster.local</code> 是所有集群本地服务名称中使用的可配置集群域后缀。</p>
<p>如果要与同一命名空间下的资源通信，可以省略后缀，直接通过主机名进行通信：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kubiaex-5s68q:/<span class="token comment"># curl http://kubia  </span>
You've hit kubiaex-bwzb9
root@kubiaex-5s68q:/<span class="token comment"># ping kubia</span>
PING kubia.default.svc.cluster.local <span class="token punctuation">(</span><span class="token number">10.107</span>.244.106<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="暴露内部服务"><a class="markdownIt-Anchor" href="#暴露内部服务"></a> 暴露内部服务</h1>
<p>服务主要作用是将集群内的服务向外公开，让外部客户端可以访问它们。如下图所示：</p>
<p><img data-src="../../../images/%E5%B0%86%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%87%BA%E5%8E%BB.jpg" alt="将服务暴露出去" /></p>
<p>有几种方式可以从外部访问服务：</p>
<ul>
<li>
<p>将服务类型设置为 NodePort</p>
<p>每个集群节点都会打开一个端口，并将流量转发重定向到基础服务。该服务只能在内部集群的 IP 和端口上访问，但也可以通过所有节点上的专用端口访问。</p>
</li>
<li>
<p>将服务类型设置为 LoadBalancer</p>
<p>LoadBalancer 是 NodePort 类型的一种扩展，它允许通过一个专用的负载均衡器来访问服务，该负载均衡器由云基础设施提供。负载均衡器将流量重定向到跨所有节点的节点端口，客户端可以通过负载均衡器的 IP 连接到服务。</p>
</li>
<li>
<p>创建一个 Ingress 资源</p>
<p>Ingress 资源可以通过一个 IP 地址公开多个服务，它运行在 HTTP 层（第 7 层），因此可以提供更多的功能。</p>
</li>
</ul>
<p>最常用的端口暴露方式是 NodePort。一般的应用端口可以通过 Nginx 做反向代理，而不需要直接暴露出去。</p>
<h2 id="nodeport"><a class="markdownIt-Anchor" href="#nodeport"></a> NodePort</h2>
<p>NodePort 类型的服务可以通过任何节点的 IP 和端口进行访问，同时也可以通过服务的内部集群 IP 进行访问，两者互不冲突。默认情况下，NodePort 可用的端口范围是从 30000 到 32767。示意图如下所示：</p>
<p><img data-src="../../../images/%E9%80%9A%E8%BF%87NodePort%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3.jpg" alt="通过NodePort暴露端口" /></p>
<p>创建服务配置文件时，除了将类型设置为 NodePort，还需要定义三个端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-np.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia-nodeport
spec:
  type: NodePort
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
    nodePort: <span class="token number">30123</span>
  selector:
    app: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，port 端口 80 代表集群内部访问端口，targetPort 端口 8080 代表 Pod 中服务监听的端口，这两个端口的定义与普通服务相同。而额外的 nodePort 端口 30123 是用于外部访问的端口。如果不设置 nodePort，Kubernetes 会使用随机端口。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-np.yaml
service/kubia-nodeport created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动后，可以通过浏览器访问地址 <a href="http://xn--ip-dh3cr99d42rrmy:30123/">http://任意节点 IP:30123/</a> 来打开服务。可以使用 JSONPath 选择器来获取所有节点的 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get nodes <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'&#123;.items[*].status.addresses[?(@.type=="InternalIP")].address&#125;'</span>
<span class="token number">192.168</span>.2.204 <span class="token number">192.168</span>.2.205 <span class="token number">192.168</span>.2.206<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要注意的是，当节点发生故障时，无法访问该节点。因此，在选择端口暴露方式时，应优先考虑使用 LoadBalancer。</p>
<h2 id="loadbalance"><a class="markdownIt-Anchor" href="#loadbalance"></a> LoadBalance</h2>
<p>负载均衡器具有唯一的 IP 地址，并将所有连接重定向到服务。LoadBalancer 服务是 NodePort 服务的扩展，如果 Kubernetes 在不支持负载均衡器服务的环境中运行，服务仍将以 NodePort 模式工作。其工作原理如下图所示：</p>
<p><img data-src="../../../images/%E9%80%9A%E8%BF%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3.jpg" alt="通过负载均衡暴露端口" /></p>
<p>可以创建一个 LoadBalancer 类型的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-lb.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia-loadbalancer
spec:
  type: LoadBalancer
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
  selector:
    app: kubia
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-lb.yaml 
service/kubia-loadbalancer created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只需将服务类型设置为 LoadBalancer，服务将从集群基础架构中获取负载均衡器，并将其 IP 地址写入服务的 EXTERNAL-IP 字段。</p>
<p>通过浏览器访问时，您会发现每次都会连接到同一个 Pod，这是因为服务在连接级别上工作。因此，首次建立连接时会选择一个随机集群，之后所有的数据包都会发送到同一个集群，直到连接关闭。</p>
<h2 id="ingress"><a class="markdownIt-Anchor" href="#ingress"></a> Ingress</h2>
<p>使用 Ingress 只需要一个公网 IP 地址就能为所有服务提供访问，Ingress 会根据请求的主机名和路径决定转发到的服务。</p>
<p>Ingress 作用在网络第七层，因此能实现基于 cookie 的会话亲和性等功能，但相对于作用在第四层协议的服务，转发效率较低。</p>
<p>Ingress 的工作原理如下图所示：</p>
<p><img data-src="../../../images/%E9%80%9A%E8%BF%87Ingress%E8%AE%BF%E9%97%AEpod.jpg" alt="通过Ingress访问pod" /></p>
<p>要让 Ingress 资源正常工作，需要配合 Ingress 控制器。可以通过官方提供的 YAML 文件直接部署 Ingress，可以选择基于 Nginx、Envoy、Haproxy、Vulcand 和 Traefik 等作为反向代理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl apply <span class="token parameter variable">-f</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml
namespace/ingress-nginx created
configmap/nginx-configuration created
configmap/tcp-services created
configmap/udp-services created
serviceaccount/nginx-ingress-serviceaccount created
clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created
role.rbac.authorization.k8s.io/nginx-ingress-role created
rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created
clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created
deployment.apps/nginx-ingress-controller created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看 YAML 内容后，将自动创建一个属于 ingress-nginx 命名空间的 nginx-ingress-controller 控制器的 Pod，然后创建服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl get pods --all-namespaces <span class="token parameter variable">-l</span> app.kubernetes.io/name<span class="token operator">=</span>ingress-nginx <span class="token parameter variable">--watch</span>
NAMESPACE       NAME                                        READY   STATUS              RESTARTS   AGE
ingress-nginx   nginx-ingress-controller-7995bd9c47-8v8rj   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          75s
ingress-nginx   nginx-ingress-controller-7995bd9c47-8v8rj   <span class="token number">0</span>/1     Running             <span class="token number">0</span>          88s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着创建服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl apply <span class="token parameter variable">-f</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/service-nodeport.yaml
service/ingress-nginx created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get pods <span class="token parameter variable">-n</span> ingress-nginx
NAME                                        READY   STATUS    RESTARTS   AGE
nginx-ingress-controller-7995bd9c47-8v8rj   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3h6m
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get svc <span class="token parameter variable">-n</span> ingress-nginx
NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                      AGE
ingress-nginx   NodePort   <span class="token number">10.98</span>.41.161   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30112/TCP,443:30970/TCP   105m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>建立 YAML 文件来绑定后端服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: kubia-ingress
spec:
  rules:
  - host: kubia.exp.com
    http:
      paths:
      - path: /
        backend:
          serviceName: kubia
          servicePort: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将虚拟域名 <code>kubia.exp.com</code> 映射到 Ingress 控制器的节点 IP（192.168.2.113-115 <code>kubia.exp.com</code>）。配置将所有请求发送到 kubia 服务的 80 端口。云服务商要求 Ingress 指向一个 NodePort 服务，但实际上可以指向任意服务。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-ingress.yaml 
ingress.extensions/kubia-ingress created
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ kubectl get ingresses
NAME            HOSTS           ADDRESS   PORTS   AGE
kubia-ingress   kubia.exp.com             <span class="token number">80</span>      59s
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl describe ingress kubia-ingress
Name:             kubia-ingress
Namespace:        default
Address:          
Default backend:  default-http-backend:80 <span class="token punctuation">(</span><span class="token operator">&lt;</span>none<span class="token operator">></span><span class="token punctuation">)</span>
Rules:
  Host           Path  Backends
  ----           ----  --------
  kubia.exp.com  
                 /   kubia:80 <span class="token punctuation">(</span><span class="token number">10.244</span>.1.28:8080,10.244.2.43:8080,10.244.2.44:8080<span class="token punctuation">)</span>
Annotations:
Events:
  Type    Reason  Age    From                      Message
  ----    ------  ----   ----                      -------
  Normal  CREATE  2m22s  nginx-ingress-controller  Ingress default/kubia-ingress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过浏览器访问 <code>kubia.exp.com:30112</code> 即可访问 kubia 服务。</p>
<p>客户端与控制器之间的通信采用 HTTPS 加密，而控制器与后端 Pod 之间的通信则不需要加密。运行在 Pod 上的应用程序不需要支持 TLS。例如，如果 Pod 上运行着 Web 服务器，它只需要接收 HTTP 通信，并让 Ingress 控制器负责处理与 TLS 相关的所有内容。只需将证书和私钥附加到 Ingress 上，这两个资源存储在 Secret 中，然后在 Ingress 的配置文件中引用它们：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ openssl genrsa <span class="token parameter variable">-out</span> tls.key <span class="token number">2048</span>
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-x509</span> <span class="token parameter variable">-key</span> tls.key <span class="token parameter variable">-out</span> tls.crt <span class="token parameter variable">-subj</span> /C<span class="token operator">=</span>CN/ST<span class="token operator">=</span>Beijing/L<span class="token operator">=</span>Beijing/O<span class="token operator">=</span>DevOps/CN<span class="token operator">=</span>kubia.exp.com
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create secret tls kubia-secret <span class="token parameter variable">--cert</span><span class="token operator">=</span>tls.crt <span class="token parameter variable">--key</span><span class="token operator">=</span>tls.key
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get secret
NAME                    TYPE                                  DATA   AGE
default-token-5wkq2     kubernetes.io/service-account-token   <span class="token number">3</span>      25h
kubia-secret            kubernetes.io/tls                     <span class="token number">2</span>      30s
tomcat-ingress-secret   kubernetes.io/tls                     <span class="token number">2</span>      55m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重新创建 Ingress，使用 HTTPS 协议将 kubia 绑定到 <code>kubia.exp.com</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-tls.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-kubia
  namespace: default
spec:
  tls:
  - hosts:
    - kubia.exp.com
    secretName: kubia-secret
  rules:
  - host: kubia.exp.com
    http:
      paths:
      - path:
        backend:
          serviceName: kubia
          servicePort: <span class="token number">8080</span>
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-tls.yaml 
ingress.extensions/ingress-kubia created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get ingress
NAME                 HOSTS              ADDRESS   PORTS     AGE
ingress-kubia        kubia.exp.com                <span class="token number">80</span>, <span class="token number">443</span>   29s
ingress-myapp        myapp.along.com              <span class="token number">80</span>        65m
ingress-tomcat       tomcat.along.com             <span class="token number">80</span>        60m
ingress-tomcat-tls   tomcat.along.com             <span class="token number">80</span>, <span class="token number">443</span>   58m
kubia-ingress        kubia.exp.com                <span class="token number">80</span>        10m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用浏览器访问 HTTPS 地址：<a href="https://kubia.exp.com:30970/">https://kubia.exp.com:30970/</a> 进行验证。</p>
<p>可以通过设置多个路径来将访问路径转发到不同的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>.
    http:
      paths:
      - path: /
        backend:
          serviceName: kubia
          servicePort: <span class="token number">80</span>
      - path: /admin
        backend:
          serviceName: admin
          servicePort: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样，可以设置多个规则来将子域名转发到不同的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: kubia-ingress
  namespace: default
spec:
  rules:
  - host: kubia.exp.com
    http:
      paths:
      - path: /
        backend:
          serviceName: kubia
          servicePort: <span class="token number">80</span>
  rules:
  - host: app.exp.com
    http:
      paths:
      - path: /
        backend:
          serviceName: app
          servicePort: <span class="token number">80</span>
      - path: /api
        backend:
          serviceName: api
          servicePort: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了使用 NodePort、LoadBalancer 等方式来暴露单个服务，还可以使用 Ingress 来暴露服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-ingress
spec:
  backend:
    serviceName: my-svc
    servicePort: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，通过外网访问 80 端口即可直接转发到 my-svc 服务。</p>
<h1 id="指向外部服务"><a class="markdownIt-Anchor" href="#指向外部服务"></a> 指向外部服务</h1>
<p>SVC 也可以将服务的地址重定向到集群外部网络的地址和端口，在集群中的 pod 可以像连接内部服务一样连接到外部服务。如下图所示：</p>
<p><img data-src="../../../images/%E6%9C%8D%E5%8A%A1%E6%8C%87%E5%90%91%E5%A4%96%E9%83%A8%E5%9C%B0%E5%9D%80.jpg" alt="服务指向外部地址" /></p>
<h2 id="endpoint"><a class="markdownIt-Anchor" href="#endpoint"></a> Endpoint</h2>
<p>SVC 通过 Endpoint（以下简称 EP）资源与 pod 进行连接，一般指向 pod 的 IP 地址和端口列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe svc kubia
Endpoints:         <span class="token number">10.244</span>.191.210:8080,10.244.191.211:8080,10.244.244.209:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以直接查询 EP 资源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get endpoints kubia
NAME    ENDPOINTS                                                     AGE
kubia   <span class="token number">10.244</span>.191.210:8080,10.244.191.211:8080,10.244.244.209:8080   100m
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe endpoints kubia
Name:         kubia
Namespace:    default
Labels:       <span class="token operator">&lt;</span>none<span class="token operator">></span>
Annotations:  endpoints.kubernetes.io/last-change-trigger-time: <span class="token number">2021</span>-11-03T11:45:07Z
Subsets:
  Addresses:          <span class="token number">10.244</span>.191.210,10.244.191.211,10.244.244.209
  NotReadyAddresses:  <span class="token operator">&lt;</span>none<span class="token operator">></span>
  Ports:
    Name     Port  Protocol
    ----     ----  --------
    <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">8080</span>  TCP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>EP 的作用是存储通过 pod 选择器获取的 pod 地址和端口，并提供给服务调用。</p>
<h2 id="配置-ep"><a class="markdownIt-Anchor" href="#配置-ep"></a> 配置 EP</h2>
<p>可以分别创建 SVC 和 EP 资源来自定义要转发到的地址列表。先创建一个没有选择器的服务，并指定 EP 的目标端口为 80：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> outside-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: outside
spec:
  ports:
  - name: http
    port: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一个 EP 来指定地址列表。名称需要与 SVC 的一致：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> outside-ep.yaml
apiVersion: v1
kind: Endpoints
metadata:
  name: outside
subsets:
  - addresses:
    - ip: <span class="token number">11.11</span>.11.11
    - ip: <span class="token number">22.22</span>.22.22
    ports:
    - port: <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分别部署后，SVC 就具有了转发到外部服务的功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> outside-svc.yaml <span class="token parameter variable">-f</span> outside-ep.yaml <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>自定义 Endpoint 通常可用于服务迁移。当集群内的应用迁移到外部时，在 EP 资源中修改地址后，SVC 提供的访问 IP 地址可以保持不变。</p>
<h2 id="配置别名"><a class="markdownIt-Anchor" href="#配置别名"></a> 配置别名</h2>
<p>除了手动配置 EP 外，还可以设置域名作为转发目标。只需要在 SVC 配置文件中设置类型为 ExternalName 即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> ext-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: exten
spec:
  type: ExternalName
  externalName: someapi.somecompany.com
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">6379</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> ext-svc.yaml 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get svc exten 
NAME    TYPE           CLUSTER-IP   EXTERNAL-IP               PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
exten   ExternalName   <span class="token operator">&lt;</span>none<span class="token operator">></span>       someapi.somecompany.com   <span class="token number">80</span>/TCP    29s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后，集群内的 pod 可以通过访问 <code>exten</code> 这个 SVC 就能连接到外部域名 <code>someapi.somecompany.com</code>。这样的好处是不需要关心外部域名的 IP 地址，即使 IP 有变动也不会影响 SVC 的运行。</p>
<h1 id="无头服务"><a class="markdownIt-Anchor" href="#无头服务"></a> 无头服务</h1>
<p>假如客户需要获取一组 pod IP，默认情况下查询服务会返回服务的集群 IP。通过把服务 IP 设为 None，客户端可以通过一个简单的 DNS A 记录查找获取到属于该服务的所有 pod IP。这种服务叫做无头服务。</p>
<h2 id="创建服务"><a class="markdownIt-Anchor" href="#创建服务"></a> 创建服务</h2>
<p>配置 YAML 并启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia-headless
  namespace: default
spec:
  clusterIP: None
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
  selector:
    app: kubia
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-headless.yaml 
service/kubia-headless created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">service</span>
NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGE
kubernetes       ClusterIP   <span class="token number">10.96</span>.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP        130d
kubia            ClusterIP   <span class="token number">10.107</span>.244.106   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP         3h43m
kubia-headless   ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP         3s
kubia-nodeport   NodePort    <span class="token number">10.99</span>.116.227    <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30123/TCP   148m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建完毕后，可以看到服务没有集群 IP。</p>
<h2 id="通过-dns-查找"><a class="markdownIt-Anchor" href="#通过-dns-查找"></a> 通过 DNS 查找</h2>
<p>拉取一个能够进行 DNS 查询的容器后，进入 pod 执行 DNS 查找：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl run dnsutils <span class="token parameter variable">--image</span><span class="token operator">=</span>tutum/dnsutils <span class="token parameter variable">--command</span> -- <span class="token function">sleep</span> infinity
pod/dnsutils created
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> dnsutils <span class="token function">nslookup</span> kubia-headless
Server:         <span class="token number">10.96</span>.0.10
Address:        <span class="token number">10.96</span>.0.10<span class="token comment">#53</span>

Name:   kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.244</span>.1.38
Name:   kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.244</span>.2.57
Name:   kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.244</span>.2.58<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果返回了 pod 的 IP，这与普通服务不同，比如 kubia 服务返回服务的集群 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> dnsutils <span class="token function">nslookup</span> kubia
Server:         <span class="token number">10.96</span>.0.10
Address:        <span class="token number">10.96</span>.0.10<span class="token comment">#53</span>

Name:   kubia.default.svc.cluster.local
Address: <span class="token number">10.102</span>.7.149
<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span>$ kubectl get svc
NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
kubernetes       ClusterIP   <span class="token number">10.96</span>.0.1      <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP   24h
kubia            ClusterIP   <span class="token number">10.102</span>.7.149   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP    64s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无头服务使用上与普通服务一样，客户也可以通过连接服务的 DNS 名称来连接到 pod 上，不过客户端直连到 pod 上，而不是通过服务代理。</p>
<p>无头服务仍然提供跨 pod 的负载平衡，通过 DNS 轮询机制实现。</p>
<h2 id="发现所有-pod"><a class="markdownIt-Anchor" href="#发现所有-pod"></a> 发现所有 Pod</h2>
<p>如果希望 pod 没有准备就绪也能被发现，可以在服务配置中添加注解：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">metadata:
  name: kubia-headless
  namespace: default
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: <span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 控制器资源</title>
    <url>/3401119197/</url>
    <content><![CDATA[<h1 id="replicationcontroller"><a class="markdownIt-Anchor" href="#replicationcontroller"></a> ReplicationController</h1>
<p>以下简称 RC。 可以使用 <code>kubectl api-resources</code> 命令查看所有缩写。</p>
<p>ReplicationController 用于确保 Pod 始终处于运行状态。它主要通过 Pod 标签来控制副本数量。RC 是最初用于复制和重新调度节点的组件，后来被 ReplicaSet 取代，不推荐再使用。</p>
<p>RC 主要由三个部分组成：</p>
<ul>
<li>标签选择器（Label Selector）：用于确定 RC 作用域中的 Pod。</li>
<li>副本个数（Replica Count）：指定应该运行的 Pod 数量。</li>
<li>Pod 模板（Pod Template）：用于创建新的 Pod 副本。</li>
</ul>
<p>RC 的配置可以随时修改：</p>
<ul>
<li>修改副本数量会立即生效。</li>
<li>更改标签选择器和 Pod 模板对正在运行的 Pod 没有影响，只会使现有的 Pod 脱离 RC 的控制范围。</li>
<li>修改模板仅影响由此 RC 创建的新 Pod。</li>
<li>如果更改了一个 Pod 的标签，它将不再由 RC 管理，RC 将自动启动一个新的 Pod 来替代它。</li>
</ul>
<h2 id="创建-rc"><a class="markdownIt-Anchor" href="#创建-rc"></a> 创建 RC</h2>
<p>创建一个最简化的 RC 配置，运行 3 个 Pod 副本，配置如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-rc.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    app: kubia
  template:
    metadata:
      labels:
        app: kubia
    spec:
      containers:
      - name: kubia
        image: luksa/kubia
        ports:
        - containerPort: <span class="token number">8080</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-rc.yaml 
replicationcontroller/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>标签选择器需要与 Pod 的 labels 标签匹配，否则 RC 会不断启动新的容器。如果不指定选择器 selector，RC 会根据 Pod 模板中的标签自动配置。</p>
<p>运行后，Kubernetes 会创建一个名为 “kubia” 的新 RC，并始终运行 3 个实例。如果没有足够的 Pod，RC 会根据模板创建新的 Pod。下面手动删除一个 Pod，RC 会立即重新创建一个新的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete po kubia-wtlrp
pod <span class="token string">"kubia-wtlrp"</span> deleted
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME          READY   STATUS        RESTARTS   AGE
kubia-2vpxd   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          105s
kubia-9fqql   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          105s
kubia-slltr   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          22s
kubia-wtlrp   <span class="token number">1</span>/1     Terminating   <span class="token number">0</span>          105s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有节点故障，RC 会在新的节点上启动原先故障节点上的 Pod，之后即使节点故障恢复，Pod 也不会再迁移回故障节点上。</p>
<h2 id="查看-rc"><a class="markdownIt-Anchor" href="#查看-rc"></a> 查看 RC</h2>
<p>查询当前运行的所有 RC：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get rc
NAME    DESIRED   CURRENT   READY   AGE
kubia   <span class="token number">3</span>         <span class="token number">3</span>         <span class="token number">3</span>       9m37s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>查询具体 RC 的信息同样使用 <code>kubectl describe</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe rc kubia 
Name:         kubia
Namespace:    default
Selector:     <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia
Labels:       <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia
Annotations:  <span class="token operator">&lt;</span>none<span class="token operator">></span>
Replicas:     <span class="token number">3</span> current / <span class="token number">3</span> desired
P Status:  <span class="token number">3</span> Running / <span class="token number">0</span> Waiting / <span class="token number">0</span> Succeeded / <span class="token number">0</span> Failed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修改模板"><a class="markdownIt-Anchor" href="#修改模板"></a> 修改模板</h2>
<p>可以通过 <code>kubectl edit rc</code> 命令来修改 RC 的 Pod 模板，例如修改模板中的标签选择器和副本数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl edit rc kubia
spec:
  replicas: <span class="token number">2</span>
  selector:
    app: kubia1
  template:
    metadata:
      labels:
        app: kubia1
<span class="token string">"/tmp/kubectl-edit-2608748675.yaml"</span> 46L, 1157C written
replicationcontroller/kubia edited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看 Pod 和 Label，发现共有 5 个 Pod，新旧标签同时存在：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po --show-labels 
NAME          READY   STATUS    RESTARTS   AGE   LABELS
kubia-2c44j   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          56s   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia1
kubia-2vpxd   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          40m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia
kubia-9fqql   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          40m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia
kubia-ggk2j   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          56s   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia1
kubia-slltr   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          38m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="水平缩放"><a class="markdownIt-Anchor" href="#水平缩放"></a> 水平缩放</h2>
<p>使用 <code>scale</code> 命令可以修改 RC 配置中的 <code>spec.replicas</code> 字段的数值，实现扩缩容效果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl scale rc kubia <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">1</span>
replicationcontroller/kubia scaled
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pod --show-labels
NAME          READY   STATUS        RESTARTS   AGE     LABELS
kubia-2c44j   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          5m18s   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia1
kubia-ggk2j   <span class="token number">1</span>/1     Terminating   <span class="token number">0</span>          5m18s   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="删除-rc"><a class="markdownIt-Anchor" href="#删除-rc"></a> 删除 RC</h2>
<p>当使用 <code>delete</code> 命令删除 RC 时，Pod 也会被删除。可以指定 <code>--cascade=orphan</code> 选项来删除 RC 同时保持 Pod 运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete rc kubia <span class="token parameter variable">--cascade</span><span class="token operator">=</span>orphan
replicationcontroller <span class="token string">"kubia"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之后可以通过标签选择器创建新的 RC 或 ReplicaSet 将它们再次管理起来。</p>
<h1 id="replicaset"><a class="markdownIt-Anchor" href="#replicaset"></a> ReplicaSet</h1>
<p>以下简称 RS。RS 和 RC 都是依赖 Pod 标签选择器来进行控制。</p>
<p>RS 的行为和用法与 RC 几乎完全相同。与 RC 相比，RS 的选择器还允许进行反向选择，或者通过标签键来选择 Pod。例如，选择所有带有 <code>env</code> 标签的 Pod（<code>env=*</code>）。</p>
<p>通常情况下，不会直接创建 RS 对象，而是通过创建 Deployment 资源时自动创建。Deployment 通过 RS 来管理多个 Pod 副本。</p>
<h2 id="创建-rs"><a class="markdownIt-Anchor" href="#创建-rs"></a> 创建 RS</h2>
<p>创建一个 YAML 配置文件并发布。与 RC 配置不同的是 <code>apiVersion</code> 版本、<code>kind</code> 类型和标签选择器的样式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-rs.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: kubia
  template:
    metadata:
      labels:
        app: kubia
    spec:
      containers:
      - name: kubia
        image: luksa/kubia
        ports:
        - name: http
          containerPort: <span class="token number">80</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-rs.yaml
replicaset.apps/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="标签选择"><a class="markdownIt-Anchor" href="#标签选择"></a> 标签选择</h2>
<p>标签选择器和 Pod 中使用的方式相同，只是语法略有不同。例如，通过 <code>matchLabels</code> 来匹配单个标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-rs.yaml
spec:
  selector:
    matchLabels:
      app: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>matchExpressions</code> 表达式同时选择两个不同 <code>app</code> 值的标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-rs.yaml
spec:
  selector:
    matchExpressions:
      - key: app
        operator: In
        values:
          - kubia
          - kubia1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator</code> 还可以使用其他运算符：<code>NotIn</code>（不在列表中）、<code>Exists</code>（匹配 Key）、<code>DoesNotExist</code>（反向匹配 Key）。</p>
<p>如果指定了多个表达式，所有表达式的匹配结果都必须为 true 才能使选择器与 Pod 匹配。</p>
<p>如果同时使用 <code>matchLabels</code> 和 <code>matchExpressions</code>，则所有标签都必须匹配。</p>
<h1 id="deployment"><a class="markdownIt-Anchor" href="#deployment"></a> Deployment</h1>
<p>最常用的控制器，可以管理多个副本的 pod 并确保它们按照预期状态运行。</p>
<p>Deployment 是一种更高级的资源，用于部署应用程序并以声明的方式升级应用。创建 Deployment 资源时，会同时创建 ReplicaSet（RS）资源，实际上是由 RS 创建和管理 pod。Deployment 的主要职责是处理应用程序升级时两个版本的控制器之间的关系。</p>
<p>下面简称为 Deploy。</p>
<h2 id="创建-deploy"><a class="markdownIt-Anchor" href="#创建-deploy"></a> 创建 Deploy</h2>
<p>创建一个 Deploy 的过程与创建 ReplicaController（RC）的声明基本相同，只是 Deploy 的声明中包含了额外的部署策略字段。由于 Deploy 可以同时管理多个版本的 pod，因此在 Deploy 的名称中不需要添加版本号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: kubia
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - image: luksa/kubia:v1
        name: nodejs
---
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  type: NodePort
  selector:
    app: kubia
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
    nodePort: <span class="token number">30002</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 Deploy 时加入 <code>--record</code> 选项，可以记录 CHANGE-CAUSE 信息，即声明文件中的注解字段：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-deploy.yaml <span class="token parameter variable">--record</span>
Flag <span class="token parameter variable">--record</span> has been deprecated, <span class="token parameter variable">--record</span> will be removed <span class="token keyword">in</span> the future
deployment.apps/kubia created
service/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>kubectl rollout</code> 命令可以查询 Deploy 的部署状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout status deployment kubia
deployment <span class="token string">"kubia"</span> successfully rolled out
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get all
NAME                         READY   STATUS        RESTARTS   AGE
pod/kubia-74967b5695-5s68q   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          10s
pod/kubia-74967b5695-8cxtb   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          10s
pod/kubia-74967b5695-bwzb9   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          10s
pod/kubia-74967b5695-jkcjl   <span class="token number">0</span>/1     Terminating   <span class="token number">0</span>          2m55s

NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGE
service/kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1      <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP        133d
service/kubia        NodePort    <span class="token number">10.101</span>.57.66   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30002/TCP   10s

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/kubia   <span class="token number">3</span>/3     <span class="token number">3</span>            <span class="token number">3</span>           10s

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/kubia-74967b5695   <span class="token number">3</span>         <span class="token number">3</span>         <span class="token number">3</span>       10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建的 pod 名字中间会有一串数字，这是 pod 模板的哈希值。由 Deploy 创建的 ReplicaSet 控制器也带有相同的哈希值。这样 Deploy 就能够对应和管理一个版本的 pod 模板。</p>
<p>通过 30002 端口访问服务来测试 pod 的工作状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v1 running <span class="token keyword">in</span> pod kubia-74967b5695-5s68q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="升级-deploy"><a class="markdownIt-Anchor" href="#升级-deploy"></a> 升级 Deploy</h2>
<p>Deploy 默认的升级策略是执行滚动更新（RollingUpdate）。另一种策略是 Recreate，它会一次性删除所有旧版本的 pod，然后创建新的 pod。</p>
<p>通过 patch 命令修改单个或少量资源属性非常有用，但是更改 Deploy 的自有属性不会触发 pod 的任何更新。可以通过设置一个时间来减慢滚动更新的速度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl patch deploy kubia <span class="token parameter variable">-p</span> <span class="token string">'&#123;"spec": &#123;"minReadySeconds": 10&#125;&#125;'</span>
deployment.apps/kubia patched<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>采用 <code>set image</code> 命令来更改包含容器资源中的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deployment kubia <span class="token assign-left variable">nodejs</span><span class="token operator">=</span>luksa/kubia:v2
deployment.apps/kubia image updated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过 describe 命令查询可以查看 Deploy 的升级方式，和 ReplicaController（RC）滚动升级类似，先增加新版本的 pod，缩减旧版本的 pod，最后完成升级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get all
NAME                         READY   STATUS        RESTARTS   AGE
pod/kubia-74967b5695-5s68q   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          3m40s
pod/kubia-74967b5695-8cxtb   <span class="token number">1</span>/1     Terminating   <span class="token number">0</span>          3m40s
pod/kubia-74967b5695-bwzb9   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          3m40s
pod/kubia-bcf9bb974-9kb8x    <span class="token number">1</span>/1     Running       <span class="token number">0</span>          3s
pod/kubia-bcf9bb974-bqwng    <span class="token number">1</span>/1     Running       <span class="token number">0</span>          21s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如下图所示，整个升级过程由运行在 Kubernetes 上的一个控制器处理和完成，简单又可靠：</p>
<p><img data-src="../../../images/%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7%E7%A4%BA%E6%84%8F.jpg" alt="滚动升级示意" /></p>
<p>如果 Deployment 中的 pod 模板引用了一个 ConfigMap（Secret），那么更改 ConfigMap 资源不会触发升级操作。需要创建一个新的 ConfigMap 并修改 pod 模板引用新的 ConfigMap。</p>
<h2 id="回滚升级"><a class="markdownIt-Anchor" href="#回滚升级"></a> 回滚升级</h2>
<p>如果升级的版本存在问题，可以自动停止升级。首先将应用升级到有错误的版本，在第 5 个请求之后会返回内部服务器错误，即 HTTP 状态码 500：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deploy kubia <span class="token assign-left variable">nodejs</span><span class="token operator">=</span>luksa/kubia:v3
deployment.apps/kubia image updated
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout status deploy kubia
Waiting <span class="token keyword">for</span> deployment <span class="token string">"kubia"</span> rollout to finish: <span class="token number">1</span> out of <span class="token number">3</span> new replicas have been updated<span class="token punctuation">..</span>.
Waiting <span class="token keyword">for</span> deployment <span class="token string">"kubia"</span> rollout to finish: <span class="token number">2</span> out of <span class="token number">3</span> new replicas have been updated<span class="token punctuation">..</span>.
Waiting <span class="token keyword">for</span> deployment <span class="token string">"kubia"</span> rollout to finish: <span class="token number">1</span> old replicas are pending termination<span class="token punctuation">..</span>.
deployment <span class="token string">"kubia"</span> successfully rolled out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>rollout undo</code> 命令回滚到上一个版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout undo deploy kubia
deployment.apps/kubia rolled back<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>undo</code> 命令也可以在滚动升级过程中运行，并直接停止升级回退到旧版本。</p>
<p>最后，通过 <code>rollout history</code> 来显示升级版本的历史记录，可以使用 <code>--revision=1</code> 指定版本号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout <span class="token function">history</span> deployment kubia
deployment.apps/kubia 
REVISION  CHANGE-CAUSE
<span class="token number">1</span>         kubectl create <span class="token parameter variable">--filename</span><span class="token operator">=</span>kubia-deploy.yaml <span class="token parameter variable">--record</span><span class="token operator">=</span>true
<span class="token number">3</span>         kubectl create <span class="token parameter variable">--filename</span><span class="token operator">=</span>kubia-deploy.yaml <span class="token parameter variable">--record</span><span class="token operator">=</span>true
<span class="token number">4</span>         kubectl create <span class="token parameter variable">--filename</span><span class="token operator">=</span>kubia-deploy.yaml <span class="token parameter variable">--record</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>滚动升级成功后，旧版本的 ReplicaSet 不会被删除，Kubernetes 会保留完整的版本修改历史。历史记录保留数目默认为 2，由 Deploy 的 <code>revisionHistoryLimit</code> 属性值来限制，更早的 ReplicaSet 会被删除。</p>
<p>因此，可以通过 <code>undo</code> 命令指定一个特定版本号，回滚到指定的版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout undo deploy kubia --to-revision<span class="token operator">=</span><span class="token number">1</span>
deployment.apps/kubia rolled back<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>--to-revision</code> 参数对应着历史记录上的版本。如果手动删除了遗留的 ReplicaSet，将导致历史版本记录丢失，无法进行回滚。另外，扩容操作不会创建新的版本。</p>
<h2 id="滚动升级策略属性"><a class="markdownIt-Anchor" href="#滚动升级策略属性"></a> 滚动升级策略属性</h2>
<p>可以通过修改 Deploy 配置文件中的 <code>spec.strategy.rollingUpdate</code> 来调整滚动升级策略的两个属性：</p>
<ul>
<li>
<p><code>maxSurge</code>（最大超出数量）</p>
<p>该属性决定了在 Deploy 配置中所期望的副本数之外，允许超出的 Pod 实例数量。默认值为 25%。例如，如果期望副本数为 4，那么在滚动升级期间，最多会运行 5 个 Pod 实例。将百分数转换为绝对值时会进行四舍五入。也可以直接指定绝对值。</p>
</li>
<li>
<p><code>maxUnavailable</code>（最大不可用数量）</p>
<p>该属性决定了在滚动升级期间，相对于期望副本数允许的不可用 Pod 实例数量。默认值为 25%，表示可用的 Pod 实例数量不能低于期望副本数的 75%。例如，如果期望副本数为 4，那么只能有一个 Pod 处于不可用状态。也可以使用绝对值进行设定。</p>
</li>
</ul>
<p>假设当前运行的副本数量为 3。当设置 <code>maxSurge=1</code>，<code>maxUnavailable=0</code> 时，表示需要始终保持 3 个可用的副本，升级过程中最多运行 4 个副本数量。每次启动 1 个新副本，新副本正常运行后，删除 1 个旧副本，直到所有旧副本都被替换掉。整个过程的示意图如下所示：</p>
<p><img data-src="../../../images/%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8B1.jpg" alt="滚动升级策略属性示例1" /></p>
<p>对于 extensions/v1beta1 版本的 Deploy，使用不同的默认值，两个参数都被设置为 1，表示允许 1 个副本处于不可用状态，升级过程中最多运行 4 个副本数量。首先删除 1 个旧副本，启动 2 个新副本，新副本正常运行后，继续删除 1 个旧副本并启动 1 个新副本，直到所有旧副本都被替换掉。整个过程的示意图如下所示：</p>
<p><img data-src="../../../images/%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8B2.jpg" alt="滚动升级策略属性示例2" /></p>
<h2 id="暂停滚动更新"><a class="markdownIt-Anchor" href="#暂停滚动更新"></a> 暂停滚动更新</h2>
<p>可以使用 <code>rollout pause</code> 命令在更新过程中暂停升级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deploy kubia <span class="token assign-left variable">nodejs</span><span class="token operator">=</span>luksa/kubia:v4
deployment.apps/kubia image updated
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout pause deploy kubia
deployment.apps/kubia paused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在此时应用程序处于一个新版本的 Pod 加上三个旧版本的 Pod 的混合运行状态下，部分请求将被切换到新的 Pod 上。通过这种方式，只有部分用户会访问到新版本，相当于运行了一个金丝雀版本。在验证新版本是否正常工作后，可以继续升级剩余的 Pod 或回滚到上一个版本。</p>
<p>可以使用 <code>&amp;&amp;</code> 符号将两个命令连接起来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deploy kubia <span class="token assign-left variable">nodejs</span><span class="token operator">=</span>luksa/kubia:v1 <span class="token operator">&amp;&amp;</span> kubectl rollout pause deploy kubia
deployment.apps/kubia image updated
deployment.apps/kubia paused
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get all
NAME                         READY   STATUS    RESTARTS   AGE
pod/kubia-74967b5695-ckpf9   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          53s
pod/kubia-7bddb8bfc7-fjkkg   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m
pod/kubia-7bddb8bfc7-hnjh4   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m12s
pod/kubia-7bddb8bfc7-wtt8g   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          108s

NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGE
service/kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1      <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP        133d
service/kubia        NodePort    <span class="token number">10.101</span>.57.66   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30002/TCP   37m

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/kubia   <span class="token number">4</span>/3     <span class="token number">1</span>            <span class="token number">4</span>           37m

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/kubia-555774bf68   <span class="token number">0</span>         <span class="token number">0</span>         <span class="token number">0</span>       9m58s
replicaset.apps/kubia-74967b5695   <span class="token number">1</span>         <span class="token number">1</span>         <span class="token number">1</span>       37m
replicaset.apps/kubia-7bddb8bfc7   <span class="token number">3</span>         <span class="token number">3</span>         <span class="token number">3</span>       31m
replicaset.apps/kubia-bcf9bb974    <span class="token number">0</span>         <span class="token number">0</span>         <span class="token number">0</span>       34m
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v3 running <span class="token keyword">in</span> pod kubia-7bddb8bfc7-wtt8g
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v1 running <span class="token keyword">in</span> pod kubia-74967b5695-ckpf9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>滚动升级的进度无法控制，因此进行金丝雀发布的正确方式是使用两个不同的 Deploy，并同时调整它们对应的 Pod 数量。</p>
<h2 id="恢复滚动升级"><a class="markdownIt-Anchor" href="#恢复滚动升级"></a> 恢复滚动升级</h2>
<p>在暂停升级期间，撤销命令不起作用。在恢复升级后才能进行撤销操作。可以使用 <code>rollout resume</code> 命令来恢复升级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout resume deploy kubia
deployment.apps/kubia resumed
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl rollout undo deploy kubia --to-revision<span class="token operator">=</span><span class="token number">3</span>
deployment.apps/kubia rolled back<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>暂停部署还可以阻止更新 Deploy 后自动触发的滚动升级过程。可以对 Deployment 进行多次更改，并在完成所有更改后再恢复滚动升级，一旦所有更改完成，则恢复更新过程。</p>
<h2 id="配置就绪探针"><a class="markdownIt-Anchor" href="#配置就绪探针"></a> 配置就绪探针</h2>
<p>使用 <code>minReadySeconds</code> 属性来设置新的 Pod 运行多久后才将其标记为可用。当所有容器的就绪探针返回成功时，Pod 就被标记为就绪状态。如果一个新的 Pod 运行出错，并且在 <code>minReadySeconds</code> 时间内其就绪探针失败，那么新版本的滚动升级将被阻止。一般会将 <code>minReadySeconds</code> 设置为较高的值，以确保 Pod 在真正接收实际流量后可以持续保持就绪状态。</p>
<p>使用之前会报错的 v3 镜像来测试就绪探针的作用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-v3.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubia
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: kubia
  minReadySeconds: <span class="token number">10</span>
  strategy:
    rollingUpdate:
      maxSurge: <span class="token number">1</span>
      maxUnavailable: <span class="token number">0</span>
    type: RollingUpdate
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - image: luksa/kubia:v3
        name: nodejs
        readinessProbe:
          periodSeconds: <span class="token number">1</span>
          httpGet:
            path: /
            port: <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过将 <code>maxUnavailable</code> 的值设置为 0，确保在升级过程中 Pod 逐个被替换。就绪探针的 GET 请求每秒执行一次，在第 6 秒开始报错。使用 <code>apply</code> 命令升级 Deployment 时，不仅会更新镜像，还会添加就绪探针以及其他参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl apply <span class="token parameter variable">-f</span> kubia-v3.yaml
Warning: resource deployments/kubia is missing the kubectl.kubernetes.io/last-applied-configuration annotation <span class="token function">which</span> is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.
deployment.apps/kubia configured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>观察 <code>curl</code> 的输出，可以看到流量并没有转发到 v3 版本的 Pod 上，因为新的 Pod 尚未就绪，被从 Service 的 endpoint 中移除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v1 running <span class="token keyword">in</span> pod kubia-74967b5695-8kmxn
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v1 running <span class="token keyword">in</span> pod kubia-74967b5695-ckpf9
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:30002
This is v1 running <span class="token keyword">in</span> pod kubia-74967b5695-ls2z2
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME                     READY   STATUS    RESTARTS   AGE
kubia-67d49c55dd-wcnwd   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          60s
kubia-74967b5695-8kmxn   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m40s
kubia-74967b5695-ckpf9   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          10m
kubia-74967b5695-ls2z2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m28s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe po kubia-67d49c55dd-wcnwd
Events:
  Type     Reason     Age                     From               Message
  ----     ------     ----                    ----               -------
  Warning  Unhealthy  2m51s <span class="token punctuation">(</span>x22 over 3m11s<span class="token punctuation">)</span>  kubelet            Readiness probe failed: HTTP probe failed with statuscode: <span class="token number">500</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后，升级一直处于进行中的状态，因为 <code>maxUnavailable</code> 为 0，所以既不会创建新的 Pod，也不会删除任何原始的 Pod。整个流程如下图所示：</p>
<p><img data-src="../../../images/%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88%E4%BD%9C%E7%94%A8.jpg" alt="就绪探针作用" /></p>
<p>如果没有正确设置 <code>minReadySeconds</code>，一旦有一个就绪探针调用成功，就会认为新的 Pod 已经可用。因此，建议将时间设定得较长一些。</p>
<p>默认情况下，滚动升级如果在 10 分钟内无法完成，将被视为失败。可以通过 <code>spec.progressDeadlineSeconds</code> 来设置此时限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl describe deploy kubia
Name:                   kubia
Namespace:              default
Replicas:               <span class="token number">3</span> desired <span class="token operator">|</span> <span class="token number">1</span> updated <span class="token operator">|</span> <span class="token number">4</span> total <span class="token operator">|</span> <span class="token number">3</span> available <span class="token operator">|</span> <span class="token number">1</span> unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        <span class="token number">10</span>
RollingUpdateStrategy:  <span class="token number">0</span> max unavailable, <span class="token number">1</span> max surge
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    False   ProgressDeadlineExceeded
OldReplicaSets:  kubia-74967b5695 <span class="token punctuation">(</span><span class="token number">3</span>/3 replicas created<span class="token punctuation">)</span>
NewReplicaSet:   kubia-67d49c55dd <span class="token punctuation">(</span><span class="token number">1</span>/1 replicas created<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果滚动升级卡住，只能通过 <code>rollout undo</code> 命令来取消滚动升级。</p>
<h1 id="statefulset"><a class="markdownIt-Anchor" href="#statefulset"></a> StatefulSet</h1>
<p>StatefulSet 用于确保每个 Pod 副本在整个生命周期中具有相同的名称、网络标识和状态，而其他控制器则不提供此功能。同时，StatefulSet 会确保副本按照固定的顺序启动、更新或删除。</p>
<p>下面简称 STS。</p>
<h2 id="应用状态"><a class="markdownIt-Anchor" href="#应用状态"></a> 应用状态</h2>
<p><img data-src="../../../images/%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81.jpg" alt="应用状态" /></p>
<p>可以通过状态和储存两个概念正交于坐标系中，得到四种应用程序类型：</p>
<ul>
<li>象限 A 中是那些具有读写磁盘需求的有状态应用程序，例如各种 RDBMS 储存系统、分布式储存系统 Redis Cluster、MongoDB、ZooKeeper、Cassandra 等。</li>
<li>象限 B 包含两类应用程序，一类是具有读写磁盘需求的无状态应用程序，另一类是仅需读取权限的无状态应用，比如 Web 服务程序。</li>
<li>象限 C 中是无磁盘访问需求的无状态应用程序。</li>
<li>象限 D 中是无磁盘访问需求的有状态应用程序，例如淘宝的购物车系统。</li>
</ul>
<h2 id="有状态服务"><a class="markdownIt-Anchor" href="#有状态服务"></a> 有状态服务</h2>
<p>在 Kubernetes 中，Pod 的管理对象包括 ReplicationController（RC）、ReplicaSet（RS）、Deployment（Deploy）、DaemonSet（DS）和 Job 等，都是面向无状态的服务。然而，许多服务是有状态的，例如 MySQL 集群、MongoDB 集群、Akka 集群等。这些集群具有一些共同点：</p>
<ul>
<li>
<p>每个节点都有固定的身份 ID，通过该 ID 进行相互发现和通信；</p>
</li>
<li>
<p>集群的规模相对固定，不能随意变动；</p>
</li>
<li>
<p>集群中的每个节点都具有状态，通常会将数据持久化到永久存储中；</p>
</li>
<li>
<p>如果磁盘损坏，集群中的某个节点将无法正常运行，从而导致集群功能受损。</p>
</li>
</ul>
<h2 id="statefulset-特点"><a class="markdownIt-Anchor" href="#statefulset-特点"></a> StatefulSet 特点</h2>
<p>StatefulSet 可以看作是 Deployment 的一个特殊变种，具有以下特性：</p>
<ul>
<li>StatefulSet 中的每个 Pod 都有稳定且唯一的网络标识，用于发现集群内的其他成员。例如，如果 StatefulSet 的名称是 “kafka”，那么第一个 Pod 的名称将是 “kafka-0”，第二个 Pod 的名称将是 “kafka-1”。</li>
<li>StatefulSet 控制的 Pod 副本启动顺序是受控的，操作第 n 个 Pod 时，前一个 Pod 已经处于运行且准备就绪的状态。</li>
<li>StatefulSet 中的 Pod 使用稳定的持久化存储卷（Persistent Volume，PV），在删除 Pod 时，默认不会删除相关的存储卷。</li>
</ul>
<p>完整可用的 StatefulSet 通常由三个组件构成：StatefulSet、Headless Service 和 VolumeClaimTemplate。</p>
<h3 id="稳定的网络标识"><a class="markdownIt-Anchor" href="#稳定的网络标识"></a> 稳定的网络标识</h3>
<p>由 StatefulSet 创建的每个 Pod 都有一个从 0 开始的顺序索引，体现在 Pod 的名称、主机名和固定存储上。</p>
<p>StatefulSet 通常与 Headless Service 配合使用。如果解析 Headless Service 的 DNS 域名，将返回该 Service 对应的所有 Pod 的 Endpoint 列表。StatefulSet 在 Headless Service 的基础上为 StatefulSet 控制的每个 Pod 实例创建了一个 DNS 域名，格式为：<code>$(podname).$(headless service name).$(namespace).svc.cluster.local</code>。</p>
<p>当 StatefulSet 管理的 Pod 实例消失后，StatefulSet 会确保重新启动一个新的 Pod 实例，新实例具有与之前 Pod 完全一致的名称和主机名。</p>
<p>扩容 StatefulSet 时，将使用下一个尚未使用的顺序索引值创建一个新的 Pod 实例。缩容时，会先删除最高索引值的实例，每次只操作一个 Pod 实例，并且在存在不健康实例的情况下，不允许进行缩容操作。</p>
<h3 id="稳定的专属储存"><a class="markdownIt-Anchor" href="#稳定的专属储存"></a> 稳定的专属储存</h3>
<p>有状态的 Pod 的存储必须是持久的，并且与 Pod 解耦。StatefulSet 需要定义一个或多个卷声明模板，并将其绑定到 Pod 实例上。</p>
<p>在扩容 StatefulSet 时，会创建新的 Pod 实例以及与之关联的一个或多个持久卷声明。在缩容时，只会删除 Pod，而保留持久卷声明，在重新扩容后，新的 Pod 会与先前的持久卷绑定。</p>
<h2 id="创建-sts"><a class="markdownIt-Anchor" href="#创建-sts"></a> 创建 STS</h2>
<p>创建一个简单的应用，接收 POST 请求，并将请求中的 body 数据写入 <code>/var/data/kubia.txt</code>，在收到 GET 请求时，返回主机名和存储的数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ec837c407906:/<span class="token comment"># cat app.js</span>
const http <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const os <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const dataFile <span class="token operator">=</span> <span class="token string">"/var/data/kubia.txt"</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> fileExists<span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  try <span class="token punctuation">&#123;</span>
    fs.statSync<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> catch <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

var handler <span class="token operator">=</span> function<span class="token punctuation">(</span>request, response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>request.method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    var <span class="token function">file</span> <span class="token operator">=</span> fs.createWriteStream<span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    file.on<span class="token punctuation">(</span><span class="token string">'open'</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      request.pipe<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console.log<span class="token punctuation">(</span><span class="token string">"New data has been received and stored."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      response.writeHead<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      response.end<span class="token punctuation">(</span><span class="token string">"Data stored on pod "</span> + os.hostname<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    var data <span class="token operator">=</span> fileExists<span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span> ? fs.readFileSync<span class="token punctuation">(</span>dataFile, <span class="token string">'utf8'</span><span class="token punctuation">)</span> <span class="token builtin class-name">:</span> <span class="token string">"No data posted yet"</span><span class="token punctuation">;</span>
    response.writeHead<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response.write<span class="token punctuation">(</span><span class="token string">"You've hit "</span> + os.hostname<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response.end<span class="token punctuation">(</span><span class="token string">"Data stored on this pod: "</span> + data + <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

var www <span class="token operator">=</span> http.createServer<span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
www.listen<span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，创建基于 NFS 的持久化存储卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /srv/pv/
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> pv001 pv002 pv003
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/srv/pv/pv001 *(rw,no_root_squash,sync)"</span> <span class="token operator">>></span> /etc/exports
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/srv/pv/pv002 *(rw,no_root_squash,sync)"</span> <span class="token operator">>></span> /etc/exports
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/srv/pv/pv003 *(rw,no_root_squash,sync)"</span> <span class="token operator">>></span> /etc/exports
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-a</span>
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ showmount <span class="token parameter variable">-e</span>
Export list <span class="token keyword">for</span> server4-master:
/srv/pv/pv003 *
/srv/pv/pv002 *
/srv/pv/pv001 *
/srv/pv       *
<span class="token punctuation">[</span>root@server4-master pv<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-v</span>
/srv/pv         <span class="token operator">&lt;</span>world<span class="token operator">></span><span class="token punctuation">(</span>sync,wdelay,hide,no_subtree_check,sec<span class="token operator">=</span>sys,rw,secure,no_root_squash,no_all_squash<span class="token punctuation">)</span>
/srv/pv/pv001   <span class="token operator">&lt;</span>world<span class="token operator">></span><span class="token punctuation">(</span>sync,wdelay,hide,no_subtree_check,sec<span class="token operator">=</span>sys,rw,secure,no_root_squash,no_all_squash<span class="token punctuation">)</span>
/srv/pv/pv002   <span class="token operator">&lt;</span>world<span class="token operator">></span><span class="token punctuation">(</span>sync,wdelay,hide,no_subtree_check,sec<span class="token operator">=</span>sys,rw,secure,no_root_squash,no_all_squash<span class="token punctuation">)</span>
/srv/pv/pv003   <span class="token operator">&lt;</span>world<span class="token operator">></span><span class="token punctuation">(</span>sync,wdelay,hide,no_subtree_check,sec<span class="token operator">=</span>sys,rw,secure,no_root_squash,no_all_squash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 List 对象来定义一组 PV 资源，效果和使用 <code>--</code> 分隔多个资源一样。设定 storageClassName 为 nfs：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> pv-list.yaml
kind: List
apiVersion: v1
items:
- apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: pv001
  spec:
    capacity:
      storage: 10Mi
    accessModes:
      - ReadWriteOnce
    persistentVolumeReclaimPolicy: Retain
    storageClassName: nfs
    nfs:
      path: /srv/pv/pv001
      server: server4-master
- apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: pv002
  spec:
    capacity:
      storage: 10Mi
    accessModes:
      - ReadWriteOnce
    persistentVolumeReclaimPolicy: Retain
    storageClassName: nfs
    nfs:
      path: /srv/pv/pv002
      server: server4-master
- apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: pv003
  spec:
    capacity:
      storage: 10Mi
    accessModes:
      - ReadWriteOnce
    persistentVolumeReclaimPolicy: Retain
    storageClassName: nfs
    nfs:
      path: /srv/pv/pv003
      server: server4-master
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> pv-list.yaml 
persistentvolume/pv001 created
persistentvolume/pv002 created
persistentvolume/pv003 created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">pv</span>
NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                 STORAGECLASS   REASON   AGE
pv001        10Mi       RWO            Retain           Available                         nfs                     8s
pv002        10Mi       RWO            Retain           Available                         nfs                     8s
pv003        10Mi       RWO            Retain           Available                         nfs                     8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在部署 StatefulSet 之前，还需要创建一个用于为有状态的 Pod 提供网络标识的 Headless Service，以实现 Pod 之间的互相发现：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  clusterIP: None
  selector:
    app: kubia
  ports:
  - name: http
    port: <span class="token number">80</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-svc-headless.yaml
service/kubia created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后是 StatefulSet 的配置，其中 <code>serviceName</code> 和 <code>template</code> 字段是必需的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-st.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kubia
spec:
  serviceName: kubia
  replicas: <span class="token number">2</span>
  selector:
    matchLabels:
      app: kubia
  template:
    metadata:
      labels:
        app: kubia
    spec:
      containers:
      - name: kubia
        image: luksa/kubia-pet
        ports:
        - name: http
          containerPort: <span class="token number">8080</span>
        volumeMounts:
        - mountPath: <span class="token string">"/var/data"</span>
          name: data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 10Mi
      storageClassName: nfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过一个名为 <code>data</code> 的 PVC 模板为每个 Pod 创建一个持久卷声明，在其中指定 <code>storageClassName: nfs</code> 来选择前面创建的 PV，这样 PVC 会自动与可用的 PV 相关联：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-st.yaml
statefulset.apps/kubia created
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get all
NAME          READY   STATUS              RESTARTS   AGE
pod/kubia-0   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          13s
pod/kubia-1   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          7s
NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
service/kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1    <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP   135d
service/kubia        ClusterIP   None         <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP    29m
NAME                     READY   AGE
statefulset.apps/kubia   <span class="token number">1</span>/2     13s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pvc
NAME           STATUS   VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-kubia-0   Bound    pv001        10Mi       RWO            nfs            42s
data-kubia-1   Bound    pv002        10Mi       RWO            nfs            36s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">pv</span>
NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                  STORAGECLASS   REASON   AGE
pv001        10Mi       RWO            Retain           Bound       default/data-kubia-0   nfs                     64s
pv002        10Mi       RWO            Retain           Bound       default/data-kubia-1   nfs                     64s
pv003        10Mi       RWO            Retain           Available                          nfs                     64s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二个 Pod 会在第一个 Pod 运行并处于就绪状态后创建。当所有 Pod 都就绪时，可以看到有 2 个 PV 已被新创建的 Pod 绑定。</p>
<h2 id="测试-sts"><a class="markdownIt-Anchor" href="#测试-sts"></a> 测试 STS</h2>
<p>由于服务处于 Headless 模式，无法通过服务访问服务本身。可以在节点上先运行代理，然后使用 <code>curl</code> 与 API 服务器与 Pod 进行通信：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl proxy
Starting to serve on <span class="token number">127.0</span>.0.1:8001
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/
You've hit kubia-0
Data stored on this pod: No data posted yet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 POST 请求发送数据后,再使用 GET 请求查询数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">"kubia-0"</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/
Data stored on pod kubia-0
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/
You<span class="token string">'ve hit kubia-0
Data stored on this pod: kubia-0
[root@server4-master ~]$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-1/proxy/
You'</span>ve hit kubia-1
Data stored on this pod: No data posted yet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>手动删除 Pod 后，验证重新调度的 Pod 是否关联了相同的存储：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete po kubia-0
pod <span class="token string">"kubia-0"</span> deleted
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> wide
NAME      READY   STATUS    RESTARTS   AGE     IP               NODE            NOMINATED NODE   READINESS GATES
kubia-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          18s     <span class="token number">10.244</span>.244.234   server6-node2   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>
kubia-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          8m39s   <span class="token number">10.244</span>.244.233   server6-node2   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除后等待一段时间，<code>kubia-0</code> 在另一个节点上重建好了，用 <code>curl</code> 试试看数据是否还在：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/
You've hit kubia-0
Data stored on this pod: kubia-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>缩容一个 StatefulSet 只会删除对应的 Pod，持久卷声明将被卸载但保留。如下图所示：</p>
<p><img data-src="../../../images/STS%E9%87%8D%E6%96%B0%E8%B0%83%E5%BA%A6.jpg" alt="STS重新调度" /></p>
<h2 id="发现节点"><a class="markdownIt-Anchor" href="#发现节点"></a> 发现节点</h2>
<p>集群中伙伴节点能够彼此发现是非常重要的需求，这样才能找到集群中的其他成员。虽然可以通过 API 服务器进行通信来获取这些信息，但这与 Kubernetes 的设计理念不符。因此，Kubernetes 通过一个无头服务（headless Service）来创建 SRV 记录，从而指向 Pod 的主机名。</p>
<p>可以通过查询 DNS 记录中的 SRV 记录来获取这些信息。SRV 记录用于指向提供服务的服务器的主机和端口号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl run <span class="token parameter variable">-it</span> srvlookup <span class="token parameter variable">--image</span><span class="token operator">=</span>tutum/dnsutils <span class="token parameter variable">--rm</span> <span class="token parameter variable">--restart</span><span class="token operator">=</span>Never -- <span class="token function">dig</span> SRV kubia.default.svc.cluster.local

<span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> DiG <span class="token number">9.9</span>.5-3ubuntu0.2-Ubuntu <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> SRV kubia.default.svc.cluster.local
<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd
<span class="token punctuation">;</span><span class="token punctuation">;</span> Got answer:
<span class="token punctuation">;</span><span class="token punctuation">;</span> -<span class="token operator">>></span>HEADER<span class="token operator">&lt;&lt;-</span> opcode: QUERY, status: NOERROR, id: <span class="token number">27077</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> flags: qr aa rd<span class="token punctuation">;</span> QUERY: <span class="token number">1</span>, ANSWER: <span class="token number">2</span>, AUTHORITY: <span class="token number">0</span>, ADDITIONAL: <span class="token number">3</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> WARNING: recursion requested but not available

<span class="token punctuation">;</span><span class="token punctuation">;</span> OPT PSEUDOSECTION:
<span class="token punctuation">;</span> EDNS: version: <span class="token number">0</span>, flags:<span class="token punctuation">;</span> udp: <span class="token number">4096</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:
<span class="token punctuation">;</span>kubia.default.svc.cluster.local. IN    SRV

<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
kubia.default.svc.cluster.local. <span class="token number">30</span> IN  SRV     <span class="token number">0</span> <span class="token number">50</span> <span class="token number">80</span> kubia-1.kubia.default.svc.cluster.local.
kubia.default.svc.cluster.local. <span class="token number">30</span> IN  SRV     <span class="token number">0</span> <span class="token number">50</span> <span class="token number">80</span> kubia-0.kubia.default.svc.cluster.local.

<span class="token punctuation">;</span><span class="token punctuation">;</span> ADDITIONAL SECTION:
kubia-0.kubia.default.svc.cluster.local. <span class="token number">30</span> IN A <span class="token number">10.244</span>.244.234
kubia-1.kubia.default.svc.cluster.local. <span class="token number">30</span> IN A <span class="token number">10.244</span>.244.233

<span class="token punctuation">;</span><span class="token punctuation">;</span> Query time: <span class="token number">1</span> msec
<span class="token punctuation">;</span><span class="token punctuation">;</span> SERVER: <span class="token number">10.96</span>.0.10<span class="token comment">#53(10.96.0.10)</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> WHEN: Fri Mar <span class="token number">18</span> <span class="token number">15</span>:40:53 UTC <span class="token number">2022</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> MSG SIZE  rcvd: <span class="token number">350</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过创建一个临时 Pod 并运行 <code>dig</code> 命令，可以看到 <code>ANSWER SECTION</code> 显示了两条指向后台无头服务的 SRV 记录。在 <code>ADDITIONAL SECTION</code> 中，每个 Pod 都拥有一条独立的记录。当一个 Pod 需要获取 StatefulSet 中其他 Pod 的列表时，只需要触发一次 SRV DNS 查询即可。</p>
<h2 id="滚动升级"><a class="markdownIt-Anchor" href="#滚动升级"></a> 滚动升级</h2>
<p>StatefulSet 的升级方式与 Deployment 相同。推荐先修改配置文件中的镜像或参数，然后使用 <code>kubectl apply -f</code> 命令进行更新：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-st.yaml 
<span class="token punctuation">..</span>.
  replicas: <span class="token number">3</span>
<span class="token punctuation">..</span>.
        image: luksa/kubia-pet-peers
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl apply <span class="token parameter variable">-f</span> kubia-st.yaml 
statefulset.apps/kubia configured
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME       READY   STATUS        RESTARTS   AGE
dnsutils   <span class="token number">1</span>/1     Running       <span class="token number">0</span>          43m
kubia-0    <span class="token number">1</span>/1     Terminating   <span class="token number">0</span>          5h10m
kubia-1    <span class="token number">1</span>/1     Running       <span class="token number">0</span>          32s
kubia-2    <span class="token number">1</span>/1     Running       <span class="token number">0</span>          77s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试集群数据"><a class="markdownIt-Anchor" href="#测试集群数据"></a> 测试集群数据</h2>
<p>当所有的 Pod 启动后，可以测试数据存储是否按预期工作。首先将 Service 修改为非无头模式，然后向集群发送一些请求：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-svc-peer.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia-public
spec:
  selector:
    app: kubia
  ports:
  - name: http
    port: <span class="token number">80</span>
    targetPort: <span class="token number">8080</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl apply <span class="token parameter variable">-f</span> kubia-svc-peer.yaml 
service/kubia-public created
<span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">"11:58:04"</span> localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/
Data stored on pod kubia-1
<span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">"11:58:04"</span> localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/
Data stored on pod kubia-1
<span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">"11:58:04"</span> localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/
Data stored on pod kubia-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在三个 Pod 中都有数据了，可以测试从服务中读取数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/
You've hit kubia-2
Data stored <span class="token keyword">in</span> the cluster:
- kubia-2.kubia.default.svc.cluster.local: <span class="token number">11</span>:58:04
- kubia-1.kubia.default.svc.cluster.local: <span class="token number">11</span>:58:04
- kubia-0.kubia.default.svc.cluster.local: kubia-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过集群中的任意一个节点都能够获取到所有伙伴节点的数据，然后收集它们的数据。</p>
<h2 id="处理节点失效"><a class="markdownIt-Anchor" href="#处理节点失效"></a> 处理节点失效</h2>
<p>对于一个有状态的 Pod，必须确保在创建替代 Pod 之前不再运行。当一个节点突然失效时，Kubernetes 并不知道节点的状态，也不知道 Pod 是否还在运行、是否还存在、是否能够被客户端访问，或者是 Kubelet 停止了上报节点状态。只有在 StatefulSet 明确知道一个 Pod 不再运行后，才会采取相应的措施。这个信息通常由管理员删除 Pod 或整个节点来明确指定。</p>
<p>可以模拟一次节点故障。首先，查看当前的运行状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> wide
NAME      READY   STATUS    RESTARTS   AGE   IP               NODE            
kubia-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          29m   <span class="token number">10.244</span>.191.226   server5-node1   
kubia-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          30m   <span class="token number">10.244</span>.191.225   server5-node1   
kubia-2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          12s   <span class="token number">10.244</span>.191.227   server5-node1   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现所有的 Pod 都运行在 node1 节点上。然后，断开 node1 的网络连接，并等待 2 分钟后查询节点信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">node</span>
NAME             STATUS     ROLES                  AGE    VERSION
server4-master   Ready      control-plane,master   135d   v1.22.3
server5-node1    NotReady   <span class="token operator">&lt;</span>none<span class="token operator">></span>                 135d   v1.22.3
server6-node2    Ready      <span class="token operator">&lt;</span>none<span class="token operator">></span>                 135d   v1.22.3
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pod <span class="token parameter variable">-o</span> wide
NAME      READY   STATUS    RESTARTS   AGE     IP               NODE           
kubia-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          119s    <span class="token number">10.244</span>.191.228   server5-node1   
kubia-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          38m     <span class="token number">10.244</span>.191.225   server5-node1  
kubia-2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          8m10s   <span class="token number">10.244</span>.191.227   server5-node1   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 node 已变为 NotReady 状态，但 pod 状态没有更新。如果运行 delete 命令，因为节点上 kubelet 无法接收到命令，所以 pod 的状态会一直显示 Terminating。</p>
<p>再过一段时间，pod 的状态会变成 Unknown。有一个配置可以调整未知状态持续多久，pod 自动从节点上驱除。</p>
<p>假如节点重连上了，删除命令会被正确执行并在空闲节点上新建 pod。如果节点永远消失了，只能通过强制删除 pod 来解决。通过删除命令加上 <code>--force</code> 和 <code>grace-period 0</code> 两个参数来强制删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete po kubia-0 <span class="token parameter variable">--force</span> --grace-period <span class="token number">0</span>
warning: Immediate deletion does not <span class="token function">wait</span> <span class="token keyword">for</span> confirmation that the running resource has been terminated. The resource may <span class="token builtin class-name">continue</span> to run on the cluster indefinitely.
pod <span class="token string">"kubia-0"</span> force deleted
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po <span class="token parameter variable">-o</span> wide
NAME      READY   STATUS    RESTARTS   AGE    IP               NODE            
kubia-0   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          19s    <span class="token number">10.244</span>.244.245   server6-node2   
kubia-1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          39m    <span class="token number">10.244</span>.191.225   server5-node1   
kubia-2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          9m7s   <span class="token number">10.244</span>.191.227   server5-node1   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>pod 强制删除后会在 node2 节点上新建，一般只有确认节点永远不能用的情况下才使用强制删除。</p>
<p>假如不强制删除，而把断开网络的 node1 节点重新连上，pod 的状态会从 Unknown 变为正常运行。</p>
<h1 id="daemonset"><a class="markdownIt-Anchor" href="#daemonset"></a> DaemonSet</h1>
<p>下面简称 DS。与 RS 相比，DS 多了一个 nodeSelector 选择器，DS 依赖节点标签选择器来控制。</p>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<p>使用 DS 来设置在集群中每个节点固定运行一个 pod，通常用来部署系统服务，比如用来收集日志或者做资源监控。</p>
<p>也可以通过 nodeSelector 选择器来选择一组节点作为部署节点，而不是默认的所有节点。</p>
<p>如果被选择器选择的节点被设置为不可调度，DS 依然会绕过调度器将 pod 部署到这种节点上。</p>
<h2 id="创建-ds"><a class="markdownIt-Anchor" href="#创建-ds"></a> 创建 DS</h2>
<p>首先给一个节点打上标签 <code>disk='ssd'</code> ：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server5-node1 <span class="token assign-left variable">disk</span><span class="token operator">=</span><span class="token string">'ssd'</span>
node/server5-node1 labeled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后建立 YAML 配置文件并启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-ds.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: ds-ssd
spec:
  selector:
    matchExpressions:
      - key: app
        operator: In
        values:
          - kubia-ssd
  template:
    metadata:
      labels:
        app: kubia-ssd
    spec:
      nodeSelector:
        disk: ssd
      containers:
      - name: kubia
        image: luksa/kubia
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-ds.yaml 
daemonset.apps/ds-ssd created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>DS 还可以配置更新机制，相关配置定义在 <code>spec.updateStrategy</code> 字段，方式为 RollingUpdate（滚动更新）或 OnDelete（删除再更新）。回滚操作同样支持。</p>
<h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2>
<p>将 server6-node2 也打上 <code>ssd</code> 标签后再查看信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server6-node2 <span class="token assign-left variable">disk</span><span class="token operator">=</span><span class="token string">'ssd'</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pod <span class="token parameter variable">-o</span> wide
NAME           READY   STATUS    RESTARTS   AGE     IP               NODE     
ds-ssd-drb2z   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m19s   <span class="token number">10.244</span>.191.199   server5-node1  
ds-ssd-f6cwh   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          23s     <span class="token number">10.244</span>.244.199   server6-node2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>去除节点标签后运行在其上的 pod 会立即删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server6-node2 disk-
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl label <span class="token function">node</span> server5-node1 disk-
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get ds
NAME     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
ds-ssd   <span class="token number">0</span>         <span class="token number">0</span>         <span class="token number">0</span>       <span class="token number">0</span>            <span class="token number">0</span>           <span class="token assign-left variable">disk</span><span class="token operator">=</span>ssd        7m52s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="job"><a class="markdownIt-Anchor" href="#job"></a> Job</h1>
<p>Job 用于执行一个可完成的任务，进程终止之后不会再次启动。</p>
<p>在发生节点故障时，该节点上由 Job 管理的 pod 将重新安排到其他节点运行。如果节点本身异常退出（返回错误退出代码时），可以将 Job 配置为重新启动容器，由 Job 管理的 pod 会一直被重新安排直到任务完成为止。</p>
<p>Job 使用 API 为 batch/v1。需要明确地将重启策略设置为 OnFailure 或 Never，防止容器在完成任务时重新启动。</p>
<h2 id="创建-job"><a class="markdownIt-Anchor" href="#创建-job"></a> 创建 Job</h2>
<p>这里调用了一个运行 120 秒的进程然后退出。指定 restartPolicy 属性为 OnFailure（默认为 Always）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  template:
    metadata:
      labels:
        app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: luksa/batch-job
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-job.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 Job 任务完成后，状态显示为 Completed：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">jobs</span>
NAME        COMPLETIONS   DURATION   AGE
batch-job   <span class="token number">1</span>/1           119s       2m59s
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get pod
NAME                 READY   STATUS      RESTARTS   AGE
batch-job--1-2ddkr   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          3m10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>出于查询日志的需求，完成任务的 pod 不会自动删除，可以通过删除创建的 Job 来一同删除。</p>
<h2 id="多次运行"><a class="markdownIt-Anchor" href="#多次运行"></a> 多次运行</h2>
<p>可以在 Job 中配置创建多个 pod 实例，设置 completions 和 parallelism 属性来以并行或串行方式运行。</p>
<p>顺序运行用于一个 Job 运行多次的场景，例如设置顺序运行五个 pod，每个 pod 成功完成后工作才结束：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-job.yaml
spec:
  completions: <span class="token number">5</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-job.yaml
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get <span class="token function">jobs</span>
NAME        COMPLETIONS   DURATION   AGE
batch-job   <span class="token number">0</span>/5           12s        12s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置并行运行需要多加一个 parallelism 参数设置并行启动 pod 数目：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-job.yaml
spec:
  completions: <span class="token number">5</span>
  parallelism: <span class="token number">3</span>
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl delete job batch-job 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-job.yaml
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get po
NAME                 READY   STATUS    RESTARTS   AGE
batch-job--1-5ghsj   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          39s
batch-job--1-mctcz   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          39s
batch-job--1-znpbq   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          39s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Job 的并行任务数同样可以通过 scale 命令来修改。</p>
<h2 id="限制条件"><a class="markdownIt-Anchor" href="#限制条件"></a> 限制条件</h2>
<p>可以通过 activeDeadlineSeconds 属性来限制 pod 的运行时间。如果超时没完成，系统会尝试终止 pod 并标记失败。</p>
<p>还能配置 Job 被标记为失败前重试的次数，通过 <code>spec.backoffLimit</code> 字段，默认为 6 次。</p>
<h1 id="cronjob"><a class="markdownIt-Anchor" href="#cronjob"></a> CronJob</h1>
<p>可以创建 CronJob 资源来通过 cron 格式时间表，设置一个定时运行的 Job 任务。</p>
<p>下面简称 CJ。K8s 通过 CJ 中配置的 Job 模板创建 Job 资源。</p>
<h2 id="创建-cj"><a class="markdownIt-Anchor" href="#创建-cj"></a> 创建 CJ</h2>
<p>创建一个每十五分钟运行一次的 Job：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-cj.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: 15job
spec:
  schedule: <span class="token string">"0,15,30,45 * * * *"</span>
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: 15job
        spec:
          restartPolicy: OnFailure
          containers:
          - name: main
            image: luksa/batch-job
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl create <span class="token parameter variable">-f</span> kubia-cj.yaml 
<span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ kubectl get cj
NAME    SCHEDULE             SUSPEND   ACTIVE   LAST SCHEDULE   AGE
15job   <span class="token number">0,15</span>,30,45 * * * *   False     <span class="token number">0</span>        <span class="token operator">&lt;</span>none<span class="token operator">></span>          16s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 schedule 段五个设置分别是：<code>分钟 小时 每月日期 月 星期</code></p>
<h2 id="超时设置"><a class="markdownIt-Anchor" href="#超时设置"></a> 超时设置</h2>
<p>可以通过 <code>startingDeadlineSeconds</code> 字段来设置预定运行超时时间，例如不能超过预定时间 15 秒后运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4-master ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> kubia-cj.yaml
spec:
  startingDeadlineSeconds: <span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>不管任何原因，时间超过了 15 秒而没启动任务，任务将不会运行并显示失败。</p>
<h2 id="其他设置"><a class="markdownIt-Anchor" href="#其他设置"></a> 其他设置</h2>
<p>其他一些 spec 字段可嵌套使用字段：</p>
<ul>
<li>
<p>concurrencyPolicy：并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业。可选值为 Allow、Forbid 或 Replace。</p>
</li>
<li>
<p>failedJobHistoryLimit：为失败的任务执行保留的历史记录数，默认为 1。</p>
</li>
<li>
<p>successfulJobsHistoryLimit：为成功的任务执行保留的历史记录数，默认为 3。</p>
</li>
<li>
<p>startingDeadlineSeconds：设置超时时间，超时未完成任务会被记入错误历史记录。</p>
</li>
<li>
<p>suspend：是否挂起后续的任务执行，默认为 false，对运行中的作业不会产生影响。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>1.常用资源</category>
      </categories>
  </entry>
  <entry>
    <title>CronJob 模板</title>
    <url>/3537711107/</url>
    <content><![CDATA[<h1 id="cronjob-模板"><a class="markdownIt-Anchor" href="#cronjob-模板"></a> CronJob 模板</h1>
<p>以下是一个完整的 CronJob 模板：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 15job                           <span class="token comment"># CronJob 名称。</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"0 5 * * *"</span>                 <span class="token comment"># 每天早上 5 点运行。从左到右依次表示：分钟、小时、每月日期、月份、星期几。</span>
  <span class="token key atrule">startingDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">500</span>          <span class="token comment"># 如果任务在 500 秒内未能启动，将视为失败并不再执行。</span>
  <span class="token key atrule">concurrencyPolicy</span><span class="token punctuation">:</span> Forbid             <span class="token comment"># 不允许并行执行任务。</span>
  <span class="token key atrule">suspend</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>                        <span class="token comment"># 不暂停任务。</span>
  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">template</span><span class="token punctuation">:</span>                         <span class="token comment"># 运行的 Pod 模板</span>
        <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
          <span class="token key atrule">labels</span><span class="token punctuation">:</span>
            <span class="token key atrule">app</span><span class="token punctuation">:</span> 15job                  
        <span class="token key atrule">spec</span><span class="token punctuation">:</span>
          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure      <span class="token comment"># 重启策略，失败时重启。</span>
          <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>             <span class="token comment"># 共享节点网络命名空间。</span>
          <span class="token key atrule">hostPID</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>                 <span class="token comment"># 共享节点 PID 命名空间。</span>
          <span class="token key atrule">hostIPC</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>                 <span class="token comment"># 共享节点 IPC 命名空间。</span>
          <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>                 <span class="token comment"># 选择运行节点。</span>
            <span class="token key atrule">disktype</span><span class="token punctuation">:</span> SSD               
          <span class="token key atrule">containers</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> main
            <span class="token key atrule">image</span><span class="token punctuation">:</span> batch<span class="token punctuation">-</span>job<span class="token punctuation">-</span>image      <span class="token comment"># 批处理任务镜像名称。</span>
            <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">]</span>  <span class="token comment"># 执行的命令。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>Deployment 模板</title>
    <url>/1856695493/</url>
    <content><![CDATA[<h1 id="deployment-模板"><a class="markdownIt-Anchor" href="#deployment-模板"></a> Deployment 模板</h1>
<p>以下是一个完整的 Deployment 模板：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1                        <span class="token comment">#必选,早前版本有extensions/v1beta1或apps/v1beta1</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment                           <span class="token comment">#必选,类型为Deployment</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>                                  <span class="token comment">#必选,元数据信息 </span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp                              <span class="token comment">#必选,Deploy的名称</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> pro                           <span class="token comment">#命名空间,实际部署到的环境</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>                                  <span class="token comment">#标签</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp                             <span class="token comment">#应用名</span>
    <span class="token key atrule">version</span><span class="token punctuation">:</span> v1                            <span class="token comment">#版本</span>
    <span class="token key atrule">env</span><span class="token punctuation">:</span> pro                               <span class="token comment">#发布环境</span>
    <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend                         <span class="token comment">#构架,区分前后端或base基础服务</span>
    <span class="token key atrule">partition</span><span class="token punctuation">:</span> HangZhou                    <span class="token comment">#服务器地区信息</span>
    <span class="token key atrule">project</span><span class="token punctuation">:</span> k8s                           <span class="token comment">#所属项目名</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>                                      <span class="token comment">#必选,规格说明</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>                              <span class="token comment">#必选,副本数量</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>                                <span class="token comment">#标签选择器,用来选择Pod</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>                           <span class="token comment">#标签选择器</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp                           <span class="token comment">#选择标签键值对</span>
    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>                      <span class="token comment">#使用标签选择表达式,如果同时两种标签选择则必须都满足</span>
      <span class="token punctuation">-</span> <span class="token punctuation">&#123;</span><span class="token key atrule">key</span><span class="token punctuation">:</span> tier<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cache<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>  
  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>                      <span class="token comment">#启动多长时间内容器未发生崩溃等异常状态视为就绪,默认0秒</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>                                <span class="token comment">#必选,定义Pod的模板</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>                              
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>                              <span class="token comment">#生成Pod的标签</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp                         <span class="token comment">#可以和选择器一致</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>                                  
      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">60</span>    <span class="token comment">#发送SIGTERM信号后等待程序关闭的时间</span>
      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always                <span class="token comment">#重启策略</span>
      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> flannel          <span class="token comment">#SA账号名</span>
      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>                       
        <span class="token key atrule">disktype</span><span class="token punctuation">:</span> SSD    
      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>                         <span class="token comment">#污点信息</span>
      <span class="token punctuation">-</span> <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule
        <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists        
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>                          
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp                        <span class="token comment">#Pod内运行容器名</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> my.com/user/myapp<span class="token punctuation">:</span><span class="token number">1.0</span>       <span class="token comment">#拉取镜像地址</span>
        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent      
        <span class="token key atrule">command</span><span class="token punctuation">:</span>                           <span class="token comment">#容器启动后的命令,还可以用["sleep", "999999"]格式</span>
        <span class="token punctuation">-</span> sh
        <span class="token punctuation">-</span> <span class="token punctuation">-</span>C
        <span class="token punctuation">-</span> <span class="token string">'while true; do echo "waiting"; sleep 5; done; echo "Done"'</span>
        <span class="token key atrule">args</span><span class="token punctuation">:</span>                              <span class="token comment">#命令参数</span>
        <span class="token punctuation">-</span> <span class="token string">'-config.file=/etc/prometheus/prometheus.yml'</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>                             <span class="token comment">#容器端口</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http                       <span class="token comment">#端口名称</span>
          <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>              <span class="token comment">#指定容器内端口</span>
          <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">811</span>                    <span class="token comment">#指定映射到的节点端口,通过节点IP:端口即能访问</span>
          <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP                    <span class="token comment">#定义协议,还可以是UDP</span>
        <span class="token key atrule">env</span><span class="token punctuation">:</span>                               <span class="token comment">#通过环境变量的方式,直接传递自定义环境变量</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> LOCAL_KEY                  <span class="token comment">#本地Key</span>
          <span class="token key atrule">value</span><span class="token punctuation">:</span> value                     <span class="token comment">#key值</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> CONFIG_MAP_KEY             <span class="token comment">#局策略可使用configMap的配置Key</span>
          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>                       <span class="token comment">#指定来源</span>
            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>               <span class="token comment">#来自configMap</span>
              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config         <span class="token comment">#选择name为special-config的configmap</span>
              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type            <span class="token comment">#选择的key</span>
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>                         <span class="token comment">#资源信息</span>
          <span class="token key atrule">requests</span><span class="token punctuation">:</span>                        <span class="token comment">#请求最小资源</span>
            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">0.1</span>
            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi
          <span class="token key atrule">limits</span><span class="token punctuation">:</span>                          <span class="token comment">#限制最大资源</span>
            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">0.2</span>
            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 320Mi
        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>                     <span class="token comment">#存活探针</span>
          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>                         <span class="token comment">#采用HTTP GET方式</span>
            <span class="token key atrule">path</span><span class="token punctuation">:</span> /health                  <span class="token comment">#监测路径</span>
            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>                     <span class="token comment">#端口</span>
            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP                   <span class="token comment">#方式</span>
          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">60</span>          <span class="token comment">#启动后延时多久开始运行监测</span>
          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>                <span class="token comment">#超时时间</span>
          <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>              <span class="token comment">#处于失败状态时,探测至少连续成功多少次转为成功</span>
          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span>              <span class="token comment">#处于成功状态时,探测至少连续失败多少次转为失败</span>
        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>                    <span class="token comment">#就绪探针</span>
          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
            <span class="token key atrule">path</span><span class="token punctuation">:</span> /
            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP
          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">30</span>
          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>
          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span>
        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>                      <span class="token comment">#挂载volumes中定义的磁盘</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sdb                        <span class="token comment">#Volume的名称</span>
          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/media           <span class="token comment">#挂载到容器中的路径</span>
          <span class="token key atrule">subPath</span><span class="token punctuation">:</span> /nginx/config           <span class="token comment">#挂载卷内目录的绝对路径</span>
      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>                             <span class="token comment">#挂载卷信息</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>cache                  
        <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                       <span class="token comment">#挂载临时卷</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sdb
        <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>                          <span class="token comment">#挂载节点上的目录</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> /any/path                  <span class="token comment">#说明路径</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>volume<span class="token punctuation">-</span>config        <span class="token comment">#供ConfigMap文件内容到指定路径使用</span>
        <span class="token key atrule">configMap</span><span class="token punctuation">:</span>
          <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>volume<span class="token punctuation">-</span>config      <span class="token comment">#ConfigMap中名称</span>
          <span class="token key atrule">items</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>script                <span class="token comment">#ConfigMap中的Key</span>
            <span class="token key atrule">path</span><span class="token punctuation">:</span> path/to/log<span class="token punctuation">-</span>script       <span class="token comment">#指定目录下的一个相对路径path/to/log-script</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root
        <span class="token key atrule">nfs</span><span class="token punctuation">:</span>                               <span class="token comment">#挂载NFS类型储存</span>
          <span class="token key atrule">server</span><span class="token punctuation">:</span> 10.10.0.55               <span class="token comment">#NFS服务器地址</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> /opt/public                <span class="token comment">#NFS中共享的路径</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> rbd<span class="token punctuation">-</span>pvc
        <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>             <span class="token comment">#挂载PVC</span>
          <span class="token key atrule">claimName</span><span class="token punctuation">:</span> rbd<span class="token punctuation">-</span>pvc1              <span class="token comment">#挂载已经申请的PVC</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>PV 模板</title>
    <url>/2406232821/</url>
    <content><![CDATA[<h1 id="pv-模板"><a class="markdownIt-Anchor" href="#pv-模板"></a> PV 模板</h1>
<p>以下是一个完整的 PV 模板：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: v1
kind: PersistentVolume
metadata:
  name: mongodb-pv
  labels:                                  <span class="token comment">#可以给PV打标签</span>
    type: ssd
spec:
  capacity:                                
    storage: 10Gi                          <span class="token comment">#储存容量</span>
  persistentVolumeReclaimPolicy: Retain    <span class="token comment">#卷回收策略,默认c,还有Recycle,Delete自动清空和删除</span>
  accessModes:
  - ReadOnlyMany                           <span class="token comment">#允许多客户读取</span>
  - ReadWriteOnce                          <span class="token comment">#允许单客户读写</span>
  - ReadWriteMany                          <span class="token comment">#允许多客户读写</span>
  nfs:                                     <span class="token comment">#储存类型是NFS</span>
    path: /data                            <span class="token comment">#NFS储存已挂载的目录</span>
    server: <span class="token number">192.168</span>.2.113                  <span class="token comment">#NFS服务器IP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>Pod 模板</title>
    <url>/94081894/</url>
    <content><![CDATA[<h1 id="pod-模板"><a class="markdownIt-Anchor" href="#pod-模板"></a> Pod 模板</h1>
<p>以下是一个完整的 Pod 模板：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1        <span class="token comment">#必选,版本号,例如v1</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod             <span class="token comment">#必选,类型为Pod</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>             <span class="token comment">#必选,元数据</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> string        <span class="token comment">#必选,Pod名称</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> string   <span class="token comment">#选选,Pod所属的命名空间,默认为default</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>             <span class="token comment">#自定义标签</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string    <span class="token comment">#自定义标签名字</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token comment">#自定义注释列表</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string    <span class="token comment">#自定义注释键值对</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>                 <span class="token comment">#必选,Pod中容器的详细定义</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>         <span class="token comment">#必选,Pod中容器列表</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string      <span class="token comment">#必选,容器名称</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> string     <span class="token comment">#必选,容器的镜像名称</span>
    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent  <span class="token comment">#获取镜像的策略: Alawys表示每次都尝试重新下载镜像 | IfnotPresent表示优先使用本地镜像,本地不存在则下载镜像 | Nerver表示仅使用本地镜像</span>
    <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>     <span class="token comment">#Pull镜像时使用的secret名称,以key: secretkey格式指定</span>
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>     <span class="token comment">#容器的启动命令列表,如不指定使用打包时使用的启动命令</span>
    <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>       <span class="token comment">#容器的启动命令参数列表</span>
    <span class="token key atrule">workingDir</span><span class="token punctuation">:</span> string      <span class="token comment">#容器的工作目录</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>     <span class="token comment">#挂载到容器内部的存储卷配置</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string      <span class="token comment">#引用pod定义的共享存储卷的名称,需用volumes[]部分定义的的卷名</span>
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> string     <span class="token comment">#存储卷在容器内mount的绝对路径,应少于512字符</span>
      <span class="token key atrule">subPath</span><span class="token punctuation">:</span> string       <span class="token comment">#储存卷中的文件夹路径</span>
      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> boolean     <span class="token comment">#是否为只读模式,默认值为读写模式</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token comment">#需要暴露的端口号列表</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string      <span class="token comment">#端口号名称</span>
      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> int    <span class="token comment">#容器需要监听的端口号</span>
      <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> int         <span class="token comment">#容器所在主机需要监听的端口号,默认与Container相同.设置hostPort时,同一台node无法启动第二个副本</span>
      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> string      <span class="token comment">#端口协议,支持TCP和UDP.默认TCP</span>
    <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token comment">#容器运行前需设置的环境变量列表</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string      <span class="token comment">#环境变量名称</span>
      <span class="token key atrule">value</span><span class="token punctuation">:</span> string     <span class="token comment">#环境变量的值</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token comment">#资源限制和请求的设置</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>         <span class="token comment">#资源限制的设置</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> string         <span class="token comment">#Cpu的限制,单位为core数,将用于docker run --cpu-shares参数</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> string      <span class="token comment">#内存限制,单位可以为Mib/Gib,将用于docker run --memory参数</span>
      <span class="token key atrule">requests</span><span class="token punctuation">:</span>       <span class="token comment">#资源请求的设置</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> string         <span class="token comment">#Cpu请求,容器启动的初始可用数量</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> string      <span class="token comment">#内存请求,容器启动的初始可用数量</span>
    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>      <span class="token comment">#对Pod内的容器健康检查的设置,当探测无响应几次后将自动重启该容器,检查方法有exec,httpGet和tcpSocket,对一个容器只需设置其中一种方法</span>
      <span class="token key atrule">exec</span><span class="token punctuation">:</span>       <span class="token comment">#对Pod容器内检查方式设置为exec方式</span>
        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>   <span class="token comment">#exec方式需要制定的命令或脚本</span>
      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>        <span class="token comment">#对Pod内的容器健康检查方法设置为HttpGet,需要指定Path,port</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> string
        <span class="token key atrule">port</span><span class="token punctuation">:</span> number
        <span class="token key atrule">host</span><span class="token punctuation">:</span> string
        <span class="token key atrule">scheme</span><span class="token punctuation">:</span> string
        <span class="token key atrule">HttpHeaders</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string
          <span class="token key atrule">value</span><span class="token punctuation">:</span> string
      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>      <span class="token comment">#对Pod内的容器健康检查方式设置为tcpSocket方式</span>
         <span class="token key atrule">port</span><span class="token punctuation">:</span> number
       <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">0</span>   <span class="token comment">#容器启动完成后首次探测的时间,单位为秒</span>
       <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment">#对容器健康检查探测等待响应的超时时间,单位秒,默认1秒.超过时间将重启容器</span>
       <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">0</span>     <span class="token comment">#对容器监控检查的定期探测时间设置,单位秒,默认10秒1次</span>
       <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">0</span>
       <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">0</span>
       <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>
         <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Always <span class="token punctuation">|</span> Never <span class="token punctuation">|</span> OnFailure<span class="token punctuation">]</span> <span class="token comment">#Pod的重启策略,Always表示始终重启,OnFailure表示只有Pod以非0退出码退出才重启,Nerver表示不再重启该Pod</span>
    <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> obeject   <span class="token comment">#设置NodeSelector表示将该Pod调度到包含这个标签的工作节点上,以key: value的格式指定</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string
    <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment">#是否使用主机网络模式,默认为false,如果设为true,表示使用宿主机网络,不使用Docker网桥,该pod只能在同一节点启动一份</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token comment">#在该pod上定义共享存储卷列表</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string     <span class="token comment">#共享存储卷名称,containers[].volumeMounts[].name将引用此名称</span>
      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token comment">#类型为emtyDir的存储卷,与Pod同生命周期的一个临时目录.为空对象</span>
      <span class="token key atrule">hostPath</span><span class="token punctuation">:</span> string      <span class="token comment">#类型为hostPath的存储卷,表示挂载Pod所在宿主机的目录</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> string      <span class="token comment">#Pod所在宿主机的目录,将被用于同期中mount的目录</span>
      <span class="token key atrule">secret</span><span class="token punctuation">:</span>       <span class="token comment">#类型为secret的存储卷,挂载集群与定义的secre对象到容器内部</span>
        <span class="token key atrule">scretname</span><span class="token punctuation">:</span> string  
        <span class="token key atrule">items</span><span class="token punctuation">:</span>     
        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> string
          <span class="token key atrule">path</span><span class="token punctuation">:</span> string
      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>      <span class="token comment">#类型为configMap的存储卷,挂载预定义的configMap对象到容器内部</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> string
        <span class="token key atrule">items</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> string
          <span class="token key atrule">path</span><span class="token punctuation">:</span> string    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>Service 模板</title>
    <url>/528668799/</url>
    <content><![CDATA[<h1 id="service-模板"><a class="markdownIt-Anchor" href="#service-模板"></a> Service 模板</h1>
<p>使用 NodePort 类型服务来发布端口适合大多数 Deployment 捆绑使用.</p>
<p>发布之后:</p>
<ul>
<li>
<p>外网通过 NodeIP:NodePort 比如 192.168.2.114:30123 访问.</p>
</li>
<li>
<p>内网其他 Pod 通过 服务名:Port 比如 kubia-nodeport:80 访问.</p>
</li>
<li>
<p>在容器 Pod 内部通过 localhost:targetPort 比如 localhost:8080 访问.</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: kubia-nodeport
  Namespace: dev             <span class="token comment">#命名空间</span>
spec:
  type: NodePort             <span class="token comment">#类型为NodePort</span>
  ports:
  - name: http               <span class="token comment">#端口名</span>
    port: <span class="token number">80</span>                 <span class="token comment">#供集群中其它容器访问的端口</span>
    targetPort: <span class="token number">8080</span>         <span class="token comment">#容器原生使用端口</span>
    nodePort: <span class="token number">30123</span>          <span class="token comment">#互联网访问端口</span>
  - name: https
    port: <span class="token number">443</span>
    targetPort: <span class="token number">8081</span>
    nodePort: <span class="token number">30123</span>
  selector:
    app: kubia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>PVC 模板</title>
    <url>/1958383264/</url>
    <content><![CDATA[<h1 id="pvc-模板"><a class="markdownIt-Anchor" href="#pvc-模板"></a> PVC 模板</h1>
<p>以下是一个完整的 PVC 模板：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
  labels:
    type: <span class="token string">"SSD"</span>               <span class="token comment">#PVC也能打标签</span>
  namespace: default          <span class="token comment">#PVC有命名空间,只有同命名空间Pod才可用</span>
spec:
  accessModes:                <span class="token comment">#访问模式,选项同PV</span>
  - ReadWriteMany
  resources:
    requests:
      storage: 1Gi            <span class="token comment">#请求储存容量</span>
  storageClassName: <span class="token string">""</span>        
  selector:                   <span class="token comment">#选择PV标签</span>
    matchLabels:
      type: ssd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Kubernets</category>
        <category>3.参考文件</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 目录配置标准与结构</title>
    <url>/4087499240/</url>
    <content><![CDATA[<h1 id="目录配置标准"><a class="markdownIt-Anchor" href="#目录配置标准"></a> 目录配置标准</h1>
<p>Linux 采用将文件储存在单个目录结构中，这种目录被称为虚拟目录（Virtual Directory）。虚拟目录将安装在主机上的所有储存设备的文件路径纳入单个目录结构中。</p>
<p>各种发行版遵循同一套文件系统层次结构标准（FHS，Filesystem Hierarchy Standard），目的在于规范每个特定目录应该放什么数据。FHS 依据文件系统使用的频繁与否，以及是否允许使用者随意变更，将目录定义为四种交互形态：</p>
<ul>
<li>
<p><strong>可分享的</strong>（Shareable）</p>
<p>可以分享给其他系统挂载使用的目录，包括可执行文件与使用者的邮件等数据。</p>
</li>
<li>
<p><strong>不可分享的</strong>（Unshareable）</p>
<p>自己机器上面运行的设备文件或者是与程序有关的 socket 文件等，仅能自己使用，所以不适合分享。</p>
</li>
<li>
<p><strong>不变的</strong>（Static）</p>
<p>有些数据是不会经常变动的，例如函数库、文件说明文档、系统管理员所管理的主机服务配置文件等。</p>
</li>
<li>
<p><strong>可变动的</strong>（Variable）</p>
<p>经常改变的数据，例如日志文件等。</p>
</li>
</ul>
<h1 id="顶级目录"><a class="markdownIt-Anchor" href="#顶级目录"></a> 顶级目录</h1>
<p>所有目录都由根目录/衍生而来，因此 FHS 标准建议根目录所在分区应该越小越好，最好不要将应用程序所安装的软件与根目录放在同一个分区。这样可以提高性能，根目录所在的文件系统也较不容易发生问题。</p>
<p>开机过程中仅有根目录会被挂载，其他分区则是在开机完成后陆续进行挂载。</p>
<p>必须存在的顶级目录：</p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>目录说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/bin</code></td>
<td>二进制目录，存放可以被 root 和一般账户所用的命令，以及在单用户维护模式下仍能被操作的常用命令，如 <code>cat</code>、<code>mv</code>、<code>chown</code> 等。</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>启动目录，存放开机会使用到的文件，包括内核文件及开机所需配置文件。</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>设备目录，Linux 上任何设备与接口设备都是以文件的形式存在于这个目录下，访问目录下的某个文件就等于访问某个设备。主要分为三类硬件，例如硬盘（sda）和打印机（lp0），终端如控制台（tty），伪设备如 <code>/dev/null</code> 和 <code>/dev/zero</code>。</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>系统配置文件目录，系统配置文件几乎都放在这里，如账号密码，服务起始文件等。一般不要放可执行文件到这个目录下。<br /><code>/etc/X11</code>：与 X Window 有关的配置文件放在这里，尤其是 xorg.conf 这个 XServer 的配置文件。<br /><code>/etc/opt</code>：放置第三方软件配置文件。<br /><code>/etc/sgml</code>：与 SGML 格式有关的各项配置文件。<br /><code>/etc/xml</code>：与 XML 格式有关的配置文件。</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>主目录，系统默认用户主文件夹，一般子文件夹以用户账号命名。</td>
</tr>
<tr>
<td><code>/lib</code>、<code>/lib64</code></td>
<td>库目录，存放开机时会用到的函数库，以及在 <code>/bin</code> 或 <code>/sbin</code> 中命令会调用的函数库。<br /><code>/lib/modules/</code>：存放内核相关的模块（驱动程序）。</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>媒体目录，存放可删除设备，包括 CD、DVD、U 盘等设备都暂时挂载于此。</td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td>挂载目录，如果想要暂时挂载某些额外的设备，一般放置到这个目录中。</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>可选目录，给第三方软件放置的目录，包括发行版附加的一些软件包。</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>系统管理员的主文件夹。</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>系统二进制目录，只有 root 可用，包括开机，修复，还原系统所需要的系统命令，如 <code>fdisk</code>、<code>ifconfig</code>、<code>init</code> 等。</td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>服务目录，一些网络服务启动后，这些服务所需要取用的数据目录，如将 www 服务需要的网页文件放置到 <code>/srv/www</code> 里。</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>临时目录，重要数据不可放置到此目录，会被一些系统进程定期清空。</td>
</tr>
<tr>
<td><code>/run</code></td>
<td>运行目录，存放系统运作时的运行时数据。</td>
</tr>
</tbody>
</table>
<p>其他重要目录：</p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>目录说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/lost+found</code></td>
<td>只有 ext 文件系统格式才会产生的目录，用来放置丢失的文件片段。</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>进程目录。这个目录本身是一个虚拟文件系统（Virtual Filesystem），它放置的数据都在内存中，如系统内核、进程、外部设备的状态及网络状态等，所以实际不占任何硬盘空间。</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>系统目录。和 <code>/proc</code> 类似的虚拟文件系统，记录与内核相关信息，包括目前已加载的内核模块与硬件设备信息。</td>
</tr>
</tbody>
</table>
<h1 id="usr-目录"><a class="markdownIt-Anchor" href="#usr-目录"></a> /usr 目录</h1>
<p><code>/usr</code> 目录存放静态数据,即不会随时间改变的文件,原则上放置独立安装的软件数据。系统默认软件也放在 <code>/usr</code> 目录下。</p>
<p><code>/usr</code> 目录下的子目录说明：</p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>目录说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/usr/bin/</code></td>
<td>存放所有的用户命令。</td>
</tr>
<tr>
<td><code>/usr/include/</code></td>
<td>存放 C/C++ 等编程语言的头文件（header）和包含文件（include）。</td>
</tr>
<tr>
<td><code>/usr/lib/</code></td>
<td>存放各种应用软件的函数库、目标文件，以及一般用户不使用的执行文件或脚本。</td>
</tr>
<tr>
<td><code>/usr/local/</code></td>
<td>推荐系统管理员自行下载安装的软件存放目录。</td>
</tr>
<tr>
<td><code>/usr/sbin/</code></td>
<td>存放非正常运行所需的系统命令，例如网络服务器软件的服务命令。</td>
</tr>
<tr>
<td><code>/usr/share/</code></td>
<td>存放共享文件，如 man 手册和 doc 帮助文档。</td>
</tr>
<tr>
<td><code>/usr/src/</code></td>
<td>一般建议将源码放在该目录下。内核源码建议放在 <code>/usr/src/linux/</code> 下。</td>
</tr>
<tr>
<td><code>/usr/libexec/</code></td>
<td>存放某些不被一般使用者惯用的可执行文件或脚本。</td>
</tr>
</tbody>
</table>
<h1 id="var-目录"><a class="markdownIt-Anchor" href="#var-目录"></a> /var 目录</h1>
<p><code>/var</code> 目录是用来存放会经常变动的文件的，包括缓存（cache）、日志文件（log file）以及某些软件运行时所产生的文件（lock file、run file）或 MySQL 数据库的文件等等。最好可以将它独立出来挂在单独的一个分区中。</p>
<p><code>/var</code> 目录下的子目录说明：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>目录说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/var/cache/</code></td>
<td>应用程序本身运行过程中会产生一些暂存文件。</td>
</tr>
<tr>
<td><code>/var/lib/</code></td>
<td>程序执行的过程中需要使用到的数据文件的放置目录。在此目录下各自的软件应该要有自己的目录，例如 MySQL 数据库放置到 <code>/var/lib/mysql/</code> 下。</td>
</tr>
<tr>
<td><code>/var/lock/</code></td>
<td>某些设备或文件资源一次只能被一个应用程序所使用，为了避免使用冲突就得给该设备上锁。例如刻录机设备在刻录中时会被锁上。目前此目录已被挪到 <code>/run/lock/</code> 中。</td>
</tr>
<tr>
<td><code>/var/log/</code></td>
<td>日志文件放置的目录，例如记录登录者信息的文件 <code>/var/log/messages</code>、<code>/var/log/wtmp</code>。</td>
</tr>
<tr>
<td><code>/var/mail/</code></td>
<td>放置个人电子邮件信箱的目录，等同于 <code>/var/spool/mail/</code>。</td>
</tr>
<tr>
<td><code>/var/run/</code></td>
<td>某些程序或服务启动后，会将它们的 PID 放置在这个目录下。</td>
</tr>
<tr>
<td><code>/var/spool/</code></td>
<td>放置一些队列数据，通常在使用后会被删除。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 中用户与用户组</title>
    <url>/2592592171/</url>
    <content><![CDATA[<h1 id="用户标识符"><a class="markdownIt-Anchor" href="#用户标识符"></a> 用户标识符</h1>
<p>每个用户至少都有两个 ID，用户 ID（UID，User ID）和用户组 ID（GID，Group ID）。</p>
<p>当显示文件属性时，系统会根据 <code>/etc/passwd</code> 与 <code>/etc/group</code> 文件的内容找到 UID/GID 对应的账号与组名再显示出来。</p>
<h1 id="用户账号"><a class="markdownIt-Anchor" href="#用户账号"></a> 用户账号</h1>
<p>用户通过终端或 SSH 登录时，系统的处理过程如下：</p>
<ol>
<li>首先在 <code>/etc/passwd</code> 中查找是否存在输入的账户，如果存在，则读取对应的 UID、GID、主目录和 shell 设置。</li>
<li>核对输入的密码是否与 <code>/etc/shadow</code> 记录匹配。</li>
<li>如果账户和密码都正确，就可以进入 shell。</li>
</ol>
<h2 id="etcpasswd-文件结构"><a class="markdownIt-Anchor" href="#etcpasswd-文件结构"></a> /etc/passwd 文件结构</h2>
<p><code>passwd</code> 文件中以行为单位记录系统中所有账号，各字段之间用冒号分隔开：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">head</span> <span class="token parameter variable">-4</span> /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上以第一条为例，总共七个字段，说明如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>root</td>
<td>账号名称，用来对应 UID。</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>密码，早期 UNIX 用来存放加密过的密码字段。</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>UID，其中 0 固定为 root 用，1-499 号留给系统账号用，500 之后为一般用户。</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>GID，组信息保存在 <code>/etc/group</code> 中。</td>
</tr>
<tr>
<td>5</td>
<td>root</td>
<td>用户信息说明列，只是用来解释账号意义。</td>
</tr>
<tr>
<td>6</td>
<td>/root</td>
<td>用户主文件夹位置。</td>
</tr>
<tr>
<td>7</td>
<td>/bin/bash</td>
<td>默认使用的 shell。如果是 <code>/sbin/nologin</code> 代表不能登录。</td>
</tr>
</tbody>
</table>
<h2 id="etcshadow-文件结构"><a class="markdownIt-Anchor" href="#etcshadow-文件结构"></a> /etc/shadow 文件结构</h2>
<p><code>shadow</code> 文件中保存了密码和相关限制设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/shadow
root:<span class="token variable">$6</span><span class="token variable">$A7YdIFXQJ47yq0</span>::0:99999:7:::
bin:*:17632:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以第一条记录为例，总共有九个字段，说明如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>root</td>
<td>账户名。</td>
</tr>
<tr>
<td>2</td>
<td>7YdIFXQJ47yq0</td>
<td>编码过的密码，使用不同编码方式产生的长度不同。</td>
</tr>
<tr>
<td>3</td>
<td>13400</td>
<td>最近改动密码的日期，以 1970/01/01 作为基准计算经过时间。</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>密码不可被改动的天数，0 无限制，11 表示每次修改密码的等待间隔为 11 天。</td>
</tr>
<tr>
<td>5</td>
<td>99999</td>
<td>密码过期的期限天数，如果超过这个限制天数没改密码，密码会变为已过期。</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>密码过期前发出警告的提前天数。</td>
</tr>
<tr>
<td>7</td>
<td>14</td>
<td>密码过期后的账号宽限时间。</td>
</tr>
<tr>
<td>8</td>
<td>14800</td>
<td>账号失效日期，过了限制日期后账号无法再使用。</td>
</tr>
<tr>
<td>9</td>
<td>-</td>
<td>保留字段。</td>
</tr>
</tbody>
</table>
<h1 id="用户组"><a class="markdownIt-Anchor" href="#用户组"></a> 用户组</h1>
<p>用户组可以将账户集中在一起组成一个逻辑排列，从而简化特权管理。和用户组有关的文件记录在 <code>/etc/group</code> 与 <code>/etc/gshadow</code> 中。</p>
<h2 id="etcgroup-文件结构"><a class="markdownIt-Anchor" href="#etcgroup-文件结构"></a> /etc/group 文件结构</h2>
<p><code>group</code> 文件记录 GID 与组名的对应：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/group
root:x:0:
bin:x:1:
daemon:x:2:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>以第一条记录为例，总共有四个字段，说明如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>root</td>
<td>用户组名。</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>用户组密码，不再使用。</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>用户组 ID。</td>
</tr>
<tr>
<td>4</td>
<td>-</td>
<td>此用户组支持的账号名称。</td>
</tr>
</tbody>
</table>
<p>初始用户组（initial group）与有效用户组（effective group）：</p>
<ul>
<li>保存在 <code>/etc/passwd</code> 中的用户对应 GID 就是初始用户组。</li>
<li>保存在 <code>/etc/group</code> 中的用户名说明用户在此组中，该组是组内用户的有效用户组。</li>
</ul>
<h2 id="etcgshadow-文件结构"><a class="markdownIt-Anchor" href="#etcgshadow-文件结构"></a> /etc/gshadow 文件结构</h2>
<p><code>gshadow</code> 文件用来设定组密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/gshadow
root:::
bin:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>文件内容和 <code>/etc/group</code> 差不多，除了第二列用来记录组密码。</p>
<h2 id="两种群组机制"><a class="markdownIt-Anchor" href="#两种群组机制"></a> 两种群组机制</h2>
<p>针对创建用户时是否创建私有组的策略有两种机制：</p>
<ul>
<li>
<p><strong>私有群组机制</strong></p>
<p>系统会创建一个与账号同名的群组作为初始群组，且主文件夹权限设置为 700，这样对用户来说保密性较好。使用这一机制的代表有 RHEL、Fedora、CentOS 等。</p>
</li>
<li>
<p><strong>公共群组机制</strong></p>
<p>新建账户时若未指定组，系统会自动将 GID=100 分配给用户作为初始群组。此组为 users 公共组，主文件夹权限为 755，同一组内的用户可以共享主文件夹内的数据。SuSE 等发行版使用这一机制。</p>
</li>
</ul>
<h1 id="新增用户"><a class="markdownIt-Anchor" href="#新增用户"></a> 新增用户</h1>
<p>使用默认设置新建用户时，系统所进行的操作如下：</p>
<ol>
<li>在 <code>/etc/passwd</code> 中创建一行与账号相关的数据，包括创建 UID、GID、主文件夹等；</li>
<li>在 <code>/etc/shadow</code> 中将账号密码相关参数填入，默认无密码；</li>
<li>在 <code>/etc/group</code> 中加入一个与账户名相同的组名；</li>
<li>在 <code>/home</code> 目录下创建与账户同名的目录作为用户主文件夹，权限设置为 700。</li>
</ol>
<p>可以通过 <code>useradd -D</code> 命令查看创建用户时使用的默认值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-D</span>
<span class="token assign-left variable">GROUP</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/home
<span class="token assign-left variable">INACTIVE</span><span class="token operator">=</span>-1
<span class="token assign-left variable">EXPIRE</span><span class="token operator">=</span>
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable">SKEL</span><span class="token operator">=</span>/etc/skel
<span class="token assign-left variable">CREATE_MAIL_SPOOL</span><span class="token operator">=</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上，这是调用了 <code>/etc/default/useradd</code> 文件的内容。各变量的说明如下：</p>
<table>
<thead>
<tr>
<th>行</th>
<th>设置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>GROUP=100</td>
<td>设置新用户的初始组为 users，在 CentOS 中不适用。</td>
</tr>
<tr>
<td>2</td>
<td>HOME=/home</td>
<td>用户主文件夹的基准目录（basedir）。</td>
</tr>
<tr>
<td>3</td>
<td>INACTIVE=-1</td>
<td>密码过期后是否会失效的设置值。</td>
</tr>
<tr>
<td>4</td>
<td>EXPIRE=</td>
<td>账号失效的日期，YYYY-MM-DD 格式。</td>
</tr>
<tr>
<td>5</td>
<td>SHELL=/bin/bash</td>
<td>新用户默认的 shell 路径。</td>
</tr>
<tr>
<td>6</td>
<td>SKEL=/etc/skel</td>
<td>新用户主目录里默认的内容参考来源。</td>
</tr>
<tr>
<td>7</td>
<td>CREATE_MAIL_SPOOL=yes</td>
<td>创建用户的邮件信箱。</td>
</tr>
</tbody>
</table>
<p>其他一些设置，如密码策略、邮箱目录等，存放在 <code>/etc/login.defs</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/login.defs <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token parameter variable">-E</span> <span class="token string">"^$|^#"</span>
MAIL_DIR        /var/spool/mail
PASS_MAX_DAYS   <span class="token number">99999</span>
PASS_MIN_DAYS   <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/etc/login.defs</code> 文件中，一些重要参数的说明如下：</p>
<table>
<thead>
<tr>
<th>行</th>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MAIL_DIR</td>
<td>用户邮箱所在位置</td>
</tr>
<tr>
<td>2-6</td>
<td>PASS_, WARN_AGE</td>
<td>密码设置相关</td>
</tr>
<tr>
<td>7-14</td>
<td>UID, SYS_UID, GID, SYS_GID</td>
<td>设置 UID/GID 号相关参数</td>
</tr>
<tr>
<td>15</td>
<td>CREATE_HOME</td>
<td>建立用户主文件夹</td>
</tr>
<tr>
<td>16</td>
<td>UMASK</td>
<td>用户主文件夹的权限设置</td>
</tr>
<tr>
<td>17</td>
<td>USERGROUPS_ENAB</td>
<td>删除用户时，如果同名组是空组，也一并删除</td>
</tr>
<tr>
<td>18</td>
<td>ENCRYPT_METHOD</td>
<td>密码加密方式</td>
</tr>
</tbody>
</table>
<h1 id="修改密码"><a class="markdownIt-Anchor" href="#修改密码"></a> 修改密码</h1>
<p>root 在修改密码时不需要输入旧密码，可以忽略密码规则。通常，普通用户在修改密码时需要输入旧密码，且密码需要符合复杂性要求。</p>
<p>密码管理机制由 <code>/etc/pam.d/passwd</code> 控制，密码测试模块使用 <code>pam_cracklib.so</code>。</p>
<p>可以使用 <code>authconfig</code> 命令查看密码哈希使用的算法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ authconfig <span class="token parameter variable">--test</span> <span class="token operator">|</span> <span class="token function">grep</span> hashing
password hashing algorithm is sha512<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假设作为一般用户，原始密码为 A2345678b，则修改密码时的错误示例如下：</p>
<table>
<thead>
<tr>
<th><strong>密码规则</strong></th>
<th><strong>错误示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>长度&gt;8</td>
<td>b2345C</td>
</tr>
<tr>
<td>不是回文（即上次密码的倒置）</td>
<td>b8765432A</td>
</tr>
<tr>
<td>不能和上次密码只有大小写区别</td>
<td>a2345678B</td>
</tr>
<tr>
<td>至少包含字母和数字</td>
<td>abababab</td>
</tr>
<tr>
<td>简单的轮询检查</td>
<td>2345678bA</td>
</tr>
</tbody>
</table>
<h1 id="pam-模块"><a class="markdownIt-Anchor" href="#pam-模块"></a> PAM 模块</h1>
<p>PAM（可插拔身份验证模块）是一套应用程序编程接口（API），用于提供一系列身份验证机制。通过告知 PAM 验证阶段的要求，PAM 能够返回验证结果（成功或失败）给用户。</p>
<p>PAM 只是一套验证机制，并可供其他程序调用，因此无论使用哪个程序，都可以使用 PAM 进行身份验证。</p>
<p>例如，<code>passwd</code> 命令调用 PAM 的过程如下：</p>
<ol>
<li>用户执行 <code>/usr/bin/passwd</code> 程序并输入密码；</li>
<li><code>passwd</code> 调用 PAM 模块进行验证；</li>
<li>PAM 模块在 <code>/etc/pam.d/</code> 中查找与 <code>passwd</code> 程序同名的配置文件；</li>
<li>根据 <code>/etc/pam.d/passwd</code> 中的设置，逐步引用相关的 PAM 模块进行验证分析；</li>
<li>将验证结果返回给 <code>passwd</code> 程序；</li>
<li><code>passwd</code> 根据 PAM 返回的结果决定下一步操作（通过或要求重试）。</li>
</ol>
<p>查看 <code>/etc/pam.d/passwd</code> 文件内容如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/pam.d/passwd
<span class="token comment">#%PAM-1.0</span>
auth       include      system-auth
account    include      system-auth
password   substack     system-auth
<span class="token parameter variable">-password</span>   optional    pam_gnome_keyring.so use_authtok
password   substack     postlogin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一行都包含三个字段，分别是验证类别（type）、控制标志（flag）以及相应的 PAM 模块及其参数。</p>
<h2 id="验证类型"><a class="markdownIt-Anchor" href="#验证类型"></a> 验证类型</h2>
<p>验证类型（Type）有四种，分别为：</p>
<ul>
<li>
<p><strong>auth</strong></p>
<p>authentication（认证）的缩写，主要用于检验用户的身份信息，通常需要密码来进行验证，因此后续接的模块用于验证用户的身份。</p>
</li>
<li>
<p><strong>account</strong></p>
<p>account（账号）主要用于授权，用于检验用户是否具有正确的授权。例如，在使用一个过期的密码进行登录时，将无法成功登录。</p>
</li>
<li>
<p><strong>session</strong></p>
<p>session（会话）管理用户在登录期间（或使用特定命令期间）PAM 提供的环境设置。该类型通常用于记录用户登录和注销的信息。例如，在使用 <code>sudo</code> 命令时，会在安全日志中记录与 PAM 相关的信息，如 session open、session close 等信息。</p>
</li>
<li>
<p><strong>password</strong></p>
<p>password（密码）用于进行密码验证和修改密码等相关操作。</p>
</li>
</ul>
<p>这四种验证类型通常按照顺序进行。首先进行身份验证（auth），然后进行授权（account），接着记录会话信息（session），最后进行密码相关的操作（password）。</p>
<h2 id="控制标志"><a class="markdownIt-Anchor" href="#控制标志"></a> 控制标志</h2>
<p>控制标志（Control Flag）用于控制验证的方式。该字段指定了验证的通过标准，有以下四种控制标志：</p>
<ul>
<li>
<p><strong>required</strong></p>
<p>若验证成功，则返回 success 标志；若验证失败，则返回 failure 标志。无论成功或失败，都将继续后续的验证流程。由于后续的验证流程可以继续进行，因此这是最常用的标志之一，也方便记录日志。</p>
</li>
<li>
<p><strong>requisite</strong></p>
<p>验证失败会立即返回原始程序，并带有 failure 标志，同时终止后续的验证流程。验证成功则带有 success 标志，并继续后续的验证流程。与 required 标志的最大区别在于，遇到失败时立即终止验证流程，因此无法记录失败产生的 PAM 信息。</p>
</li>
<li>
<p><strong>sufficient</strong></p>
<p>若验证成功，则立即返回 success 给原始程序，并终止后续的验证流程。验证失败则带有 failure 标志，并继续后续的验证流程。与 requisite 标志正好相反。</p>
</li>
<li>
<p><strong>optional</strong></p>
<p>optional 标志通常用于显示信息，而不是用于验证。</p>
</li>
</ul>
<p>如果控制标志字段中出现 include，表示调用后面的文件作为该类别的验证配置。</p>
<h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2>
<p>模块存放路径：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/etc/pam.d/*</code></td>
<td>每个程序单独的 PAM 配置文件。</td>
</tr>
<tr>
<td><code>/lib/security/*</code></td>
<td>PAM 模块文件实际放置位置。</td>
</tr>
<tr>
<td><code>/etc/security/*</code></td>
<td>其他 PAM 环境配置文件。</td>
</tr>
<tr>
<td><code>/usr/share/doc/pam-*/</code></td>
<td>详细的 PAM 说明文件。</td>
</tr>
</tbody>
</table>
<p>一些比较常用的模块：</p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pam_securetty.so</td>
<td>限制系统管理员 root 只能从安全的终端机登录，例如 tty1-7(由 <code>/etc/securetty</code> 设定)。</td>
</tr>
<tr>
<td>pam_nologin.so</td>
<td>限制一般用户能否登录主机。当 <code>/etc/nologin</code> 文件存在时，所有一般用户均无法登录。</td>
</tr>
<tr>
<td>pam_selinux.so</td>
<td>SELinux 是针对程序来进行详细管理权限的功能。</td>
</tr>
<tr>
<td>pam_console.so</td>
<td>需要使用特殊的终端接口登录主机时，这个模块帮助处理一些文件权限的问题。</td>
</tr>
<tr>
<td>pam_loginuid.so</td>
<td>验证用户的 UID 数值，可以使用这个模块来规范。</td>
</tr>
<tr>
<td>pam_env.so</td>
<td>用来设置环境变量的一个模块。</td>
</tr>
<tr>
<td>pam_unix.so</td>
<td>用于验证阶段的认证功能，可以用于授权阶段的账号许可证管理、日志记录等。</td>
</tr>
<tr>
<td>pam_pwquality.so</td>
<td>用来验证密码的强度，包括密码是否在字典中、密码最大重试次数等。</td>
</tr>
<tr>
<td>pam_cracklib.so</td>
<td>用来检验密码强度，已被 pam_pwquality.so 取代。</td>
</tr>
<tr>
<td>pam_limits.so</td>
<td><code>ulimit</code> 命令用到了这个模块。</td>
</tr>
</tbody>
</table>
<p>另外一个比较常用的是 <code>/etc/security/limits.conf</code> 这个配置文件，可以直接修改这个文件来对用户的系统使用配额做一些设置。</p>
<p>例如修改用户 user1 只能新建小于 100MB 的文件（hard），且大于 80MB 会警告（soft）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vim</span> /etc/security/limits.conf 
<span class="token comment">#&lt;domain>      &lt;type>  &lt;item>         &lt;value></span>
<span class="token comment">#</span>
<span class="token comment">#*               soft    core            0</span>
<span class="token comment">#*               hard    rss             10000</span>
<span class="token comment">#@student        hard    nproc           20</span>
<span class="token comment">#@faculty        soft    nproc           20</span>
<span class="token comment">#@faculty        hard    nproc           50</span>
<span class="token comment">#ftp             hard    nproc           0</span>
<span class="token comment">#@student        -       maxlogins       4</span>
user1            soft    fsize           <span class="token number">80000</span>
user1            hard    fsize           <span class="token number">100000</span>
<span class="token string">"/etc/security/limits.conf"</span> 64L, 2499C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>ulimit</code> 查询，并使用 <code>dd</code> 命令测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-a</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'file size'</span>
core <span class="token function">file</span> size          <span class="token punctuation">(</span>blocks, -c<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token function">file</span> size               <span class="token punctuation">(</span>blocks, -f<span class="token punctuation">)</span> <span class="token number">80000</span>
<span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>filetest <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">200</span>
File size limit exceeded
<span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-k</span> filetest
-rw-rw-r--. <span class="token number">1</span> user1 user1 <span class="token number">81920000</span> Sep <span class="token number">13</span> <span class="token number">11</span>:23 filetest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如限制用户组 group1 每次只能有一个用户登录系统（maxlogins）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vim</span> /etc/security/limits.conf 
<span class="token comment">#&lt;domain>      &lt;type>  &lt;item>         &lt;value></span>
@group1          hard    maxlogins       <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>登录相关日志文件存放目录有 <code>/var/log/secure</code> 和 <code>/var/log/messages</code>。如果发生任何无法登录或是产生意外错误，由 PAM 模块将数据记录在 <code>/var/log/secure</code> 中。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>计算机软件基础</title>
    <url>/2759544459/</url>
    <content><![CDATA[<h1 id="数字系统"><a class="markdownIt-Anchor" href="#数字系统"></a> 数字系统</h1>
<p>计算机使用电信号的开和关来代表二进制的 1 和 0，这种逢 2 进 1 位的表示法称为二进制。除了二进制，常用的进制还有八进制和十六进制。然而，现实生活中使用的数字系统是十进制。</p>
<p>在编程语言中，表示二进制数的前缀是&quot;0b&quot;，表示八进制数的前缀是&quot;0o&quot;，表示十六进制数的前缀是&quot;0x&quot;。</p>
<h2 id="二进制转十进制"><a class="markdownIt-Anchor" href="#二进制转十进制"></a> 二进制转十进制</h2>
<p>例如，要将二进制数 1101101 转换为十进制数，手动计算方法如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1101101</mn><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>6</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>5</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>=</mo><mn>64</mn><mo>+</mo><mn>32</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>109</mn></mrow><annotation encoding="application/x-tex">1101101=1*2^6+1*2^5+0*2^4+1*2^3+1*2^2+0*2^1+1=64+32+0+8+4+0+1=109
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span></span></span></span></span></p>
<p>在 Bash 中，可以使用<code>echo $(())</code>来直接将二进制数转换为十进制数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span>#<span class="token number">1101101</span><span class="token variable">))</span></span>
<span class="token number">109</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="十进制转二进制"><a class="markdownIt-Anchor" href="#十进制转二进制"></a> 十进制转二进制</h2>
<p>例如，将十进制数 109 转换为二进制数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">109</span>/2<span class="token operator">=</span><span class="token number">54</span><span class="token punctuation">..</span>.1
054/2<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">..</span>.0
027/2<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">..</span>.1
013/2<span class="token operator">=</span>06<span class="token punctuation">..</span>.1
007/2<span class="token operator">=</span>03<span class="token punctuation">..</span>.0
003/2<span class="token operator">=</span>01<span class="token punctuation">..</span>.1
001/2<span class="token operator">=</span>00<span class="token punctuation">..</span>.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将商除到 0 为止，把所有的余数从下往上读，得到的就是二进制结果 1101101。</p>
<p>在 Bash 中，可以通过调用<code>bc</code>来进行计算：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"obase=2;ibase=10;109"</span><span class="token operator">|</span><span class="token function">bc</span> <span class="token parameter variable">-l</span>
<span class="token number">1101101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="二进制转十六进制"><a class="markdownIt-Anchor" href="#二进制转十六进制"></a> 二进制转十六进制</h2>
<p>例如，将二进制数 1101101 转换为十六进制数。</p>
<p>因为四位二进制恰好等于一位十六进制，所以先将二进制数从低位到高位分为四位一组，高位不足四位在前面补 0：</p>
<p>0110 1101</p>
<p>然后将每一组转为对应的十六进制数：</p>
<p>6 D</p>
<p>得到转换结果 0x6D。</p>
<h2 id="十六进制转二进制"><a class="markdownIt-Anchor" href="#十六进制转二进制"></a> 十六进制转二进制</h2>
<p>例如，将十六进制数 0x6D 转换为二进制数。</p>
<p>原理同二进制转十六进制，将每位十六进制单独拿出来：</p>
<p>6 D</p>
<p>将每位转为对应的二进制：</p>
<p>0110 1101</p>
<p>得到转换结果 1101101。</p>
<h2 id="计量单位"><a class="markdownIt-Anchor" href="#计量单位"></a> 计量单位</h2>
<p>计算机中常用的计量单位有下面一些：</p>
<ul>
<li>存储容量单位
<ul>
<li><strong>比特</strong>（bit）：二进制单位，只记录 0 或 1。</li>
<li><strong>字节</strong>（Byte）：储存记录用的单位，1Byte = 8bit。1KB = 1024Byte，再往上有 GB、TB、PB、EB、ZB 等单位。</li>
</ul>
</li>
<li>速度单位
<ul>
<li><strong>运算速度</strong>：Hz 代表秒分之一，CPU 运算速度常使用 MHz 或 GHz。1MHz = 1000*1000Hz。</li>
<li><strong>网络传输</strong>：bps 意思是 bit per second 每秒多少比特，常见的网卡速度 100Mbps 意即每秒传输 100Mb，转为实际文件传输速度等于 12.5MB/s。</li>
</ul>
</li>
</ul>
<h1 id="编码系统"><a class="markdownIt-Anchor" href="#编码系统"></a> 编码系统</h1>
<p>计算机只能识别数字，因此需要使用编码系统将文字转换为数字进行储存。</p>
<h2 id="编码过程"><a class="markdownIt-Anchor" href="#编码过程"></a> 编码过程</h2>
<p>编码的过程是根据一个编码对照表将文字转换为对应编码表中的编号，并将编号存入文件中。</p>
<p>在读取文件时，再根据编码对照表将编号还原成文字进行显示。</p>
<p>如果选择的编码表与实际不符，则会出现所谓的“乱码”。</p>
<p>常用的编码表包括 ASCII、GB2312 和 Unicode 等。</p>
<h2 id="ascii-编码"><a class="markdownIt-Anchor" href="#ascii-编码"></a> ASCII 编码</h2>
<p>美国信息交换标准码（ASCII，American Standard Code for Information Interchange）为每个字符指定 7 位（最左边的位被忽略掉），占用 1Byte 的记录，因此总共可以表示 128 个字符，即从二进制 0000000 到 1111111。</p>
<p>ASII 码中包含 33 个控制字符、52 个字母（65 ~ 90，97 ~ 122）、10 个数字（48 ~ 57）、32 个标点符号以及空白符。</p>
<h2 id="gb2312-编码"><a class="markdownIt-Anchor" href="#gb2312-编码"></a> GB2312 编码</h2>
<p>简体中文最常用的是 GB2312 编码，每个中文字会占用 2Bytes。</p>
<p>理论上有 2<sup>16</sup>=65536 个记录位置，实际只收录了一万三千多个中文字。</p>
<h2 id="unicode-编码"><a class="markdownIt-Anchor" href="#unicode-编码"></a> Unicode 编码</h2>
<p>Unicode 编码也叫 UTF-8 或统一码。基本上包含了所有语言的文字。</p>
<h1 id="逻辑门"><a class="markdownIt-Anchor" href="#逻辑门"></a> 逻辑门</h1>
<p>计算机中的逻辑电路基本单元有以下几种：</p>
<h2 id="非门not-gate"><a class="markdownIt-Anchor" href="#非门not-gate"></a> 非门（NOT Gate）</h2>
<p>也称为反相器、倒相器、逻辑否定电路，它的输出是输入的反相。当输入端为高电平(1)时，输出端为低电平(0)，当输入端为低电平(0)时，输出端为高电平(1)。</p>
<p>非门的真值表：</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E9%9D%9E%E9%97%A8.png" alt="非门" /></p>
<h2 id="与门and-gate"><a class="markdownIt-Anchor" href="#与门and-gate"></a> 与门（AND Gate）</h2>
<p>与门又称与电路、逻辑积、逻辑与电路。当所有的输入同时为高电平(1)时，输出才为高电平(1)，否则输出为低电平(0)。</p>
<p>与门的真值表：</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输入 B</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E4%B8%8E%E9%97%A8.png" alt="与门" /></p>
<h2 id="或门or-gate"><a class="markdownIt-Anchor" href="#或门or-gate"></a> 或门（OR Gate）</h2>
<p>又称或电路、逻辑和电路。只要输入中有一个为高电平(1)时，输出就为高电平(1)；只有当所有的输入全为低电平(0)时，输出才为低电平(0)。</p>
<p>或门的真值表：</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输入 B</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E6%88%96%E9%97%A8.jpg" alt="或门" /></p>
<h2 id="与非门nand-gate"><a class="markdownIt-Anchor" href="#与非门nand-gate"></a> 与非门（NAND Gate）</h2>
<p>与非门是与门和非门的叠加。当输入均为高电平(1)时，输出为低电平(0)；当输入中至少有一个为低电平(0)时，输出为高电平(1)。与非门可以看作是与门和非门的叠加。</p>
<p>与非门真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门" /></p>
<h2 id="或非门nor-gate"><a class="markdownIt-Anchor" href="#或非门nor-gate"></a> 或非门（NOR Gate）</h2>
<p>或非门实现逻辑或非功能。它有多个输入端，1 个输出端。多输入或非门可由 2 输入或非门和反相器构成。只有当两个输入 A 和 B 为低电平(0)时，输出为高电平(1)。也可以理解为任意输入为高电平(1)，输出为低电平(0)。</p>
<p>或非门真值表:</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输入 B</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E6%88%96%E9%9D%9E%E9%97%A8.png" alt="或非门" /></p>
<h2 id="异或门xor-gate"><a class="markdownIt-Anchor" href="#异或门xor-gate"></a> 异或门（XOR Gate）</h2>
<p>异或门是数字逻辑中实现逻辑异或的逻辑门。多输入异或门可由两输入异或门构成。若两个输入的电平相异，则输出为高电平(1)；若两个输入的电平相同，则输出为低电平(0)。即如果两个输入不同，则异或门输出高电平(1)。</p>
<p>异或门真值表:</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输入 B</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E5%BC%82%E6%88%96%E9%97%A8.png" alt="异或门" /></p>
<h2 id="同或门xnor-gate"><a class="markdownIt-Anchor" href="#同或门xnor-gate"></a> 同或门（XNOR Gate）</h2>
<p>同或门也称为异或非门，在异或门的输出端再加上一个非门就构成了异或非门。当 2 个输入端中有且只有一个是低电平(0)时，输出为低电平(0)。即当输入电平相同时，输出为高电平(1)。</p>
<p>同或门真值表:</p>
<table>
<thead>
<tr>
<th>输入 A</th>
<th>输入 B</th>
<th>输出 Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>逻辑符号表示如下：</p>
<p><img data-src="../../../images/%E5%90%8C%E6%88%96%E9%97%A8.png" alt="同或门" /></p>
<h2 id="二进制加法器"><a class="markdownIt-Anchor" href="#二进制加法器"></a> 二进制加法器</h2>
<p>可以使用两种基本逻辑门来计算两个二进制数相加的结果：</p>
<ul>
<li>
<p><strong>位相加</strong></p>
<p>位相加的计算结果由 XOR 异或门实现。</p>
<table>
<thead>
<tr>
<th>位和</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>进位位</strong></p>
<p>进位位的计算结果由 AND 与门实现。</p>
<table>
<thead>
<tr>
<th>进位</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>将它们连起来就成为半加器（Half Adder）：</p>
<p><img data-src="../../../images/%E5%8D%8A%E5%8A%A0%E5%99%A8.png" alt="半加器" /></p>
<p>为了将可能产生的进位位纳入下一次运算，需要对三个二进制数进行加法运算，最终将两个半加器和一个或门连接起来成为一个全加器（Full Adder）：</p>
<p><img data-src="../../../images/%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="全加器" /></p>
<p>首先这一次计算两个二进制数 A 和 B 的和得到进位和位和输出。然后将位和输出与上一次计算结果的进位输出相加得到另外一个进位和位和输出，最后将两次的进位输出做或运算，与上一步得出的位和输出在一起传递给下一环节。</p>
<h1 id="软件程序"><a class="markdownIt-Anchor" href="#软件程序"></a> 软件程序</h1>
<p>通常软件程序可以分为两类：操作系统和应用程序。</p>
<h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2>
<p>操作系统（OS，Operating System）是一组程序，用于管理计算机的所有活动以及驱动系统中的所有硬件。</p>
<p>操作系统内核直接参考硬件规格编写，用于管理硬件，因此同一个操作系统内核不能在不同的硬件构架下运行。</p>
<p>操作系统的功能主要包括：</p>
<ul>
<li>
<p><strong>系统调用接口</strong>（System call interface）</p>
<p>方便程序员通过接口与内核通信，利用硬件资源。</p>
</li>
<li>
<p><strong>程序管理</strong>（Process Control）</p>
<p>一部计算机可以同时运行很多软件，一般管运行中的程序叫进程。进程可以在前台也可以在后台运行，内核控制着系统管理运行在系统上的所有进程。</p>
</li>
<li>
<p><strong>内存管理</strong>（Memory Management）</p>
<p>因为程序代码和数据都必须载入到内存中运行，所以内存控制非常重要。</p>
<p>交换空间（虚拟内存）用于物理内存不足时提供内存交换（swap）功能，调用虚拟内存的过程称为页面调度（Paging）。</p>
<p>内存储存单元按组划分成很多块，这些块称为页面（Page）。内核将每个内存页面放在物理内存或交换空间中，然后维护一个内存页面表，自动把一段时间未访问的内存页面复制到交换空间（Swapping Out）。当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。</p>
</li>
<li>
<p><strong>文件系统管理</strong>（Filesystem Management）</p>
<p>负责对多种文件系统的支持，管理数据输入输出工作，文件格式支持等。</p>
</li>
<li>
<p><strong>设备驱动</strong>（Device Driver）</p>
<p>管理硬件的驱动。驱动程序相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。</p>
</li>
</ul>
<h2 id="应用程序"><a class="markdownIt-Anchor" href="#应用程序"></a> 应用程序</h2>
<p>应用程序是利用操作系统提供的开发接口开发出来的软件，这些软件通常针对特定功能而开发。</p>
<h2 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h2>
<p>源代码是创建软件的原始数据。可以使用诸如 C++之类的编程语言编写源代码，在使用这些代码之前需要进行编译。使用 Perl 或 Python 这样的脚本语言编写源代码，则无需编译即可运行。</p>
<h2 id="开源许可"><a class="markdownIt-Anchor" href="#开源许可"></a> 开源许可</h2>
<p>以源代码形式提供的软件称为开源软件，通常可以自由地查看、共享、使用和修改它。</p>
<p>开源软件许可证声明对源代码拥有版权，并确定代码的使用和发布以及派生代码的使用和发布的自由范围和限制。常见的开源许可证有 BSD 和 GPL。</p>
<ul>
<li>
<p><strong>BSD 许可证</strong></p>
<p>持有 BSD 许可证的源代码可以自由地进行修改，而且不需要重新发布这些修改。常用于私有或商业软件中。</p>
</li>
<li>
<p><strong>GPL 许可证</strong></p>
<p>GNU 通用公共许可证（GPL）规定任何已发布的软件所做的任何修改都必须以相同的许可证发布。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 备份与刻录工具</title>
    <url>/3733482185/</url>
    <content><![CDATA[<h1 id="备份基础"><a class="markdownIt-Anchor" href="#备份基础"></a> 备份基础</h1>
<p>系统备份重要目录有：<code>/etc/</code>、<code>/home/</code>、<code>/root/</code>、<code>/var</code>。不需要备份的目录有：<code>/dev</code>、<code>/proc</code>、<code>/sys</code>、<code>/run</code>、<code>/mnt</code>、<code>/media</code>、<code>/tmp</code>。</p>
<p>常见备份类型有 3 种：</p>
<ul>
<li>完全备份（full）：在备份定义的范围内备份所有数据。</li>
<li>差分备份（differential）：备份所有自上次备份之后发生过变化的数据。在恢复时需要用到完全备份和最近的差分备份。</li>
<li>增量备份（incremental）：备份上次备份完成之后所有发生变化的数据，而不考虑上次备份是什么类型。</li>
</ul>
<h1 id="使用-rsync-备份"><a class="markdownIt-Anchor" href="#使用-rsync-备份"></a> 使用 rsync 备份</h1>
<p><code>rsync</code>可以对两个目录进行镜像，用法非常简单：<code>rsync -av 来源目录 目标目录</code></p>
<p>例如备份<code>/root</code>目录到<code>/backup</code>目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rsync</span> <span class="token parameter variable">-av</span> /root /backup/
sending incremental <span class="token function">file</span> list
root/
root/.bash_history
root/.bash_logout
root/.bash_profile
root/.bashrc
root/.cshrc
root/.tcshrc
root/.viminfo
root/anaconda-ks.cfg
root/.pki/
root/.pki/nssdb/

sent <span class="token number">4,095</span> bytes  received <span class="token number">184</span> bytes  <span class="token number">8,558</span>.00 bytes/sec
total size is <span class="token number">3,458</span>  speedup is <span class="token number">0.81</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进行差异备份使用同样的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> anaconda-ks.cfg <span class="token number">1</span>.cfg
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rsync</span> <span class="token parameter variable">-av</span> /root /backup/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token number">1</span>.cfg 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rsync</span> <span class="token parameter variable">-av</span> /root /backup/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll /backup/root/
total <span class="token number">8</span>
-rw-------. <span class="token number">1</span> root root  <span class="token number">240</span> Sep <span class="token number">21</span> <span class="token number">18</span>:02 <span class="token number">1</span>.cfg
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">8</span> 01:38 anaconda-ks.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看到在当前目录新增或修改文件，备份后<code>/backup</code>目录下会一同新增和修改。当前目录删除文件，备份后<code>/backup</code>目录并不会同步删除文件。</p>
<p>另外，<code>rsync</code>还支持通过网络备份。例如将本地<code>/root</code>备份到<code>192.168.2.102</code>主机上面：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">rsync</span> <span class="token parameter variable">-av</span> <span class="token parameter variable">-e</span> <span class="token function">ssh</span> /root root@192.168.2.234:/backup
sending incremental <span class="token function">file</span> list
root/
root/.bash_history
root/iptables/
root/iptables/iptables.allow
root/iptables/iptables.deny
root/iptables/iptables.rules

sent <span class="token number">33,124</span> bytes  received <span class="token number">363</span> bytes  <span class="token number">22,324</span>.67 bytes/sec
total size is <span class="token number">31,780</span>  speedup is <span class="token number">0.95</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>种方式要求远端服务器也安装了<code>rsync</code>软件。</p>
<h1 id="使用-dump-备份"><a class="markdownIt-Anchor" href="#使用-dump-备份"></a> 使用 Dump 备份</h1>
<p>Dump 是 ext 文件系统的备份工具。</p>
<h2 id="工具简介"><a class="markdownIt-Anchor" href="#工具简介"></a> 工具简介</h2>
<p>Dump 备份工具可以指定备份等级，与上一等级比较只备份差异文件。</p>
<p>备份对象为单一文件系统时，可以使用完整 dump 功能，可以使用挂载点或设备名来进行备份。</p>
<p>备份对象为目录时，仅能使用 level 0 完整备份，不能使用 -u 参数创建时间记录文件。</p>
<p>命令用法：</p>
<p><code>dump [-Suvj] [-level] [-f 备份文件] 待备份数据</code></p>
<p>可用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-S</td>
<td>仅列出后面的待备份数据需要多少容量才能备份完毕。</td>
</tr>
<tr>
<td>-u</td>
<td>将这次的 dump 时间记录到 /etc/dumpdateS 文件中。</td>
</tr>
<tr>
<td>-v</td>
<td>将备份过程显示出来。</td>
</tr>
<tr>
<td>-j</td>
<td>假如对 bzip2 的支持，将数据压缩，默认压缩等级 2。</td>
</tr>
<tr>
<td>-level</td>
<td>从 0 到 9 共 10 个等级。</td>
</tr>
<tr>
<td>-f</td>
<td>接备份生成的文件名。</td>
</tr>
<tr>
<td>-W</td>
<td>列出在 /etc/fstab 里面具有 dump 设置的分区是否有备份过。</td>
</tr>
</tbody>
</table>
<h2 id="完整备份"><a class="markdownIt-Anchor" href="#完整备份"></a> 完整备份</h2>
<p>先测试备份目标需要多少容量:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-h</span> <span class="token operator">|</span> <span class="token function">grep</span> sdb
/dev/sdb4                 91M  342K   86M   <span class="token number">1</span>% /root/sdb4m
<span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ dump <span class="token parameter variable">-S</span> /dev/sdb4
<span class="token number">39936</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>单位为 B，所以需要容量为 39KB。</p>
<p>将 <code>/dev/sdb4</code> 备份到<code>/root/backup/sdb4.dump</code>中，同时更新记录文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 backup<span class="token punctuation">]</span>$ dump <span class="token parameter variable">-0u</span> <span class="token parameter variable">-f</span> /root/backup/sdb4.dump /dev/sdb4
  DUMP: Date of this level <span class="token number">0</span> dump: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span>
  DUMP: Dumping /dev/sdb4 <span class="token punctuation">(</span>/root/sdb4m<span class="token punctuation">)</span> to /root/backup/sdb4.dump
  DUMP: DUMP IS DONE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看备份更新记录:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 backup<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/dumpdates 
/dev/sdb4 <span class="token number">0</span> Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span> <span class="token parameter variable">-0400</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="差异备份"><a class="markdownIt-Anchor" href="#差异备份"></a> 差异备份</h2>
<p>先查看上次备份的时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 backup<span class="token punctuation">]</span>$ dump <span class="token parameter variable">-W</span>
Last dump<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">done</span> <span class="token punctuation">(</span>Dump <span class="token string">'>'</span> <span class="token function">file</span> systems<span class="token punctuation">)</span>:
  /dev/sdb4     <span class="token punctuation">(</span>/root/sdb4m<span class="token punctuation">)</span> Last dump: Level <span class="token number">0</span>, Date Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到 <code>/dev/sdb4</code> 已经进行过一次 level 0 备份。使用 level 1 备份 <code>/dev/sdb4</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ dump <span class="token parameter variable">-1u</span> <span class="token parameter variable">-f</span> /root/backup/sdb4.dump1 /dev/sdb4
  DUMP: Date of this level <span class="token number">1</span> dump: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:34:25 <span class="token number">2021</span>
  DUMP: Date of last level <span class="token number">0</span> dump: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span>
  DUMP: Dumping /dev/sdb4 <span class="token punctuation">(</span>/root/sdb4m<span class="token punctuation">)</span> to /root/backup/sdb4.dump1
  DUMP: DUMP IS DONE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="备份目录"><a class="markdownIt-Anchor" href="#备份目录"></a> 备份目录</h2>
<p>对目录备份只能使用 level 0 来完成备份。</p>
<p>下面将 <code>/root/sdb4m/lost+found</code> 目录压缩备份到 <code>/root/backup/lost.dump.bz2</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ dump <span class="token parameter variable">-0j</span> <span class="token parameter variable">-f</span> /root/backup/lost.dump.bz2 /root/sdb4m/lost+found/
  DUMP: Date of this level <span class="token number">0</span> dump: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:39:46 <span class="token number">2021</span>
  DUMP: Dumping /dev/sdb4 <span class="token punctuation">(</span>/root/sdb4m <span class="token punctuation">(</span>dir /lost+found<span class="token punctuation">))</span> to /root/backup/lost.dump.bz2
  DUMP: DUMP IS DONE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="还原备份"><a class="markdownIt-Anchor" href="#还原备份"></a> 还原备份</h2>
<p>还原备份使用<code>restore</code>工具，主要参数有：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t</td>
<td>查看<code>dump</code>文件的内容。</td>
</tr>
<tr>
<td>-C</td>
<td>将<code>dump</code>文件内的数据拿来与实际的文件系统作比较，列出不相同的文件。</td>
</tr>
<tr>
<td>-i</td>
<td>进入互动模式，可以仅还原部分文件。</td>
</tr>
<tr>
<td>-r</td>
<td>将整个文件系统还原。</td>
</tr>
<tr>
<td>-h</td>
<td>查看完整备份数据中的<code>inode</code>与文件系统<code>label</code>等信息。</td>
</tr>
<tr>
<td>-f</td>
<td>选择要读取的<code>dump</code>文件。</td>
</tr>
<tr>
<td>-D</td>
<td>与<code>-C</code>搭配，查出后面接的挂载点与<code>dump</code>内有不同的文件。</td>
</tr>
</tbody>
</table>
<p>查看<code>dump</code>文件<code>sdb4.dmp</code>的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 backup<span class="token punctuation">]</span>$ restore <span class="token parameter variable">-t</span> <span class="token parameter variable">-f</span> sdb4.dump 
Dump   date: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:34:25 <span class="token number">2021</span>
Dumped from: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span>
Level <span class="token number">1</span> dump of /root/sdb4m on 101c7:/dev/sdb4
Label: P1
         <span class="token number">2</span>      <span class="token builtin class-name">.</span>
        <span class="token number">13</span>      ./test10m.img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示出文件名与原文件的<code>inode</code>号码。</p>
<p>查询<code>sdb4.dmp</code>与文件系统的差异：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 backup<span class="token punctuation">]</span>$ restore <span class="token parameter variable">-C</span> <span class="token parameter variable">-f</span> sdb4.dump <span class="token parameter variable">-D</span> /root/sdb4m/
Dump   date: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:34:25 <span class="token number">2021</span>
Dumped from: Fri Sep <span class="token number">10</span> <span class="token number">14</span>:26:24 <span class="token number">2021</span>
Level <span class="token number">1</span> dump of /root/sdb4m on 101c7:/dev/sdb4
Label: P1
filesys <span class="token operator">=</span> /root/sdb4m/
restore: unable to <span class="token function">stat</span> ./test10m.img: No such <span class="token function">file</span> or directory
Some files were modified<span class="token operator">!</span>  <span class="token number">1</span> compare errors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示有一个文件被更改。</p>
<p>进入到需要还原的文件系统的挂载点下，将<code>sdb4.dump</code>还原到当前文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ restore <span class="token parameter variable">-r</span> <span class="token parameter variable">-f</span> /root/backup/sdb4.dump 
restore: ./lost+found: File exists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此文件系统中已存在的文件不会被修改，同名文件则会被覆盖。</p>
<p>想还原部分文件可以使用交互模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ restore <span class="token parameter variable">-i</span> <span class="token parameter variable">-f</span> /root/backup/sdb4.dump 
restore <span class="token operator">></span> <span class="token function">ls</span>
.:
a.cfg       lost+found/

restore <span class="token operator">></span> <span class="token builtin class-name">help</span>
Available commands are:
        <span class="token function">ls</span> <span class="token punctuation">[</span>arg<span class="token punctuation">]</span> - list directory
        <span class="token builtin class-name">cd</span> arg - change directory
        <span class="token builtin class-name">pwd</span> - print current directory
        <span class="token function">add</span> <span class="token punctuation">[</span>arg<span class="token punctuation">]</span> - <span class="token function">add</span> <span class="token variable"><span class="token variable">`</span>arg' to list of files to be extracted
        delete <span class="token punctuation">[</span>arg<span class="token punctuation">]</span> - delete <span class="token variable">`</span></span>arg<span class="token string">' from list of files to be extracted
        extract - extract requested files
        setmodes - set modes of requested directories
        quit - immediately exit program
        what - list dump header information
        verbose - toggle verbose flag (useful with ``ls'</span>'<span class="token punctuation">)</span>
        prompt - toggle the prompt display
        <span class="token builtin class-name">help</span> or <span class="token variable"><span class="token variable">`</span>?' - print this list
If no <span class="token variable">`</span></span>arg' is supplied, the current directory is used
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了可以使用<code>ls</code>，<code>cd</code>等命令，主要操作命令为：</p>
<ul>
<li><code>add</code> 将文件加入等下要解压缩的文件列表中；</li>
<li><code>delete</code> 将文件从解压缩的列表中删除；</li>
<li><code>extract</code> 开始将刚才选择的文件列表解压。</li>
</ul>
<p>将<code>a.cfg</code>加入解压缩列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">restore <span class="token operator">></span> <span class="token function">add</span> a.cfg  
restore <span class="token operator">></span> <span class="token function">ls</span>
.:
*a.cfg        lost+found/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要被解压缩的文件前面会出现*符号。</p>
<p>开始进行解压缩：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">restore <span class="token operator">></span> extract
You have not <span class="token builtin class-name">read</span> any volumes yet.
Unless you know <span class="token function">which</span> volume your file<span class="token punctuation">(</span>s<span class="token punctuation">)</span> are on you should start
with the last volume and work towards the first.
Specify next volume <span class="token comment"># (none if no more volumes): 1</span>
<span class="token builtin class-name">set</span> owner/mode <span class="token keyword">for</span> <span class="token string">'.'</span>? <span class="token punctuation">[</span>yn<span class="token punctuation">]</span> n
restore <span class="token operator">></span> quit
<span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ ll
total <span class="token number">3</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep <span class="token number">10</span> <span class="token number">15</span>:05 a.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>交互过程中分别会询问：</p>
<ul>
<li>需要的 volume 是什么：1</li>
<li>是否需要修改权限：n</li>
</ul>
<p>完成后使用 quit 命令退出，就可以查看到需要的文件已经被解压出来了。</p>
<h1 id="使用-xfsdump-备份"><a class="markdownIt-Anchor" href="#使用-xfsdump-备份"></a> 使用 XfsDump 备份</h1>
<p>CentOS 7 中常用<code>xfsdump</code>和<code>xfsrestore</code>工具来备份<code>XFS</code>格式文件系统。</p>
<h2 id="工具简介-2"><a class="markdownIt-Anchor" href="#工具简介-2"></a> 工具简介</h2>
<p><code>xfsdump</code>和<code>dump</code>的备份原理相似，但<code>xfsdump</code>通过文件系统的 UUID 来区分各个备份文件，因此不能备份具有相同 UUID 的两个文件系统。此外，<code>xfsdump</code>不支持对特定目录进行备份。</p>
<p>命令用法：<code>xfsdump [-L 标签] [-M 说明] [-l 备份等级] [-f 输出备份文件] 待备份数据</code></p>
<h2 id="完整备份-2"><a class="markdownIt-Anchor" href="#完整备份-2"></a> 完整备份</h2>
<p>对分区<code>/xfs333</code>做完整备份并将结果保存在<code>/root/backup/sdd1.dump</code>中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsdump <span class="token parameter variable">-l</span> <span class="token number">0</span> <span class="token parameter variable">-L</span> sdd1 <span class="token parameter variable">-M</span> sdd1 <span class="token parameter variable">-f</span> /root/backup/sdd1.dump /xfs333
xfsdump: using <span class="token function">file</span> dump <span class="token punctuation">(</span>drive_simple<span class="token punctuation">)</span> strategy
xfsdump: version <span class="token number">3.1</span>.7 <span class="token punctuation">(</span>dump <span class="token function">format</span> <span class="token number">3.0</span><span class="token punctuation">)</span> - <span class="token builtin class-name">type</span> ^C <span class="token keyword">for</span> status and control
xfsdump: level <span class="token number">0</span> dump of 101c7:/xfs333
xfsdump: dump date: Thu Sep <span class="token number">16</span> <span class="token number">14</span>:59:39 <span class="token number">2021</span>
xfsdump: session id: 4545d809-55e2-4de6-ba33-381ed071399c
xfsdump: session label: <span class="token string">"sdd1_all"</span>
xfsdump:   stream <span class="token number">0</span> /root/backup/sdd1.dump OK <span class="token punctuation">(</span>success<span class="token punctuation">)</span>
xfsdump: Dump Status: SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>备份记录保存在<code>/var/lib/xfsdump/inventory</code>中。</p>
<h2 id="增量备份"><a class="markdownIt-Anchor" href="#增量备份"></a> 增量备份</h2>
<p>先查询是否存在备份记录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsdump <span class="token parameter variable">-I</span>
<span class="token function">file</span> system <span class="token number">0</span>:
        fs id:          c96b6650-756a-4496-bf26-6e7286c55891
        session <span class="token number">0</span>:
                <span class="token function">mount</span> point:    101c7:/xfs333
                device:         101c7:/dev/sdd1
                time:           Thu Sep <span class="token number">16</span> <span class="token number">14</span>:59:39 <span class="token number">2021</span>
                session label:  <span class="token string">"sdd1_all"</span>
                session id:     4545d809-55e2-4de6-ba33-381ed071399c
                level:          <span class="token number">0</span>
                resumed:        NO
                subtree:        NO
                streams:        <span class="token number">1</span>
                stream <span class="token number">0</span>:
                        pathname:       /root/backup/sdd1.dump
                        start:          ino <span class="token number">67</span> offset <span class="token number">0</span>
                        end:            ino <span class="token number">70</span> offset <span class="token number">0</span>
                        interrupted:    NO
                        media files:    <span class="token number">1</span>
                        media <span class="token function">file</span> <span class="token number">0</span>:
                                mfile index:    <span class="token number">0</span>
                                mfile type:     data
                                mfile size:     <span class="token number">10512128</span>
                                mfile start:    ino <span class="token number">67</span> offset <span class="token number">0</span>
                                mfile end:      ino <span class="token number">70</span> offset <span class="token number">0</span>
                                media label:    <span class="token string">"sdd1_all"</span>
                                media id:       e2964845-d8da-4b5f-8226-9390468d538f
xfsdump: Dump Status: SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到存在一个 session 0 的 level 0 备份。接着进行 level 1 的增量备份，备份参数和制作 level 0 时一样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsdump <span class="token parameter variable">-l</span> <span class="token number">1</span> <span class="token parameter variable">-L</span> sdd1_1 <span class="token parameter variable">-M</span> sdd1_1 <span class="token parameter variable">-f</span> /root/backup/sdd1.dump1 /xfs333
xfsdump: using <span class="token function">file</span> dump <span class="token punctuation">(</span>drive_simple<span class="token punctuation">)</span> strategy
xfsdump: version <span class="token number">3.1</span>.7 <span class="token punctuation">(</span>dump <span class="token function">format</span> <span class="token number">3.0</span><span class="token punctuation">)</span> - <span class="token builtin class-name">type</span> ^C <span class="token keyword">for</span> status and control
xfsdump: level <span class="token number">1</span> incremental dump of 101c7:/xfs333 based on level <span class="token number">0</span> dump begun Thu Sep <span class="token number">16</span> <span class="token number">14</span>:59:39 <span class="token number">2021</span>
xfsdump:   stream <span class="token number">0</span> /root/backup/sdd1.dump1 OK <span class="token punctuation">(</span>success<span class="token punctuation">)</span>
xfsdump: Dump Status: SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完成后可以用 <code>xfsdump -I</code> 查询备份记录，多了一个 session 1 的记录。</p>
<h2 id="还原备份-2"><a class="markdownIt-Anchor" href="#还原备份-2"></a> 还原备份</h2>
<p>备份还原使用的是 <code>xfsrestore</code> 命令，基本使用方法如下：</p>
<p><code>xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录</code></p>
<p>常用选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-I</td>
<td>查询备份数据，包括 Label 名称与备份时间等。</td>
</tr>
<tr>
<td>-f</td>
<td>后面指定备份文件目录。</td>
</tr>
<tr>
<td>-L</td>
<td>指定备份等级。</td>
</tr>
<tr>
<td>-s</td>
<td>仅恢复特定目录或文件。</td>
</tr>
<tr>
<td>-i</td>
<td>进入交互模式。</td>
</tr>
</tbody>
</table>
<p>恢复完整备份，需要先查询到 session label 值，用来代表要恢复的备份等级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsrestore <span class="token parameter variable">-f</span> /root/backup/sdd1.dump <span class="token parameter variable">-L</span> sdd1_all /xfs333
xfsrestore: using <span class="token function">file</span> dump <span class="token punctuation">(</span>drive_simple<span class="token punctuation">)</span> strategy
xfsrestore:   stream <span class="token number">0</span> /root/backup/sdd1.dump OK <span class="token punctuation">(</span>success<span class="token punctuation">)</span>
xfsrestore: Restore Status: SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>指定将备份数据恢复到 <code>/tmp/xfs/</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsrestore <span class="token parameter variable">-f</span> /root/backup/sdd1.dump <span class="token parameter variable">-L</span> sdd1_all /tmp/xfs/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指定仅还原备份文件中的 <code>255</code> 目录到 <code>/tmp/xfs</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsrestore <span class="token parameter variable">-f</span> /root/backup/sdd1.dump <span class="token parameter variable">-L</span> sdd1_all <span class="token parameter variable">-s</span> <span class="token number">255</span> /tmp/xfs/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>恢复 level 1 备份到 <code>/tmp/xfs</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsrestore <span class="token parameter variable">-f</span> /root/backup/sdd1.dump1 /tmp/xfs/
xfsrestore:   stream <span class="token number">0</span> /root/backup/sdd1.dump1 OK <span class="token punctuation">(</span>success<span class="token punctuation">)</span>
xfsrestore: Restore Status: SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用交互模式来恢复文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfsrestore <span class="token parameter variable">-f</span> /root/backup/sdd1.dump <span class="token parameter variable">-i</span> /tmp/xfs/

 <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> subtree selection dialog <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>

the following commands are available:
        <span class="token builtin class-name">pwd</span> 
        <span class="token function">ls</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token punctuation">]</span>
        <span class="token builtin class-name">cd</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token punctuation">]</span>
        <span class="token function">add</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token punctuation">]</span>
        delete <span class="token punctuation">[</span> <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token punctuation">]</span>
        extract 
        quit 
        <span class="token builtin class-name">help</span> 

 -<span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用方式与 <code>restoredump</code> 一样，选择好文件后（比如 <code>10M</code>）使用 <code>extract</code> 命令解压：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> -<span class="token operator">></span> <span class="token function">add</span> 10M

 -<span class="token operator">></span> <span class="token function">ls</span>
              <span class="token number">68</span> <span class="token number">255</span>/
    *         <span class="token number">67</span> 10M 

 -<span class="token operator">></span> extract

 --------------------------------- end dialog ---------------------------------

xfsrestore: restoring non-directory files
xfsrestore: restore complete: <span class="token number">154</span> seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream <span class="token number">0</span> /root/backup/sdd1.dump OK <span class="token punctuation">(</span>success<span class="token punctuation">)</span>
xfsrestore: Restore Status: SUCCESS
<span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ ll /tmp/xfs/
total <span class="token number">10240</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">10485760</span> Sep <span class="token number">16</span> <span class="token number">14</span>:55 10M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="其他备份方式"><a class="markdownIt-Anchor" href="#其他备份方式"></a> 其他备份方式</h1>
<p>遇到一些特殊的需求时，可能需要使用 <code>dd</code> 和 <code>cpio</code> 命令来进行备份。</p>
<h2 id="使用-dd-备份"><a class="markdownIt-Anchor" href="#使用-dd-备份"></a> 使用 dd 备份</h2>
<p><code>dd</code> 可以通过直接读取扇区的方式，将整个设备备份成一个文件，使用方法如下：</p>
<p><code>dd if=&quot;输入文件&quot; of=&quot;输出文件&quot; bs=&quot;block大小&quot; count=&quot;block数量&quot;</code></p>
<p>例如备份磁盘第一个扇区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sdb <span class="token assign-left variable">of</span><span class="token operator">=</span>/tmp/bmr.back <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token number">1</span>+0 records <span class="token keyword">in</span>
<span class="token number">1</span>+0 records out
<span class="token number">512</span> bytes <span class="token punctuation">(</span><span class="token number">512</span> B<span class="token punctuation">)</span> copied, <span class="token number">0.000158292</span> s, <span class="token number">3.2</span> MB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>备份 <code>sdb5</code> 整个分区，类似于 Ghost 软件做的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sdb5 <span class="token assign-left variable">of</span><span class="token operator">=</span>/root/sdb5.disk
<span class="token number">163840</span>+0 records <span class="token keyword">in</span>
<span class="token number">163840</span>+0 records out
<span class="token number">83886080</span> bytes <span class="token punctuation">(</span><span class="token number">84</span> MB<span class="token punctuation">)</span> copied, <span class="token number">0.476346</span> s, <span class="token number">176</span> MB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>还原备份到 <code>sdb5</code> 只需要将 <code>if</code> 和 <code>of</code> 交换一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/root/sdb5.disk <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/sdb5
<span class="token number">163840</span>+0 records <span class="token keyword">in</span>
<span class="token number">163840</span>+0 records out
<span class="token number">83886080</span> bytes <span class="token punctuation">(</span><span class="token number">84</span> MB<span class="token punctuation">)</span> copied, <span class="token number">0.246963</span> s, <span class="token number">340</span> MB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用-cpio-备份"><a class="markdownIt-Anchor" href="#使用-cpio-备份"></a> 使用 cpio 备份</h2>
<p><code>cpio</code>（copy in/out）命令从其他命令获取输入，因此需要配合类似 <code>find</code> 等命令来获取需要备份的文件名。<code>cpio</code> 可以将数据备份到磁带机上。常见用法：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>备份</td>
<td><code>cpio -ovcB &gt; 文件或设备</code></td>
</tr>
<tr>
<td>还原</td>
<td><code>cpio -ivcdu &lt; 文件或设备</code></td>
</tr>
<tr>
<td>查看</td>
<td><code>cpio -ivct &lt; 文件或设备</code></td>
</tr>
</tbody>
</table>
<p>例如将 <code>/boot</code> 目录备份到 <code>boot.cpio</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /boot <span class="token operator">|</span> cpio <span class="token parameter variable">-ocvB</span> <span class="token operator">></span> boot.cpio
/boot/initramfs-3.10.0-862.el7.x86_64kdump.img
/boot/initramfs-3.10.0-1160.41.1.el7.x86_64kdump.img
<span class="token number">31339</span> blocks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>boot.cpio</code> 解压：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ cpio <span class="token parameter variable">-idvc</span> <span class="token operator">&lt;</span> boot.cpio<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="镜像制作"><a class="markdownIt-Anchor" href="#镜像制作"></a> 镜像制作</h1>
<p>在 Linux 下制作镜像可以使用 <code>mkisofs</code> 命令，可用参数如下:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o</td>
<td>生成的镜像文件名字。</td>
</tr>
<tr>
<td>-r</td>
<td>附带记录文件属性。</td>
</tr>
<tr>
<td>-v</td>
<td>显示过程。</td>
</tr>
<tr>
<td>-m</td>
<td>要排除的文件。</td>
</tr>
<tr>
<td>-V</td>
<td>新建 Volume。</td>
</tr>
<tr>
<td>-graft-point</td>
<td>保留文件结构，否则文件将会全部存在顶层目录下。</td>
</tr>
</tbody>
</table>
<p>例如将 <code>/root</code> 和 <code>/etc</code> 目录制作成 <code>system.img</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">mkisofs</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-V</span> <span class="token string">'home'</span> <span class="token parameter variable">-o</span> /tmp/system.img -graft-point /root<span class="token operator">=</span>/root /home<span class="token operator">=</span>/home
I: -input-charset not specified, using utf-8 <span class="token punctuation">(</span>detected <span class="token keyword">in</span> locale settings<span class="token punctuation">)</span>
<span class="token number">47.36</span>% done, estimate finish Fri Sep <span class="token number">10</span> <span class="token number">21</span>:42:20 <span class="token number">2021</span>
<span class="token number">94.80</span>% done, estimate finish Fri Sep <span class="token number">10</span> <span class="token number">21</span>:42:20 <span class="token number">2021</span>
Total translation table size: <span class="token number">0</span>
Total rockridge attributes bytes: <span class="token number">4458</span>
Total directory bytes: <span class="token number">26624</span>
Path table size<span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>: <span class="token number">160</span>
Max brk space used <span class="token number">24000</span>
<span class="token number">10557</span> extents written <span class="token punctuation">(</span><span class="token number">20</span> MB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>-graft-point</code> 后面接要备份的数据，等号左边代表镜像文件内的目录，右侧是实际路径。</p>
<h1 id="光盘刻录"><a class="markdownIt-Anchor" href="#光盘刻录"></a> 光盘刻录</h1>
<p>在 Linux 下，使用<code>cdrecord</code>命令进行 CD/DVD 刻录。</p>
<p>首先扫描系统中的光驱设备：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ cdrecord <span class="token parameter variable">--devices</span>
wodim: Overview of accessible drives <span class="token punctuation">(</span><span class="token number">1</span> found<span class="token punctuation">)</span> <span class="token builtin class-name">:</span>
-------------------------------------------------------------------------
<span class="token number">0</span>  <span class="token assign-left variable">dev</span><span class="token operator">=</span><span class="token string">'/dev/sg2'</span>      rwrw-- <span class="token builtin class-name">:</span> <span class="token string">'NECVMWar'</span> <span class="token string">'VMware IDE CDR10'</span>
-------------------------------------------------------------------------
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将<code>system.img</code>刻录成数据 CD：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ cdrecord <span class="token parameter variable">-v</span> <span class="token assign-left variable">dev</span><span class="token operator">=</span><span class="token string">'/dev/sg2'</span> <span class="token assign-left variable">fs</span><span class="token operator">=</span>8m <span class="token parameter variable">-dummy</span> <span class="token parameter variable">-data</span> /tmp/system.img 
wodim: No <span class="token function">write</span> mode specified.
wodim: Assuming <span class="token parameter variable">-tao</span> mode.
wodim: Future versions of wodim may have different drive dependent defaults.
TOC Type: <span class="token number">1</span> <span class="token operator">=</span> CD-ROM
scsidev: <span class="token string">'/dev/sg2'</span>
devname: <span class="token string">'/dev/sg2'</span>
scsibus: <span class="token parameter variable">-2</span> target: <span class="token parameter variable">-2</span> lun: <span class="token parameter variable">-2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>wodim</code>命令刻录<code>system.img</code>文件如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ wodim <span class="token parameter variable">-v</span> <span class="token assign-left variable">dev</span><span class="token operator">=</span>/dev/sr0 <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">8</span> <span class="token parameter variable">-dummy</span> <span class="token parameter variable">-eject</span> /tmp/system.img
wodim: No <span class="token function">write</span> mode specified.
wodim: Assuming <span class="token parameter variable">-tao</span> mode.
wodim: Future versions of wodim may have different drive dependent defaults.
TOC Type: <span class="token number">1</span> <span class="token operator">=</span> CD-ROM
scsidev: <span class="token string">'/dev/sr0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 用户管理</title>
    <url>/3199649610/</url>
    <content><![CDATA[<h1 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h1>
<p>针对用户的新增,删除,修改操作.</p>
<h2 id="新增用户"><a class="markdownIt-Anchor" href="#新增用户"></a> 新增用户</h2>
<p>可以使用 <code>useradd</code> 命令来新建用户。命令用法如下：</p>
<p><code>useradd [-u UID] [-g 初始组] [-G 次要组] [-nM] [-c 说明] [-d 主目录绝对路径] [-a shell] 用户名</code></p>
<p>主要参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u</td>
<td>接 UID 数字，直接指定一个特定的 UID 号码</td>
</tr>
<tr>
<td>-g</td>
<td>接组名或 GID，设置初始用户组</td>
</tr>
<tr>
<td>-G</td>
<td>接组名或 GID，设置用户的附加组</td>
</tr>
<tr>
<td>-M</td>
<td>不创建用户主文件夹（系统账号默认值）</td>
</tr>
<tr>
<td>-m</td>
<td>创建用户主文件夹（一般账号默认值）</td>
</tr>
<tr>
<td>-c</td>
<td>用户说明文字内容</td>
</tr>
<tr>
<td>-d</td>
<td>指定用户主目录位置，必须使用绝对路径</td>
</tr>
<tr>
<td>-r</td>
<td>创建一个系统账号，UID 会有限制</td>
</tr>
<tr>
<td>-s</td>
<td>接指定的 shell，默认为 /bin/bash</td>
</tr>
<tr>
<td>-e</td>
<td>接日期格式 “YYYY-MM-DD”，设置账号失效日</td>
</tr>
<tr>
<td>-f</td>
<td>指定密码是否失效，0 为立刻失效，-1 为永不失效</td>
</tr>
<tr>
<td>-N</td>
<td>不创建同名的组</td>
</tr>
<tr>
<td>-p</td>
<td>设置密码</td>
</tr>
</tbody>
</table>
<p>例如，新建立用户 user1，密码为 user1：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-p</span> user1 user1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置一个 2040 年 1 月 13 日过期的临时用户 user2：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-p</span> <span class="token function">passwd</span> <span class="token parameter variable">-e</span> <span class="token number">2040</span>-01-13 user2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="修改密码"><a class="markdownIt-Anchor" href="#修改密码"></a> 修改密码</h2>
<p>可以使用 <code>passwd</code> 命令来进行密码设置功能。主要参数如下：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>锁定密码，设置密码失效</td>
</tr>
<tr>
<td>-i</td>
<td>接日期，设置密码失效日期</td>
</tr>
<tr>
<td>-u</td>
<td>解锁密码</td>
</tr>
<tr>
<td>-n</td>
<td>设置修改密码限制周期</td>
</tr>
<tr>
<td>-x</td>
<td>设置密码使用最长天数</td>
</tr>
<tr>
<td>-w</td>
<td>密码过期前的警告天数</td>
</tr>
</tbody>
</table>
<p><code>passwd</code> 后不接账户名为设置当前账户密码。root 给别账号设置密码可以无视密码规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">passwd</span> user1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>passwd</code> 支持 <code>--stdin</code> 参数，使得可以在脚本中批量建立账户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"abc"</span> <span class="token operator">|</span> <span class="token function">passwd</span> <span class="token parameter variable">--stdin</span> user1
Changing password <span class="token keyword">for</span> user user1.
passwd: all authentication tokens updated successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以用 <code>chage</code> 查看密码策略。例如查看 user1 的参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ chage <span class="token parameter variable">-l</span> user1
Last password change                                    <span class="token builtin class-name">:</span> Sep <span class="token number">13</span>, <span class="token number">2021</span>
Password expires                                        <span class="token builtin class-name">:</span> never
Password inactive                                       <span class="token builtin class-name">:</span> never
Account expires                                         <span class="token builtin class-name">:</span> never
Minimum number of days between password change          <span class="token builtin class-name">:</span> <span class="token number">0</span>
Maximum number of days between password change          <span class="token builtin class-name">:</span> <span class="token number">99999</span>
Number of days of warning before password expires       <span class="token builtin class-name">:</span> <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外 <code>chage</code> 还可以修改密码策略，例如修改密码最后修改时间为 0，用户下次登录时会被要求强制修改密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ chage <span class="token parameter variable">-d</span> <span class="token number">0</span> user1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="修改用户参数"><a class="markdownIt-Anchor" href="#修改用户参数"></a> 修改用户参数</h2>
<p>可以使用 <code>usermod</code> 命令来修改已存在的用户设置，命令使用参数可参考 <code>useradd</code> 命令。</p>
<p>例如，修改用户 <code>user7</code> 的用户名为 <code>user07</code>，并修改用户主目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">usermod</span> <span class="token parameter variable">-d</span> /home/user07 <span class="token parameter variable">-m</span> <span class="token parameter variable">-l</span> user07 user7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>再例如，将用户 <code>user1</code> 的 shell 设置为 <code>id</code>，这样用户只能运行 <code>id</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">usermod</span> <span class="token parameter variable">-s</span> /usr/bin/id user1
<span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">su</span> user1
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">context</span><span class="token operator">=</span>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>切换到 <code>user1</code> 时直接运行了 <code>id</code> 命令。修改 shell 还可以使用 <code>chsh</code> 命令来操作。</p>
<p>将 shell 指定为 <code>/sbin/nologin</code> 表示不能登录，并将尝试登录记录到 syslog 后台程序。可以修改 <code>/etc/nologin.txt</code> 文件来为 <code>nologin</code> 用户展示信息。</p>
<h2 id="删除用户"><a class="markdownIt-Anchor" href="#删除用户"></a> 删除用户</h2>
<p>可以使用<code>userdel</code>命令来删除用户和用户相关数据，指定<code>-r</code>参数可以连同用户主目录和邮件一起删除:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">userdel</span> <span class="token parameter variable">-r</span> user1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一般更建议先将用户停用，使用<code>usermod -e 1</code>让用户立即过期。</p>
<h1 id="用户组管理"><a class="markdownIt-Anchor" href="#用户组管理"></a> 用户组管理</h1>
<p>针对用户组的新增，修改，删除。</p>
<h2 id="新增用户组"><a class="markdownIt-Anchor" href="#新增用户组"></a> 新增用户组</h2>
<p>使用 <code>groupadd</code> 命令新建用户组，例如新建组 group1：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">groupadd</span> group1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="修改用户组"><a class="markdownIt-Anchor" href="#修改用户组"></a> 修改用户组</h2>
<p>可以通过 <code>groupmod</code> 命令来修改已存在的组名或 GID。比如将组 group1 改名为 newgroup：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">groupmod</span> <span class="token parameter variable">-n</span> newgroup group1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将组 user7 的 GID 改为 10007：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">groupmod</span> <span class="token parameter variable">-g</span> <span class="token number">10007</span> user7
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> /etc/group <span class="token operator">|</span> <span class="token function">grep</span> user7
user7:x:10007:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="删除用户组"><a class="markdownIt-Anchor" href="#删除用户组"></a> 删除用户组</h2>
<p>使用 <code>groupdel</code> 可以删除无人使用的用户组（目标不能是初始用户组）。例如删除组 group2：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">groupdel</span> group2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="用户组管理员"><a class="markdownIt-Anchor" href="#用户组管理员"></a> 用户组管理员</h2>
<p>用户组管理员是设置一个组内的成员为管理用，专门管理哪些账号可以加入/移出该组。</p>
<p>管理用户组成员使用 <code>gpasswd</code> 命令。例如将 user2 设置为组 group2 的管理员：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gpasswd <span class="token parameter variable">-A</span> user2 group2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置组密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gpasswd user2
Changing the password <span class="token keyword">for</span> group user2
New Password: 
Re-enter new password: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>管理员可以使用 <code>-a</code> 参数将其他用户加入到管理的小组。比如将 user3 加入到 group2：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gpasswd <span class="token parameter variable">-a</span> user3 group2
Adding user user3 to group group2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="查询信息"><a class="markdownIt-Anchor" href="#查询信息"></a> 查询信息</h1>
<p>可以使用多种命令来查询用户和组的详细信息。</p>
<h2 id="查询用户信息"><a class="markdownIt-Anchor" href="#查询用户信息"></a> 查询用户信息</h2>
<p>通过<code>id</code>命令可以查询到用户的 UID 和 GID 信息，例如查询用户<code>user2</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">id</span> user2
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用<code>whoami</code>命令显示当前登录的用户名，等同于<code>id -un</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">whoami</span>
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查询用户属组信息可以使用<code>groups</code>命令，例如查询<code>user1</code>的所属组:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">groups</span> user1
user1 <span class="token builtin class-name">:</span> user1 root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>finger</code>命令是一般用户可以使用的用户信息数据查询工具，例如查询<code>root</code>用户的信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ finger root
Login: root                             Name: root
Directory: /root                        Shell: /bin/bash
On since Sat Sep <span class="token number">11</span> 09:35 <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span> on tty1    <span class="token number">1</span> day <span class="token number">20</span> hours idle
On since Sat Sep <span class="token number">11</span> 07:08 <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span> on pts/0 from <span class="token number">192.168</span>.2.101
   <span class="token number">3</span> seconds idle
Last login Mon Sep <span class="token number">13</span> 05:48 <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span> on pts/1
No mail.
No Plan.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不加参数，<code>finger</code>查询出来的是目前在系统上登录的用户与登录时间。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ finger
Login     Name       Tty      Idle  Login Time   Office     Office Phone   Host
root      root       tty1       1d  Sep <span class="token number">11</span> 09:35           
root      root       pts/0          Sep <span class="token number">11</span> 07:08                           <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修改用户附加信息"><a class="markdownIt-Anchor" href="#修改用户附加信息"></a> 修改用户附加信息</h2>
<p>若要修改 <code>finger</code> 命令输出结果中的 Office、Phone 等信息，可以使用 <code>chfn</code> 命令。</p>
<p>输入 <code>chfn</code> 命令后，会进入交互式输入页面：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ chfn
Changing finger information <span class="token keyword">for</span> root.
Name <span class="token punctuation">[</span>root<span class="token punctuation">]</span>: assassing
Office <span class="token punctuation">[</span><span class="token punctuation">]</span>: STU
Office Phone <span class="token punctuation">[</span><span class="token punctuation">]</span>: 010-8515834
Home Phone <span class="token punctuation">[</span><span class="token punctuation">]</span>: none

Finger information changed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改的内容实际存放在 <code>/etc/passwd</code> 文件中第五个字段中。</p>
<h2 id="查询用户登录信息"><a class="markdownIt-Anchor" href="#查询用户登录信息"></a> 查询用户登录信息</h2>
<p>使用<code>who</code>命令可以简单查看当前在线的用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">who</span>
root     tty1         <span class="token number">2021</span>-09-11 09:35
root     pts/0        <span class="token number">2021</span>-09-13 08:19 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span>
root     pts/1        <span class="token number">2021</span>-09-13 <span class="token number">11</span>:38 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>w</code>命令可以看到更详细的在线用户信息，包括系统资源使用和最后执行的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ w
<span class="token number">11</span>:38:55 up <span class="token number">3</span> days, <span class="token number">20</span>:30,  <span class="token number">3</span> users,  load average: <span class="token number">0.01</span>, <span class="token number">0.02</span>, <span class="token number">0.05</span>
<span class="token environment constant">USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1                      Sat09    2days  <span class="token number">0</span>.01s  <span class="token number">0</span>.01s <span class="token parameter variable">-bash</span>
root     pts/0    <span class="token number">192.168</span>.2.101    08:19    <span class="token number">7</span>.00s  <span class="token number">0</span>.11s  <span class="token number">0</span>.00s w
root     pts/1    <span class="token number">192.168</span>.2.101    <span class="token number">11</span>:38   <span class="token number">45</span>.00s  <span class="token number">0</span>.01s  <span class="token number">0</span>.00s <span class="token parameter variable">-bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要查询用户的登录动作记录，可以使用<code>last</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ last
root     pts/1        <span class="token number">192.168</span>.2.101    Mon Sep <span class="token number">13</span> <span class="token number">11</span>:38   still logged <span class="token keyword">in</span>   
root     pts/0        <span class="token number">192.168</span>.2.101    Mon Sep <span class="token number">13</span> 08:19   still logged <span class="token keyword">in</span>   
root     tty1                          Sat Sep <span class="token number">11</span> 09:35   still logged <span class="token keyword">in</span>   
root     pts/1        <span class="token number">192.168</span>.2.101    Sat Sep <span class="token number">11</span> 08:58 - 06:09 <span class="token punctuation">(</span><span class="token number">1</span>+21:10<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>想知道每个账号最后登录时间可以使用<code>lastlog</code>命令，它会去读取<code>/var/log/lastlog</code>文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lastlog
Username         Port     From             Latest
root             pts/1    <span class="token number">192.168</span>.2.101    Mon Sep <span class="token number">13</span> <span class="token number">11</span>:38:10 <span class="token parameter variable">-0400</span> <span class="token number">2021</span>
bin                                        **Never logged in**
daemon                                     **Never logged in**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="配置检查工具"><a class="markdownIt-Anchor" href="#配置检查工具"></a> 配置检查工具</h2>
<p>使用<code>pwck</code>命令可以检查 <code>/etc/passwd</code> 文件是否正确：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pwck
user <span class="token string">'ftp'</span><span class="token builtin class-name">:</span> directory <span class="token string">'/var/ftp'</span> does not exist
pwck: no changes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>pwconv</code> 命令将 <code>/etc/passwd</code> 内的账号与密码移动到 <code>/etc/shadow</code> 中，用来迁移早期 Linux 的用户数据。</p>
<p><code>pwunconv</code> 是 <code>pwconv</code> 的反向操作。</p>
<p><code>chpasswd</code> 用来读入未加密前的密码，并将加密后的密码写入到 <code>/etc/shadow</code> 中。例如修改 <code>user1</code> 的密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"user1:newpassword"</span> <span class="token operator">|</span> chpasswd <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="用户交流"><a class="markdownIt-Anchor" href="#用户交流"></a> 用户交流</h1>
<p>Linux 内置的几个命令可以直接和系统内其他用户交流。</p>
<h2 id="在线交流"><a class="markdownIt-Anchor" href="#在线交流"></a> 在线交流</h2>
<p>例如使用<code>write</code>可以直接将信息传给其他在线用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">write</span> root
write: root is logged <span class="token keyword">in</span> <span class="token function">more</span> than once<span class="token punctuation">;</span> writing to pts/1
my message1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输入完毕用<code>Ctrl+d</code>结束并发送，对面会立即收到信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ 
Message from root@101c7 on pts/0 at <span class="token number">11</span>:45 <span class="token punctuation">..</span>.
my message1
EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>想要关闭消息接受可以使用<code>mesg n</code>命令（重新打开用<code>mesg y</code>）。</p>
<h2 id="群发消息"><a class="markdownIt-Anchor" href="#群发消息"></a> 群发消息</h2>
<p>使用<code>wall</code>命令能发送广播，让所有在线的用户都收到消息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ wall <span class="token string">"911"</span>
<span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ 
Broadcast message from user1@101c7 <span class="token punctuation">(</span>pts/1<span class="token punctuation">)</span> <span class="token punctuation">(</span>Mon Sep <span class="token number">13</span> <span class="token number">11</span>:52:06 <span class="token number">2021</span><span class="token punctuation">)</span>:

<span class="token number">911</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="用户切换"><a class="markdownIt-Anchor" href="#用户切换"></a> 用户切换</h1>
<p>在用户间切换使用<code>su</code>命令（switch user）。一般用户切换到 root 需要 root 的密码。命令格式为：</p>
<p><code>su [-lm] [-c 命令] [用户名]</code></p>
<p>可用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>代表使用 login-shell 的变量文件读取方式来登录</td>
</tr>
<tr>
<td>-l</td>
<td>也是 login-shell 的方式，后面需要加账号</td>
</tr>
<tr>
<td>-m</td>
<td>使用目前的环境设置，而不读取新用户的配置文件</td>
</tr>
<tr>
<td>-c</td>
<td>仅运行一次命令，后面加要执行的命令</td>
</tr>
</tbody>
</table>
<h2 id="non-login-shell"><a class="markdownIt-Anchor" href="#non-login-shell"></a> non-login shell</h2>
<p>使用<code>su</code>命令仅切换用户身份时，将以非登录 Shell 方式登录，此方式不会读取用户配置文件。例如，切换到<code>user1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 dir2<span class="token punctuation">]</span>$ <span class="token function">su</span> user1
<span class="token punctuation">[</span>user1@101c7 dir2<span class="token punctuation">]</span>$ <span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'root'</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
<span class="token assign-left variable">MAIL</span><span class="token operator">=</span>/var/spool/mail/root
<span class="token assign-left variable"><span class="token environment constant">PWD</span></span><span class="token operator">=</span>/root/sdb4m/dir1/dir2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，<code>PATH</code>和<code>MAIL</code>等变量并没有切换到<code>user1</code>。</p>
<h2 id="login-shell"><a class="markdownIt-Anchor" href="#login-shell"></a> login shell</h2>
<p>要使用登录 Shell 的方式登录需要记得使用 <code>-</code>（切换到 root）或 <code>-l</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 dir2<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-l</span> user1
Last login: Mon Sep <span class="token number">13</span> 08:11:48 EDT <span class="token number">2021</span> on pts/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用 <code>-c</code> 参数能很方便地使用其他账户身份运行命令而并不需要登录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 dir2<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-l</span> user1 <span class="token parameter variable">-c</span> <span class="token string">'whoami'</span>
user1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="用-sudo-执行命令"><a class="markdownIt-Anchor" href="#用-sudo-执行命令"></a> 用 sudo 执行命令</h2>
<p>通过 <code>sudo</code> 命令，能让在 <code>/etc/sudoers</code> 文件中列出的用户使用其他用户的身份（包括 nologin 的系统用户）来执行命令。使用方法如下：</p>
<p><code>sudo [-b] [-u 其他用户名]</code></p>
<p>例如，以 <code>user2</code> 的身份在 <code>/tmp</code> 目录下新建名为 <code>us2</code> 的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token parameter variable">-u</span> user2 <span class="token function">touch</span> /tmp/us2 <span class="token punctuation">;</span> ll <span class="token parameter variable">-l</span> /tmp/us2
-rw-r--r--. <span class="token number">1</span> user2 user2 <span class="token number">0</span> Sep <span class="token number">13</span> 08:24 /tmp/us2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果要运行一连串命令，使用 <code>sh -c</code> 将命令用双引号括起来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token parameter variable">-u</span> user2 <span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">"touch /tmp/us1; mv /tmp/us1 /tmp/us3"</span><span class="token punctuation">;</span>ll /tmp/us3
-rw-r--r--. <span class="token number">1</span> user2 user2 <span class="token number">0</span> Sep <span class="token number">13</span> 08:29 /tmp/us3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="设置-sudoers"><a class="markdownIt-Anchor" href="#设置-sudoers"></a> 设置 sudoers</h2>
<p>使用 <code>visudo</code> 命令设置 sudo 配置文件 <code>/etc/sudoers</code>。例如，将 <code>user1</code> 加入到 <code>sudoers</code> 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ visudo
<span class="token comment">## Allow root to run any commands anywhere</span>
root     <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
user1    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二段 <code>(ALL)=(ALL)</code> 表示登录者的来源主机名=(可切换的身份)，第三段表示可执行的命令。必须使用绝对路径指定。</p>
<p>切换到 <code>user1</code> 使用 <code>sudo</code> 运行命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">sudo</span> ll /root

We trust you have received the usual lecture from the <span class="token builtin class-name">local</span> System
Administrator. It usually boils down to these three things:

    <span class="token comment">#1) Respect the privacy of others.</span>
    <span class="token comment">#2) Think before you type.</span>
    <span class="token comment">#3) With great power comes great responsibility.</span>
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> user1: 
sudo: ll: <span class="token builtin class-name">command</span> not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入 <code>user1</code> 的密码后可以自由使用 <code>sudo</code>。如果两次 <code>sudo</code> 操作的间隔超过 5 分钟，需要重新输入一次密码。</p>
<p>设置用户组 <code>%group2</code> 可以不需要密码使用 <code>sudo</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ visudo
root       <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
%group2    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       NOPASSWD:ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以通过 <code>User_Alias</code> 和 <code>Cmnd_alias</code> 配置来设置别名，配置使用的别名一定要使用大写。</p>
<p>例如，将 <code>ADMUSER</code> 指向用户 <code>user1</code> 和 <code>user2</code>，<code>ADMPW</code> 指向 <code>/usr/bin/passwd</code>，并排除掉直接运行 <code>passwd</code> 和 <code>passwd root</code> 命令（都为给 <code>root</code> 修改密码）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ visudo
User_Alias ADMUSER <span class="token operator">=</span> user1, user2
Cmnd_Alias ADMPW <span class="token operator">=</span> /usr/bin/passwd <span class="token punctuation">[</span>A-za-z<span class="token punctuation">]</span>*, <span class="token operator">!</span>/usr/bin/passd, <span class="token operator">!</span>/usr/bin/passwd root
ADMUSER   <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>       NOPASSWD:ADMPW<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>sudo -l</code> 可以查询当前 <code>sudo</code> 权限设置情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token parameter variable">-l</span>
Matching Defaults entries <span class="token keyword">for</span> root on server1:
    <span class="token operator">!</span>visiblepw, always_set_home, match_group_by_gid, always_query_group_plugin, env_reset, <span class="token assign-left variable">env_keep</span><span class="token operator">=</span><span class="token string">"COLORS DISPLAY HOSTNAME
    HISTSIZE KDEDIR LS_COLORS"</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">"MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE"</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">"LC_COLLATE
    LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES"</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">"LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE"</span>,
    <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">"LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY"</span>, <span class="token assign-left variable">secure_path</span><span class="token operator">=</span>/sbin<span class="token punctuation">\</span>:/bin<span class="token punctuation">\</span>:/usr/sbin<span class="token punctuation">\</span>:/usr/bin

User root may run the following commands on server1:
    <span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 软件安装与管理</title>
    <url>/1357678012/</url>
    <content><![CDATA[<h1 id="编译安装"><a class="markdownIt-Anchor" href="#编译安装"></a> 编译安装</h1>
<p>编译程序是将源代码编译成机器语言生成可执行二进制程序的过程。</p>
<p>在 Linux 中，可以使用 <code>configure</code> 命令对系统环境进行检测和收集，生成 <code>Makefile</code> 文件，<code>make</code> 命令根据 <code>Makefile</code> 文件的配置来对源文件进行编译，生成可执行二进制程序。</p>
<p>简单来说，通过源代码安装程序的步骤如下：</p>
<ol>
<li>从网上下载包含源代码的压缩包；</li>
<li>解压压缩包；</li>
<li>使用 <code>gcc</code> 进行源代码编译，生成目标文件（object files）；</li>
<li>使用 <code>gcc</code> 进行函数库、主程序和辅助程序的链接，形成二进制文件；</li>
<li>将二进制文件及相关配置文件安装到指定目录。</li>
</ol>
<p>编译安装需要用到的程序包括：<code>gcc</code>、<code>make</code>、<code>autoconfig</code>，以及相关的库文件和头文件。通常可以使用 <code>yum groupinstall &quot;Development Tools&quot;</code> 命令来安装所需套件。</p>
<h2 id="单一程序"><a class="markdownIt-Anchor" href="#单一程序"></a> 单一程序</h2>
<p>编写一个简单的 C 语言源代码进行编译测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> hello.c
<span class="token comment">#include &lt;stdio.h></span>
int main <span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        printf<span class="token punctuation">(</span><span class="token string">"hello<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token string">"hello.c"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 5L, 58C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 gcc 进行编译并运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gcc hello.c 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll
total <span class="token number">20</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">8</span> 01:38 anaconda-ks.cfg
-rwxr-xr-x. <span class="token number">1</span> root root <span class="token number">8360</span> Sep <span class="token number">21</span> <span class="token number">20</span>:33 a.out
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">59</span> Sep <span class="token number">21</span> <span class="token number">20</span>:32 hello.c
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ./a.out 
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>若没有指定输出文件名，则可执行文件名为 a.out。使用 <code>-o</code> 参数指定输出文件名为 hello.exe：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gcc <span class="token parameter variable">-c</span> hello.c
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ gcc <span class="token parameter variable">-o</span> hello.exe hello.o
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ./hello.exe 
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="主副程序链接"><a class="markdownIt-Anchor" href="#主副程序链接"></a> 主副程序链接</h2>
<p>如果在主程序里又调用了另一个副程序，例如新建一个<code>world.c</code>，再到<code>hello.c</code>调用它：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> world.c
<span class="token comment">#include &lt;stdio.h></span>
void world <span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        printf<span class="token punctuation">(</span><span class="token string">"world!<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token string">"world.c"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 5L, 62C written
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> hello.c 
<span class="token comment">#include &lt;stdio.h></span>
int main <span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        printf<span class="token punctuation">(</span><span class="token string">"hello "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        world <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token string">"hello.c"</span> 6L, 69C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样执行编译，最终生成二进制文件<code>helloworld</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ gcc <span class="token parameter variable">-c</span> hello.c world.c 
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ll
total <span class="token number">20</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">8</span> 01:38 anaconda-ks.cfg
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">69</span> Sep <span class="token number">21</span> <span class="token number">20</span>:43 hello.c
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1560</span> Sep <span class="token number">21</span> <span class="token number">20</span>:44 hello.o
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">62</span> Sep <span class="token number">21</span> <span class="token number">20</span>:42 world.c
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1488</span> Sep <span class="token number">21</span> <span class="token number">20</span>:44 world.o
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ gcc <span class="token parameter variable">-o</span> helloworld hello.o world.o
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ./helloworld 
hello world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个生成的二进制文件<code>helloworld</code>包含了两个源代码里的内容。如果修改了源文件<code>world.c</code>内容，只需要重新编译<code>world.c</code>文件，将新的<code>world.o</code>和<code>hello.o</code>链接制作出修改过后的二进制可执行文件。</p>
<h2 id="调用外部函数库"><a class="markdownIt-Anchor" href="#调用外部函数库"></a> 调用外部函数库</h2>
<p>如果调用的是系统函数库，直接在源文件里<code>include</code>进来。也可以使用<code>-I</code>参数来指定<code>include</code>文件位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> sin.c
<span class="token comment">#include &lt;stdio.h></span>
<span class="token comment">#include &lt;math.h></span>
int main <span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        float value<span class="token punctuation">;</span>
        value <span class="token operator">=</span> sin <span class="token punctuation">(</span><span class="token number">3</span>/2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">printf</span> <span class="token punctuation">(</span><span class="token string">"%f<span class="token entity" title="\n">\n</span>"</span>,value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token string">"sin.c"</span> 8L, 115C written
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ gcc sin.c -I/usr/include     
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ./a.out 
<span class="token number">0.841471</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要指定函数库位置可以使用<code>-L</code>参数。另外，<code>-</code>参数表示加入某函数库，<code>m</code>代表<code>libm.so</code>函数库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ gcc sin.c <span class="token parameter variable">-lm</span> -L/lib -L/lib64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="创建-makefile"><a class="markdownIt-Anchor" href="#创建-makefile"></a> 创建 Makefile</h2>
<p><code>Makefile</code>文件作用为简化整个编译流程。可以手动创建一个<code>Makefile</code>来测试下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> makefile
main: hello.o world.o
        gcc <span class="token parameter variable">-o</span> main hello.o world.o
<span class="token string">"makefile"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 2L, 51C written
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">make</span>
cc    <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> hello.o hello.c
cc    <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> world.o world.c
gcc <span class="token parameter variable">-o</span> main hello.o world.o
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ll
total <span class="token number">40</span>
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">69</span> Sep <span class="token number">21</span> <span class="token number">20</span>:43 hello.c
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1560</span> Sep <span class="token number">21</span> <span class="token number">21</span>:05 hello.o
-rwxr-xr-x. <span class="token number">1</span> root root <span class="token number">8472</span> Sep <span class="token number">21</span> <span class="token number">21</span>:05 main
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">51</span> Sep <span class="token number">21</span> <span class="token number">21</span>:05 makefile
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">62</span> Sep <span class="token number">21</span> <span class="token number">20</span>:42 world.c
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">1488</span> Sep <span class="token number">21</span> <span class="token number">21</span>:05 world.o
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">make</span>
make: `main' is up to date.
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ./main 
hello world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目标（<code>target</code>）与相关文件之间以分号<code>:</code>隔开，<code>gcc</code>行前必须使用 <code>[Tab]</code> 按键来缩进。</p>
<p>如果更新了源文件，只需要再次执行 <code>make</code> 命令就可以将生成的可执行文件更新。</p>
<p>当有两个以上执行动作时，例如编译完成后删除生成的 <code>.o</code> 文件，可以直接在后面接自定义阶段名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> makefile 
main: hello.o world.o
        gcc <span class="token parameter variable">-o</span> main hello.o world.o
clean:
        <span class="token function">rm</span> <span class="token parameter variable">-f</span> hello.o world.o
<span class="token string">"makefile"</span> 4L, 81C written
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">make</span> clean
<span class="token function">rm</span> <span class="token parameter variable">-f</span> hello.o world.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行时，在 <code>make</code> 后面接阶段名即可执行那一阶段定义的命令。</p>
<p>默认不接参数时执行 <code>main</code> 中命令，想要先执行 <code>main</code> 段再执行 <code>clean</code> 段，可以把两个阶段名都写出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">make</span> main clean
cc    <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> hello.o hello.c
cc    <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> world.o world.c
gcc <span class="token parameter variable">-o</span> main hello.o world.o
<span class="token function">rm</span> <span class="token parameter variable">-f</span> hello.o world.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>Makefile</code> 中可以使用变量来简化内容，例如将 <code>hello.o</code> <code>world.o</code> 定义为 <code>OBJS</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> makefile 
OBJS <span class="token operator">=</span> hello.o world.o
main: <span class="token variable">$&#123;OBJS&#125;</span>
        gcc <span class="token parameter variable">-o</span> main <span class="token variable">$&#123;OBJS&#125;</span>
clean:
        <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable">$&#123;OBJS&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外可以用 <code>$@</code> 代表目前的 <code>target</code>（也就是 <code>main</code>）。</p>
<h2 id="从源代码安装程序"><a class="markdownIt-Anchor" href="#从源代码安装程序"></a> 从源代码安装程序</h2>
<p>通常建议将源代码放在 <code>/usr/local/src</code> 目录下，软件安装到 <code>/usr/local</code> 目录下。</p>
<p>一般从网上下载的源码包安装实际操作步骤如下：</p>
<ol>
<li>取得原始文件，一般是 <code>tar</code> 压缩包；</li>
<li>将 <code>tar</code> 解压缩，读取里面的 <code>INSTALL</code> 或 <code>README</code> 等文档；</li>
<li>根据文档的要求安装好一些依赖软件；</li>
<li>创建 <code>makefile</code>，一般用 <code>./configure</code> 脚本来检测系统与相关软件属性；</li>
<li>运行 <code>make clean; make</code> 以 <code>makefile</code> 作为配置来编译；</li>
<li>运行 <code>make install</code> 将目标文件安装到指定路径。</li>
</ol>
<p>以上每个步骤都必须执行成功，才能进行下一步骤。</p>
<p>下面以安装 NTP 举例。先到官网 <a href="http://www.ntp.org/downloads.html">http://www.ntp.org/downloads.html</a> 找到最新的安装包用 <code>wget</code> 下载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /usr/local/src
<span class="token punctuation">[</span>root@234c8 src<span class="token punctuation">]</span>$ <span class="token function">wget</span> http://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p15.tar.gz
<span class="token number">100</span>%<span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token number">7,015</span>,970   <span class="token number">23</span>.5KB/s   <span class="token keyword">in</span> 6m 2s  

<span class="token number">2021</span>-09-21 <span class="token number">22</span>:14:23 <span class="token punctuation">(</span><span class="token number">18.9</span> KB/s<span class="token punctuation">)</span> - ‘ntp-4.2.8p15.tar.gz’ saved <span class="token punctuation">[</span><span class="token number">7015970</span>/7015970<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>验证下载的 <code>tar</code> 文件 MD5 值是否正确：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 src<span class="token punctuation">]</span>$ <span class="token function">wget</span> http://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p15.tar.gz.md5
<span class="token number">100</span>%<span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token number">61</span>          --.-K/s   <span class="token keyword">in</span> 0s      

<span class="token number">2021</span>-09-21 <span class="token number">23</span>:01:20 <span class="token punctuation">(</span><span class="token number">9.29</span> MB/s<span class="token punctuation">)</span> - ‘ntp-4.2.8p15.tar.gz.md5’ saved <span class="token punctuation">[</span><span class="token number">61</span>/61<span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@234c8 src<span class="token punctuation">]</span>$ md5sum ntp-4.2.8p15.tar.gz <span class="token parameter variable">--check</span> ntp-4.2.8p15.tar.gz.md5 
md5sum: ntp-4.2.8p15.tar.gz: no properly formatted MD5 checksum lines found
ntp-4.2.8p15.tar.gz: OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将其解压并阅读 <code>README</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 src<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zxv</span> <span class="token parameter variable">-f</span> ntp-4.2.8p15.tar.gz 
ntp-4.2.8p15/lib/isc/ia64/include/isc/
ntp-4.2.8p15/lib/isc/ia64/include/isc/atomic.h
ntp-4.2.8p15/lib/isc/alpha/include/
ntp-4.2.8p15/lib/isc/alpha/include/isc/
ntp-4.2.8p15/lib/isc/alpha/include/isc/atomic.h
<span class="token punctuation">[</span>root@234c8 src<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> ntp-4.2.8p15 <span class="token punctuation">;</span> <span class="token function">less</span> README
Submit patches, bug reports, and enhancement requests via

                        http://bugs.ntp.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>README 文件解释了每个文件的作用。然后使用<code>./configure</code>创建 makefile，并加入<code>--prefix</code>参数指定安装位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ ./configure <span class="token parameter variable">--help</span>
<span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/ntp --enable-all-clocks --enable-parse-clocks
config.status: creating Makefile
config.status: creating config.h
config.status: creating evconfig-private.h
config.status: evconfig-private.h is unchanged
config.status: executing depfiles commands
config.status: executing libtool commands
<span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ <span class="token function">cat</span> Makefile <span class="token operator">|</span> <span class="token function">grep</span> /usr/local/ntp
NTP_KEYSDIR <span class="token operator">=</span> /usr/local/ntp/etc
PERLLIBDIR <span class="token operator">=</span> /usr/local/ntp/share/ntp/lib
prefix <span class="token operator">=</span> /usr/local/ntp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后使用<code>make</code>来安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ <span class="token function">make</span> clean<span class="token punctuation">;</span> <span class="token function">make</span>
make<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>: Entering directory <span class="token variable"><span class="token variable">`</span>/usr/local/src/ntp-4.2.8p15'
make<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable">`</span></span>/usr/local/src/ntp-4.2.8p15<span class="token string">'
make[1]: Leaving directory `/usr/local/src/ntp-4.2.8p15'</span>
<span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ <span class="token function">make</span> check
make<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable"><span class="token variable">`</span>/usr/local/src/ntp-4.2.8p15'
make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable">`</span></span>/usr/local/src/ntp-4.2.8p15<span class="token string">'
[root@234c8 ntp-4.2.8p15]$ make install
Installing stand-alone HTML documentation
make[3]: Leaving directory `/usr/local/src/ntp-4.2.8p15'</span>
make<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable"><span class="token variable">`</span>/usr/local/src/ntp-4.2.8p15'
make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable">`</span></span>/usr/local/src/ntp-4.2.8p15'
<span class="token punctuation">[</span>root@234c8 ntp-4.2.8p15<span class="token punctuation">]</span>$ ll /usr/local/ntp/
total <span class="token number">0</span>
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">189</span> Sep <span class="token number">21</span> <span class="token number">22</span>:26 bin
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">6</span> Sep <span class="token number">21</span> <span class="token number">22</span>:26 libexec
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">6</span> Sep <span class="token number">21</span> <span class="token number">22</span>:26 sbin
drwxr-xr-x. <span class="token number">5</span> root root  <span class="token number">39</span> Sep <span class="token number">21</span> <span class="token number">22</span>:26 share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>patch</code>命令来对源码进行更新后，还需要再次编译才能生效。</p>
<h1 id="函数库管理"><a class="markdownIt-Anchor" href="#函数库管理"></a> 函数库管理</h1>
<p>在 Linux 下依据函数库是否被编译到程序内部分为动态与静态函数库：</p>
<ul>
<li>
<p><strong>静态</strong>（Static）</p>
<p>一般扩展名为 <code>.a</code>，在编译时直接整合到执行程序中。</p>
</li>
<li>
<p><strong>动态</strong>（Dynamic）</p>
<p>扩展名为 <code>.so</code>，在编译时程序只有一个指向（Pointer）位置，需要用到时才会去读取。</p>
</li>
</ul>
<p>现在软件偏向使用动态函数库，这样方便升级函数库后不需重新编译程序。</p>
<h2 id="将函数库常驻内存"><a class="markdownIt-Anchor" href="#将函数库常驻内存"></a> 将函数库常驻内存</h2>
<p>可以将常用的动态函数库载入内存中，这样程序调用函数库时比从硬盘读取速度快。方法如下：</p>
<ul>
<li>在 <code>/etc/ld.so.conf</code> 里写明要读入内存中的函数库目录；</li>
<li>利用 <code>ldconfig</code> 将 <code>ld.so.conf</code> 中配置的函数库读入内存；</li>
<li>同时也将数据记录一份在 <code>/etc/ld.so.cache</code> 这个文件中。</li>
</ul>
<p>假设要把 MySQL 数据库的函数库载入内存（实际上系统默认已经这么做了）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/ld.so.conf.d/mariadb-x86_64.conf 
/usr/lib64/mysql
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ldconfig
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ldconfig <span class="token parameter variable">-p</span> <span class="token operator">|</span> <span class="token function">grep</span> mysql
        libmysqlclient.so.18 <span class="token punctuation">(</span>libc6,x86-64<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> /usr/lib64/mysql/libmysqlclient.so.18
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="程序的动态函数库解析"><a class="markdownIt-Anchor" href="#程序的动态函数库解析"></a> 程序的动态函数库解析</h2>
<p>可以使用<code>ldd</code>命令来查询，例如查询<code>df</code>命令使用的动态函数库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ldd /usr/bin/df
        linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>0x00007ffe7de99000<span class="token punctuation">)</span>
        libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libc.so.6 <span class="token punctuation">(</span>0x00007fec1f049000<span class="token punctuation">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007fec1f417000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以继续拿<code>ldd</code>来查询某个函数的相关函数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ ldd <span class="token parameter variable">-v</span> /lib64/libc.so.6 
        /lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f894f632000<span class="token punctuation">)</span>
        linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>0x00007ffecdfd8000<span class="token punctuation">)</span>

        Version information:
        /lib64/libc.so.6:
                ld-linux-x86-64.so.2 <span class="token punctuation">(</span>GLIBC_2.3<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> /lib64/ld-linux-x86-64.so.2
                ld-linux-x86-64.so.2 <span class="token punctuation">(</span>GLIBC_PRIVATE<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> /lib64/ld-linux-x86-64.so.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个命令可以用来检查程序安装时的依赖性。</p>
<h1 id="软件管理"><a class="markdownIt-Anchor" href="#软件管理"></a> 软件管理</h1>
<p>通常不同的分发商会将一些软件编译好成二进制，并通过软件管理平台提供给用户。Fedora/CentOS 系列使用 RPM 软件管理机制和 yum 线上更新模式，而 Debian/Ubuntu 使用 dpkg 软件管理机制和 APT 线上更新模式。</p>
<h2 id="rpm-与-srpm"><a class="markdownIt-Anchor" href="#rpm-与-srpm"></a> RPM 与 SRPM</h2>
<p>RPM 的全名是 RedHat Package Manager，它要求软件文件安装环境与打包时一致，并且需要满足软件依赖性需求。</p>
<p>SRPM 是 Source RPM，也就是提供的 RPM 包的源文件，通常扩展名为 *.src.rpm。与普通源代码安装不同的是，要将它以 RPM 管理的方式编译成 RPM 文件，再安装到系统中。</p>
<p>RPM 包文件名通常有固定格式，例如：<code>cronolog-1.6.2-14.el7.x86_64.rpm</code>：</p>
<ul>
<li><code>cronolog</code>：软件名</li>
<li><code>1.6.2</code>：软件版本。主版本为 1，在主版本架构下的功能更新变动次版本号 6，小修补则用动用再次版本号 2 来表示。</li>
<li><code>14</code>：释出版本次数，也就是编译次数。可能由于一些 bug 或安全原因，重新调整过编译参数。</li>
<li><code>el7.x86_64</code>：适合的硬件平台。如果没有硬件等级限制，用 <code>noarch</code> 表示。</li>
<li><code>rpm</code>：固定扩展名</li>
</ul>
<p>RPM 的特点：</p>
<ul>
<li>RPM 内含已经编译过的程序与配置文件，不需要使用者重新编译。</li>
<li>RPM 在被安装之前，会检查系统版本、剩余容量等，可避免被错误安装。</li>
<li>RPM 文件本身提供软件版本信息、软件依赖信息、用途说明、文件内容等信息。</li>
<li>RPM 管理的方式使用数据库记录 RPM 文件相关参数，方便升级、卸载、查询等。</li>
</ul>
<p>RPM 使用 YUM 服务器提供下载，每次安装软件前，yum 都会先在线更新本地软件数据库，得出需要安装的软件列表。再到 YUM 服务器去获取软件，通过 RPM 的机制开始安装。使用 RPM 安装软件的信息会记录在 <code>/var/lib/rpm/</code> 目录下的数据库内。</p>
<p>SRPM 文件编译打包使用 <code>rpmbuild --rebuild</code> 命令。配置文件一般是 SPECS 目录下的 <code>.spec</code> 文件，修改完成后可以用 <code>rpmbuild -bb spec</code> 文件来编译成 RPM 文件。</p>
<h2 id="rpm-命令"><a class="markdownIt-Anchor" href="#rpm-命令"></a> RPM 命令</h2>
<p>安装使用 <code>-ivh</code> 参数，比如安装 <code>cronolog</code> 软件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> cronolog-1.6.2-14.el7.x86_64.rpm 
Preparing<span class="token punctuation">..</span>.                          <span class="token comment">################################# [100%]</span>
Updating / installing<span class="token punctuation">..</span>.
   <span class="token number">1</span>:cronolog-1.6.2-14.el7            <span class="token comment">################################# [100%]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数后面可以接多个 rpm 包来一次安装，也可以指定网络上的地址来安装。</p>
<p>其他一些有用的参数如下:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--nodeps</code></td>
<td>强制忽略软件依赖性来安装</td>
</tr>
<tr>
<td><code>--replacefiles</code></td>
<td>直接覆盖掉原先安装过的软件</td>
</tr>
<tr>
<td><code>--replacepkgs</code></td>
<td>直接重装 rpm 包</td>
</tr>
<tr>
<td><code>--force</code></td>
<td>等于 <code>--replacefiles</code> 加 <code>--replacepkgs</code></td>
</tr>
<tr>
<td><code>--test</code></td>
<td>测试 rpm 包是否能正确安装</td>
</tr>
<tr>
<td><code>--justdb</code></td>
<td>在数据库有错误时，更新此软件在数据库内的信息</td>
</tr>
<tr>
<td><code>--nosignature</code></td>
<td>忽略数字签名检查</td>
</tr>
<tr>
<td><code>--prefix</code> 路径</td>
<td>指定软件安装到自定义目录</td>
</tr>
<tr>
<td><code>--noscripts</code></td>
<td>禁止软件在安装时执行的命令</td>
</tr>
</tbody>
</table>
<p>如果要升级软件使用 <code>-Uvh</code> 参数:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-Uvh</span> cronolog-1.6.2-14.el7.x86_64.rpm 
Preparing<span class="token punctuation">..</span>.                          <span class="token comment">################################# [100%]</span>
        package cronolog-1.6.2-14.el7.x86_64 is already installed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>查询本机已安装的软件或 RPM 包可以使用以下命令及参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-q</code></td>
<td>仅查询软件是否有安装</td>
</tr>
<tr>
<td><code>-qa</code></td>
<td>列出所有已经安装的软件</td>
</tr>
<tr>
<td><code>-qi</code></td>
<td>列出软件详细信息</td>
</tr>
<tr>
<td><code>-ql</code></td>
<td>列出软件的所有文件与目录路径</td>
</tr>
<tr>
<td><code>-qc</code></td>
<td>列出软件的所有配置文件</td>
</tr>
<tr>
<td><code>-qd</code></td>
<td>列出软件的说明文档</td>
</tr>
<tr>
<td><code>-qR</code></td>
<td>列出软件的依赖情况</td>
</tr>
<tr>
<td><code>-qf</code></td>
<td>找出查询文件属于哪一个已经安装的软件</td>
</tr>
<tr>
<td><code>-q --script</code></td>
<td>列出是否含有安装后需要执行的脚本</td>
</tr>
<tr>
<td><code>-qp[icdlR]</code></td>
<td>查询 RPM 文件内的信息</td>
</tr>
</tbody>
</table>
<p>例如，查询 cronolog 软件安装的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-ql</span> cronolog
/usr/bin/cronosplit
/usr/sbin/cronolog
/usr/share/doc/cronolog-1.6.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询 cronolog 软件相关说明：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-qi</span> cronolog
Name        <span class="token builtin class-name">:</span> cronolog
Version     <span class="token builtin class-name">:</span> <span class="token number">1.6</span>.2
Release     <span class="token builtin class-name">:</span> <span class="token number">14</span>.el7
Architecture: x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询文件 <code>/bin/rpcgen</code> 属于哪个软件包。如果文件被误删了也可以查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-qf</span> /bin/rpcgen 
glibc-common-2.17-324.el7_9.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用 <code>-V</code> 参数来验证某个软件是否缺失或更改了文件，例如查询 rootfiles：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-V</span> rootfiles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>卸载软件使用 <code>-e</code> 参数，当软件没有依赖关系时才能卸载。如果强制移除软件造成数据库错误，可以使用 <code>--rebuilddb</code> 来重建数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">--rebuilddb</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="yum-命令"><a class="markdownIt-Anchor" href="#yum-命令"></a> YUM 命令</h2>
<p><code>yum</code> (Yellowdog Updater Modified) 是一种通过线上服务器安装软件的工具，常用参数包括 <code>-y</code> 用于自动确认，以及 <code>--installroot</code> 用于指定安装路径。</p>
<p>使用 <code>list</code> 选项查询软件列表，使用 <code>search</code> 选项在线上搜索软件，例如搜索和 <code>vim</code> 有关的软件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum search <span class="token function">vim</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.tuna.tsinghua.edu.cn
 * epel: mirrors.tuna.tsinghua.edu.cn
 * extras: mirrors.tuna.tsinghua.edu.cn
 * updates: mirrors.tuna.tsinghua.edu.cn
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> N/S matched: <span class="token function">vim</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
beakerlib-vim-syntax.noarch <span class="token builtin class-name">:</span> Files <span class="token keyword">for</span> syntax highlighting BeakerLib tests <span class="token keyword">in</span> VIM editor
boxes-vim.noarch <span class="token builtin class-name">:</span> Vim plugin <span class="token keyword">for</span> boxes
fluxbox-vim-syntax.noarch <span class="token builtin class-name">:</span> Fluxbox syntax scripts <span class="token keyword">for</span> <span class="token function">vim</span>
geany-plugins-vimode.x86_64 <span class="token builtin class-name">:</span> Vim-mode plugin <span class="token keyword">for</span> Geany<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>info</code> 选项搜索软件信息，例如搜索 <code>gdisk</code> 软件的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum info gdisk
Available Packages
Name        <span class="token builtin class-name">:</span> gdisk
Arch        <span class="token builtin class-name">:</span> x86_64
Version     <span class="token builtin class-name">:</span> <span class="token number">0.8</span>.10
Release     <span class="token builtin class-name">:</span> <span class="token number">3</span>.el7
Size        <span class="token builtin class-name">:</span> <span class="token number">190</span> k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出可升级的软件使用 <code>list updates</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum list updates
Updated Packages
epel-release.noarch                     <span class="token number">7</span>-14                                   epel   
kernel.x86_64                           <span class="token number">3.10</span>.0-1160.42.2.el7                   update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装软件使用 <code>install</code> 命令，升级使用 <code>update</code> 命令，例如安装 <code>agrep</code> 软件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> agrep
Installed:
  agrep.x86_64 <span class="token number">0</span>:0.8.0-18.20140228gitc2f5d13.el7                                                           

Dependency Installed:
  tre.x86_64 <span class="token number">0</span>:0.8.0-18.20140228gitc2f5d13.el7     tre-common.noarch <span class="token number">0</span>:0.8.0-18.20140228gitc2f5d13.el7    

Complete<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以只下载 RPM 包但不安装（软件已安装的情况下使用 <code>reinstall</code> 代替 <code>install</code>）。例如下载 <code>agrep</code> 到 <code>/root/dl/</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> agrep <span class="token parameter variable">--downloadonly</span> <span class="token parameter variable">--downloaddir</span><span class="token operator">=</span>/root/dl/
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ll /root/dl/
total <span class="token number">96</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">19924</span> Nov  <span class="token number">4</span>  <span class="token number">2016</span> agrep-0.8.0-18.20140228gitc2f5d13.el7.x86_64.rpm
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">40868</span> Nov  <span class="token number">4</span>  <span class="token number">2016</span> tre-0.8.0-18.20140228gitc2f5d13.el7.x86_64.rpm
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">32920</span> Nov  <span class="token number">4</span>  <span class="token number">2016</span> tre-common-0.8.0-18.20140228gitc2f5d13.el7.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>软件删除使用 <code>remove</code> 命令，例如移除掉 <code>agrep</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum remove agrep
Remove  <span class="token number">1</span> Package

Installed size: <span class="token number">22</span> k
Is this ok <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span>: y
Downloading packages:
Running transaction check
Running transaction <span class="token builtin class-name">test</span>
Transaction <span class="token builtin class-name">test</span> succeeded
Running transaction
  Erasing    <span class="token builtin class-name">:</span> agrep-0.8.0-18.20140228gitc2f5d13.el7.x86_64                                            <span class="token number">1</span>/1 
  Verifying  <span class="token builtin class-name">:</span> agrep-0.8.0-18.20140228gitc2f5d13.el7.x86_64                                            <span class="token number">1</span>/1 

Removed:
  agrep.x86_64 <span class="token number">0</span>:0.8.0-18.20140228gitc2f5d13.el7                                                           

Complete<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要加入自定义仓库地址，可以修改 yum 配置文件 <code>/etc/yum.repos.d/CentOS-Base.repo</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/yum.repos.d/CentOS-Base.repo
<span class="token punctuation">[</span>base<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - Base
<span class="token assign-left variable">mirrorlist</span><span class="token operator">=</span>http://mirrorlist.centos.org/?release<span class="token operator">=</span><span class="token variable">$releasever</span><span class="token operator">&amp;</span><span class="token assign-left variable">arch</span><span class="token operator">=</span><span class="token variable">$basearch</span><span class="token operator">&amp;</span><span class="token assign-left variable">repo</span><span class="token operator">=</span>os<span class="token operator">&amp;</span><span class="token assign-left variable">infra</span><span class="token operator">=</span><span class="token variable">$infra</span>
<span class="token comment">#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中以中括号代表软件库名称，可以自己取名，其他设置如下：</p>
<ul>
<li>name：自定义仓库名，不要重名即可；</li>
<li>mirrorlist：列出这个软件仓库可用的映射站点，可以不需要；</li>
<li>baseurl：后面接实际软件仓库网址；</li>
<li>enable：设置是否要启用此仓库；</li>
<li>gpgcheck：是否要检查数字签名；</li>
<li>gpgkey：数字签名文件位置。</li>
</ul>
<p>设置好以后可以使用 <code>repolist all</code> 来查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ yum repolist all
repo <span class="token function">id</span>                       repo name                                status
C7.8.2003-updates/x86_64      CentOS-7.8.2003 - Updates                disabled
base/7/x86_64                 CentOS-7 - Base                          enabled: <span class="token number">10,072</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>yum 支持软件群组功能，可以使用下面选项来操作：</p>
<ul>
<li>grouplist：列出所有可用的软件群组；</li>
<li>groupinfo：查询软件群组内容；</li>
<li>groupinstall：安装一组软件群组；</li>
<li>groupremove：删除某软件群组。</li>
</ul>
<p>软件群组内软件分主要和可选，使用 <code>groupinstall</code> 只会安装主要软件，可以修改 <code>/etc/yum.conf</code> 配置，在 <code>distroverpkg</code> 下面加入一行配置 <code>group_package_types=default, mandatory, optional</code> 来安装所有软件群组的软件。</p>
<p>另外，想要通过代理连接下载，可以在配置文件中新增一行 <code>proxy=代理服务器地址</code> 来启用。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 下搜索文件</title>
    <url>/3570307132/</url>
    <content><![CDATA[<h1 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h1>
<p>通配符（wildcard）是 Bash 操作接口的一个功能。常用的通配符如下表：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表 0 到无穷多个任意字符。</td>
</tr>
<tr>
<td>?</td>
<td>代表一定有一个任意字符。</td>
</tr>
<tr>
<td>[]</td>
<td>代表一定有一个括号内的字符，例如 [xgw] 代表可能是 xgw 其中一个。</td>
</tr>
<tr>
<td>[-]</td>
<td>代表在编码顺序内的所有字符，例如 [0-9] 代表 0 到 9 之间的所有数字。</td>
</tr>
<tr>
<td>[^]</td>
<td>第一个字符为 ^ 代表反向选择，例如 [^xpw]代表任意一个非 xpw 的字符。</td>
</tr>
</tbody>
</table>
<h1 id="快速搜索"><a class="markdownIt-Anchor" href="#快速搜索"></a> 快速搜索</h1>
<p>在 Linux 中，可以使用不同的命令进行快速搜索，以下是一些常用命令。</p>
<p>使用 <code>which</code> 命令来查找命令所在路径。这个命令根据的是$PATH 环境变量所指定的路径去查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">which</span> <span class="token function">ls</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">ls</span><span class="token operator">=</span><span class="token string">'ls --color=auto'</span>
        /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>whereis</code> 命令会在指定的几个常用目录中搜索文件，使用 <code>-l</code> 参数可以查看可搜索的目录。</p>
<p><code>whereis</code> 命令可以搜索以下类型的文件：二进制文件（<code>-b</code>）、说明文件（<code>-m</code>）、源代码（<code>-s</code>）和其他特殊文件（<code>-u</code>）。</p>
<p>例如搜索和 <code>ifconfig</code> 有关的说明文档：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">whereis</span> <span class="token parameter variable">-m</span> <span class="token function">ifconfig</span>
ifconfig: /usr/share/man/man8/ifconfig.8.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>locate</code> 命令使用数据库来查找文件。数据库存放在 <code>/var/lib/mlocate/</code> 目录下，每天会更新一次。若需要手动更新数据库，可以使用 <code>updatedb</code> 命令。</p>
<p>例如忽略大小写搜索与 <code>passwd</code> 有关的文件，并列出前四个结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">locate</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-l</span> <span class="token number">4</span> <span class="token function">passwd</span>
/etc/passwd
/etc/passwd-
/etc/pam.d/passwd
/etc/security/opasswd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="精确搜索"><a class="markdownIt-Anchor" href="#精确搜索"></a> 精确搜索</h1>
<p>精确搜索指使用<code>find</code>命令执行的搜索。</p>
<h2 id="按时间搜索文件"><a class="markdownIt-Anchor" href="#按时间搜索文件"></a> 按时间搜索文件</h2>
<p>与时间有关的参数有<code>-atime</code>，<code>-ctime</code>和<code>-mtime</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-mtime n</code></td>
<td>表示在 n 天之前那天内被更改过的文件；</td>
</tr>
<tr>
<td><code>-mtime +n</code></td>
<td>列出在 n 天之前（不含 n）被更改过的文件，文件修改日期大于等于 n+1 天；</td>
</tr>
<tr>
<td><code>-mtime -n</code></td>
<td>列出在 n 天之内（包含 n）被更改过的文件，文件修改日期小于等于 n 天；</td>
</tr>
<tr>
<td><code>-newer file</code></td>
<td>列出比<code>file</code>还要新的文件名。</td>
</tr>
</tbody>
</table>
<p>例如，搜索过去系统上 24 小时内有更改过的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-mtime</span> <span class="token number">0</span>
/dev/char
/dev/char/189:132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>查找当前目录下修改时间在 5 分钟到 24 小时之间的文件：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token parameter variable">-mtime</span> <span class="token number">0</span> <span class="token parameter variable">-mmin</span> +5
<span class="token builtin class-name">.</span>
./.bash_history
./audit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>寻找<code>/etc</code>目录下比<code>/etc/passwd</code>文件日期新的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /etc <span class="token parameter variable">-newer</span> /etc/passwd <span class="token operator">|</span> <span class="token function">tail</span> 
/etc/audit/audit.rules
/etc/postfix
/etc/kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查找<code>/root</code>目录下更改时间在 5 天前的文件并删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> /root <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mtime</span> +5 <span class="token parameter variable">-ok</span> rm<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除当前目录中访问时间在 7 天以前，含有数字后缀的<code>admin.log</code>文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">"admin.log[0-9][0-9][0-9]"</span> <span class="token parameter variable">-atime</span> <span class="token parameter variable">-7</span> <span class="token parameter variable">-exec</span> <span class="token function">rm</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="按用户名及组名搜索"><a class="markdownIt-Anchor" href="#按用户名及组名搜索"></a> 按用户名及组名搜索</h2>
<p>可以使用 <code>find</code> 命令按照文件的所有者和用户组来搜索文件，常用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-uid n</code></td>
<td>按照用户 UID 来搜索</td>
</tr>
<tr>
<td><code>-gid n</code></td>
<td>按用户组 GID 来搜索</td>
</tr>
<tr>
<td><code>-user name</code></td>
<td>按用户名来搜索</td>
</tr>
<tr>
<td><code>-group name</code></td>
<td>按用户组名来搜索</td>
</tr>
<tr>
<td><code>-nouser</code></td>
<td>搜索文件的所有者不存在 <code>/etc/passwd</code> 的人</td>
</tr>
<tr>
<td><code>-nogroup</code></td>
<td>搜索所有用户组不存在 <code>/etc/group</code> 中的文件</td>
</tr>
</tbody>
</table>
<p>例如查找 <code>/home</code> 目录下属于用户 abc 的文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /home <span class="token parameter variable">-user</span> abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查找系统中不属于任何人的文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-nouser</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="按文件名及属性搜索"><a class="markdownIt-Anchor" href="#按文件名及属性搜索"></a> 按文件名及属性搜索</h2>
<p>主要参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name filename</td>
<td>搜索文件名为 filename 的文件</td>
</tr>
<tr>
<td>-iname filename</td>
<td>忽略大小写，搜索文件名为 filename 的文件</td>
</tr>
<tr>
<td>-size [±]SIZE</td>
<td>搜索大小比 SIZE 大（+）或小（-）的文件，大小单位有 c、k、m、g 等</td>
</tr>
<tr>
<td>-type TYPE</td>
<td>搜索文件类型为 TYPE 的文件，如一般文件（f）、设备文件（b、c）、目录（d）、连接（l）、socket（s）等</td>
</tr>
<tr>
<td>-perm mode</td>
<td>搜索权限刚好等于 mode 的文件，如 mode 为 4775</td>
</tr>
<tr>
<td>-perm -mode</td>
<td>搜索权限必须全部包括 mode 的权限，如 mode 为 0744，会找到权限为 4775 的文件</td>
</tr>
<tr>
<td>-perm +mode</td>
<td>搜索权限包含任一 mode 的权限，如 mode 为 755 时，会找到权限为 101 的文件</td>
</tr>
</tbody>
</table>
<p>例如，在当前目录中查找文件 redis-3.2.6.tar.gz 并删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token parameter variable">-name</span> redis-3.2.6.tar.gz <span class="token parameter variable">-delete</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>忽略大小写，在 <code>/etc</code> 目录下搜索 ssh 文件或目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> /etc <span class="token parameter variable">-iname</span> <span class="token function">ssh</span>
/etc/ssh
/etc/selinux/targeted/active/modules/100/ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/etc</code> 目录中查找以 rc 开头的文件，并以列表形式显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> /etc <span class="token parameter variable">-name</span> rc* <span class="token parameter variable">-ls</span>
<span class="token number">50332831</span>    <span class="token number">0</span> drwxr-xr-x  <span class="token number">10</span> root     root          <span class="token number">127</span> Sep  <span class="token number">7</span> 05:53 /etc/rc.d
<span class="token number">16781412</span>    <span class="token number">0</span> drwxr-xr-x   <span class="token number">2</span> root     root           <span class="token number">45</span> Oct <span class="token number">13</span>  <span class="token number">2020</span> /etc/rc.d/rc0.d
<span class="token number">33644238</span>    <span class="token number">0</span> drwxr-xr-x   <span class="token number">2</span> root     root           <span class="token number">45</span> Oct <span class="token number">13</span>  <span class="token number">2020</span> /etc/rc.d/rc1.d
<span class="token number">50332832</span>    <span class="token number">0</span> drwxr-xr-x   <span class="token number">2</span> root     root           <span class="token number">45</span> Oct <span class="token number">13</span>  <span class="token number">2020</span> /etc/rc.d/rc2.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/root</code> 目录下搜索所有小于 1MB 的文件，用 <code>-size -1M</code> 参数等同于 <code>-size 0M</code>，需要注意。这是个 ChatGPT 都会答错的问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> /root <span class="token parameter variable">-size</span> <span class="token parameter variable">-1M</span>
/root/audit/a.log
/root/3/3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>查找 <code>/root</code> 目录下大于 10KB 并且（<code>-a</code> 表示“与”）小于 2M 的普通文件，并以列表形式显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /root <span class="token parameter variable">-type</span> f <span class="token parameter variable">-size</span> +10k <span class="token parameter variable">-a</span> <span class="token parameter variable">-size</span> <span class="token parameter variable">-2M</span> <span class="token parameter variable">-exec</span> <span class="token function">ls</span> <span class="token parameter variable">-lh</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span>
-rw-------. <span class="token number">1</span> root root 17K Sep <span class="token number">16</span> 03:15 /root/.bash_history
-rw-------. <span class="token number">1</span> root root 178K Sep  <span class="token number">9</span> 05:48 /root/audit/b.log
-rw-r--r--. <span class="token number">1</span> root root 30K Sep <span class="token number">10</span> <span class="token number">15</span>:05 /root/backup/sdb4.dump
-rw-r--r--. <span class="token number">1</span> root root 11K Sep <span class="token number">10</span> <span class="token number">14</span>:39 /root/backup/lost.dump.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查找当前目录中的所有目录并排序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-type</span> d <span class="token operator">|</span> <span class="token function">sort</span>
<span class="token builtin class-name">.</span>
./3
./audit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在当前目录下查找除普通文件以外的所有类型的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token operator">!</span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-print</span>
<span class="token builtin class-name">.</span>
./.pki
./.pki/nssdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查找 <code>/bin</code> 和 <code>/sbin</code> 目录下中含有 SGID, SUID 或 SBIT 属性的文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /bin /sbin <span class="token parameter variable">-perm</span> +7000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="处理搜索结果"><a class="markdownIt-Anchor" href="#处理搜索结果"></a> 处理搜索结果</h2>
<p><code>find</code> 命令可以接受表达式，表达式可能由下列成份组成：操作符、选项、测试表达式以及动作。</p>
<p>常见动作有 <code>-print</code>（打印输出，默认动作）、<code>-ls</code>（显示长目录列表）、<code>-delete</code>（删除文件）。</p>
<p><code>-exec</code> 选项后面跟命令（不支持别名）或脚本，然后是大括号 <code>&#123;&#125;</code> 表示由 <code>find</code> 找到的路径名，一个空格，接 <code>\</code> 用来转义分号；表示命令结束。相应命令的形式为 <code>command &#123;&#125; \</code>；</p>
<p><code>-ok</code> 和 <code>-exec</code> 的作用相同，只不过在执行每一个命令之前都会给出提示，让用户来确定是否执行。</p>
<p>例如在 <code>/etc</code> 目录中搜索 <code>passwd</code> 文件并从中找 <code>root</code> 相关信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">find</span> /etc <span class="token parameter variable">-name</span> <span class="token string">"passwd*"</span> <span class="token parameter variable">-exec</span> <span class="token function">grep</span> <span class="token string">"root"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span>
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/usr/sam</code> 目录下查找不在 <code>dir1</code> 子目录之内的所有文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /usr/sam <span class="token parameter variable">-path</span> <span class="token string">"/usr/sam/dir1"</span> <span class="token parameter variable">-prune</span> <span class="token parameter variable">-o</span> <span class="token parameter variable">-print</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>复制搜索到的文件到 <code>backup</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-exec</span> <span class="token function">cp</span> <span class="token parameter variable">--parents</span>  <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> ./backup/ <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>-exec</code> 为每个文件生成一条单独的命令，例如搜索到 57 个文件，那么将生成 57 条单独命令。如果想要提高效率，可以使用 <code>xargs</code> 运行任何使用参数指定的命令，参数通过标准输入传递给程序。</p>
<p>例如配合 <code>grep</code> 在 <code>find</code> 找到的文件中搜寻特定内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> /var <span class="token parameter variable">-name</span> *.log <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">grep</span> <span class="token string">"notice"</span>
/var/log/anaconda/X.log:        <span class="token punctuation">(</span>++<span class="token punctuation">)</span> from <span class="token builtin class-name">command</span> line, <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">)</span> notice, <span class="token punctuation">(</span>II<span class="token punctuation">)</span> informational,
/var/log/anaconda/journal.log:Sep <span class="token number">22</span> <span class="token number">13</span>:09:41 localhost kernel: <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token number">1107</span> audit<span class="token punctuation">(</span><span class="token number">1632316181.830</span>:44<span class="token punctuation">)</span>: <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">1577</span> <span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">auid</span><span class="token operator">=</span><span class="token number">4294967295</span> <span class="token assign-left variable">ses</span><span class="token operator">=</span><span class="token number">4294967295</span> <span class="token assign-left variable">subj</span><span class="token operator">=</span>system_u:system_r:system_dbusd_t:s0-s0:c0.c1023 <span class="token assign-left variable">msg</span><span class="token operator">=</span>'avc:  received policyload notice <span class="token punctuation">(</span>seqno<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将搜索到的文件重命名，可以在 <code>xargs</code> 中使用 <code>&#123;&#125;</code> 占位符来代表搜索结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">"back.sh*"</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-i</span> <span class="token function">mv</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>.dele
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ll back*
-rwxr--r--. <span class="token number">1</span> root root <span class="token number">52</span> Oct  <span class="token number">7</span> 06:15 back.sh1.dele
-rwxr--r--. <span class="token number">2</span> root root <span class="token number">52</span> Sep <span class="token number">23</span> <span class="token number">19</span>:18 back.sh.dele<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 基本文件操作</title>
    <url>/3891118029/</url>
    <content><![CDATA[<h1 id="文件和目录查询"><a class="markdownIt-Anchor" href="#文件和目录查询"></a> 文件和目录查询</h1>
<p>使用 <code>ls</code> 命令可以列出目录中的文件，不包括隐藏文件。默认按文件名排序。<code>ll</code> 命令是 <code>ls -l</code> 的别名。</p>
<p>以下是一些常用选项参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示隐藏文件</td>
</tr>
<tr>
<td>-d</td>
<td>仅查看目录本身属性</td>
</tr>
<tr>
<td>-h</td>
<td>使显示结果更友好</td>
</tr>
<tr>
<td>-i</td>
<td>列出 inode 号码</td>
</tr>
<tr>
<td>-l</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-n</td>
<td>列出 UID 与 GID</td>
</tr>
<tr>
<td>-R</td>
<td>连同子目录内容一起列出</td>
</tr>
<tr>
<td>-S</td>
<td>以文件大小排序</td>
</tr>
<tr>
<td>-t</td>
<td>依时间排序</td>
</tr>
</tbody>
</table>
<p>可以同时查看多个文件信息，路径之间用空格隔开：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll ./dir1/ ./audit/
./audit/:
total <span class="token number">360</span>
-rw-------. <span class="token number">2</span> root root <span class="token number">182023</span> Sep <span class="token number">9</span> 05:01 audit.log
lrwxrwxrwx. <span class="token number">1</span> root root <span class="token number">9</span> Sep <span class="token number">9</span> 05:29 ha.log -<span class="token operator">></span> audit.log
-rw-------. <span class="token number">2</span> root root <span class="token number">182023</span> Sep <span class="token number">9</span> 05:01 la.log

./dir1/:
total <span class="token number">0</span>
-rwxrwxr--. <span class="token number">1</span> <span class="token function">ftp</span> root <span class="token number">0</span> Sep <span class="token number">8</span> <span class="token number">23</span>:29 xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用通配符 *（? 匹配单字母）来显示所有匹配的文件和目录，包括子文件夹中的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> s*
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">83886080</span> Sep <span class="token number">10</span> <span class="token number">22</span>:20 sdb5.disk

sdb4m:
total <span class="token number">20</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep <span class="token number">10</span> <span class="token number">15</span>:05 a.cfg
drwx------. <span class="token number">2</span> root root <span class="token number">16384</span> Sep <span class="token number">10</span> <span class="token number">15</span>:03 lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>展示完整的文件修改时间使用 <code>--full-time</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-Al</span> --full-time /etc/bash_completion.d/
total <span class="token number">72</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">56178</span> <span class="token number">2020</span>-05-28 <span class="token number">16</span>:32:30.000000000 <span class="token parameter variable">-0400</span> <span class="token function">git</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">829</span> <span class="token number">2020</span>-02-05 07:58:44.000000000 <span class="token parameter variable">-0500</span> iprutils
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">11736</span> <span class="token number">2020</span>-03-31 <span class="token number">23</span>:33:31.000000000 <span class="token parameter variable">-0400</span> mercurial.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以指定展示特定时间戳，比如查询文件访问时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token parameter variable">--time</span><span class="token operator">=</span>atime 
total <span class="token number">364</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep <span class="token number">9</span> 05:51 b.log
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">178</span> Sep <span class="token number">9</span> 05:57 c.log
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep <span class="token number">9</span> 05:48 mvau.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-F</code> 参数能在文件名末显示该文件的类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-F</span> /sbin/
accessdb*              fsfreeze*                   mkdict@ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果中可执行文件会在文件名后加*，软链接加@，目录加/，管道加|，并用不同颜色表示结果。</p>
<p>此外，还可以使用 stat 命令来查看某个文件的具体属性，其展示结果一步到位，包括文件大小、块数、I/O 块大小、设备号、Inode 号码、硬链接数量、文件权限、UID 和 GID、SELinux 安全上下文、文件访问时间、修改时间、变化时间和创建时间等信息。例如，查看 <a href="http://ftp.sh">ftp.sh</a> 文件的属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">stat</span> ftp.sh
  File: ‘ftp.sh’
  Size: <span class="token number">52</span>              Blocks: <span class="token number">8</span>          IO Block: <span class="token number">4096</span>   regular <span class="token function">file</span>
Device: fd00h/64768d    Inode: <span class="token number">4215134</span>     Links: <span class="token number">1</span>
Access: <span class="token punctuation">(</span>0644/-rw-r--r--<span class="token punctuation">)</span>  Uid: <span class="token punctuation">(</span>    <span class="token number">0</span>/    root<span class="token punctuation">)</span>   Gid: <span class="token punctuation">(</span>    <span class="token number">0</span>/    root<span class="token punctuation">)</span>
Context: unconfined_u:object_r:admin_home_t:s0
Access: <span class="token number">2021</span>-09-23 <span class="token number">19</span>:18:22.974352478 +0800
Modify: <span class="token number">2021</span>-09-23 <span class="token number">19</span>:18:04.472546785 +0800
Change: <span class="token number">2021</span>-09-23 <span class="token number">19</span>:18:04.473546775 +0800
 Birth: -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，Size 表示文件大小，Blocks 表示块数，IO Block 表示 I/O 块大小，regular file 表示文件类型为常规文件，Device 表示设备号，Inode 表示 Inode 号码，Links 表示硬链接数量，Access 表示文件访问时间，Modify 表示文件修改时间，Change 表示文件状态更改时间，Birth 表示文件创建时间。</p>
<h1 id="检查文件类型"><a class="markdownIt-Anchor" href="#检查文件类型"></a> 检查文件类型</h1>
<p>想了解某个文件的基本数据类型，可以使用 file 命令。</p>
<p>例如，查看二进制文件 passwd 的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">file</span> /usr/bin/passwd 
/usr/bin/passwd: setuid ELF <span class="token number">64</span>-bit LSB shared object, x86-64, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, <span class="token keyword">for</span> GNU/Linux <span class="token number">2.6</span>.32, BuildID<span class="token punctuation">[</span>sha1<span class="token punctuation">]</span><span class="token operator">=</span>dee1b9ab6618c6bfb84a14f85ba258c742cf4aec, stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再比如，查看日志文件 b.log 的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">file</span> b.log 
b.log: ASCII text, with very long lines<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="复制文件与目录"><a class="markdownIt-Anchor" href="#复制文件与目录"></a> 复制文件与目录</h1>
<p>使用 <code>cp</code> 命令可以复制文件和文件夹，系统已经为 <code>cp</code> 加入 <code>-i</code> 选项以询问用户是否覆盖文件。</p>
<p>例如，复制当前目录下的 anaconda-ks.cfg 文件到 <code>/home/</code> 下并命名为 anac.cfg:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> anaconda-ks.cfg /home/anac.cfg <span class="token punctuation">;</span> ll /home
total <span class="token number">4</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">9</span> 05:12 anac.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>复制文件夹需要使用递归参数 <code>-r</code>，例如复制 <code>/var/log</code> 下的文件夹 audit 到当前目录:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> <span class="token parameter variable">-r</span> /var/log/audit/ <span class="token builtin class-name">.</span> <span class="token punctuation">;</span> ll ./audit/
total <span class="token number">180</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:14 audit.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>复制后的文件属性，如修改时间和权限（所有者变为操作者）会改变。如果要保留源文件属性，可以使用 <code>-a</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll /var/log/audit/
total <span class="token number">180</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:01 audit.log
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll audit/
total <span class="token number">180</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:14 audit.log
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> audit/ <span class="token punctuation">;</span> <span class="token function">cp</span> <span class="token parameter variable">-ra</span> /var/log/audit/ <span class="token builtin class-name">.</span> <span class="token punctuation">;</span> ll audit/
total <span class="token number">180</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:01 audit.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="删除文件与目录"><a class="markdownIt-Anchor" href="#删除文件与目录"></a> 删除文件与目录</h1>
<p>删除文件或文件夹使用 rm 命令。如果需要删除以-开头的特殊文件，需要使用相对路径。</p>
<p>例如，要删除当前目录下的 la.log 和 ha.log 两个文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> la.log ha.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要删除文件夹，则需要使用 <code>-r</code> 参数，并且可以使用通配符*。例如，要删除当前文件夹下以 app 开头的所有文件和文件夹：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> app*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="移动和更名文件和目录"><a class="markdownIt-Anchor" href="#移动和更名文件和目录"></a> 移动和更名文件和目录</h1>
<p>在 Linux 中，可以使用 <code>mv</code> 命令移动和更名文件和目录。移动文件或目录会保持其 inode 编号和时间戳不变。</p>
<p>例如，将文件 audit.log 移动到其上级目录并将其更名为 mvau.log：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">mv</span> audit.log <span class="token punctuation">..</span>/mvau.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以同时移动多个文件到指定目录。例如，将 mvau.log 和 b.log 一次性移动到目录 audit 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mv</span> mvau.log b.log audit/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="修改文件时间戳"><a class="markdownIt-Anchor" href="#修改文件时间戳"></a> 修改文件时间戳</h1>
<p>在 Linux 系统中，每个文件都有三个时间戳：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Modification Time(<strong>mtime</strong>)  修改时间</td>
<td>当文件<strong>内容更改</strong>时会更新这个时间.不包括文件的属性或权限更改</td>
</tr>
<tr>
<td>Status Time(<strong>ctime</strong>)     状态(创建)时间</td>
<td>当文件<strong>状态改变</strong>时会更新这个时间,比如权限和属性的更改</td>
</tr>
<tr>
<td>Access Time(<strong>atime</strong>)    (上次)访问时间</td>
<td>当文件<strong>内容读取</strong>时会更新这个时间,比如用 cat 或 less 去读取</td>
</tr>
</tbody>
</table>
<p>可以使用 <code>touch</code> 命令来修改文件的时间戳。如果不指定时间，则修改为当前时间。</p>
<p>例如，将 a.log 文件的修改时间和访问时间修改为 2007 年 1 月 1 日 1 点 1 分：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ ll a.log<span class="token punctuation">;</span>ll <span class="token parameter variable">--time</span><span class="token operator">=</span>atime a.log<span class="token punctuation">;</span> ll <span class="token parameter variable">--time</span><span class="token operator">=</span>ctime a.log 
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 07:35 a.log
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 07:35 a.log
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 07:35 a.log
<span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">touch</span> <span class="token parameter variable">-t</span> 0701010101 a.log
<span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ ll a.log<span class="token punctuation">;</span>ll <span class="token parameter variable">--time</span><span class="token operator">=</span>atime a.log<span class="token punctuation">;</span> ll <span class="token parameter variable">--time</span><span class="token operator">=</span>ctime a.log 
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Jan  <span class="token number">1</span>  <span class="token number">2007</span> a.log
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Jan  <span class="token number">1</span>  <span class="token number">2007</span> a.log
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 07:38 a.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h1>
<p><code>touch</code> 命令本意用来更新文件时间戳，当文件不存在时会创建一个新的空文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">touch</span> a.log <span class="token punctuation">;</span> ll
total <span class="token number">364</span>
-rw-r--r--. <span class="token number">1</span> root root      <span class="token number">0</span> Sep  <span class="token number">9</span> 07:35 a.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>cat</code> 命令接收用户输入，并将其重定向到文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile
<span class="token number">123</span>
<span class="token number">32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输入完毕后按下 Ctrl+d 组合键以结束输入。</p>
<h1 id="擦除文件内容"><a class="markdownIt-Anchor" href="#擦除文件内容"></a> 擦除文件内容</h1>
<p>当使用 <code>rm</code> 命令删除文件时，实际上只是将文件的块标记为可写，而磁盘上的数据并没有被删除。如果要安全删除文件并保证不留下任何痕迹，可以使用 <code>shred</code> 命令，它会用随机数据对目标文件进行多次覆写。例如，以下命令对名为 www 的文件进行四次覆写，最后填充为零后再删除文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ shred <span class="token parameter variable">-fuvz</span> www 
shred: www: pass <span class="token number">1</span>/4 <span class="token punctuation">(</span>random<span class="token punctuation">)</span><span class="token punctuation">..</span>.
shred: www: pass <span class="token number">2</span>/4 <span class="token punctuation">(</span>random<span class="token punctuation">)</span><span class="token punctuation">..</span>.
shred: www: pass <span class="token number">3</span>/4 <span class="token punctuation">(</span>random<span class="token punctuation">)</span><span class="token punctuation">..</span>.
shred: www: pass <span class="token number">4</span>/4 <span class="token punctuation">(</span>000000<span class="token punctuation">)</span><span class="token punctuation">..</span>.
shred: www: removing
shred: www: renamed to 000
shred: 000: renamed to 00
shred: 00: renamed to <span class="token number">0</span>
shred: www: removed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，<code>shred</code> 命令并不适用于所有文件系统。例如，ZFS 文件系统会为新数据分配新的数据块，而不是直接覆写旧数据。</p>
<h1 id="连接文件"><a class="markdownIt-Anchor" href="#连接文件"></a> 连接文件</h1>
<p>在 Linux 中，可以使用 <code>ln</code> 命令来连接文件。<code>ln</code> 命令有两种链接方式：硬链接和软链接。</p>
<h2 id="硬连接"><a class="markdownIt-Anchor" href="#硬连接"></a> 硬连接</h2>
<p>硬连接（hard link）是在某个目录 block 数据中新建一条文件名，连接到某个已存在的 inode 号码关联记录。</p>
<p>硬链接特点：</p>
<ul>
<li>新建的硬连接属性权限和源文件一样，修改也和源文件同步，是因为其数据储存在引用的 inode 块中；</li>
<li>一个文件有几个硬连接就有几个 Link Counter；</li>
<li>建立硬连接不占用磁盘空间与 inode 数目。</li>
</ul>
<p>建立硬连接有两个限制：</p>
<ul>
<li>不能跨文件系统，因为不同文件系统有不同 inode；</li>
<li>不能连接到目录。</li>
</ul>
<h2 id="软连接"><a class="markdownIt-Anchor" href="#软连接"></a> 软连接</h2>
<p>软连接（symbolic link）也叫做符号连接或快捷方式，是指向另一个文件或目录的特殊文件。它有自己的 inode 编号和硬链接计数器。但是软链接的内容是源文件的路径名。</p>
<p>软连接文件属性为 l ，使用 <code>ls</code> 查看时会有个 -&gt; 符号指向源文件的路径名。</p>
<p>如果源文件改名或删除，软链接文件将不会指向正确位置，因为其使用文件名作为引用。</p>
<h2 id="目录的连接数量"><a class="markdownIt-Anchor" href="#目录的连接数量"></a> 目录的连接数量</h2>
<p>当新建一个目录时，新的目录连接数为 2。</p>
<p>比如新建目录 <code>/root/1/</code>，另一个硬连接等于 <code>/root/1/.</code>。</p>
<p>而上层目录的连接数会增加 1，也就是增加了 <code>/root/1/..</code> 这个硬连接。</p>
<h2 id="创建连接"><a class="markdownIt-Anchor" href="#创建连接"></a> 创建连接</h2>
<p>使用 <code>ln</code> 和 <code>cp</code> 命令都可以创建连接。默认不加参数使用 <code>ln</code> 建立的就是硬连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">ln</span> hhh hhh_hark<span class="token punctuation">;</span> ll <span class="token parameter variable">-i</span>
total <span class="token number">24</span>
<span class="token number">16</span> -rw-r--r--. <span class="token number">2</span> root root     <span class="token number">4</span> Sep <span class="token number">10</span> 01:57 hhh
<span class="token number">16</span> -rw-r--r--. <span class="token number">2</span> root root     <span class="token number">4</span> Sep <span class="token number">10</span> 01:57 hhh_hark
<span class="token number">11</span> drwx------. <span class="token number">2</span> root root <span class="token number">16384</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:54 lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建符号连接使用参数 <code>-s</code> 来建立：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">ln</span> <span class="token parameter variable">-s</span> hhh hhh_soft<span class="token punctuation">;</span> ll <span class="token parameter variable">-i</span>
total <span class="token number">24</span>
<span class="token number">16</span> -rw-r--r--. <span class="token number">2</span> root root     <span class="token number">4</span> Sep <span class="token number">10</span> 01:57 hhh
<span class="token number">16</span> -rw-r--r--. <span class="token number">2</span> root root     <span class="token number">4</span> Sep <span class="token number">10</span> 01:57 hhh_hark
<span class="token number">12</span> lrwxrwxrwx. <span class="token number">1</span> root root     <span class="token number">3</span> Sep <span class="token number">10</span> 02:04 hhh_soft -<span class="token operator">></span> hhh
<span class="token number">11</span> drwx------. <span class="token number">2</span> root root <span class="token number">16384</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:54 lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="隐藏属性"><a class="markdownIt-Anchor" href="#隐藏属性"></a> 隐藏属性</h1>
<p>文件和文件夹主要的隐藏属性列表如下：</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>访问此文件的 atime 不会被修改，可避免读写较慢的机器过度访问磁盘。</td>
</tr>
<tr>
<td>S</td>
<td>加上此属性后，任何修改都将立即写入硬盘，不在内存中缓存。</td>
</tr>
<tr>
<td>a</td>
<td>设置此属性后，文件只能增加数据，不能删除也不能修改数据。设置在目录上，目录内的文件不能删除。</td>
</tr>
<tr>
<td>c</td>
<td>此文件会自动压缩，读取时自动解压缩。储存时会先进行压缩。</td>
</tr>
<tr>
<td>d</td>
<td>当 dump 执行时，此文件或目录不会被 dump 备份。</td>
</tr>
<tr>
<td>i</td>
<td>文件不能删除、改名、修改。设置在目录上表示不允许在目录内建立和删除文件。</td>
</tr>
<tr>
<td>s</td>
<td>如果文件被删除，立即将原先位置填充，完全销毁数据。</td>
</tr>
<tr>
<td>u</td>
<td>开启回收站功能，文件被删除后还能恢复。</td>
</tr>
</tbody>
</table>
<p>上表是在 ext 文件系统中可用的属性，xfs 文件系统仅支持部分隐藏属性。</p>
<h2 id="设置隐藏属性"><a class="markdownIt-Anchor" href="#设置隐藏属性"></a> 设置隐藏属性</h2>
<p>使用 <code>chattr</code> 命令来给文件设置隐藏属性。例如给文件 1 加上 i 和 a 属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ chattr +ia <span class="token number">1</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token number">1</span>
rm: cannot remove <span class="token string">'1'</span><span class="token builtin class-name">:</span> Operation not permitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>取消文件的隐藏属性 i：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ chattr <span class="token parameter variable">-i</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果设置对象是文件夹，使用 <code>-R</code> 可以递归修改，在文件夹中新建的文件会继承隐藏属性。</p>
<h2 id="显示文件隐藏属性"><a class="markdownIt-Anchor" href="#显示文件隐藏属性"></a> 显示文件隐藏属性</h2>
<p>使用 <code>lsattr</code> ming’l 来查看文件或目录的隐藏属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lsattr <span class="token parameter variable">-R</span>
---------------- ./anaconda-ks.cfg
---------------- ./audit

./audit:
---------------- ./audit/mvau.log
---------------- ./audit/b.log

---------------- ./2
--S--adA-------- ./3

./3:
--S--adA-------- ./3/3

--S-ia-A-------- ./1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件内容查看</title>
    <url>/1251081056/</url>
    <content><![CDATA[<h1 id="一次性输出"><a class="markdownIt-Anchor" href="#一次性输出"></a> 一次性输出</h1>
<p>在 Linux 中，可以使用 <code>cat</code> 和 <code>tac</code> 命令一次性将文本内容打印出来，即将标准输入的数据复制到标准输出。</p>
<p><code>cat</code> 是 Catenate 的缩写，从第一行开始显示文件内容。另外一个重要的应用是组合多个文件。如果没有指定文件或文件为 <code>-</code>，则从标准输入读取。</p>
<p>例如，要查看 <code>c.log</code> 文件的内容，并使用 <code>-b</code> 参数来显示行号（不计空行，计空行使用 <code>-n</code>）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token parameter variable">-b</span> c.log 
     <span class="token number">1</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061.322</span>:415<span class="token punctuation">)</span>
     <span class="token number">2</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_END <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061</span>
     <span class="token number">3</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_START <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">163</span>
     <span class="token number">4</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-A</code> 参数可以将特殊字符打印出来，例如 <code>[Tab]</code> 显示为 <code>^I</code>，<code>[Enter]</code> 换行显示为 <code>$</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token parameter variable">-nA</span> c.log 
     <span class="token number">1</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061.322</span>:415<span class="token punctuation">)</span>
     <span class="token number">2</span> ^Itype<span class="token operator">=</span>USER_END <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061</span>$
     <span class="token number">3</span>   <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_START <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">163</span>$
     <span class="token number">4</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audi$
     <span class="token number">5</span> $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cat</code> 命令的一个常见用途是将多个文件内容组合到一个文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> ftp.sh ca.srl <span class="token operator">>></span> newfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>tac</code> 命令可以倒序输出文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">tac</span> c.log 
<span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audi
  <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_START <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">163</span>
       <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_END <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061</span>
<span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061.322</span>:415<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要将每行的内容反转输出，可以使用 <code>rev</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">rev</span> ftp.sh 
gro.miv.ptf nepo
bup <span class="token function">dc</span>
txt.tahWdniFoTerehW teg
eyb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>nl</code> 命令可以自定义行号位置打印文件内容，例如给行号加零填充：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">nl</span> <span class="token parameter variable">-n</span> rz c.log 
000001 <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061.322</span>:415<span class="token punctuation">)</span>
000002  <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_END <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061</span>
000003   <span class="token assign-left variable">type</span><span class="token operator">=</span>USER_START <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">163</span>
000004 <span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="阅读文件"><a class="markdownIt-Anchor" href="#阅读文件"></a> 阅读文件</h1>
<p>使用 <code>more</code> 命令可以查看文件内容并逐页翻阅：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">more</span> nohup.out
Vim: Warning: Output is not to a terminal
Vim: Warning: Input is not from a terminal
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
--More--<span class="token punctuation">(</span><span class="token number">23</span>%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当文件内容超过一页时，会提示 <code>--More--</code>，此时可以使用以下按键进行操作：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>空格(space)</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>回车(enter)</td>
<td>向下滚动一行</td>
</tr>
<tr>
<td>/字符串</td>
<td>向下搜索关键字,定位到那一页</td>
</tr>
<tr>
<td>:f</td>
<td>显示文件名以及当前行数</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>b</td>
<td>往回翻页,对管道无用</td>
</tr>
<tr>
<td>v</td>
<td>调用 vi 编辑器</td>
</tr>
</tbody>
</table>
<p>使用<code>less</code>命令查看文件时，可以使用方向键进行导航：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">less</span> nohup.out
Vim: Warning: Output is not to a terminal
Vim: Warning: Output is not to a terminal
<span class="token builtin class-name">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进入查看页面后，可以使用以下键盘按键：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>PageUp/PageDown</td>
<td>向上/向下翻页。</td>
</tr>
<tr>
<td>方向键上/方向键下</td>
<td>向上/向下滚动一行。</td>
</tr>
<tr>
<td>/字符串&amp;?字符串</td>
<td>向下&amp;向上查询字符串。</td>
</tr>
<tr>
<td>n/N</td>
<td>向下/向上重复查询。</td>
</tr>
<tr>
<td>v</td>
<td>启动 vi 编辑器编辑当前文件。</td>
</tr>
<tr>
<td>q</td>
<td>离开。</td>
</tr>
<tr>
<td>h</td>
<td>帮助文件。</td>
</tr>
</tbody>
</table>
<p>可以通过设置环境变量 PAGER 来指定希望使用的分页程序。</p>
<h1 id="数据选取"><a class="markdownIt-Anchor" href="#数据选取"></a> 数据选取</h1>
<p><code>head</code> 命令可以设定从文件开头开始选取多少行的内容。例如，要查看 nohup.out 文件的前 2 行内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">head</span> <span class="token parameter variable">-2</span> nohup.out
Vim: Warning: Output is not to a terminal
Vim: Warning: Input is not from a terminal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>tail</code> 命令则从文件后面开始取多少行的内容并显示出来。例如，要选取查看 list.txt 文件最后 1 行的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> <span class="token parameter variable">-1</span> list.txt
/tmp/etc/skel/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以加上 <code>-f</code> 参数来持续打印文件内容，这在查看日志文件时非常有用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> nohup.out 
Vim: Error reading input, exiting<span class="token punctuation">..</span>.sers package to sandbox the tcsd daemon:/devv
Vim: Finished.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这将持续打印 nohup.out 文件的内容，直到手动停止命令。</p>
<h1 id="二进制文件查看"><a class="markdownIt-Anchor" href="#二进制文件查看"></a> 二进制文件查看</h1>
<p>使用普通的文本查看命令查看二进制文件会显示乱码，可以使用 <code>od</code> 命令来查阅二进制文件。</p>
<p>例如，以默认八进制方式查看 <code>passwd</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ od /bin/passwd <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">10</span>
0000000 042577 043114 000402 000001 000000 000000 000000 000000
0000020 000003 000076 000001 000000 031110 000000 000000 000000
0000040 000100 000000 000000 000000 062620 000000 000000 000000
0000060 000000 000000 000100 000070 000011 000100 000035 000034
0000100 000006 000000 000005 000000 000100 000000 000000 000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 <code>-t</code> 参数指定显示格式，例如将十六位进制与 ASCII 字符同时显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ od <span class="token parameter variable">-t</span> xCc c.log
0000000  <span class="token number">74</span>  <span class="token number">79</span>  <span class="token number">70</span>  <span class="token number">65</span>  3d  <span class="token number">43</span>  <span class="token number">52</span>  <span class="token number">45</span>  <span class="token number">44</span>  5f  <span class="token number">44</span>  <span class="token number">49</span>  <span class="token number">53</span>  <span class="token number">50</span>  <span class="token number">20</span>  6d
          t   y   p   e   <span class="token operator">=</span>   C   R   E   D   _   D   I   S   P       m
0000020  <span class="token number">73</span>  <span class="token number">67</span>  3d  <span class="token number">61</span>  <span class="token number">75</span>  <span class="token number">64</span>  <span class="token number">69</span>  <span class="token number">74</span>  <span class="token number">28</span>  <span class="token number">31</span>  <span class="token number">36</span>  <span class="token number">33</span>  <span class="token number">31</span>  <span class="token number">31</span>  <span class="token number">37</span>  <span class="token number">38</span>
          s   g   <span class="token operator">=</span>   a   u   d   i   t   <span class="token punctuation">(</span>   <span class="token number">1</span>   <span class="token number">6</span>   <span class="token number">3</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">7</span>   <span class="token number">8</span>
0000040  <span class="token number">30</span>  <span class="token number">36</span>  <span class="token number">31</span>  2e  <span class="token number">33</span>  <span class="token number">32</span>  <span class="token number">32</span>  3a  <span class="token number">34</span>  <span class="token number">31</span>  <span class="token number">35</span>  <span class="token number">29</span>  3a  <span class="token number">20</span>  <span class="token number">70</span>  <span class="token number">69</span>
          <span class="token number">0</span>   <span class="token number">6</span>   <span class="token number">1</span>   <span class="token builtin class-name">.</span>   <span class="token number">3</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token builtin class-name">:</span>   <span class="token number">4</span>   <span class="token number">1</span>   <span class="token number">5</span>   <span class="token punctuation">)</span>   <span class="token builtin class-name">:</span>       p   i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>hexdump</code> 命令来查看二进制文件，唯一区别是 <code>hexdump</code> 默认情况下以十六进制显示数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ hexdump <span class="token parameter variable">-C</span> /usr/bin/scsi_temperature
00000000  <span class="token number">23</span> <span class="token number">21</span> 2f <span class="token number">62</span> <span class="token number">69</span> 6e 2f <span class="token number">62</span>  <span class="token number">61</span> <span class="token number">73</span> <span class="token number">68</span> 0a 0a <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span>  <span class="token operator">|</span><span class="token comment">#!/bin/bash..###|</span>
00000010  <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span>  <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span> <span class="token number">23</span>  <span class="token operator">|</span><span class="token comment">################|</span>
*
00000050  0a <span class="token number">23</span> 0a <span class="token number">23</span> <span class="token number">20</span> <span class="token number">20</span> <span class="token number">43</span> <span class="token number">68</span>  <span class="token number">65</span> <span class="token number">63</span> 6b <span class="token number">20</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">65</span> <span class="token number">20</span>  <span class="token operator">|</span><span class="token builtin class-name">.</span><span class="token comment">#.#  Check the |</span>
00000060  <span class="token number">74</span> <span class="token number">65</span> 6d <span class="token number">70</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">61</span> <span class="token number">74</span>  <span class="token number">75</span> <span class="token number">72</span> <span class="token number">65</span> <span class="token number">20</span> 6f <span class="token number">66</span> <span class="token number">20</span> <span class="token number">74</span>  <span class="token operator">|</span>temperature of t<span class="token operator">|</span>
00000070  <span class="token number">68</span> <span class="token number">65</span> <span class="token number">20</span> <span class="token number">67</span> <span class="token number">69</span> <span class="token number">76</span> <span class="token number">65</span> 6e  <span class="token number">20</span> <span class="token number">53</span> <span class="token number">43</span> <span class="token number">53</span> <span class="token number">49</span> <span class="token number">20</span> <span class="token number">64</span> <span class="token number">65</span>  <span class="token operator">|</span>he given SCSI de<span class="token operator">|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面二进制数据显示方式叫规范格式（Canonical Format）。每行最左边是十六进制表示的偏移，中间 16 个字节是实际数据，右边为相应 ASCII 字符。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 基本目录操作</title>
    <url>/735422586/</url>
    <content><![CDATA[<h1 id="路径"><a class="markdownIt-Anchor" href="#路径"></a> 路径</h1>
<p>根据文件名写法不同，可以分为绝对路径（absolute）和相对路径（relative）：</p>
<ul>
<li>
<p><strong>绝对路径</strong></p>
<p>由根目录开始写起的文件或目录名称，定义了在虚拟目录结构中该文件的确切位置。例如 <code>/home/base/.bashrc</code>。</p>
</li>
<li>
<p><strong>相对路径</strong></p>
<p>基于目前位置的路径写法。例如 <code>./base/.bashrc</code> 或 <code>../../home/base/</code> 等。</p>
</li>
</ul>
<p>Linux 中有些比较特殊的目录表示符号如下表：</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>此层目录</td>
</tr>
<tr>
<td>…</td>
<td>上一层目录</td>
</tr>
<tr>
<td>-</td>
<td>前一个工作目录</td>
</tr>
<tr>
<td>~</td>
<td>目前用户身份所在的主文件夹</td>
</tr>
<tr>
<td>~account</td>
<td>代表 account 这个用户的主文件夹</td>
</tr>
</tbody>
</table>
<h1 id="显示当前目录"><a class="markdownIt-Anchor" href="#显示当前目录"></a> 显示当前目录</h1>
<p>使用 <code>pwd</code> 命令（Print Working Directory 的缩写）显示目前所在目录。</p>
<p>如显示当前路径：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 init.d<span class="token punctuation">]</span>$ <span class="token builtin class-name">pwd</span>
/etc/init.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>追踪链接文件显示实际路径加 <code>-P</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 init.d<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /var/mail <span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span>
/var/mail
<span class="token punctuation">[</span>root@101c7 mail<span class="token punctuation">]</span>$ <span class="token builtin class-name">pwd</span> <span class="token parameter variable">-P</span>
/var/spool/mail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="切换目录"><a class="markdownIt-Anchor" href="#切换目录"></a> 切换目录</h1>
<p>切换目录使用 <code>cd</code> 命令（change directory 的缩写）。</p>
<p>例如进入到用户 abc 主目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> ~abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用绝对路径写法进入到 <code>/etc/fonts/</code> 目录中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /etc/fonts/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>回退到上个目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> -
/etc/fonts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用相对路径写法进入到上级目录下的 init.d 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 fonts<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/init.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不接参数直接进入当前用户的主目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> <span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span>
/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="新建目录"><a class="markdownIt-Anchor" href="#新建目录"></a> 新建目录</h1>
<p>使用 <code>mkdir</code> 命令（make directory 的简写）来建立目录。</p>
<p>如建立一个名为 test1 的目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> test1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以用 -p 参数建立嵌套目录，比如建立 test2 文件夹后，在其下建立 test3 文件夹：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> test2/test3 <span class="token punctuation">;</span> ll test2
total <span class="token number">0</span>
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Sep <span class="token number">9</span> 04:19 test3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以同时创建多个目录，目录名之间用空格分开。如一次建立 a1、b2、c3 三个文件夹：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> a1 b2 c3 <span class="token punctuation">;</span> ll
total <span class="token number">3</span>
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Sep <span class="token number">9</span> 04:21 a1
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Sep <span class="token number">9</span> 04:21 b2
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Sep <span class="token number">9</span> 04:21 c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建目录默认权限是 755，可以用 <code>-m</code> 参数在创建目录时自定义权限，比如建立权限为 777 的文件夹 decay：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 a1<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-m</span> <span class="token number">777</span> decay <span class="token punctuation">;</span> ll
total <span class="token number">0</span>
drwxrwxrwx. <span class="token number">2</span> root root <span class="token number">6</span> Sep <span class="token number">9</span> 04:23 decay<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="删除空目录"><a class="markdownIt-Anchor" href="#删除空目录"></a> 删除空目录</h1>
<p>使用 <code>rmdir</code> 只能删除空目录。例如同时删除空目录 b2、c3：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">rmdir</span> b2 c3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以加入 <code>-p</code> 来递归删除多级空目录。例如删除 decay 目录下面的空文件夹 cc，再删除 decay 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 a1<span class="token punctuation">]</span>$ ll
total <span class="token number">0</span>
drwxrwxrwx. <span class="token number">3</span> root root <span class="token number">16</span> Sep <span class="token number">9</span> 04:31 decay
<span class="token punctuation">[</span>root@101c7 a1<span class="token punctuation">]</span>$ <span class="token function">rmdir</span> <span class="token parameter variable">-p</span> decay/cc/ <span class="token punctuation">;</span> ll
total <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查询目录大小"><a class="markdownIt-Anchor" href="#查询目录大小"></a> 查询目录大小</h1>
<p>使用 <code>du</code> 可以查询到文件或目录所占大小。列出当前目录下面所有文件与目录大小：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">du</span> <span class="token parameter variable">-ha</span>
102K    ./100K2
21M     ./1.copy
21M     ./lost+found/1.copy
21M     ./lost+found
<span class="token number">2</span>.0K    ./a.cfg
21M     ./1.iso
<span class="token number">2</span>.0K    ./users/jill.txt
<span class="token number">4</span>.0K    ./users
102K    ./100K
61M     <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最末一行显示整个文件夹大小为 61MB。</p>
<p>只统计当前目录下文件和文件夹（不列出文件夹下文件）大小，不包括隐藏文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">du</span> <span class="token parameter variable">-sh</span> *
102K    ./100K
102K    ./100K2
21M     ./1.copy
21M     ./1.iso
<span class="token number">2</span>.0K    ./a.cfg
21M     ./lost+found
<span class="token number">4</span>.0K    ./users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>统计包含隐藏文件和文件夹大小：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-250 ~<span class="token punctuation">]</span>$ <span class="token function">du</span> <span class="token parameter variable">-h</span> --max-depth<span class="token operator">=</span><span class="token number">1</span>
<span class="token number">0</span>       ./.pki
16M     ./.kube
16K     ./.ssh
<span class="token number">0</span>       ./.git-credential-cache
<span class="token number">8</span>.0K    ./.docker
124K    ./.mizu
40K     ./.cache
<span class="token number">1</span>.7G    ./1
<span class="token number">1</span>.7G    <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>NTP 服务</title>
    <url>/3532663001/</url>
    <content><![CDATA[<h1 id="ntp-通信协议"><a class="markdownIt-Anchor" href="#ntp-通信协议"></a> NTP 通信协议</h1>
<p>NTP 是网络校时协议（Network Time Protocol）。为了修正因为 BIOS 内部芯片问题导致与标准时间（UTC, Coordinated Universal Time）存在的偏差，而通过网络进行时间同步（Synchronize）。此外，DTSS（Digital Time Synchronization Protocol）也可实现同样的功能。</p>
<p>Linux 系统中有两个时间：</p>
<ul>
<li>软件时钟：Linux 自己的系统时间，从 1970.1.1 开始记录的时间参数。</li>
<li>硬件时钟：计算机在 BIOS 记录的实际时间（UTC），通过硬件记录。写入硬件时钟使用 <code>hwclock</code> 命令。</li>
</ul>
<p>NTP 服务器使用的端口为 123，通过 UDP 数据包传输。</p>
<p>我国授时中心服务器的 IP 地址为 210.72.145.44。</p>
<h1 id="ntp-服务器层次"><a class="markdownIt-Anchor" href="#ntp-服务器层次"></a> NTP 服务器层次</h1>
<p>NTP 时间服务器采用类似分级构架（Stratum）来处理时间的同步化，并且采用 Server/Client 的主从构架。网络上会提供一些主要与次要时间服务器，均属于第一级（stratum-1）与第二级（stratum-2）的时间服务器。</p>
<p>如果我们的 NTP 服务器向二级时间服务器要求时间同步，那么我们的 NTP 服务器即为三级（stratum-3）时间服务器。依此传递下去，最多可达 15 个阶层。</p>
<p>一般在进行 NTP 主机的设置时，会选择多台上层的 Time Server 来作为我们的 NTP 服务器校时用，这样可以避免某台时间服务器下线造成无法更新。</p>
<h1 id="服务器设置"><a class="markdownIt-Anchor" href="#服务器设置"></a> 服务器设置</h1>
<p>启动 NTP 服务器需要安装 <code>ntp</code> 软件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> ntp ntpdate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改时区可以使用 <code>timedatectl</code> 命令。例如修改成上海时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ timedatectl set-timezone <span class="token string">"Asia/Shanghai"</span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ timedatectl
      Local time: Mon <span class="token number">2021</span>-10-11 05:07:51 CST
  Universal time: Sun <span class="token number">2021</span>-10-10 <span class="token number">21</span>:07:51 UTC
        RTC time: Sun <span class="token number">2021</span>-10-10 <span class="token number">21</span>:07:51
       Time zone: Asia/Shanghai <span class="token punctuation">(</span>CST, +0800<span class="token punctuation">)</span>
     NTP enabled: <span class="token function">yes</span>
NTP synchronized: <span class="token function">yes</span>
 RTC <span class="token keyword">in</span> <span class="token builtin class-name">local</span> TZ: no
      DST active: n/a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器配置文件位于 <code>/etc/ntp.conf</code>，其内容修改部分如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/ntp.conf
restrict <span class="token number">210.72</span>.145.44
restrict <span class="token number">192.168</span>.2.0 mask <span class="token number">255.255</span>.255.0 nomodify
server <span class="token number">210.72</span>.145.44
server cn.pool.ntp.org
driftfile /var/lib/ntp/drift
keys /etc/ntp/keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>restrict</code> 行用来控制权限，上面运行局域网内主机通过这部主机来进行网络校时。其他可用参数有：</p>
<ul>
<li>ignore：拒绝所有类型的 NTP 连接。</li>
<li>nomodify：客户端不能使用 <code>ntpc</code> 和 <code>ntpq</code> 来修改服务器的时间参数，但可以通过这部主机来进行网络校时。</li>
<li>noquery：客户端不能使用 <code>ntpq</code> 和 <code>ntpc</code> 等命令来查询时间服务器，不提供 NTP 的网络校时。</li>
<li>notrap：不提供 trap 这个远程时间登录（remote event logging）的功能。</li>
<li>notrust：拒绝没有认证的客户端。</li>
</ul>
<p><code>server</code> 行用来设置上层 NTP 服务器地址，可以设置多个。</p>
<p><code>driftfile</code> 行指定的文件用来记录本机与上层 Time Server 之间振荡周期频率误差。</p>
<p><code>keys</code> 行指定用来认证的密钥文件。</p>
<h1 id="服务器管理"><a class="markdownIt-Anchor" href="#服务器管理"></a> 服务器管理</h1>
<p>配置修改完毕后，可以通过 <code>systemctl</code> 来启动 <code>ntpd</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> ntpd
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span> <span class="token function">grep</span> ntpd
udp     <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">10.1</span>.1.1:123            <span class="token number">0.0</span>.0.0:*                           <span class="token number">30097</span>/ntpd 
udp     <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.2.254:123       <span class="token number">0.0</span>.0.0:*                           <span class="token number">30097</span>/ntpd  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通常，NTP 启动后需要十五分钟内才会和上层 NTP 服务器连接上。可以使用 <code>ntpstat</code> 命令查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ntpstat
synchronised to NTP server <span class="token punctuation">(</span><span class="token number">111.230</span>.189.174<span class="token punctuation">)</span> at stratum <span class="token number">3</span>
   <span class="token function">time</span> correct to within <span class="token number">212</span> ms
   polling server every <span class="token number">64</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面结果显示时间矫正了 212 ms，并且每隔 64 秒会主动去更新时间。</p>
<p>使用 <code>ntpq</code> 可以查询我们的 NTP 与相关上层 NTP 的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ntpq <span class="token parameter variable">-p</span>
     remote           refid      st t when poll reach   delay   offset  jitter
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
 <span class="token number">210.72</span>.145.44   .INIT.          <span class="token number">16</span> u    -   <span class="token number">64</span>    <span class="token number">0</span>    <span class="token number">0.000</span>    <span class="token number">0.000</span>   <span class="token number">0.000</span>
 ntp.wdc1.us.lea <span class="token number">130.133</span>.1.10     <span class="token number">2</span> u    <span class="token number">9</span>   <span class="token number">64</span>   <span class="token number">37</span>  <span class="token number">251.796</span>   <span class="token parameter variable">-4.729</span>   <span class="token number">0.252</span>
*111.230.189.174 <span class="token number">100.122</span>.36.4     <span class="token number">2</span> u   <span class="token number">65</span>   <span class="token number">64</span>   <span class="token number">17</span>   <span class="token number">21.948</span>   <span class="token parameter variable">-6.164</span>   <span class="token number">0.297</span>
+ntp6.flashdance <span class="token number">194.58</span>.202.20    <span class="token number">2</span> u   <span class="token number">66</span>   <span class="token number">64</span>   <span class="token number">17</span>  <span class="token number">237.552</span>   <span class="token parameter variable">-6.099</span>   <span class="token number">5.726</span>
+2402:f000:1:416 <span class="token number">186.195</span>.4.16     <span class="token number">2</span> u   <span class="token number">62</span>   <span class="token number">64</span>   <span class="token number">17</span>   <span class="token number">33.758</span>   <span class="token parameter variable">-3.033</span>   <span class="token number">0.306</span>
<span class="token parameter variable">-sv1.ggsrv.de</span>    <span class="token number">205.46</span>.178.169   <span class="token number">2</span> u   <span class="token number">65</span>   <span class="token number">64</span>   <span class="token number">17</span>  <span class="token number">280.605</span>   <span class="token number">10.958</span>   <span class="token number">2.962</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>各字段意义如下：</p>
<ul>
<li>remote：NTP 主机的 IP 或主机名。最左边符号 * 代表目前使用的 NTP，符号 + 表示已连接的备选 NTP。</li>
<li>refid：参考的上层 NTP 主机地址。</li>
<li>st：stratum 阶层等级。</li>
<li>when：上次时间同步操作后的时间间隔。</li>
<li>poll：下次时间同步更新操作的时间间隔。</li>
<li>reach：已经向上层 NTP 服务器要求更新的次数。</li>
<li>delay：网络传输过程当中的延迟，单位为微秒。</li>
<li>offset：时间补偿结果，单位为毫秒。</li>
<li>jitter：Linux 系统时间与 BIOS 硬件时间的差异时间，单位为微秒。</li>
</ul>
<h1 id="客户端设置"><a class="markdownIt-Anchor" href="#客户端设置"></a> 客户端设置</h1>
<p>客户端可以使用 <code>ntpdate</code> 命令来与服务器同步时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ntpdate <span class="token number">192.168</span>.2.254
<span class="token number">11</span> Oct <span class="token number">15</span>:54:26 ntpdate<span class="token punctuation">[</span><span class="token number">125764</span><span class="token punctuation">]</span>: adjust <span class="token function">time</span> server <span class="token number">192.168</span>.2.254 offset <span class="token parameter variable">-0.002236</span> sec
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">date</span><span class="token punctuation">;</span>hwclock <span class="token parameter variable">-r</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同步之后使用 <code>hwclock</code> 写入到硬件。<code>ntpd</code> 服务端和客户端之间时间误差不允许超过 1000 秒。</p>
<p>服务端配置也是修改 <code>/etc/ntp.conf</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/ntp.conf 
restrict <span class="token number">192.168</span>.2.254
server <span class="token number">192.168</span>.2.254<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后启动 <code>ntpd</code> 服务，客户端就会自动到服务端同步时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl start ntpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 网络基础知识</title>
    <url>/799638542/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<p>Internet（1980 年代）由 ARPANET（1970 年代）发展而来。</p>
<h2 id="网络硬件"><a class="markdownIt-Anchor" href="#网络硬件"></a> 网络硬件</h2>
<p>组成计算机网络的组件大致有下面这些：</p>
<ul>
<li>节点（Node）：节点是具有网络地址（IP）设备的统称。</li>
<li>服务器（Server）：提供数据给用户的主机就能被称为一台服务器。</li>
<li>工作站（Workstation）：任何可以在网络输入的设备都可以是工作站。</li>
<li>客户端（Client）：主动发起连接去请求数据的，就可以称为客户端。</li>
<li>网卡（NIC，Network Interface Card）：用于提供网络连接的设备。</li>
<li>网络接口：利用软件设计出来的网络接口，主要提供网络地址（IP）。</li>
<li>网络拓扑（Topology）：各个节点在网络上面的链接方式，通常指物理连接方式。</li>
<li>网关（Gateway）：具有两个以上的网络接口，可以连接两个以上不同网段的设备叫网关设备。</li>
</ul>
<h2 id="网络范围"><a class="markdownIt-Anchor" href="#网络范围"></a> 网络范围</h2>
<p>依据网络的大小范围分为两类：局域网（LAN，Local Area Network）和广域网（WAN，Wide Area Network）。</p>
<h2 id="osi-七层协议"><a class="markdownIt-Anchor" href="#osi-七层协议"></a> OSI 七层协议</h2>
<p>OSI（Open System Interconnection）七层协议是将整个网络连接过程分为数个层次（Layer），每个层次都有特定的独立功能。这样可以针对不同层次来编写程序，每个层次之间的功能互不干扰。</p>
<p>越接近硬件的层次为底层，越接近应用的层次为高层。无论是接收端还是发送端，每一层都只认识对方同一层次的数据。数据通过层层包装后发送，再由接收方层层解包。总体情况如下图所示：</p>
<p><img data-src="../../../images/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="OSI七层模型" /></p>
<p>上层包裹会放入下层数据中，而数据前面则是这个数据的报头。第二层比较特殊，它分为两个子层来处理数据。</p>
<p>每一层负责的任务如下：</p>
<ul>
<li>
<p>Layer 1 <strong>物理层</strong>（Physical Layer）</p>
<p>由于网络传输介质只能传送 0 和 1，因此物理层必须定义所使用的传输设备的电压与信号等。同时还必须了解数据帧转成比特流的编码方式，最后连接实际传输介质并发送/接收比特信号。代表设备有中继器（Repeater）和集线器。</p>
</li>
<li>
<p>Layer 2 <strong>数据链路层</strong>（Data-Link Layer）</p>
<p>这一层比较特殊，分两个子层进行数据的转换操作。下层是实体定义，上层是软件封装定义。代表设备是网桥（Bridge）：</p>
<ul>
<li>
<p>面向硬件主要负责的是 MAC（Media Access Control），也称这个数据包裹为 MAC 数据帧（Frame）。MAC 是网络接口设备所能处理的主要数据包，也是被物理层编码成比特流的数据。MAC 必须要经过通信协议来取得网络介质的使用权，目前最常用的是 IEEE 802.3 的以太网络协议。</p>
</li>
<li>
<p>面向软件部分则是由逻辑链接层（LLC, Logical Link Control）所控制，主要处理来自上层的数据包（Packet）并转成 MAC 的格式，负责的工作包括信息交换、流量控制、错误问题的处理等。</p>
</li>
</ul>
</li>
<li>
<p>Layer 3 <strong>网络层</strong>（Network Layer）</p>
<p>网络地址（IP, Internet Protocol）就是在这一层定义。同时也定义出计算机之间的连接建立，终止与保持，数据包的传输路径选择等。因此这层除了 IP 外，就是数据包能否到达目的地的路由概念了。代表设备是路由器（Router）。</p>
</li>
<li>
<p>Layer 4 <strong>传输层</strong> (Transport Layer)</p>
<p>这一层定义了发送端与接收端的连接技术，如 TCP / UDP 技术。同时包括该技术的数据包格式，数据包的发送，流程控制，传输过程的检查与重新发送等，以确保各个资料数据包可以正确无误地到达目的端。</p>
</li>
<li>
<p>Layer 5 <strong>会话层</strong> (Session Layer)</p>
<p>定义了两个地址之间连接信道的连接与中断。此外，也可建立应用程序之间的会话，提供其他加强型服务，如网络管理，建立与断开，会话控制等。会话层用来确定网络服务建立的连接。</p>
</li>
<li>
<p>Layer 6 <strong>表示层</strong> (Presentation Layer)</p>
<p>将来自本地应用程序的数据格式转换或重新编码成网络的标准格式，然后再交给下面的传输层等来处理。所以，这一层主要定义的是网络服务之间的数据格式转换，包括数据的加密解密。</p>
</li>
<li>
<p>Layer 7 <strong>应用层</strong> (Application Layer)</p>
<p>应用层本身并不属于应用程序所有，而是定义了应用程序如何进入该层的沟通接口，以将数据接收或发送给应用程序，并最终展示给用户。</p>
</li>
</ul>
<h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2>
<p>TCP 协议是可靠的，面向连接的传输层协议，它能保证数据按顺序抵达目的地。该协议会把数据分割成数据包，也叫分段（Segment）。如果接收端没有向发送方返回分段确认，发送方将使用重传方案（Retransmission Scheme）来重发该分段。</p>
<p>IP 是把数据通过 Internet 发送实际所使用的方法或协议。与 TCP 不同的是，IP 是一个无连接的协议，这意味着在进行通信的两个端点之间没有连续的连接，数据的组合由 TCP 来完成。</p>
<p>其实 TCP/IP 也是使用 OSI 七层协议的观念，只是简化为四层：</p>
<ul>
<li>OSI 七层协议中的数据链路层和物理层，在 TCP/IP 中统一为网络接口层。</li>
<li>网络层没变，主要应用是 IP/ICMP。</li>
<li>传输层也没变，主要应用是 TCP/UDP。</li>
<li>而应用层，表示层和会话层合并称为应用层。相关应用有 HTTP，FTP，SSH，SMTP 等。</li>
</ul>
<p>用网页浏览器举例，一个网站浏览的过程像这样：</p>
<ol>
<li>应用程序：打开浏览器输入网址按下回车后，网址和相关数据会被浏览器包成数据包，向下开始传输。</li>
<li>应用层：由应用层提供的 HTTP 通信协议，将浏览器的数据封装起来，并给予一个应用层报头，丢给传输层。</li>
<li>传输层：由于 HTTP 为可靠连接，因此将数据丢入 TCP 封装内，并给予一个 TCP 封装的报头，然后传给网络层。</li>
<li>网络层：将 TCP 数据封装到 IP 数据包内，再给予一个 IP 包头（来源与目标 IP），传给网络接口层。</li>
<li>网络接口层：如果使用以太网络时，IP 会根据 CSMA/CD 标准，封装到 MAC 数据帧中，并给予 MAC 帧头，再转成比特流后，利用传输介质开始传送。</li>
<li>服务器接收到数据包后，以反方向解开，交给对应的层次进行分析。最后 WWW 服务软件获知请求的数据内容，将数据依循上面流程一层层封装，传送到用户手上。</li>
</ol>
<h1 id="tcpip-网络接口层相关协议"><a class="markdownIt-Anchor" href="#tcpip-网络接口层相关协议"></a> TCP/IP 网络接口层相关协议</h1>
<p>TCP/IP 最底层的网络接口层主要与硬件关系密切，下面分段解析相关硬件和协议。</p>
<h2 id="广域网设备"><a class="markdownIt-Anchor" href="#广域网设备"></a> 广域网设备</h2>
<p>广域网上使用的设备较多，最常见的有以下一些：</p>
<ul>
<li>
<p>传统电话拨号连接 PPP 协议（Point-to-Point Protocol）</p>
<p>早期网络通过调制解调器加上电话线以及电脑的九针串行端口，通过 PPP 协议拨号获得网络 IP 参数来上网。速度很慢且会占用电话线路。PPP 支持 TCP/IP、NetBEUI、IPX/SPX 等通信协议。</p>
</li>
<li>
<p>整合服务数字网络（ISDN，Integrated Services Digital Network）</p>
<p>利用电话线路来联网，只是连接两端都需要有 ISDN 的调制解调器来提供连接功能。ISDN 的传输有多种信道可以使用，并能将多个信道整合应用，因此速度可以翻倍提升。例如美国规格使用 23 个以上信道来连接，每个 B 信道速度约 64Kbps，总速度可达 1.5Mbps 左右。</p>
</li>
<li>
<p>非对称数字用户环路（ADSL，Asymmetric Digital Subscriber Line）的 PPPoE 协议（PPP over Ethernet）</p>
<p>也是通过电话线来拨号取得 IP，不过使用的是电话的高频部分，与一般语音电话的频率不同，因此不影响电话使用。由于在中国上传/下载的带宽不同，因此才被称为非对称的环路。ADSL 同样使用调制解调器，只是它通过 PPPoE 的方法，将 PPP 仿真在以太网卡上，因此电脑需要通过一张网卡来连接到调制解调器，并通过拨号程序来取得新的接口（ppp0）。</p>
</li>
<li>
<p>电缆调制解调器（Cable Modem）</p>
<p>通过有线电视使用的缆线作为网络信号介质，同样需要具备调制解调器来连接到 ISP，以取得网络参数来上网。Cable Modem 的带宽主要是共享型，所以通常具有区域性。</p>
</li>
</ul>
<h3 id="局域网设备"><a class="markdownIt-Anchor" href="#局域网设备"></a> 局域网设备</h3>
<p>局域网环境中，最常用的是以太网，其次还有光纤信道等。</p>
<p>早前 IEEE 所制定的以太网络标准为 802.3 的 IEEE 10BASE5，这个标准定义是：10 代表传输速度 10 Mbps，BASE 表示采用基带信号进行传输，5 表示每个网络节点之间最长可达 500 米。</p>
<p>传输介质也就是网线使用的是类似传统电话线的双绞线（Twisted Pair Ethernet），IEEE 将这种线路的以太网传输方式制定成 10BASE-T 的标准。10BASE-T 使用的是 10 Mbps 全速运行且采用非屏蔽双绞线（UTP）的网线。此外，10BASE-T 的 UTP 网线可以使用星形连接（Star），也就是以一个集线器为中心来连接各网络设备的方法。</p>
<p>后来 IEEE 制定了 802.3u 这个支持到 100 Mbps 传输速度的 100BASE-T 标准，这个标准同 10BASE-T 差异不大，只是双绞线制作需要更精良，同时也已经支持使用了四对绞线的网线，也就是目前很常见的 8 芯网线。这种网线常称为五类线（CAT5，Category 5）。这种传输速度的以太网就被称为 Fast Ethernet。</p>
<p>至于千兆网络 Gigabit Ethernet 使用的网线等级为 CAT5e 或 CAT6。每当传输速度增加，线材的电磁效应互相干扰会加强，因此对网线的要求更严格。</p>
<p>RJ-49 网络接口因为每条芯线的对应不同分为 568A 与 568B 接头：</p>
<table>
<thead>
<tr>
<th>接头/线序</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>568A</td>
<td>白绿</td>
<td>绿</td>
<td>白橙</td>
<td>蓝</td>
<td>白蓝</td>
<td>橙</td>
<td>白棕</td>
<td>棕</td>
</tr>
<tr>
<td>568B</td>
<td>白橙</td>
<td>橙</td>
<td>白绿</td>
<td>蓝</td>
<td>白蓝</td>
<td>绿</td>
<td>白棕</td>
<td>棕</td>
</tr>
</tbody>
</table>
<p>对于 100 Mbps 网络，实际使用的只有 1、2、3、6 芯，根据网线连接不同设备线序不同，又分两种连接方式：</p>
<ul>
<li>
<p>交叉线：一边 568A 一边 568B 的接头时叫交叉线，用在直连两台主机的网卡。</p>
</li>
<li>
<p>直连线：两头都是 568A 或 568B 时叫直连线，用来连接主机网卡与网络设备。</p>
</li>
</ul>
<h2 id="csmacd"><a class="markdownIt-Anchor" href="#csmacd"></a> CSMA/CD</h2>
<p>以太网的核心是以太网卡，每张网卡在生产时都会有一个 MAC 地址（Media Access Control），也称为硬件地址或物理地址。以太网卡之间的数据传输采用 CSMA/CD（Carrier Sense Multiple Access with Collision Detection）标准。</p>
<p>假设有主机 A 和主机 B 通过 10 Mbps 集线器（Hub）物理连接在一起，A 到 B 的数据传输流程如下：</p>
<ol>
<li>监听介质使用情况（Carrier Sense）：A 主机在发送网络数据包之前，需要先监听网络介质，确认没有其他设备正在使用才会发送数据。</li>
<li>多点传输（Multiple Access）：A 主机发送的数据会被集线器复制一份，并发送给连接到该集线器的所有主机。但由于目标是主机 B，其他主机会丢弃这些数据帧。</li>
<li>冲突检测（Collision Detection）：发送的数据帧附带有冲突检测功能。如果在数据发送过程中出现网络阻塞，导致数据帧损坏，A 主机会在等待超时时间后重新发送原始数据包。</li>
</ol>
<h2 id="mac-封装格式"><a class="markdownIt-Anchor" href="#mac-封装格式"></a> MAC 封装格式</h2>
<p>CSMA/CD 发送的数据帧实际上就是 MAC，它是在整个网络硬件上传输数据的最小单位。数据帧中包含两个非常重要的数据：目标网卡的 MAC 地址和来源网卡的 MAC 地址。MAC 数据帧的内容如下所示：</p>
<p><img data-src="../../../images/MAC%E6%95%B0%E6%8D%AE%E5%B8%A7.png" alt="MAC数据帧" /></p>
<p>MAC 地址范围从 00:00:00:00:00:00 到 FF:FF:FF:FF:FF:FF，这 6 Bytes 中，前 3 Bytes 为厂商代码，后 3 Bytes 是配置码。这个 MAC 地址直连仅在局域网内使用，在广域网中 MAC 地址会跟随网络设备变化。</p>
<p>数据帧内的数据大小范围为 46 Bytes 到 1500 Bytes。当最小为 46 Bytes 数据量时，加上包内其他固定 18 Bytes 数据量，则数据帧总大小最少为 64 Bytes。假如实际数据量不足 46 Bytes，则会填充到 46 Bytes。</p>
<h2 id="mtu-最大传输单元"><a class="markdownIt-Anchor" href="#mtu-最大传输单元"></a> MTU 最大传输单元</h2>
<p>标准以太网数据帧所能传送的数据量最大值也叫最大传输单元（MTU，Maximum Transmission Unit）。标准定义为 1500 Bytes，不过每种网络接口的 MTU 都不相同，有定义为 1492 Bytes 的 MTU（802.2+802.3 组合封装）。超过 MTU 的数据包会被拆解分发。</p>
<p>在千兆网中另有一个参数叫巨帧（Jumbo Frame），等同于 MTU 的作用，一般定义到 9000 Bytes。但由于大多数网络设备都使用 MTU 标准，因此巨帧只用于内部网络传输数据，以此提高网速。</p>
<h2 id="集线器与交换机"><a class="markdownIt-Anchor" href="#集线器与交换机"></a> 集线器与交换机</h2>
<p>使用集线器的网络共享设备之间可能会发生冲突，交换机（Switch）可以解决这一问题。</p>
<p>在一个支持 OSI 第二层的交换机上，会有一个特别的内存，用来记录每个交换机端口与其连接的网卡 MAC 地址。当传输数据时直接通过交换机内存再转给目标主机，这样克服了数据包冲突问题。</p>
<p>交换机端口有全双工/半双工（full-duplex/half-duplex）两种工作模式，全双工表示端口上行和下行带宽可同时达到端口速度。半双工则是上行和下行共享端口速度，类似于集线器工作模式。</p>
<p>交换机拥有自动协调网口速度功能（Auto-negotiation，又叫 N-Way），可以自动协调出最高的传输速度来通信。此外，交换机还能自动识别交叉线或直连线来自适应。</p>
<h1 id="tcpip-网络层相关数据包"><a class="markdownIt-Anchor" href="#tcpip-网络层相关数据包"></a> TCP/IP 网络层相关数据包</h1>
<p>Internet 其实就是 TCP/IP 这个通信协议的通称，由 Inter NIC 所管理。</p>
<h2 id="ip-数据包封装"><a class="markdownIt-Anchor" href="#ip-数据包封装"></a> IP 数据包封装</h2>
<p>目前 IP 分为 IPv4 和 IPv6，IPv6 用来解决 IPv4 地址不足的问题，地址位可达 128 位。</p>
<p>IPv4 封装报头格式如下：</p>
<p><img data-src="../../../images/IP%E6%8A%A5%E5%A4%B4.jpg" alt="IP报头" /></p>
<p>下面分别说明：</p>
<ul>
<li>
<p>版本 (Version)：</p>
<p>声明这个 IP 数据包的版本，比如 IPv4 或 IPv6。</p>
</li>
<li>
<p>IP 报头长度 (IHL, Internet Header Length)：</p>
<p>告知这个 IP 数据包的报头长度，以 4 个字节为一个单位记录 IP 报头长度。</p>
</li>
<li>
<p>服务类型 (Type Of Service)：</p>
<p>这个项目内容为 PPPDTRCU，表示这个 IP 数据包的服务类型：</p>
<ul>
<li>PPP：表示这个数据包的优先级，目前很少使用。</li>
<li>D：若为 0 表示一般延迟 (Delay)，若为 1 表示低延迟。</li>
<li>T：若为 0 表示一般传输量 (Throughput)，若为 1 表示高传输量。</li>
<li>R：若为 0 表示一般可靠度 (Reliability)，若为 1 表示高可靠度。</li>
<li>C：若为 0 表示选择一般路由 (Router)，若为 1 表示选择最快路由。</li>
<li>U：保留未被使用。</li>
</ul>
</li>
<li>
<p>总长度 (Total Length)：</p>
<p>指这个 IP 数据包的总容量，包括报头与数据部分 (Data) 部分，最大可达 65535Bytes (64KB)。</p>
</li>
<li>
<p>识别码 (Identification)：</p>
<p>当 IP 数据包太大进行分割后，这个字段用来标记分段的数据属于哪个 IP 数据包。</p>
</li>
<li>
<p>特殊标志 (Flags)：</p>
<p>其字段为 0DM：</p>
<ul>
<li>D：为 0 表示可以分段，为 1 表示不可分段。</li>
<li>M：为 0 表示此 IP 为最后分段，为 1 表示非最后分段。</li>
</ul>
</li>
<li>
<p>分段偏移 (Fragment Offset)：</p>
<p>表示这个 IP 分段在原始 IP 数据包中的位置，以 8 字节为 1 单位编号。有了总长度、识别码、特殊标志和分段偏移后，就能将 IP 分段重组为 IP 数据包了。</p>
</li>
<li>
<p>生存时间 (TTL, Time to Live)：</p>
<p>指这个 IP 数据包的生存时间，范围为 0~255。当这个 IP 数据包通过一个路由器时，TTL 就会减 1，TTL 等于 0 时，数据包会被直接丢弃。</p>
</li>
<li>
<p>协议代码（Protocol Number）：</p>
<p>IP 数据包中包含来自传输层和网络层本身的数据，此字段用于记录每种数据包的内容。具体的代码和对应的数据包协议名称如下表所示：</p>
<table>
<thead>
<tr>
<th>IP 内代码</th>
<th>数据包协议名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ICMP（Internet Control Message Protocol）</td>
</tr>
<tr>
<td>2</td>
<td>IGMP（Internet Group Management Protocol）</td>
</tr>
<tr>
<td>3</td>
<td>GGP（Gateway-to-Gateway Protocol）</td>
</tr>
<tr>
<td>4</td>
<td>IP（Internet Protocol）</td>
</tr>
<tr>
<td>6</td>
<td>TCP（Transmission Control Protocol）</td>
</tr>
<tr>
<td>8</td>
<td>EGP（Exterior Gateway Protocol）</td>
</tr>
<tr>
<td>17</td>
<td>UDP（User Datagram Protocol）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>报头校验码（Header Checksum）：</p>
<p>用于检查 IP 报头是否存在错误。</p>
</li>
<li>
<p>来源 IP 地址（Source Address）：</p>
<p>是一个长度为 32 位的 IP 地址。</p>
</li>
<li>
<p>目标 IP 地址（Destination Address）：</p>
<p>对应于来源 IP 地址的目标 IP 地址。</p>
</li>
<li>
<p>其他参数（Options）：</p>
<p>提供额外的功能，包括安全处理机制、路由记录、时间戳、严格和宽松的来源路由等。</p>
</li>
<li>
<p>补齐项目（Padding）：</p>
<p>当 Options 的内容不足时，使用 Padding 来补足 32 位比特位。</p>
</li>
</ul>
<h2 id="ip-地址组成与分级"><a class="markdownIt-Anchor" href="#ip-地址组成与分级"></a> IP 地址组成与分级</h2>
<p>IP 地址由 32 位的 0 或 1 组成。为了便于记忆，将其分为 4 段，每段 8 位字节转换成十进制，能表示的范围是 0~255，这就是最常见的 IP 地址书写方式。</p>
<p>前三段数字称为网络号码（Net_ID），最后一段数字称为主机号码（Host_ID）。在<strong>同一网段</strong>内定义，意味着处于同一个物理网段内的主机 IP 具有相同的 Net_ID，并且具有唯一的 Host_ID。</p>
<p>在同一网段内，Host_ID 不能重复。此外，Host_ID=0 代表整个网段地址（网络 IP），而 Host_ID=255 表示广播地址（广播 IP）。</p>
<p>为了便于管理 IP 地址，国际互联网号码分配机构（Inter NIC）将整个 IP 网段分为五个类别：</p>
<ul>
<li>A 类：0.0.0.0~127.255.255.255</li>
<li>B 类：128.0.0.0~191.255.255.255</li>
<li>C 类：192.0.0.0~223.255.255.255</li>
<li>D 类：224.0.0.0~239.255.255.255</li>
<li>E 类：240.0.0.0~255.255.255.255</li>
</ul>
<p>其中，D 类用于组播（multicast），E 类保留未使用的网段。</p>
<h2 id="ip-地址种类与获得"><a class="markdownIt-Anchor" href="#ip-地址种类与获得"></a> IP 地址种类与获得</h2>
<p>在 IPv4 中，IP 地址有两种类型：</p>
<ul>
<li>
<p>公共 IP（Public IP）</p>
<p>这些 IP 地址是由 Inter NIC 统一规划的，只有这种 IP 地址才能连接到互联网。</p>
</li>
<li>
<p>私有 IP（Private IP）</p>
<p>也称为保留 IP，这些 IP 地址不能直接连接到互联网，主要用于局域网内的主机连接规划。私有 IP 地址共分为三段：</p>
<ul>
<li>A 类：10.0.0.0~10.255.255.255</li>
<li>B 类：172.16.0.0~172.31.255.255</li>
<li>C 类：192.168.0.0~192.168.255.255</li>
</ul>
</li>
</ul>
<p>此外，还存在特殊的环回 IP 网段（127.0.0.0/8），也称为 “lo” 网络。最初它被用于测试操作系统内部循环所需的网络，同时也可供系统内部需要使用网络接口的服务使用。</p>
<p>例如，在没有安装网卡的情况下，想要测试已安装的服务是否正常工作，就可以使用这个内部环回网络。默认的主机（localhost）IP 是 127.0.0.1，因此如果启动了 WWW 服务器，只需在本机浏览器中使用 127.0.0.1 即可直接访问该服务。</p>
<p>获取 IP 地址的方式有两种：</p>
<ul>
<li>
<p>手动配置静态（Static）IP 地址</p>
<p>直接编辑配置文件来指定 IP 相关参数。</p>
</li>
<li>
<p>自动获取（DHCP）IP 地址</p>
<p>在局域网内有一台主机或设备负责管理所有计算机的网络设备。客户端网络启动时主动向该服务器请求获取 IP 参数，并在获取后将其配置在本机上。</p>
</li>
</ul>
<h2 id="子网掩码"><a class="markdownIt-Anchor" href="#子网掩码"></a> 子网掩码</h2>
<p>子网掩码（Netmask）用于将 IP 地址段划分为多个子网。它以位数的形式表示已被占用的地址。例如，占用 8 位用十进制表示就是 255.0.0.0，占用 23 位用十进制表示就是 255.255.254.0。</p>
<p>例如，192.168.1.0 255.255.255.0 表示此 IP 段的 Host_ID=192.168.1 已被占用且不可更改，只能修改 Net_ID，即 IP 的可用范围为 192.168.1.0~192.168.1.255。</p>
<p>再例如，192.168.1.0 255.255.255.128 同样表示此 IP 段的 Host_ID=192.168.1 已被占用且不可更改，剩下的 Net_ID 拆开来看：</p>
<ul>
<li>二进制 00000000 = 十进制 0，代表第一个可用的 Net_ID=0；</li>
<li>二进制 10000000 = 十进制 128，也就是子网掩码占用了 25 位；</li>
<li>二进制 01111111 = 十进制 127，代表能更改的 Net_ID 最大值为 127；</li>
</ul>
<p>因此，整个网段的可用 IP 范围为 192.168.1.0~192.168.1.127。</p>
<p>对于第二个子网 192.168.1.128 255.255.255.128，同样将 Net_ID 拿出来看：</p>
<ul>
<li>二进制 10000000 = 十进制 128，代表第二个子网的 Net_ID 从 128 开始计算；</li>
<li>二进制 10000000 = 十进制 128，子网掩码占用不可更改的位没有变化；</li>
<li>二进制 11111111 = 十进制 255，代表第二个子网能更改的 Net_ID 最大值为 255；</li>
</ul>
<p>因此，第二个网段的可用 IP 范围为 192.168.1.128~192.168.1.255。</p>
<p>再举个例子，假设 IP 地址和子网掩码设置为 192.168.1.43 255.255.255.240，计算 IP 段的范围：</p>
<ul>
<li>二进制 00101011 = 十进制 43，此为设置 IP 的 Net_ID 值；</li>
<li>二进制 11110000 = 十进制 240，得到子网掩码占用的位数为 28 位；</li>
<li>二进制 00100000 = 十进制 32，此为网段开始 IP 的 Net_ID 值；</li>
<li>二进制 00101111 = 十进制 47，此为网段结束 IP 的 Net_ID 值；</li>
</ul>
<p>可得此网段的 IP 范围为 192.168.1.32~192.168.1.47，除去表示网段的地址 192.168.1.32 和表示广播的地址 192.168.1.47 ，共 14 个可用地址。下一网段从 48 也就是二进制 00110000 开始。</p>
<p>总结一下，子网掩码位数和网段内可用 IP 数的关系为（子网掩码位数小于等于 30）：IP 数=2<sup>32-子网掩码位数</sup>-2</p>
<h2 id="路由网关"><a class="markdownIt-Anchor" href="#路由网关"></a> 路由网关</h2>
<p>在同一个局域网内，可以通过 IP 广播的方式来实现数据传输，而非局域网数据传输依靠路由器来协助。</p>
<p>网关（Gateway）/ 路由器（Router）的功能是负责在不同网络之间进行数据包传递（IP Forwarding），并且具有管理路由表的功能。因此，主机的 IP 和网关的 IP 必须在同一个网段内。</p>
<p>假设 network1（192.168.0.0/24）的 user1 需要与 network2（192.168.1.0/24）的 user2 进行通信，具体过程如下：</p>
<ol>
<li>当 user1 有数据包需要发送时，主机会查阅 IP 数据包报头中的目标 IP 地址。</li>
<li>如果目标 IP 和本机 IP 在同一网段内，则直接通过局域网将数据传递给对方。</li>
<li>但是，user2 和 user1 不在同一个网络中，因此，user1 的主机会分析自己的路由表中是否存在其他符合条件的路由设置值。如果没有，则将 IP 数据包发送给默认路由器（Default Gateway）进行处理。</li>
<li>路由器接收到 user1 的数据包后，也会分析路由表，找到 user2 的地址信息，然后将 user1 的数据包发送给 user2。</li>
</ol>
<h2 id="arprarp"><a class="markdownIt-Anchor" href="#arprarp"></a> ARP/RARP</h2>
<p>以太网主要通过 MAC 地址传输数据，因此在局域网环境下使用网络地址解析协议（ARP，Address Resolution Protocol）。ARP 通过发送 ARP 数据包来查询目标 IP 对应的 MAC 地址，并将记录写入本机的 ARP 表中（保存在内存中，保留 20 分钟）。</p>
<p>RARP（Reverse ARP）是反向网络解析协议，它通过 MAC 地址获取目标 IP 地址。</p>
<p>可以使用 <code>arp -n</code> 命令查看本机已记录的 ARP 表数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ arp <span class="token parameter variable">-n</span>
Address                  HWtype  HWaddress           Flags Mask            Iface
<span class="token number">192.168</span>.2.1              ether   e0:4f:bd:b8:8b:e0   C                     ens33
<span class="token number">192.168</span>.2.102            ether   <span class="token number">10</span>:7b:44:91:aa:08   C                     ens33
<span class="token number">192.168</span>.2.101            ether   0c:9d:92:83:db:35   C                     ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以使用 <code>-s</code> 和 <code>-d</code> 参数手动添加或删除记录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ arp <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.202 05:3E:43:9B:AF:FD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于 ARP 表会动态更新，通常不需要手动修改它。</p>
<h2 id="icmp-协议"><a class="markdownIt-Anchor" href="#icmp-协议"></a> ICMP 协议</h2>
<p>ICMP，即因特网控制报文协议（Internet Control Message Protocol），用于在通过 IP 协议互联的主机和网关之间发送流量控制信息，它是一种错误检测与报告机制，主要用于确保网络的连接状态和连接的正确性。</p>
<p>ICMP 通过 IP 数据包进行数据传输，并有许多不同的类型用于检测和报告。以下是一些常见的类型：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>类别名称与意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Echo Reply（表示响应信息）</td>
</tr>
<tr>
<td>3</td>
<td>Destination Unreachable（表示目的地不可达）</td>
</tr>
<tr>
<td>4</td>
<td>Source Quench（当路由器负载过高时，可使发送端停止发送）</td>
</tr>
<tr>
<td>5</td>
<td>Redirect（用于重定向路由路径信息）</td>
</tr>
<tr>
<td>8</td>
<td>Echo Request（请求响应信息）</td>
</tr>
<tr>
<td>11</td>
<td>Time Exceeded for a Datagram（当某些路由传输过程中超时时，通知源设备该数据包已被忽略）</td>
</tr>
<tr>
<td>12</td>
<td>Parameter Problem on a Datagram（当 ICMP 数据包重复之前的错误时，回复关于参数错误的信息）</td>
</tr>
<tr>
<td>13</td>
<td>Timestamp Request（请求对方发送时间信息，用于计算路由时间差异，以满足同步性协议的要求）</td>
</tr>
<tr>
<td>14</td>
<td>Timestamp Reply（响应 Timestamp Request 信息）</td>
</tr>
<tr>
<td>15</td>
<td>Information Request（在 RARP 协议应用之前，用于在开机时获取网络信息）</td>
</tr>
<tr>
<td>16</td>
<td>Information Reply（响应 Information Request 信息）</td>
</tr>
<tr>
<td>17</td>
<td>Address Mask Request（用于查询子网掩码的配置信息）</td>
</tr>
<tr>
<td>18</td>
<td>Address Mask Reply（响应子网掩码查询信息）</td>
</tr>
</tbody>
</table>
<p>发送 ICMP 数据包最常用的命令是 <code>ping</code> 和 <code>traceroute</code>。</p>
<h1 id="tcpip-传输层相关数据包"><a class="markdownIt-Anchor" href="#tcpip-传输层相关数据包"></a> TCP/IP 传输层相关数据包</h1>
<p>网络层的 IP 数据包只负责将数据送到目标主机，数据包是否被接收成功是传输层来控制。</p>
<h2 id="tcp-协议"><a class="markdownIt-Anchor" href="#tcp-协议"></a> TCP 协议</h2>
<p>传输层的数据打包成 TCP 数据包，报头内容如下：</p>
<p><img data-src="../../../images/TCP%E6%8A%A5%E5%A4%B4.jpg" alt="TCP报头" /></p>
<p>下面分别说明：</p>
<ul>
<li>
<p>源端口和目标端口（Source Port &amp; Destination Port）</p>
<p>指定数据发送的端口和目标端口，可以说是 TCP 数据包上最重要的参数。由于是 16 位，因此端口最大可达 65535 号。服务器与客户端要达成连接的话，两边都要有一个对应端口建立连接信道，让数据通过这个信道进行沟通。</p>
</li>
<li>
<p>数据包序号（Sequence Number）</p>
<p>由于 TCP 数据包必须放入 IP 数据包中，如果 TCP 数据太大时，就需要进行分段，这个字段用来记录每个数据包的序号，可以让接收端将 TCP 的数据重组。</p>
</li>
<li>
<p>回应序号（Acknowledgment）</p>
<p>为了确认服务端确实收到了客户端的数据包，服务端会将回应序号响应给客户端。</p>
</li>
<li>
<p>数据补偿（Data Offset）</p>
<p>为了确认整个 TCP 数据包的大小，需要这个标志来说明数据包字段的起始位置。</p>
</li>
<li>
<p>保留（Reserved）</p>
<p>未使用的保留字段。</p>
</li>
<li>
<p>控制标志码（Control Flag）</p>
<p>用来说明连接的状态，整个字段有 6 个比特，分别代表 6 个标志位。若为 1 表示启用：</p>
<ul>
<li>URG（Urgent）：若为 1 代表该包为紧急数据包，接收端应该要紧急处理，同时会启用紧急指针。</li>
<li>ACK（Acknowledge）：若为 1 代表该包为响应数据包。</li>
<li>PSH（Push Function）：若为 1 代表要求对方立即传送缓冲区内的其他对应数据包，无需等待缓冲区满了才送。</li>
<li>RST（Reset）：若为 1 代表连接会被立即结束，无需等待终止确认手续。这是个强制结束的连接，发送方已断线。</li>
<li>SYN（Synchronous）：若为 1 表示发送端希望双方建立同步处理，也就是要求建立连接。</li>
<li>FIN（Finish）：若为 1 表示传输结束，通知对方数据已完毕。是否立即断开连接取决于发送方是否还在等待对方的响应。</li>
</ul>
</li>
<li>
<p>滑动窗口（Window）</p>
<p>用来控制数据包的流量，可以告知对方目前本机的接收缓冲区还可以接收多少数据包。当 Window = 0 时，代表缓冲区已满，所以要暂停传输数据。</p>
</li>
<li>
<p>确认校验码（Checksum）</p>
<p>在数据发送前，发送端会进行一次校验操作，并将校验值填入此字段。接收端收到数据包后会再次进行校验，对比校验和值，如果不一致，会认为数据包已损坏，要求发送端重新发送该数据包。</p>
</li>
<li>
<p>紧急数据指针（Urgent Pointer）</p>
<p>该字段仅在 URG = 1 时有效，用来指示紧急数据所在的位置。</p>
</li>
<li>
<p>选项（Options）</p>
<p>目前该字段主要用于指示接收端可接收的最大数据段容量。如果不使用该字段，则表示可以使用任意数据段大小。</p>
</li>
<li>
<p>填充字段（Padding）</p>
<p>类似于 IP 数据包需要固定的 32 位包头，由于选项字段长度不固定，所以需要使用填充字段来对齐。</p>
</li>
</ul>
<p>在 Linux 下，启用小于 1024 的端口需要以 root 身份进行，因此也被称为特权端口。一般客户端会使用大于 1024 且未被使用的端口号来请求数据。</p>
<p>由于网络是双向的，要建立连接，服务器和客户端都需要提供 IP 地址和端口号。这对数据称为套接字对（Socket Pair），也就是来源 IP + 来源端口（Source Address + Source Port）对应目的 IP + 目的端口（Destination Address + Destination Port）。</p>
<h2 id="tcp-三次握手"><a class="markdownIt-Anchor" href="#tcp-三次握手"></a> TCP 三次握手</h2>
<p>TCP 被称为可靠数据传输协议，是通过许多机制来实现，其中最重要的就是三次握手（Three-way Handshake）功能：</p>
<ul>
<li>
<p>数据包发起</p>
<p>当客户端想要对服务端连接时，必须送出一个请求连接的数据包。客户端使用一个大于 1024 号的随机端口作沟通端口。在 TCP 报头当中带有 <code>SYN=1</code>，<code>Sequence=1001</code> 的主动连接。</p>
</li>
<li>
<p>数据包接收与确认数据包发送</p>
<p>当服务器接到这个数据包，并确定要接收这个数据包后，就会开始制作一个同时带有 <code>SYN=1</code>，<code>ACK=1</code> 的数据包。其中 Acknowledge 的号码是要给客户端确认用，所以该数字会比上一步骤里的 Sequence 号码加一 <code>Acknowledge=1002</code>。服务器也要确认客户端确实可以接收数据包才行，所以也会发送一个 <code>Sequence=2001</code> 的数据包给客户，并等待客户给服务端的回应。</p>
</li>
<li>
<p>回送确认数据包</p>
<p>当客户端收到来自服务器端的 <code>Acknowledge=1002</code> 后，就能够确认之前哪个请求数据包被正确接收。接下来如果客户端也同意与服务器端建立连接，会再次发送一个 <code>ACK=1</code>， <code>Acknowledge=2002</code> 确认数据包给服务器。</p>
</li>
<li>
<p>最后取得确认</p>
<p>若一切顺利，服务端收到 <code>ACK=1</code>， <code>Acknowledge=2002</code> 的数据包后，就能建立起这次连接了。</p>
</li>
</ul>
<p>这就是网络双向确认。无论服务端还是客户端，都必须通过一次 <code>SYN</code> 与 <code>ACK</code> 来建立连接，总共三次会话。</p>
<h2 id="udp-协议"><a class="markdownIt-Anchor" href="#udp-协议"></a> UDP 协议</h2>
<p>UDP 协议全称为 User Datagram Protocol，即用户数据报协议。UDP 不提供可靠的传输模式，接收端在接收到数据包后，不会回复响应数据包（ACK）给客户端。反过来说，这可以使希望自己进行流量控制的应用程序具有更大的灵活性。例如，NFS 的流量控制，以及 DNS 和 TRP 等协议的多播数据，可以向多个客户端同时进行广播。</p>
<p>报头数据内容如下：</p>
<p><img data-src="../../../images/UDP%E6%8A%A5%E5%A4%B4.jpg" alt="UDP报头" /></p>
<p>由于无需确认对方是否正确收到数据，故报头数据较少，因此，UDP 可以在数据区填入更多内容。</p>
<h1 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h1>
<p>路由的主要功能是规划网络数据包的传递方式与方向。</p>
<h2 id="路由器"><a class="markdownIt-Anchor" href="#路由器"></a> 路由器</h2>
<p>路由器的主要功能是转发网络数据包。具体而言，路由器会分析来源端数据包的 IP 包头，在包头内找到要送达的目标 IP，通过路由器本身的路由表来将数据包传送到下一个目标（Next Hop）。</p>
<p>Linux 本身具备转发数据包的能力，因此也被称为软路由。转发功能默认情况下是关闭的，可以手动设置并启用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/sys/net/ipv4/ip_forward
<span class="token number">0</span>
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"net.ipv4.ip_forward = 1"</span> <span class="token operator">>></span> /etc/sysctl.conf
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">sysctl</span> <span class="token parameter variable">-p</span>
net.ipv4.ip_forward <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="路由表"><a class="markdownIt-Anchor" href="#路由表"></a> 路由表</h2>
<p>在 Linux 系统下，路由表是按照小网络到大网络的顺序排列的。路由表主要根据以下几种情况进行设计：</p>
<ul>
<li>
<p>基于网络接口的路由</p>
<p>当主机上存在多个网络接口时，就会存在相应的路由。这个路由用于指向与网络接口所在同一网段的网关或网口。</p>
</li>
<li>
<p>手动或默认路由</p>
<p>使用 <code>route</code> 命令添加路由时，规划的路径必须能够直达（Broadcast）到网口或 IP 的情况下才有效。例如，指定通过 <code>ens37</code> 端口访问 <code>192.168.3.0/24</code> 网段:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route <span class="token function">add</span> <span class="token parameter variable">-net</span> <span class="token number">192.168</span>.3.0 netmask <span class="token number">255.255</span>.255.0 dev ens37
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route <span class="token parameter variable">-n</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.2.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">100</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token number">192.168</span>.2.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">100</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token number">192.168</span>.3.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> ens37<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有在这样指定后，才能添加一条指向 <code>192.168.3.110</code> 的路由。</p>
</li>
<li>
<p>动态路由</p>
<p>除了使用命令添加和自动生成的路由，还可以通过路由器之间的协商来实现动态路由的环境。但是这需要额外安装软件，例如 <code>zebra</code> 或 <code>Quagga</code>。</p>
</li>
</ul>
<p>Linux 的路由规则是通过内核实现的，所有路由表规则都在内核功能中，也就是在内存中运行。</p>
<h2 id="网络地址转换"><a class="markdownIt-Anchor" href="#网络地址转换"></a> 网络地址转换</h2>
<p>网络地址转换（NAT，Network Address Translation）可以实现 IP 共享的功能。NAT 服务器本身就是一个路由器，它比普通路由器多了一个 IP 转换功能。</p>
<p>路由器的 IP 转发负责让两个网段能够相互通信，而 IP 转换则负责在公共 IP 和私有 IP 之间进行通信。</p>
<p>Linux 的 NAT 服务器可以通过修改数据包的 IP 包头中的源 IP 或目标 IP，使来自私有 IP 的数据包转发到 NAT 服务器的公共 IP，从而直接连接到互联网。</p>
<h2 id="单网卡绑多-ip"><a class="markdownIt-Anchor" href="#单网卡绑多-ip"></a> 单网卡绑多 IP</h2>
<p>一个网卡具备多个 IP 的功能被称为 IP Alias。</p>
<p>IP Alias 功能的最大用途是应急情况下的应用。例如，当电脑前面连接了可配置交换机和路由器时，它们的 IP 不在同一个网段。默认情况下，使用本机 IP 只能访问其中一个设备。这时可以使用 IP Alias 创建一个虚拟端口，并配置另一个设备使用相同网段的 IP，从而在不修改主 IP 的情况下访问两个设备。</p>
<p>由于 IP Alias 是通过实体网卡进行仿真的，因此其状态也会随着实体网卡的变化而变化。如果希望保留虚拟网卡的设置，可以在 <code>/etc/sysconfig/network-scripts</code> 目录下创建相同名称的配置文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Bash 变量</title>
    <url>/2082872357/</url>
    <content><![CDATA[<h1 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h1>
<p>变量简单定义就是让某一个特定字符串代表不固定内容。</p>
<p>在 Bash 中变量分为环境变量和 shell 变量。</p>
<h1 id="显示变量"><a class="markdownIt-Anchor" href="#显示变量"></a> 显示变量</h1>
<p>可以使用 <code>echo $变量名</code> 来查看变量。将变量加上 <code>&#123;&#125;</code> 效果是一样的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token environment constant">$PATH</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个特性可以让字符串扩展变量。例如用 <code>echo</code> 显示 my ${rev}th version。</p>
<h1 id="设置变量"><a class="markdownIt-Anchor" href="#设置变量"></a> 设置变量</h1>
<p>直接用等号连接变量和内容就行了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token assign-left variable">myhome</span><span class="token operator">=</span>ext333
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$myhome</span>
ext333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>myhome='ext333'</code> 的格式也能设置变量。通常变量值有带空格或特殊符号要这样设置。</p>
<p>注意等号两边如果有空格表示等量关系测试。</p>
<h1 id="取消变量"><a class="markdownIt-Anchor" href="#取消变量"></a> 取消变量</h1>
<p>使用 <code>unset 变量名</code> 取消变量设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">unset</span> myhome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>记住删除环境变量时，不用带 <code>$</code>。所有使用变量时用 <code>$</code>，操作变量不使用 <code>$</code>。</p>
<h1 id="变量设置规则"><a class="markdownIt-Anchor" href="#变量设置规则"></a> 变量设置规则</h1>
<ul>
<li>
<p>等号两边不能直接接空格符，变量内容有空格可使用双引号或单引号括起来。</p>
</li>
<li>
<p>变量名只能使用英文字母和数字。按照惯例，变量用全大写字母表示，不以数字开头。</p>
</li>
<li>
<p><strong>双引号</strong>内特殊字符美元（<code>$</code>）、反引号（`）和反斜线（<code>\</code>）可以保持原有特性，例如将 `` 撇号内的命令执行：</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token assign-left variable">varlan</span><span class="token operator">=</span><span class="token string">"lang is <span class="token environment constant">$LANG</span>"</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$varlan</span>
lang is en_US.UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>单引号</strong>内特殊字符仅作为一般字符，因此也称单引号为强引用（Strong Quote），双引号为弱引用（Weak Quote）。</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token assign-left variable">varlang</span><span class="token operator">=</span><span class="token string">'lang is $LANG'</span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token variable">$varlang</span>
lang is <span class="token environment constant">$LANG</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>
<p><strong>转义字符 <code>\</code></strong> 将特殊符号（如 <code>$</code>、<code>\</code>、空格、<code>!</code> 等）变成一般字符。</p>
</li>
<li>
<p><strong>命令替换</strong>特性可以使用 <code>命令</code> 或 <code>$(命令)</code>来引用其他命令的 stdout：</p>
</li>
</ul>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token assign-left variable">varlan</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">)</span></span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token variable">$varlan</span>
<span class="token number">3.10</span>.0-1160.41.1.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>变量增加内容</strong>可用 <code>变量名称=$变量名称+新增内容</code> 或 <code>变量=$&#123;变量&#125;+新增内容</code> 来给变量添加内容：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$&#123;<span class="token environment constant">PATH</span>&#125;</span>:/root
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>若该变量需要在其他子程序执行，用 <code>export</code> 来使当前变量变成环境变量：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>在子程序中修改全局环境变量并不会影响父 shell 中该变量的值，使用 <code>export</code> 也无效。</li>
<li>通常大写字符为系统默认环境变量，自行设置变量可以使用小写字符。</li>
</ul>
<h1 id="查看变量"><a class="markdownIt-Anchor" href="#查看变量"></a> 查看变量</h1>
<p>要查看已定义的环境变量（全局变量），可以使用 <code>env</code> 或 <code>export</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">env</span>
<span class="token assign-left variable"><span class="token environment constant">XDG_SESSION_ID</span></span><span class="token operator">=</span><span class="token number">15</span>
<span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>101c7
<span class="token assign-left variable">SELINUX_ROLE_REQUESTED</span><span class="token operator">=</span>
<span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>vt100
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要查看所有变量，包括自定义变量（局部变量），使用 <code>set</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">set</span>
<span class="token assign-left variable"><span class="token environment constant">XDG_SESSION_ID</span></span><span class="token operator">=</span><span class="token number">15</span>
<span class="token assign-left variable">_</span><span class="token operator">=</span><span class="token number">16710</span>
<span class="token assign-left variable">colors</span><span class="token operator">=</span>/root/.dircolors
<span class="token assign-left variable">varlan</span><span class="token operator">=</span><span class="token number">3.10</span>.0-1160.41.1.el7.x86_64
<span class="token assign-left variable">varlang</span><span class="token operator">=</span><span class="token string">'lang is $LANG'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Bash 没有绝对的全局变量，环境变量即是全局变量又是局部变量。想要知道哪些是绝对的局部变量，只能比较 <code>env</code> 和 <code>set</code> 的输出。</p>
<h1 id="获取变量长度"><a class="markdownIt-Anchor" href="#获取变量长度"></a> 获取变量长度</h1>
<p>指取得变量字符串的长度，可以这样表示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>PATH&#125;</span>
<span class="token number">59</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="path-变量"><a class="markdownIt-Anchor" href="#path-变量"></a> PATH 变量</h1>
<p>环境变量 <code>PATH</code> 定义了可执行文件目录。</p>
<p>如果不同目录中有相同名称文件，则按照先查询到的同名命令先被执行。</p>
<p>不同身份用户默认的 <code>PATH</code> 不同。</p>
<p>查看当前系统中 <code>PATH</code> 变量，显示结果每个目录中间用冒号 <code>:</code> 隔开，按照先后顺序排列：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 a1<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>将 <code>/root</code> 目录加入到 <code>$PATH</code> 变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 a1<span class="token punctuation">]</span>$ <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$PATH</span>"</span>:/root <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="数组变量"><a class="markdownIt-Anchor" href="#数组变量"></a> 数组变量</h1>
<p>数组是能够储存多个值的变量，这些值可以单独引用，也可以作为整个数组来引用。</p>
<p>要设置环境变量，可以把值放到括号里，值与值之间用空格分隔：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token assign-left variable">myarray</span><span class="token operator">=</span><span class="token punctuation">(</span>one two<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>echo</code> 直接变量只能读取第一个值，要引用一个单独的数组元素，必须使用索引值，从 0 开始索引：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$myarray</span> 
one
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>
two<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要显示整个数组变量，可以用星号或@作为通配符放在索引位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
one two
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
<span class="token number">1,11</span>,111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以直接修改某个索引位置的值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ myarray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>删除某个索引值位置的值用 <code>unset</code> 命令，它会清空对应索引值数据，但并不会重建索引：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">unset</span> myarray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>

<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对其他 shell 而言，数组变量可移植性不好，所以不常用到。</p>
<h1 id="特殊变量"><a class="markdownIt-Anchor" href="#特殊变量"></a> 特殊变量</h1>
<p><code>$$</code> 代表 shell 的线程代号(PID)，可以查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">17701</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>$?</code> 代表上一个执行的命令所回传的值，成功执行返回 0，执行错误返回其他状态码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token assign-left variable">141</span><span class="token operator">=</span><span class="token number">55</span>
-bash: <span class="token assign-left variable">141</span><span class="token operator">=</span><span class="token number">55</span>: <span class="token builtin class-name">command</span> not found
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">127</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>退出状态码一般通用参考如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>命令成功结束</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的 shell 命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与 Linux 信号 x 相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过 Ctrl+C 终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody>
</table>
<h1 id="读取变量"><a class="markdownIt-Anchor" href="#读取变量"></a> 读取变量</h1>
<p>要由用户输入来定义变量可以使用<code>read</code>命令。</p>
<p>例如让用户在 30 秒内输入来自定义变量<code>myname</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"type your name: "</span> <span class="token parameter variable">-t</span> <span class="token number">30</span> myname
<span class="token builtin class-name">type</span> your name: ass
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$myname</span>
ass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="声明变量"><a class="markdownIt-Anchor" href="#声明变量"></a> 声明变量</h1>
<p><code>declare</code>或<code>typeset</code>可以用来声明变量，并支持定义变量类型。</p>
<p>可用参数为：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>将变量定义为数组（array）类型。</td>
</tr>
<tr>
<td>-i</td>
<td>将变量定义为整数（integer）类型。</td>
</tr>
<tr>
<td>-x</td>
<td>用法与 <code>export</code> 一样，将变量变成环境变量。</td>
</tr>
<tr>
<td>-r</td>
<td>将变量设置为 readonly 类型，不能修改也不能取消。</td>
</tr>
</tbody>
</table>
<p>例如让变量计算 1+2 的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">declare</span> <span class="token parameter variable">-i</span> <span class="token assign-left variable">sum</span><span class="token operator">=</span><span class="token number">1</span>+2
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$sum</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将变量由环境变量变为非环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">declare</span> <span class="token parameter variable">-r</span> <span class="token function">sum</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">declare</span> <span class="token parameter variable">-p</span> <span class="token function">sum</span>
<span class="token builtin class-name">declare</span> <span class="token parameter variable">-air</span> <span class="token assign-left variable">sum</span><span class="token operator">=</span><span class="token string">'([0]="3")'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>定义数组变量 sum：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">declare</span> <span class="token parameter variable">-a</span> <span class="token function">sum</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ sum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">111</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">222</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;sum<span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>
<span class="token number">111</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以不使用<code>declare</code>提前声明。读取时必须使用<code>$&#123;数组&#125;</code>的方式读取。</p>
<h1 id="变量内容修改"><a class="markdownIt-Anchor" href="#变量内容修改"></a> 变量内容修改</h1>
<p>变量内容修改使用<code>echo</code>设置，设置方式如下表：</p>
<table>
<thead>
<tr>
<th><strong>变量设置方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$&#123;变量#关键字&#125;</code></td>
<td>若变量内容从头开始的数据符合&quot;关键字&quot;，则将符合的最少数据删除。</td>
</tr>
<tr>
<td><code>$&#123;变量##关键字&#125;</code></td>
<td>若变量内容从头开始的数据符合&quot;关键字&quot;，则将符合的最多数据删除。</td>
</tr>
<tr>
<td><code>$&#123;变量%关键字&#125;</code></td>
<td>若变量内容从尾向前的数据符合&quot;关键字&quot;，则将符合的最少数据删除。</td>
</tr>
<tr>
<td><code>$&#123;变量%%关键字&#125;</code></td>
<td>若变量内容从尾向前的数据符合&quot;关键字&quot;，则将符合的最多数据删除。</td>
</tr>
<tr>
<td><code>$&#123;变量/旧字符串/新字符串&#125;</code></td>
<td>若变量内容符合&quot;旧字符串&quot;，则第一个旧字符串会被新字符串替代。</td>
</tr>
<tr>
<td><code>$&#123;变量//旧字符串/新字符串&#125;</code></td>
<td>若变量内容符合&quot;旧字符串&quot;，则全部的旧字符串会被新字符串替代。</td>
</tr>
</tbody>
</table>
<p>例如删除变量中最后一个<code>/root/bin</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$myvar</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myvar<span class="token operator">%</span><span class="token operator">:</span>*bin&#125;</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>表示删除的是右数从 <code>:</code> 开始到 <code>bin</code> 结尾这一段内容。</p>
<p>尽可能多地删除变量从左数 <code>/usr</code> 开始到 <code>local</code> 结束之间的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myvar<span class="token operator">##</span><span class="token operator">/</span>usr*local&#125;</span>
/bin:/usr/sbin:/usr/bin:/root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>尽可能少地删除结果是这样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myvar<span class="token operator">#</span><span class="token operator">/</span>usr*local&#125;</span>
/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="设置变量默认值"><a class="markdownIt-Anchor" href="#设置变量默认值"></a> 设置变量默认值</h1>
<p>当需要变量不存在时使用一个常用设置时，可以用 <code>变量&#123;变量-默认值&#125;</code> 来设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token variable">$myvar1</span>

<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token assign-left variable">myvar1</span><span class="token operator">=</span><span class="token variable">$&#123;myvar1-root&#125;</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$myvar1</span>
root
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token assign-left variable">myvar1</span><span class="token operator">=</span>alice <span class="token punctuation">;</span> <span class="token assign-left variable">myvar1</span><span class="token operator">=</span><span class="token variable">$&#123;myvar1-root&#125;</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$myvar1</span>
alice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果变量为空字符串无法辨别是否没有设置，这时用 <code>变量&#123;变量:-默认值&#125;</code> 来设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token assign-left variable">myvar1</span><span class="token operator">=</span><span class="token string">""</span> <span class="token punctuation">;</span> <span class="token assign-left variable">myvar1</span><span class="token operator">=</span><span class="token variable">$&#123;myvar1<span class="token operator">:-</span>root&#125;</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$myvar1</span>
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>设置方法对比结果如下表：</p>
<table>
<thead>
<tr>
<th>设置方式</th>
<th>str 没有设置</th>
<th>str 为空字符串</th>
<th>str 为非空字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>var=${str-expr}</td>
<td>var=expr</td>
<td>var=</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str:-expr}</td>
<td>var=expr</td>
<td>var=expr</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str+expr}</td>
<td>var=</td>
<td>var=expr</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str:+expr}</td>
<td>var=</td>
<td>var=</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str=expr}</td>
<td>str=expr，var=expr</td>
<td>str 不变，var=</td>
<td>str 不变，var=$str</td>
</tr>
<tr>
<td>var=${str:=expr}</td>
<td>str=expr，var=expr</td>
<td>str=expr，var=expr</td>
<td>str 不变，var=$str</td>
</tr>
<tr>
<td>var=${str?expr}</td>
<td>expr 输出至 stderr</td>
<td>var=</td>
<td>var=str</td>
</tr>
<tr>
<td>var=${str:?expr}</td>
<td>expr 输出至 stderr</td>
<td>expr 输出至 stderr</td>
<td>var=str</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>Bash 基础</title>
    <url>/1325555629/</url>
    <content><![CDATA[<h1 id="shell-的定义"><a class="markdownIt-Anchor" href="#shell-的定义"></a> Shell 的定义</h1>
<p>Shell 是一个命令行解释器，其功能是提供用户操作系统的一个接口，因此 shell 需要可以调用其他软件，用户通过 shell 来操作这些应用程序。也就是只要能够操作应用程序的接口都能够称为 shell。</p>
<p>可以通过检查 <code>/etc/shells</code> 来得知当前系统可用的 shell：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/shells 
/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件 <code>passwd</code> 里记录了用户能使用的 shell：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">grep</span> root
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="bash-特点"><a class="markdownIt-Anchor" href="#bash-特点"></a> bash 特点</h1>
<p>Bash (Bourne Again Shell) 的主要特点有：</p>
<ul>
<li><strong>命令记忆能力</strong>：在命令行中按上下键就能找到输入过的命令， 默认记录最大 1000 条。</li>
<li><strong>命令补全功能</strong>：通过 <code>[Tab]</code> 按键能自动补全命令或文件名。</li>
<li><strong>命令别名功能</strong>：可以使用 <code>alias</code> 命名一些自定义命令。</li>
<li><strong>作业后台控制</strong>：可以将工作丢到后台执行。</li>
<li><strong>使用程序脚本</strong>：可以将很多命令写成一个文件执行。</li>
<li><strong>可使用通配符</strong>：支持常用的通配符比如 <code>*</code> 和 <code>?</code>。</li>
</ul>
<h1 id="命令类型"><a class="markdownIt-Anchor" href="#命令类型"></a> 命令类型</h1>
<p>bash 已经内置了很多命令，可以使用 <code>type</code> 命令来查询命令类型。内建命令（Builtin）和外部命令的区别在于前者不需要使用子程序来进行，它们已经和 shell 编译成一体，作为 shell 工具的组成部分存在。因此内建命令执行速度更快，效率更高。</p>
<p>有些命令两种实现都有，<code>which</code> 命令只显示出外部命令文件，这种情况下要使用外部命令文件直接使用绝对路径运行。</p>
<p>例如查询 <code>man</code> 和 <code>cd</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">type</span> <span class="token function">ls</span>
<span class="token function">ls</span> is aliased to `ls <span class="token parameter variable">--color</span><span class="token operator">=</span>auto'
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">type</span> <span class="token function">man</span>
<span class="token function">man</span> is /usr/bin/man
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">type</span> <span class="token builtin class-name">cd</span>
<span class="token builtin class-name">cd</span> is a shell <span class="token builtin class-name">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示 <code>man</code> 是外部命令，<code>cd</code> 是内部命令，<code>ls</code> 有别名。</p>
<p>对于别名命令可以用 <code>-a</code> 参数进一步查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token builtin class-name">type</span> <span class="token parameter variable">-a</span> <span class="token function">ls</span>
<span class="token function">ls</span> is aliased to `ls <span class="token parameter variable">--color</span><span class="token operator">=</span>auto'
<span class="token function">ls</span> is /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="特殊符号"><a class="markdownIt-Anchor" href="#特殊符号"></a> 特殊符号</h1>
<p>理论上文件名中不要使用以下已被特殊定义的字符：</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#</code></td>
<td>批注符号，一般在脚本中拿来注释说明行。</td>
</tr>
<tr>
<td><code>**</code></td>
<td>转义符号，将特殊字符还原成一般字符。</td>
</tr>
<tr>
<td>|</td>
<td>管道（pipe），分隔两个管道命令的界定。</td>
</tr>
<tr>
<td><code>;</code></td>
<td>连续命令执行分隔符。</td>
</tr>
<tr>
<td><code>~</code></td>
<td>用户的主文件夹。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>使用变量前导符，即是变量之前需要加的变量替代值。</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>作业控制（job control），将命令放置后台工作。</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑运算意义的非（not）。</td>
</tr>
<tr>
<td><code>/</code></td>
<td>目录符号，路径分隔的符号。</td>
</tr>
<tr>
<td><code>&gt;</code>, <code>&gt;&gt;</code></td>
<td>数据流重定向，输出导向，代表替换与追加。</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&lt;&lt;</code></td>
<td>数据流重定向，输入导向。</td>
</tr>
<tr>
<td><code>' '</code></td>
<td>单引号，不具有变量置换功能。</td>
</tr>
<tr>
<td><code>&quot; &quot;</code></td>
<td>双引号，具有变量置换功能。</td>
</tr>
<tr>
<td>` `</td>
<td>套在可以先执行的命令两边，等同于 <code>$()</code>。</td>
</tr>
<tr>
<td><code>( )</code></td>
<td>在中间为子 shell 的起始与结束。</td>
</tr>
<tr>
<td><code>&#123; &#125;</code></td>
<td>在中间为命令块的组合。</td>
</tr>
</tbody>
</table>
<h1 id="命令回传码"><a class="markdownIt-Anchor" href="#命令回传码"></a> 命令回传码</h1>
<p>可以通过命令回传码来判断后续命令是否执行，在两条命令间用 <code>&amp;&amp;</code> 或 <code>||</code> 连起来。具体意义如下：</p>
<table>
<thead>
<tr>
<th><strong>执行的命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd1 &amp;&amp; cmd2</td>
<td>若 cmd1 执行完毕且正确执行(<code>$?</code>=0)，继续执行 cmd2。否则(<code>$?</code>≠b0)不执行 cmd2</td>
</tr>
<tr>
<td>cmd1 || cmd2</td>
<td>若 cmd1 执行完毕且正确执行(<code>$?</code>=0)，不执行 cmd2。否则(<code>$?</code>≠0)继续执行 cmd2</td>
</tr>
</tbody>
</table>
<p>例如判断目录 <code>/tmp/abc</code> 存在时执行 <code>cd</code> 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> /tmp/abc
ls: cannot access /tmp/abc: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果只有 <code>ls</code> 报错，说明并没有执行后面的 <code>cd</code> 命令。</p>
<p>例如判断目录 <code>/tmp/abc</code> 不存在时自动新建目录并进入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /tmp/abc <span class="token operator">||</span> <span class="token function">mkdir</span> /tmp/abc <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> /tmp/abc <span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span>
ls: cannot access /tmp/abc: No such <span class="token function">file</span> or directory
/tmp/abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>假如目录 <code>/tmp/abc</code> 存在时，回传为 0，不执行 <code>mkdir</code> 命令，$?=0 继续向后传，顺利执行 <code>cd</code> 命令。</p>
<p>如果将 <code>||</code> 和 <code>&amp;&amp;</code> 后面的命令调转一下位置，先进行 <code>&amp;&amp;</code> 判断，那么在文件夹不存在的情况下，<code>cd</code> 命令不会运行，但会执行 <code>mkdir</code> 命令，没有达到目标。因此命令执行的顺序很重要。</p>
<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1>
<p>标准输出（stdout，Standard Output）与标准错误输出（stderr，Standard Error Output）指的是命令执行所回传的正常与报错信息。默认情况下都是输出到屏幕上。</p>
<p>标准输入（stdin，Standard Input）一般接受的是用户键盘输入数据。</p>
<h1 id="匿名管道"><a class="markdownIt-Anchor" href="#匿名管道"></a> 匿名管道</h1>
<p>匿名管道（Anonymous Pipe）命令使用 <code>|</code> 符号界定用途时，将前一个命令的标准输出（stdout，不能处理 stderr）转给后一命令做标准输入，管道将自动创建。</p>
<p>每个管道后面接的第一个数据必须是命令，并且这个命令必须能接受 stdin 的数据。例如 <code>less</code>、<code>tail</code>、<code>grep</code> 等。</p>
<h1 id="命名管道"><a class="markdownIt-Anchor" href="#命名管道"></a> 命名管道</h1>
<p>命名管道（FIFO，First-in First-out）和匿名管道相似，不同的是命名管道必须显式创建，并且可以重用。</p>
<p>通常命名管道用来促进两个进程之间的数据交换，这一操作也叫做进程间通信（IPC，Interprocess Communication），程序将在需要时创建，使用然后删除命名管道。</p>
<p>命名管道使用 <code>mkfifo</code> 命令来创建。例如创建一个叫做 <code>fifotest</code> 的管道并输送一些数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mkfifo</span> fifotest
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ll <span class="token operator">></span> fifotest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再另开一个终端通过 <code>cat</code> 来捕获 <code>fifotest</code> 中的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;</span> fifotest 
total <span class="token number">16</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1818</span> Sep <span class="token number">22</span> <span class="token number">21</span>:13 anaconda-ks.cfg
drwxr-xr-x. <span class="token number">4</span> root root  <span class="token number">157</span> Sep <span class="token number">29</span> <span class="token number">18</span>:17 bin
prw-r--r--. <span class="token number">1</span> root root    <span class="token number">0</span> Oct  <span class="token number">4</span> <span class="token number">23</span>:14 fifotest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>管道本身没有储存数据，一旦管道中有数据进入，<code>cat</code> 会立即将其打印出来。</p>
<h1 id="减号-用途"><a class="markdownIt-Anchor" href="#减号-用途"></a> 减号 <code>-</code> 用途</h1>
<p>在管道命令中，经常会使用到前一个命令的 stdout 作为这次的 stdin，某些命令需要用到文件名（例如 <code>tar</code>）来进行处理时，该 stdin 与 stdout 可以利用减号 <code>-</code> 来代替。</p>
<h1 id="子-shell"><a class="markdownIt-Anchor" href="#子-shell"></a> 子 shell</h1>
<p>把命令用括号括起来（可以是连续命令）后，命令列表就成为了进程列表，这些命令被称为一个编组（Grouping）。其作用表示使用一个子 shell 来执行对应命令。</p>
<p>使用 <code>$BASH_SUBSHELL</code> 变量可以检测是否在子 shell 中运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">pwd</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$BASH_SUBSHELL</span> 
/root
<span class="token number">0</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token punctuation">(</span>pwd <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">)</span>
/root
<span class="token number">1</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token punctuation">(</span>pwd <span class="token punctuation">;</span> <span class="token punctuation">(</span>echo <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">))</span>
/root
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建子 shell 可以嵌套运行，一般用来进行多进程处理，例如将程序置入后台运行。但是采用子 shell 的代价太高，必须为子 shell 创建出一个全新的环境，会明显拖慢处理速度。</p>
<p>另一个可以调用子 shell 的方式是使用协程，它能在后台生成一个子 shell 并在这个子 shell 中执行命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ coproc my_sleep <span class="token punctuation">&#123;</span> <span class="token function">sleep</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">41326</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">jobs</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Running                 coproc my_sleep <span class="token punctuation">&#123;</span> <span class="token function">sleep</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数据流重定向"><a class="markdownIt-Anchor" href="#数据流重定向"></a> 数据流重定向</h1>
<p>数据流重定向可以将 stdout 和 stderr 分别传送到其他的文件或设备中去，将由 stdin 的数据改为文件内容来替代输入：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入（stdin）</td>
<td>代码 0，使用 &lt; 或 &lt;&lt;；</td>
</tr>
<tr>
<td>标准输出（stdout）</td>
<td>代码 1，使用 &gt; 或 &gt;&gt;；</td>
</tr>
<tr>
<td>标准错误输出（stderr）</td>
<td>代码 2，使用 2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody>
</table>
<p>例如将根目录文件列表输出到 <code>root.txt</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-la</span> / <span class="token operator">></span> root.txt
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> root.txt 
drwxr-xr-x.   <span class="token number">2</span> root root    <span class="token number">6</span> Apr <span class="token number">11</span>  <span class="token number">2018</span> opt
dr-xr-xr-x. <span class="token number">227</span> root root    <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 proc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>/root</code> 目录信息追加到 <code>root.txt</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-la</span> ~ <span class="token operator"><span class="token file-descriptor important">1</span>>></span> root.txt
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token operator">|</span> <span class="token function">grep</span> root.txt 
-rw-r--r--. <span class="token number">1</span> root root      <span class="token number">2640</span> Sep <span class="token number">11</span> <span class="token number">10</span>:05 root.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>1&gt;</code> 来定义标准输出，因为默认就是代码 1，要输出标准错误，使用 <code>2&gt;</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> xx <span class="token operator"><span class="token file-descriptor important">2</span>>></span> root.txt <span class="token punctuation">;</span> <span class="token function">tail</span> <span class="token parameter variable">-3</span> root.txt
cat: xx: No such <span class="token function">file</span> or directory
-rw-r--r--.  <span class="token number">1</span> root root       <span class="token number">129</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .tcshrc
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">20971520</span> Jul  <span class="token number">7</span> 04:07 TinyCore-current.iso<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将标准输出和标准错误输出分别输出到不同文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-name</span> .bashrc <span class="token operator">></span> list.txt <span class="token operator"><span class="token file-descriptor important">2</span>></span> list_error.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将标准输出和标准错误输出到同一个文件可以用 <code>2&gt;&amp;1</code>，也可以用 <code>&amp;&gt;</code> 来操作：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-name</span> .bashrc <span class="token operator">></span> list.txt <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-name</span> .bashrc <span class="token operator">&amp;></span> list.txt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以将标准错误输出直接丢弃：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-name</span> .bashrc <span class="token operator">></span> list.txt <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 <code>list.txt</code> 文件的内容作为 <code>cat</code> 命令的输入来生成文件 <code>catfile</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;</span> /root/list.txt <span class="token punctuation">;</span> <span class="token function">head</span> catfile
/etc/skel/.bashrc
/root/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>&lt;&lt;</code> 称为内联输入重定向（Inline Input Redirection），代表的含义是从标准输入接收数据，遇到了关键词则结束输入。例如下面设的结束关键词 “end”，输入 end 再敲击回车后，输入立马结束，不同于 <code>Ctrl+d</code> 结束输入，end 这个关键词不会被记录到文件中，仅仅作为结束标记使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span>
<span class="token operator">></span> <span class="token function">yes</span> it/<span class="token string">'s begin
> line 2
> end
[root@101c7 ~]$ cat catfile 
yes it/'</span>s begin
line <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>操作符 <code>&gt;</code> 有几个修饰符标记，这些标记可以改变它的行为。例如：</p>
<ol>
<li>操作符 <code>&gt;&amp;</code> 表示将标准输出和错误同时进行重定向；</li>
<li>操作符 <code>&gt;!</code> 将迫使文件以 append 模式创建，或者以 normal 模式覆盖一个已存在的文件；</li>
<li>操作符 <code>&gt;@</code> 将以二进制模式而不是文件模式打开一个文件。</li>
</ol>
<h1 id="双向重定向"><a class="markdownIt-Anchor" href="#双向重定向"></a> 双向重定向</h1>
<p><code>tee</code> 命令可以将单向传输的数据流半路截取同时移作他用。</p>
<p>例如将 <code>ls</code> 命令的结果追加到 <code>root.txt</code> 文件末尾并排序打印出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-la</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> root.txt <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">head</span> -3<span class="token punctuation">;</span> <span class="token function">tail</span> <span class="token parameter variable">-3</span> root.txt 
drwx------.  <span class="token number">2</span> root root        <span class="token number">52</span> Sep <span class="token number">11</span> 04:07 audit
drwxr-----.  <span class="token number">3</span> root root        <span class="token number">19</span> Sep  <span class="token number">7</span> 05:51 .pki
drwxr-xr-x.  <span class="token number">2</span> root root        <span class="token number">23</span> Sep <span class="token number">10</span> <span class="token number">13</span>:03 etc
-rw-r--r--.  <span class="token number">1</span> root root       <span class="token number">129</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .tcshrc
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">20971520</span> Jul  <span class="token number">7</span> 04:07 TinyCore-current.iso
-rw-------.  <span class="token number">1</span> root root      <span class="token number">3358</span> Sep <span class="token number">11</span> 04:33 .viminfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="参数代换"><a class="markdownIt-Anchor" href="#参数代换"></a> 参数代换</h1>
<p><code>xargs</code> 用来产生某个命令的参数。<code>xargs</code> 可以读入 <code>stdin</code> 的数据，并以空格符或断行字符进行分辨，将 <code>stdin</code> 的数据分隔成为参数。主要是因为很多命令并不支持管道命令，才需要使用 <code>xargs</code>。</p>
<p>基本用法：<code>xargs [-0epn] command</code></p>
<p>参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-0</td>
<td>如果输入的 <code>stdin</code> 含有特殊字符比如 <code>,</code> 和 <code>\</code> 等，这个参数可以将它还原成一般字符；</td>
</tr>
<tr>
<td>-e</td>
<td>这个是 <code>EOF</code> 的意思，后面可以接一个字符串，当解析到这个字符串时就会停止继续工作；</td>
</tr>
<tr>
<td>-p</td>
<td>在执行每个命令参数时，都会询问用户；</td>
</tr>
<tr>
<td>-n</td>
<td>后面接次数，每次 <code>command</code> 命令执行时，要使用几个参数。</td>
</tr>
<tr>
<td></td>
<td>当 <code>xargs</code> 后面没有接任何的命令时，默认以 <code>echo</code> 来进行输出。</td>
</tr>
</tbody>
</table>
<p>例如将 <code>/etc/passwd</code> 第 1 列取出，只取 3 行，使用 <code>finger</code> 命令将账号内容显示出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">1</span> /etc/passwd <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-3</span> <span class="token operator">|</span> <span class="token function">xargs</span> finger
Login: root                             Name: root
Directory: /root                        Shell: /bin/bash
On since Sat Sep <span class="token number">11</span> 09:35 <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span> on tty1    <span class="token number">3</span> hours <span class="token number">14</span> minutes idle
On since Sat Sep <span class="token number">11</span> 07:08 <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span> on pts/0 from <span class="token number">192.168</span>.2.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>finger</code> 命令用来查询账户说明信息，<code>xargs</code> 将 3 个账号名称传给 <code>finger</code> 作为参数。</p>
<p>将 <code>passwd</code> 中所有账号都用 <code>finger</code> 查询，但一次只查询 5 个：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">1</span> /etc/passwd <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-p</span> <span class="token parameter variable">-n</span> <span class="token number">5</span> finger
finger root bin daemon adm lp ?<span class="token punctuation">..</span>.
finger <span class="token function">sync</span> <span class="token function">shutdown</span> <span class="token function">halt</span> mail operator ?<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同上，当参数分析到 <code>lp</code> 就结束命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">1</span> /etc/passwd <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-p</span> -e<span class="token string">'lp'</span> finger
finger root bin daemon adm ?<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意 <code>-e</code> 与 <code>'lp'</code> 之间没有空格。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>Perl 基础</title>
    <url>/591566948/</url>
    <content><![CDATA[<h1 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h1>
<p>Perl 在 Linux 中是内置程序，可以创建一个最简单的 <code>hello.pl</code> 来测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">vi</span> hello.pl 
<span class="token comment">#! /usr/bin/perl -w</span>

print <span class="token string">"hello<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">755</span> hello.pl 
<span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ ./hello.pl 
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一行 <code>#!</code> 指定 Perl 程序所在位置。<code>-w</code> 开关告诉 Perl 解释器提供完整的警告消息的方法。最新版本中可以不使用 <code>-w</code> 开关。</p>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<p>在 Perl 中使用变量之前不需要声明变量类型，所有标量型变量（Scalar Variable），也就是只包含一个元素的变量，都是以美元符号 <code>$</code> 作为前缀：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string">"Alice"</span><span class="token punctuation">;</span>
<span class="token variable">$age</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token variable">$URL_ADDR</span> <span class="token operator">=</span> <span class="token string">'http://www.g.cn'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Perl 也允许定义多个元素的变量，使用符号 <code>@</code> 作为前缀：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">@authors</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token string">"Cindy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">@list</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>数组元素也可以通过使用 <code>$</code> 和元素的序号来解引用，从 0 开始计算：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">@authors</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Perl 还允许声明关联数组（Associative Array）或以字符串作为索引的散列（Hash）。散列的索引称为键（Key），散列由百分号 <code>%</code> 特别指定：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">%person</span> <span class="token operator">=</span> <span class="token punctuation">(</span> name <span class="token operator">=></span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> age <span class="token operator">=></span> <span class="token string">'30'</span><span class="token punctuation">,</span> url<span class="token operator">=></span> <span class="token string">'tty.org'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<p>Perl 允许使用所有其他语言都有的同样的基本数学运算符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /usr/bin/perl</span>

<span class="token variable">$a</span><span class="token operator">=</span><span class="token number">77</span><span class="token punctuation">;</span>
<span class="token variable">$b</span><span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">;</span>
<span class="token variable">$result</span><span class="token operator">=</span><span class="token variable">$a</span>/<span class="token variable">$b</span><span class="token punctuation">;</span>
print <span class="token variable">$result</span><span class="token punctuation">;</span>
print <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="基本函数"><a class="markdownIt-Anchor" href="#基本函数"></a> 基本函数</h1>
<p>Perl 提供的通用函数。</p>
<h2 id="打印"><a class="markdownIt-Anchor" href="#打印"></a> 打印</h2>
<p>函数 <code>print</code> 向标准输出或其他流输出一个字符串，它具有和其他很多语言一样的控制字符：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token keyword">print</span> <span class="token string">"Hello again\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>向一个具有文件句柄的文件打印文本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">print FILE <span class="token string">"hello<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>想在一个文本字符串中打印一个变量的值，可以使用点号（<code>.</code>）字符把变量内容加入到字符串语句中：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token keyword">print</span> <span class="token string">"The result is:"</span><span class="token operator">.</span><span class="token variable">$result</span><span class="token operator">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="字符串操作"><a class="markdownIt-Anchor" href="#字符串操作"></a> 字符串操作</h2>
<p>函数 <code>chomp</code> 用于删除变量末尾的多个换行符：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">chomp <span class="token variable">@authors</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数 <code>join</code> 把两个单独的字符串连接成一个字符串，类似 <code>print</code> 中点号的作用，但 <code>join</code> 可以单独指定两个字符串之间的分隔符。例如使用冒号作为连接字段的分隔符：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">$fields</span> <span class="token operator">=</span> join <span class="token string">':'</span> <span class="token punctuation">,</span> <span class="token variable">$a1</span><span class="token punctuation">,</span> <span class="token variable">$a2</span><span class="token punctuation">,</span> <span class="token variable">$b</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数 <code>split</code> 将根据指定的分隔符把一个字符串分割成一组字符串。例如将指定的字符串分割到两个单独的变量中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token variable">$f1</span>,<span class="token variable">$f2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">split</span> /:/, <span class="token string">'Alice:Bob'</span>, <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者不限制分割的段数，把分割结果存入到一个多元素的变量中：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token punctuation">(</span><span class="token variable">@fs</span><span class="token punctuation">)</span> <span class="token operator">=</span> split <span class="token regex">/:/</span><span class="token punctuation">,</span> <span class="token variable">$raw_data</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>split</code> 函数还可以使用正则表达式进行模式匹配：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token punctuation">(</span><span class="token variable">@fs</span><span class="token punctuation">)</span> <span class="token operator">=</span> split <span class="token regex">/[^0-9]/</span><span class="token punctuation">,</span> <span class="token variable">$raw_date</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2>
<p>Perl 使用 <code>open</code>、<code>close</code>、<code>opendir</code>、<code>readdir</code> 和 <code>closedir</code> 这些函数来访问 Linux 系统上的底层文件系统。</p>
<p>函数 <code>open</code> 用来打开文件，然后就可以使用所获得的文件句柄处理文件内容，对文件进行读写操作：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token comment">#! /usr/bin/perl</span>

open<span class="token punctuation">(</span>FILE<span class="token punctuation">,</span> <span class="token string">"/etc/passwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">@filedata</span><span class="token operator">=</span><span class="token filehandle symbol">&lt;FILE></span><span class="token punctuation">;</span>
close<span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">foreach</span> <span class="token variable">$item</span> <span class="token punctuation">(</span><span class="token variable">@filedata</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">print</span> <span class="token variable">$item</span> <span class="token operator">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>opendir</code> 用于打开目录并创建一个文件句柄，<code>readdir</code> 用于读取文件句柄，<code>closedir</code> 用于关闭文件句柄。</p>
<h2 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h2>
<p><code>my</code> 运算符声明在一个有限范围（例如循环）内存在的变量。<code>local</code> 声明一个或多个已经存在的全局变量，这些变量拥有只在一个代码块中有效的值。</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">$name</span> <span class="token operator">=</span> Alice
<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">@date</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">my</span> <span class="token variable">$current_file</span><span class="token punctuation">;</span>
	<span class="token keyword">local</span> <span class="token variable">$name</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先在任何循环或子程序外定义的变量 <code>$name</code> 为全局声明，可以在后续代码块中的任意位置上使用。然后 <code>$current_file</code> 由 <code>my</code> 运算符声明，只在 <code>foreach</code> 循环中有效。最后是 <code>local</code> 运算符，它将变量限制到特定的代码块中，也就是修改一个已经存在的变量的作用域，待代码块执行结束，该变量将恢复成全局变量并继承全集变量的值。</p>
<h2 id="循环和条件"><a class="markdownIt-Anchor" href="#循环和条件"></a> 循环和条件</h2>
<p><code>while</code> 循环示例如下：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token variable">$counter</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">print</span> <span class="token variable">$counter</span><span class="token operator">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span>
        <span class="token variable">$counter</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>do...while</code> 循环会在第一次循环结束时检查测试条件，因此至少会执行循环体一次：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">print</span> <span class="token variable">$counter</span><span class="token operator">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span>
        <span class="token variable">$counter</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token variable">$counter</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>foreach</code> 循环用于遍历数组，并把每个元素传递到一个临时变量中，直到打印完所有元素：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">@list</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">foreach</span> <span class="token variable">$tmp</span> <span class="token punctuation">(</span><span class="token variable">@list</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">print</span> <span class="token variable">$tmp</span> <span class="token operator">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>if...else</code> 循环用于测试条件并有选择地执行：</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl"><span class="token variable">$name</span><span class="token operator">=</span><span class="token string">'Bob'</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$name</span> <span class="token operator">eq</span> <span class="token string">'Alice'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">print</span> <span class="token string">"Hey"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">elsif</span> <span class="token punctuation">(</span><span class="token variable">$name</span> <span class="token operator">eq</span> <span class="token string">'Bob'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">print</span> <span class="token string">"Hi"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">print</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>Shell 脚本基础</title>
    <url>/2734315757/</url>
    <content><![CDATA[<h1 id="shell-script-定义"><a class="markdownIt-Anchor" href="#shell-script-定义"></a> Shell Script 定义</h1>
<p>Shell Script 就是利用 shell 的功能所写的一个程序，这个程序使用纯文本文件，将一些 shell 的语法与命令写在里面，搭配正则表达式、管道命令与数据流重定向等功能达到所想要的处理目的。</p>
<p>脚本编写注意事项：</p>
<ul>
<li>命令执行时从上而下，从左到右地分析与执行；</li>
<li>命令参数之间的多个空白都会被忽略掉；</li>
<li>空白行会被忽略掉，包括 <code>[tab]</code> 也被视为空格；</li>
<li>如果读到一个 <code>[Enter]</code>(CR)，就尝试开始执行该命令；</li>
<li>一行内容太多，可使用 <code>\</code>+ <code>[Enter]</code> 来扩展至下一行；</li>
<li><code>#</code> 可以作为批注，任何 <code>#</code> 后面的内容都会被注释掉。</li>
</ul>
<h1 id="编写脚本"><a class="markdownIt-Anchor" href="#编写脚本"></a> 编写脚本</h1>
<p>先以一个最简单的脚本作为范例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># Program:</span>
<span class="token comment">#   This program shows "Hello Hell!" in your screen.</span>
<span class="token comment"># History:</span>
<span class="token comment"># 2046/1/1  Ass First release</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">'Hello Hell! \a \n'</span>
<span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">bash</span> sh01.sh 
Hello Hell<span class="token operator">!</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>逐行内容分析如下：</p>
<ul>
<li>
<p><strong>#!/bin/bash</strong></p>
<p>声明这个脚本使用的 shell 名称，使这个脚本执行时能加载 bash 的相关环境配置文件（一般是 <code>~/.bashrc</code>），并执行 bash 来使下面的命令能够执行。如果没有设置好这一行，脚本可能无法执行，因为系统无法判断需要使用什么 shell 来执行。</p>
</li>
<li>
<p><strong>#开头的内容</strong></p>
<p>除了第一行 <code>#!</code> 用来声明 shell 外，其他 <code>#</code> 开头的行都是批注作用。</p>
</li>
<li>
<p><strong>主要环境变量的声明</strong></p>
<p>建议将一些重要的环境变量设置好。如 PATH 和 LANG。这样可以让程序在进行时可以直接执行一些外部命令，而不必写绝对路径。</p>
</li>
<li>
<p><strong>主要程序部分</strong></p>
<p>此处为 <code>echo</code> 命令。</p>
</li>
<li>
<p><strong>告知执行结果</strong></p>
<p>利用 <code>exit</code> 这个命令来让程序中断，并回传一个数值给系统。执行完脚本后使用 <code>echo $?</code> 命令可以显示 0 值。也可以利用 <code>exit n</code> 的功能自定义不超过 255 的退出状态码。</p>
</li>
</ul>
<h1 id="执行脚本"><a class="markdownIt-Anchor" href="#执行脚本"></a> 执行脚本</h1>
<p>直接执行脚本需要对脚本拥有 <code>r</code>和 <code>x</code> 权限，方式有下面几种：</p>
<ul>
<li>可以通过绝对路径直接执行，比如 <code>/root/test.sh</code>；</li>
<li>可以通过相对路径直接执行，比如 <code>./test.sh</code>；</li>
<li>可以将脚本放置到 PATH 指定的目录内，如 <code>~/bin/</code> 内，输入 <code>test.sh</code> 就能直接执行；</li>
<li>以 bash 子进程来执行，例如 <code>bash test.sh</code>。以此方式执行 <code>test.sh</code> 只要有 <code>r</code> 的权限就能执行；</li>
<li>用 <code>source</code> 命令来执行脚本将直接在父进程中运行，例如 <code>source test.sh</code>。也可以使用快捷方法点操作符（Dot Operator）例如 <code>. test.sh</code>。</li>
</ul>
<p>直接执行脚本的方式会使用一个新的 bash 环境来执行脚本命令，也就是在子进程的 bash 内执行。这样子进程内的各项变量或操作在结束后不会传回到父进程中。</p>
<h1 id="捕获信号"><a class="markdownIt-Anchor" href="#捕获信号"></a> 捕获信号</h1>
<p>使用 <code>trap</code> 命令可以捕获 shell 中发出的 Linux 信号并直接处理。例如捕获 <code>[Ctrl]+C</code> 发出的 <code>SIGINT</code> 信号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">trap</span> <span class="token string">"echo 'Trapped CTRL+C'"</span> SIGINT
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token parameter variable">-lt</span> <span class="token number">4</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
<span class="token builtin class-name">echo</span> <span class="token string">"looping"</span>
<span class="token function">sleep</span> <span class="token number">1</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>移除捕获可以用 <code>trap -- SIGINT</code> 来操作。</p>
<p>查询所有可以捕获的信号列表可以使用 <code>-l</code> 参数，其结果显示和 <code>kill</code> 的一样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">trap</span> <span class="token parameter variable">-l</span>
 <span class="token number">1</span><span class="token punctuation">)</span> SIGHUP       <span class="token number">2</span><span class="token punctuation">)</span> SIGINT       <span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT      <span class="token number">4</span><span class="token punctuation">)</span> SIGILL       <span class="token number">5</span><span class="token punctuation">)</span> SIGTRAP
 <span class="token number">6</span><span class="token punctuation">)</span> SIGABRT      <span class="token number">7</span><span class="token punctuation">)</span> SIGBUS       <span class="token number">8</span><span class="token punctuation">)</span> SIGFPE       <span class="token number">9</span><span class="token punctuation">)</span> SIGKILL     <span class="token number">10</span><span class="token punctuation">)</span> SIGUSR1
<span class="token number">11</span><span class="token punctuation">)</span> SIGSEGV     <span class="token number">12</span><span class="token punctuation">)</span> SIGUSR2     <span class="token number">13</span><span class="token punctuation">)</span> SIGPIPE     <span class="token number">14</span><span class="token punctuation">)</span> SIGALRM     <span class="token number">15</span><span class="token punctuation">)</span> SIGTERM
<span class="token number">16</span><span class="token punctuation">)</span> SIGSTKFLT   <span class="token number">17</span><span class="token punctuation">)</span> SIGCHLD     <span class="token number">18</span><span class="token punctuation">)</span> SIGCONT     <span class="token number">19</span><span class="token punctuation">)</span> SIGSTOP     <span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP
<span class="token number">21</span><span class="token punctuation">)</span> SIGTTIN     <span class="token number">22</span><span class="token punctuation">)</span> SIGTTOU     <span class="token number">23</span><span class="token punctuation">)</span> SIGURG      <span class="token number">24</span><span class="token punctuation">)</span> SIGXCPU     <span class="token number">25</span><span class="token punctuation">)</span> SIGXFSZ
<span class="token number">26</span><span class="token punctuation">)</span> SIGVTALRM   <span class="token number">27</span><span class="token punctuation">)</span> SIGPROF     <span class="token number">28</span><span class="token punctuation">)</span> SIGWINCH    <span class="token number">29</span><span class="token punctuation">)</span> SIGIO       <span class="token number">30</span><span class="token punctuation">)</span> SIGPWR
<span class="token number">31</span><span class="token punctuation">)</span> SIGSYS      <span class="token number">34</span><span class="token punctuation">)</span> SIGRTMIN    <span class="token number">35</span><span class="token punctuation">)</span> SIGRTMIN+1  <span class="token number">36</span><span class="token punctuation">)</span> SIGRTMIN+2  <span class="token number">37</span><span class="token punctuation">)</span> SIGRTMIN+3
<span class="token number">38</span><span class="token punctuation">)</span> SIGRTMIN+4  <span class="token number">39</span><span class="token punctuation">)</span> SIGRTMIN+5  <span class="token number">40</span><span class="token punctuation">)</span> SIGRTMIN+6  <span class="token number">41</span><span class="token punctuation">)</span> SIGRTMIN+7  <span class="token number">42</span><span class="token punctuation">)</span> SIGRTMIN+8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>trap</code> 除了用作在进行某些特殊操作时忽略信号外，还可以用来删除临时文件。例如捕获一个由用户发送的中断，并使用 <code>trap</code> 清除在脚本的执行期间所创建的临时文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">function</span> <span class="token function-name function">removeTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$tmpFile</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Del temp files..."</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$tmpFile</span>"</span>
    <span class="token keyword">else</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"No temp file."</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">&#125;</span>
<span class="token builtin class-name">trap</span> removeTemp <span class="token number">1</span> <span class="token number">2</span>
<span class="token assign-left variable">tmpFile</span><span class="token operator">=</span>/tmp/sigtrap<span class="token variable">$$</span>
<span class="token function">cat</span> <span class="token operator">></span> <span class="token variable">$tmpFile</span>

<span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>trap</code> 命令必须写在脚本执行命令之前，否则可能无法捕获到信号。</p>
<h1 id="判断测试"><a class="markdownIt-Anchor" href="#判断测试"></a> 判断测试</h1>
<p>使用<code>test</code>指令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<p>文件类型检测参数如下，检测类型前会先检查文件是否存在：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>文件名是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>文件类型是否为文件</td>
</tr>
<tr>
<td>-d</td>
<td>文件类型是否为目录</td>
</tr>
<tr>
<td>-b</td>
<td>文件是否为 Block 设备</td>
</tr>
<tr>
<td>-c</td>
<td>文件是否为 Character 设备</td>
</tr>
<tr>
<td>-S</td>
<td>文件是否为 Socket 文件</td>
</tr>
<tr>
<td>-p</td>
<td>文件是否为 FIFO(pipe) 文件</td>
</tr>
<tr>
<td>-L</td>
<td>文件是否为连接文件</td>
</tr>
</tbody>
</table>
<p>文件的权限检测参数如下，也会先检查文件是否存在。<code>root</code>权限常有例外：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>检测是否具有 <code>r</code> 权限</td>
</tr>
<tr>
<td>-w</td>
<td>检测是否具有 <code>w</code> 权限</td>
</tr>
<tr>
<td>-x</td>
<td>检测是否具有 <code>x</code> 权限</td>
</tr>
<tr>
<td>-u</td>
<td>检测是否具有 <code>SUID</code> 属性</td>
</tr>
<tr>
<td>-g</td>
<td>检测是否具有 <code>SGID</code> 属性</td>
</tr>
<tr>
<td>-k</td>
<td>检测是否具有 <code>Sticky bit</code> 属性</td>
</tr>
<tr>
<td>-s</td>
<td>检测文件是否为非空白文件</td>
</tr>
</tbody>
</table>
<p>两个文件之间的比较参数如下，例如<code>test file1 -nt file2</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nt</td>
<td>newer than 缩写，判断<code>file1</code>是否比<code>file2</code>新。</td>
</tr>
<tr>
<td>-ot</td>
<td>older than 缩写，判断<code>file1</code>是否比<code>file2</code>旧。</td>
</tr>
<tr>
<td>-ef</td>
<td>判断<code>file1</code>与<code>file2</code>是否为同一文件。主要判定两个文件是否指向相同的<code>inode</code>。</td>
</tr>
</tbody>
</table>
<p>整数之间的判定，例如<code>test n1 -eq n2</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>两数值相等 (equal)</td>
</tr>
<tr>
<td>-ne</td>
<td>两数值不等 (not equal)</td>
</tr>
<tr>
<td>-gt</td>
<td><code>n1</code> 大于 <code>n2</code> (greater than)</td>
</tr>
<tr>
<td>-lt</td>
<td><code>n1</code> 小于 <code>n2</code> (less than)</td>
</tr>
<tr>
<td>-ge</td>
<td><code>n1</code> 大于等于 <code>n2</code> (greater than or equal)</td>
</tr>
<tr>
<td>-le</td>
<td><code>n1</code> 小于等于 <code>n2</code> (less than or equal)</td>
</tr>
</tbody>
</table>
<p>判定字符串的数据，例如<code>[ -z &quot;$&#123;JAVA&#125;&quot; ]</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n string</td>
<td>判定字符串 <code>string</code> 是否为 0，若 <code>string</code> 不为空返回 <code>true</code></td>
</tr>
<tr>
<td>-z string</td>
<td>判定字符串 <code>string</code> 是否为 0，若 <code>string</code> 为空字符串返回 <code>true</code></td>
</tr>
<tr>
<td>str1=str2</td>
<td>判定 <code>str1</code> 是否等于 <code>str2</code>，相等返回 <code>true</code></td>
</tr>
<tr>
<td>str1!=str2</td>
<td>判定 <code>str1</code> 是否不等于 <code>str2</code>，不相等返回 <code>true</code></td>
</tr>
</tbody>
</table>
<p>多重条件判定，例如 <code>test -r file -a -x file</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>两个条件同时成立时才返回 <code>true</code></td>
</tr>
<tr>
<td>-o</td>
<td>任何一个条件成立时返回 <code>true</code></td>
</tr>
<tr>
<td>!</td>
<td>反向状态，例如 <code>test ! -e file</code>，当 <code>file</code> 不存在时返回 <code>true</code></td>
</tr>
</tbody>
</table>
<p>通常使用中括号 <code>[]</code> 来代替 <code>test</code> 进行数据判断，例如判断两个变量是否相等：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$HOME</span>"</span> <span class="token operator">==</span> <span class="token string">"<span class="token variable">$MAIL</span>"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">'no'</span>
no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>中括号 <code>[]</code>用作判断时：</p>
<ul>
<li>中括号内每个组件都需要有空格来分隔；</li>
<li>中括号内的变量最好都以双引号括起来；</li>
<li>中括号内的常量最好都以单或双引号括起来。</li>
</ul>
<h1 id="数值运算"><a class="markdownIt-Anchor" href="#数值运算"></a> 数值运算</h1>
<p>可以使用 <code>$[计算式]</code> 来进行简单整数运算：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+4<span class="token punctuation">]</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span>a*b<span class="token punctuation">]</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>$((计算式))</code> 来进行高级整数运算。在 <code>(())</code> 中的变量不需要 <code>$</code> 来引用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-rp</span> <span class="token string">"first number:"</span> nu1
<span class="token builtin class-name">read</span> <span class="token parameter variable">-rp</span> <span class="token string">"second number:"</span> nu2
<span class="token assign-left variable">total</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>nu1<span class="token operator">**</span>nu2<span class="token variable">))</span></span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\n">\n</span>The result of <span class="token variable">$nu1</span> * <span class="token variable">$nu2</span> is <span class="token variable">$total</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一种不太常用的方式是使用命令 <code>expr</code>，因为有些符号在 shell 中另有含义（比如 <code>*</code>），这时需要用 <code>\</code> 来转义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">expr</span> <span class="token number">5</span> <span class="token punctuation">\</span>* <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token number">3</span> + <span class="token number">1</span> <span class="token punctuation">\</span><span class="token punctuation">)</span>
<span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果想计算小数，可以调用 <code>bc</code> 来处理。其中 scale 指明了小数点位数。默认情况下 scale 为 0，使用 <code>-l</code> 参数启动时 scale 为 20：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">"scale=4; <span class="token variable">$a</span>/<span class="token variable">$b</span>"</span><span class="token operator">|</span><span class="token function">bc</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以用来进行不同进制之间的转换，例如十进制转十六进制。表达十六进制的字母必须大写，小写会被 <code>bc</code> 认为是变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">53</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">"ibase=10;obase=16; <span class="token variable">$a</span>+<span class="token variable">$b</span>"</span> <span class="token operator">|</span> <span class="token function">bc</span> <span class="token parameter variable">-l</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>双方括号<code>[[]]</code>用来对字符串进行模式匹配：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> r* <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"Hello <span class="token environment constant">$USER</span>"</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"Deny"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="参数变量"><a class="markdownIt-Anchor" href="#参数变量"></a> 参数变量</h1>
<p>如果脚本支持参数，那么脚本名或脚本路径为 <code>$0</code> 变量。想取绝对文件名而不是路径时，可以用 <code>basename</code> 命令来处理。</p>
<p>后面参数从 <code>$1</code> 开始赋值直到 <code>$9</code>。超过 9 个变量引用时要加上大括号，如在脚本中引用第 11 个变量采取 <code>$&#123;11&#125;</code> 来引用。</p>
<p>特殊的参数变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>代表输入的参数个数.</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>代表 <code>$1</code>、<code>$2</code>、<code>$3</code> 之意，每个变量是独立的，可以用 for 遍历。</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>代表 <code>$1c$2c$3</code>，其中 <code>c</code> 为分隔符，默认是空格.</td>
</tr>
</tbody>
</table>
<p>在脚本中使用 <code>shift</code> 可以进行参数变量偏移。比如 <code>shift 3</code> 代表拿掉前 3 个参数变量。这时遍历命令行参数的另一个好办法，尤其是在不知道有多少个参数时，可以只操作第一个参数，用 <code>shift</code> 移动参数后继续操作第一个参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"para<span class="token variable">$count</span> = <span class="token variable">$1</span>"</span>
    <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$count <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
    <span class="token builtin class-name">shift</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="逻辑判断"><a class="markdownIt-Anchor" href="#逻辑判断"></a> 逻辑判断</h1>
<p>许多程序要求对 shell 脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令称为结构化命令（Structured Command）。</p>
<p>循环语句内使用其他循环命令叫做嵌套循环（Nested Loop）。</p>
<h2 id="ifthen"><a class="markdownIt-Anchor" href="#ifthen"></a> if…then</h2>
<p><code>if</code> 语句本身并不执行任何判断，只会运行 <code>if</code> 或 <code>elif</code> 后面那个命令，如果命令的退出状态码是 0，位于 <code>then</code> 部分的命令就会被执行。否则 bash shell 会继续执行脚本中的下一个命令，直到 <code>fi</code> 为止。</p>
<p><code>if</code> 后可以有多个条件判断式，用 <code>&amp;&amp;</code> 或 <code>||</code> 隔开代表 And 或 Or。</p>
<p><strong>单条件判断的写法</strong>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> 条件判断式 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    条件成立时运行的命令<span class="token punctuation">;</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>多条件判断的写法</strong>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> 条件判断式1 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    条件判断式1成立时运行的命令<span class="token punctuation">;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> 条件判断式2 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    条件判断式2成立时运行的命令<span class="token punctuation">;</span>
<span class="token keyword">else</span>
    条件判断式都不成立时运行的命令<span class="token punctuation">;</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="caseesac"><a class="markdownIt-Anchor" href="#caseesac"></a> case…esac</h2>
<p>基本写法如下，其中 <code>;;</code> 代表其他语言中的 break 跳出作用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">case</span> $变量名称 <span class="token keyword">in</span>
    <span class="token string">"第一个变量内容"</span><span class="token punctuation">)</span>
        程序段
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"第二个变量内容"</span><span class="token punctuation">)</span>
        程序段
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
        不符合所有条件的程序执行段
        <span class="token builtin class-name">exit</span> <span class="token number">1</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h1>
<p>在 Bash 脚本中，有多种循环结构，最常用的有 <code>for</code> 循环和 <code>while</code> 循环。</p>
<h2 id="while-do-done"><a class="markdownIt-Anchor" href="#while-do-done"></a> while do done</h2>
<p>条件成立时进行循环，基本写法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token punctuation">[</span> 判断式 <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    程序段落
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="until-do-done"><a class="markdownIt-Anchor" href="#until-do-done"></a> until do done</h2>
<p>条件成立时终止循环，基本写法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> <span class="token punctuation">[</span> 判断式 <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    程序段落
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="fordodone"><a class="markdownIt-Anchor" href="#fordodone"></a> for…do…done</h2>
<p><code>for</code> 语法用来表示已知次数的循环。<code>in</code> 后面参数之间用空格隔开，基本语法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> con1 con2 con3 <span class="token punctuation">..</span>.
<span class="token keyword">do</span>
    程序段
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>内部字段分隔符（Internal Field Separator）定义了空格、制表符和换行符作为字段分隔符。如果值之间不是用空格分隔，可以临时修改 <code>IFS</code> 变量的值（例如使用冒号和换行符 <code>IFS=:$'\n'</code>），再使用 <code>for</code> 循环读取变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">IFS</span>.OLD</span><span class="token operator">=</span><span class="token environment constant">$IFS</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:,
for循环程序段
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token environment constant">$IFS</span>.OLD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用通配符来达成遍历目录的目的，例如遍历 <code>/root</code> 和 <code>/home</code> 目录下的文件和目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /root/* /home/.bash*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以用 <code>seq</code>（sequence 的缩写）来定义连续数字。比如定义循环范围 1 到 10：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">nu</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">10</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要定义连续字符可以写成 <code>echo &#123;a..z&#125;</code>。例如用 <code>for</code> 循环输出 1 到 5：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以使用自定义数值处理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>初始值<span class="token punctuation">;</span> 限制值<span class="token punctuation">;</span> 执行步长<span class="token punctuation">))</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始值</td>
<td>直接以类似 <code>i=1</code> 设置好</td>
</tr>
<tr>
<td>限制值</td>
<td>值在限制值范围内继续循环，例如 <code>i&lt;=20</code></td>
</tr>
<tr>
<td>执行步长</td>
<td>每做一次循环时变量的变化范围，例如 <code>i=i+1</code></td>
</tr>
</tbody>
</table>
<h2 id="控制循环"><a class="markdownIt-Anchor" href="#控制循环"></a> 控制循环</h2>
<p>使用 <code>break</code> 命令可以用来退出任意类型的循环。如果有多层循环，<code>break</code> 会自动终止所在最内层的循环。可以用 <code>break n</code> 来指定要停止的外部循环。<code>n</code> 为 1 代表当前循环：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> a<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"The <span class="token variable">$a</span> loop"</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> b <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$b</span> <span class="token parameter variable">-gt</span> <span class="token number">30</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
            <span class="token builtin class-name">break</span> <span class="token number">2</span>
        <span class="token keyword">fi</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Vaule is <span class="token variable">$b</span>"</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>continue</code> 命令可以提前终止某次循环，继续运行下次循环。同样在多层循环中可用 <code>continue n</code> 来指定要继续执行的循环层级：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> a<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-gt</span> <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-lt</span> <span class="token number">7</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">continue</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"now 'a' is <span class="token variable">$a</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="循环输出"><a class="markdownIt-Anchor" href="#循环输出"></a> 循环输出</h2>
<p>在 shell 脚本中，可以对循环的输出使用管道或进行重定向。通过在 <code>done</code> 命令之后添加一个处理命令来实现：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /root/*<span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> <span class="token variable">$file</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $file<span class="token variable">)</span></span> is directory"</span>
    <span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$file</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $file<span class="token variable">)</span></span> is file"</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span> <span class="token operator">></span>output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<p>函数是一个脚本代码块，可以为其命名并在代码中任何位置重用。</p>
<h2 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h2>
<p>可以使用 <code>function</code> 来定义函数，函数需要在调用前定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    程序段
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数"></a> 调用函数</h2>
<p>使用 <code>函数名 参数1 参数2...</code> 格式来调用函数。函数可以在内部使用调用时传入的参数。例如 <code>$0</code> 代表函数名，<code>$1</code> 代表第一个参数。</p>
<h2 id="函数返回"><a class="markdownIt-Anchor" href="#函数返回"></a> 函数返回</h2>
<p>使用 <code>return</code> 命令来退出函数并返回特定的退出状态码，用来控制函数状态。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">sh1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span> <span class="token variable">$1</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
    <span class="token builtin class-name">return</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span>
sh1 <span class="token number">100</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Exit status is: <span class="token variable">$?</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>退出状态码必须是 0~255。</p>
<h2 id="函数变量"><a class="markdownIt-Anchor" href="#函数变量"></a> 函数变量</h2>
<p>脚脚本内任意位置定义的有效变量都是全局变量。要在函数使用局部变量，在函数内使用 <code>local</code> 定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">taax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">local</span> <span class="token assign-left variable">valuea</span><span class="token operator">=</span><span class="token number">51</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="数组变量"><a class="markdownIt-Anchor" href="#数组变量"></a> 数组变量</h2>
<p>函数中使用数组需要将数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部可以将所有的参数重新组合成为一个新的数组变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">testarr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">local</span> newarray
    <span class="token assign-left variable">newarray</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token variable">)</span></span><span class="token punctuation">)</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"The array: <span class="token variable">$&#123;newarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>"</span>
<span class="token punctuation">&#125;</span>
<span class="token assign-left variable">myarray</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>
testarr <span class="token variable">$&#123;myarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数递归"><a class="markdownIt-Anchor" href="#函数递归"></a> 函数递归</h2>
<p>shell 中函数可以递归调用，也就是可以调用自己产生的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">pingf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">local</span> <span class="token assign-left variable">temp</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$<span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token variable">))</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$temp</span> <span class="token parameter variable">-gt</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        pingf <span class="token variable">$temp</span>
    <span class="token keyword">else</span>
        <span class="token builtin class-name">echo</span> <span class="token variable">$temp</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">&#125;</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"Type Number:"</span> mynum
pingf mynum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数库"><a class="markdownIt-Anchor" href="#函数库"></a> 函数库</h2>
<p>可可以将函数定义成函数库文件，然后在其他脚本中引用。例如定义一个简单的 <code>sh01.sh</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">sh1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span> <span class="token variable">$1</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在其他脚本中调用 <code>sh01.sh</code> 文件要使用 <code>source</code> 命令，这样确保引用的脚本不会在子 shell 中运行，而获取不到引用脚本中的变量或函数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">.</span> ~/sh01.sh
sh1 <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以通过这一方式来调用系统函数库。</p>
<h1 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h1>
<p>在脚本中要重定向输出，除了和命令行一样的方法外，还能通过 <code>exec</code> 命令设置脚本执行期间重定向某类文件描述符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span>stderror.txt
<span class="token builtin class-name">echo</span> <span class="token string">"this is stdout"</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span>stdout.txt
<span class="token builtin class-name">echo</span> <span class="token string">"stdout2file"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"stderror2file"</span><span class="token operator">></span><span class="token file-descriptor important">&amp;2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的运行结果第一个输出会在屏幕显示，第二个标准输出存到了 <code>stdout.txt</code>，第三个错误输出使用 <code>&gt;&amp;2</code> 来重定向到文件 <code>stderror.txt</code>，这是与命令行重定向稍微有区别之处。</p>
<p>重定向输入也是通过 <code>exec</code> 命令将文件指向文件描述符 0:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>output.txt
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> out_line<span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$out_line</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除此之外，还可以重定向到其他文件描述符(3~8)来自定义作用。例如用文件描述符 3 储存标准输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>></span><span class="token file-descriptor important">&amp;1</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span>stdout.txt
<span class="token builtin class-name">echo</span> <span class="token string">"stdout2file1"</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;3</span>
<span class="token builtin class-name">echo</span> <span class="token string">"stdout"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要关闭文件描述符使用 <code>exec 3&gt;&amp;-</code>。</p>
<h1 id="创建临时文件"><a class="markdownIt-Anchor" href="#创建临时文件"></a> 创建临时文件</h1>
<p>可以使用 <code>mktemp -t</code> 命令在 <code>/tmp</code> 下新建一个临时文件，使用完即可删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">tempfile</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp <span class="token parameter variable">-t</span> testfile.XXXX<span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"testline1"</span><span class="token operator">></span><span class="token variable">$tempfile</span>
<span class="token function">cat</span> <span class="token variable">$tempfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建临时目录使用 <code>mktemp -d</code> 命令在 <code>/tmp</code> 下新建：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">tempdir</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp <span class="token parameter variable">-d</span> testdir.XXXX<span class="token variable">)</span></span>
<span class="token builtin class-name">cd</span> <span class="token variable">$tempdir</span>
<span class="token assign-left variable">tempfile</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp testfile.XXX<span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"tempdir&amp;tempfile"</span><span class="token operator">></span><span class="token variable">$tempfile</span>
<span class="token function">cat</span> <span class="token variable">$tempfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="创建菜单"><a class="markdownIt-Anchor" href="#创建菜单"></a> 创建菜单</h1>
<p><code>select</code> 命令可以创建出菜单，获取输入并自动处理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">sh1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"sh1 is runing"</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function-name function">sh2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"sh2 is runing"</span>
<span class="token punctuation">&#125;</span>
<span class="token assign-left variable"><span class="token environment constant">PS3</span></span><span class="token operator">=</span><span class="token string">"Enter:"</span>
<span class="token keyword">select</span> <span class="token for-or-select variable">youropt</span> <span class="token keyword">in</span> <span class="token string">"Exit"</span> <span class="token string">"show sh1"</span> <span class="token string">"show sh2"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">case</span> <span class="token variable">$youropt</span> <span class="token keyword">in</span>
    <span class="token string">"Exit"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">break</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"show sh1"</span><span class="token punctuation">)</span>
        sh1
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"show sh2"</span><span class="token punctuation">)</span>
        sh2
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
        <span class="token function">clear</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Wrong input"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token keyword">esac</span>
<span class="token keyword">done</span>
<span class="token function">clear</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">bash</span> sh01.sh 
<span class="token number">1</span><span class="token punctuation">)</span> Exit
<span class="token number">2</span><span class="token punctuation">)</span> show sh1
<span class="token number">3</span><span class="token punctuation">)</span> show sh2
Enter:2
sh1 is runing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要制作出像内核功能选择那样的窗口，可以使用 <code>dialog</code> 工具。</p>
<h1 id="调试脚本"><a class="markdownIt-Anchor" href="#调试脚本"></a> 调试脚本</h1>
<p>可以使用 bash 的 <code>-n</code> 参数来检查脚本有无语法错误：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">bash</span> <span class="token parameter variable">-n</span> sh11.sh 
sh11.sh: line <span class="token number">8</span>: syntax error: unexpected end of <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>没有错误什么也不会输出。有错误会显示错误所在行与类型。可以和 <code>-v</code> 连用得到一个详细的输出。</p>
<p>使用 <code>-x</code> 参数将执行过程全部列出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">bash</span> <span class="token parameter variable">-x</span> sh11.sh 
+ <span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token number">1</span>
+ <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">101</span> <span class="token punctuation">))</span></span>
+ <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">&lt;=</span><span class="token number">110</span> <span class="token punctuation">))</span></span>
+ <span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token number">101</span>
+ <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">))</span></span>
+ <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">&lt;=</span><span class="token number">110</span> <span class="token punctuation">))</span></span>
+ <span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token number">10403</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>带 <code>+</code> 开头的行表示命令串，实际输出没有 <code>+</code>。</p>
<p>另外可以设置调试的范围，在希望开始调试的地方插入 <code>set -x</code> 命令，在希望结束调试的地方插入 <code>set +x</code> 命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Docker Compose 编排容器</title>
    <url>/504557237/</url>
    <content><![CDATA[<h1 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> Docker Compose</h1>
<p>Docker Compose，原名为 Fig，是 Docker 官方开发的用于简化多容器部署和迁移过程的容器编排（Orchestration）插件。Compose 使用一个 YAML 格式的 docker-compose.yml 模板文件来定义一组相关联的应用容器，形成一个服务栈。</p>
<p>在 Compose 中有几个重要的概念：</p>
<ul>
<li>任务（task）：一个容器被称为一个任务，拥有独一无二的 ID，在同一个服务中的多个任务序号依次递增。</li>
<li>服务（service）：某个相同应用镜像的容器副本集合，一个服务可以横向扩展为多个容器实例。</li>
<li>服务栈（stack）：由多个服务组成，互相配合完成特定任务，一般定义在一个 docker-compose.yml 文件中。</li>
</ul>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<p>V1 版本由 Python 编写，安装方式如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ curl <span class="token punctuation">-</span>L https<span class="token punctuation">:</span>//github.com/docker/compose/releases/download/1.29.2/docker<span class="token punctuation">-</span>compose<span class="token punctuation">-</span>Linux<span class="token punctuation">-</span>x86_64 <span class="token punctuation">-</span>o /usr/local/bin/docker<span class="token punctuation">-</span>compose
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ curl <span class="token punctuation">-</span>L https<span class="token punctuation">:</span>//raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/bash/docker<span class="token punctuation">-</span>compose <span class="token punctuation">></span> /etc/bash_completion.d/docker<span class="token punctuation">-</span>compose
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ chmod +x /usr/local/bin/docker<span class="token punctuation">-</span>compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>V2 版本使用 Golang 重构，安装方式如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ curl <span class="token punctuation">-</span>L https<span class="token punctuation">:</span>//github.com/docker/compose/releases/download/v2.0.1/docker<span class="token punctuation">-</span>compose<span class="token punctuation">-</span>linux<span class="token punctuation">-</span>x86_64 <span class="token punctuation">-</span>o /usr/libexec/docker/cli<span class="token punctuation">-</span>plugins/docker<span class="token punctuation">-</span>compose
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ chmod +x /usr/libexec/docker/cli<span class="token punctuation">-</span>plugins/docker<span class="token punctuation">-</span>compose
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ docker compose version
Docker Compose version v2.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不需要使用时，可以直接删除对应的二进制文件即可。</p>
<h1 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h1>
<p>一个简单的配置文件样本如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>alpine
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"6379"</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frontend
  <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">9.4</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">ROOT_PASSWORD</span><span class="token punctuation">:</span> example
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/var/lib/postgresql/data
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> backend
  <span class="token key atrule">vote</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_vote<span class="token punctuation">:</span>before
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"5000:80"</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frontend
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> redis
  <span class="token key atrule">result</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_result<span class="token punctuation">:</span>before
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"5001:80"</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> backend
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db
  <span class="token key atrule">worker</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_worker
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> frontend
      <span class="token punctuation">-</span> backend
  <span class="token key atrule">visualizer</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/visualizer<span class="token punctuation">:</span>stable
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>
    <span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1m30s
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>
      
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
  <span class="token key atrule">backend</span><span class="token punctuation">:</span>

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  db<span class="token punctuation">-</span>data<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的示例模板文件中可以看出顶级的配置项有：</p>
<ul>
<li>version：定义了版本信息。</li>
<li>services：定义了服务的配置信息，包含应用于为该服务启动的每个容器的配置。</li>
<li>networks：定义了网络信息，提供给 services 中的具体容器使用。</li>
<li>volumes：定义了卷信息，提供给 services 中的具体容器使用。</li>
</ul>
<h1 id="配置详解"><a class="markdownIt-Anchor" href="#配置详解"></a> 配置详解</h1>
<p>一些常见配置命令说明如下:</p>
<h2 id="alias"><a class="markdownIt-Anchor" href="#alias"></a> alias</h2>
<p>网络上此服务的别名（备用主机名）。同一网络上的其他容器可以使用服务名称或此别名连接到其中一个服务的容器。</p>
<p>由于 aliases 是网络范围的，因此相同的服务可以在不同的网络上具有不同的别名。</p>
<p>网络范围的别名可以由多个容器共享，甚至可以由多个服务共享。如果是这样的话，则无法保证名称解析为容器。</p>
<p>例如设置网络别名：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">some-service</span><span class="token punctuation">:</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token key atrule">some-network</span><span class="token punctuation">:</span>
        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> alias1
          <span class="token punctuation">-</span> alias3
      <span class="token key atrule">other-network</span><span class="token punctuation">:</span>
        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> alias2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="bulid"><a class="markdownIt-Anchor" href="#bulid"></a> bulid</h2>
<p>指定 Dockerfile 所在文件夹的路径，可以是绝对或相对路径，Compose 将会利用它自动构建并使用这个镜像。例如：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 context 指令指定 Dockerfile 所在文件夹的路径，同时使用 dockerfile 指令指定 Dockerfile 文件名：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> /root/build
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile<span class="token punctuation">-</span>alternate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dockerfile 指令不能跟 image 同时使用，否则 Compose 不知道根据哪个指令来生成最终的服务镜像。</p>
<h2 id="command"><a class="markdownIt-Anchor" href="#command"></a> command</h2>
<p>使用 command 可以覆盖容器启动后默认执行的命令，可以为字符串格式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">command</span><span class="token punctuation">:</span> bundle exec thin <span class="token punctuation">-</span>p 3000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以为 JSON 数组格式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bundle"</span><span class="token punctuation">,</span> <span class="token string">"exec"</span><span class="token punctuation">,</span> <span class="token string">"thin"</span><span class="token punctuation">,</span> <span class="token string">"-p"</span><span class="token punctuation">,</span> <span class="token string">"3000"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="container_name"><a class="markdownIt-Anchor" href="#container_name"></a> container_name</h2>
<p>指定容器名称。不指定默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">container_name</span><span class="token punctuation">:</span> docker<span class="token punctuation">-</span>web<span class="token punctuation">-</span>container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="depends_on"><a class="markdownIt-Anchor" href="#depends_on"></a> depends_on</h2>
<p>解决容器的依赖和启动先后的问题。例如先启动 redis 和 db 再启动 web：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db
      <span class="token punctuation">-</span> redis
<span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
<span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>web 服务不会等待 redis 和 db 完全启动之后才启动。</p>
<h2 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> dns</h2>
<p>自定义 DNS 服务器，可以是单个也可以是一个列表：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dns</span><span class="token punctuation">:</span> 8.8.8.8
<span class="token key atrule">dns</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> 8.8.8.8
  <span class="token punctuation">-</span> 9.9.9.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> entrypoint</h2>
<p>覆盖容器中默认的入口命令：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="env-file"><a class="markdownIt-Anchor" href="#env-file"></a> env file</h2>
<p>从文件获取环境变量，可以为文件路径或列表。如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。如果有变量名称与 <code>environment</code> 指令冲突，以后者为准：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">env file</span><span class="token punctuation">:</span> .env

<span class="token key atrule">env file</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> ./cornmon.enV
  <span class="token punctuation">-</span> ./apps/web.env
  <span class="token punctuation">-</span> /opt/secrets.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>环境变量文件中每一行必须符合格式，支持以 <code>#</code> 开头的注释行：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># cornmon.env : Set development environment</span>
PROG ENV=development<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> environment</h2>
<p>设置环境变量。可以使用数组或字典两种格式。只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span>
  <span class="token key atrule">RACK_ENV</span><span class="token punctuation">:</span> development
  <span class="token key atrule">SESSION_SECRET</span><span class="token punctuation">:</span>
<span class="token key atrule">environment</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> RACK_ENV=development
  <span class="token punctuation">-</span> SESSION_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果变量名称或者值中用到 <code>true|false</code>、<code>yes|no</code> 等表达布尔含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。包括：<code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code>。</p>
<h2 id="expose"><a class="markdownIt-Anchor" href="#expose"></a> expose</h2>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定容器内部的端口为参数：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">expose</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> <span class="token string">"3000"</span>
 <span class="token punctuation">-</span> <span class="token string">"8000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="extends"><a class="markdownIt-Anchor" href="#extends"></a> extends</h2>
<p>基于其他模板文件进行扩展。一般情况下，推荐在基础模板中只定义一些可以共享的镜像和环境变量，在扩展模板中具体指定应用变量、链接、数据卷等信息。</p>
<p>例如已有一个 webapp 服务，定义一个基础模板文件为 common.yml：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># common.yml</span>
<span class="token key atrule">webapp</span><span class="token punctuation">:</span>
  <span class="token key atrule">build</span><span class="token punctuation">:</span> ./webapp
  <span class="token key atrule">environment</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> DEBUG=false
    <span class="token punctuation">-</span> SEND EMAILS=false <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># development.yml</span>
<span class="token key atrule">web</span><span class="token punctuation">:</span>
  <span class="token key atrule">extends</span><span class="token punctuation">:</span>
    <span class="token key atrule">file</span><span class="token punctuation">:</span> common.yml
    <span class="token key atrule">service</span><span class="token punctuation">:</span> webapp
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">"8000:8000"</span>
  <span class="token key atrule">links</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> db
  <span class="token key atrule">environment</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> DEBUG=true
<span class="token key atrule">db</span><span class="token punctuation">:</span>
  <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后者会自动继承 common.yml 中的 webapp 服务及环境变量定义。使用 extends 需要注意以下两点：</p>
<ul>
<li>要避免出现循环依赖。例如 A 依赖 B，B 依赖 C，C 反过来依赖 A 的情况。</li>
<li>extends 不会继承 links 和 volumes_from 中定义的容器和数据卷资源。</li>
</ul>
<h2 id="external-links"><a class="markdownIt-Anchor" href="#external-links"></a> external links</h2>
<p>链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">external links</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> redis_1
  <span class="token punctuation">-</span> project_db_1<span class="token punctuation">:</span>mysql
  <span class="token punctuation">-</span> project_db_1<span class="token punctuation">:</span>postgresql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="extra-hosts"><a class="markdownIt-Anchor" href="#extra-hosts"></a> extra hosts</h2>
<p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">extra_hosts</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">"googledns:8.8.8.8"</span>
  <span class="token punctuation">-</span> <span class="token string">"dockerhub:52.1.157.61"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>服务容器启动后会在 <code>/etc/hosts</code> 文件中添加 googledns 和 dockerhub 两条内容。</p>
<h2 id="healthcheck"><a class="markdownIt-Anchor" href="#healthcheck"></a> healthcheck</h2>
<p>通过命令检查容器是否健康运行。包括检测方法（test）、间隔（interval）、超时（timeout）、重试次数（retries）、启动等待时间（start_period）等：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>
  <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost"</span><span class="token punctuation">]</span>
  <span class="token key atrule">interval</span><span class="token punctuation">:</span> 1m30s
  <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 10s
  <span class="token key atrule">retries</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 30s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="image"><a class="markdownIt-Anchor" href="#image"></a> image</h2>
<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">image</span><span class="token punctuation">:</span> ubuntu
<span class="token key atrule">image</span><span class="token punctuation">:</span> orchardup/postgresql
<span class="token key atrule">image</span><span class="token punctuation">:</span> a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果同时指定了 image 和 build，那 image 不再具有单独使用的意义，而是指定了当前要构建的镜像的名称。也就是说，Compose 构建的镜像将使用 image 中指定的名称 webapp:tag 进行命名：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span> ./dir
<span class="token key atrule">image</span><span class="token punctuation">:</span> webapp<span class="token punctuation">:</span>tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="labels"><a class="markdownIt-Anchor" href="#labels"></a> labels</h2>
<p>为容器添加 Docker 元数据（metadata）信息。例如，可以为容器添加辅助说明信息：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">labels</span><span class="token punctuation">:</span>
  <span class="token key atrule">com.startupteam.description</span><span class="token punctuation">:</span> <span class="token string">"webapp for a startup team"</span>
  <span class="token key atrule">com.startupteam.department</span><span class="token punctuation">:</span> <span class="token string">"devops department"</span>
  <span class="token key atrule">com.startupteam.release</span><span class="token punctuation">:</span> <span class="token string">"rc3 for v1.0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="logging"><a class="markdownIt-Anchor" href="#logging"></a> logging</h2>
<p>与日志相关的配置，包括一系列子配置。logging.driver 类似于 --log-driver 参数，用于指定日志驱动类型。目前支持三种日志驱动类型：json-file、syslog、none。logging.options 设置日志驱动的相关参数。例如，设置为 syslog 格式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>
  <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"syslog"</span>
  <span class="token key atrule">options</span><span class="token punctuation">:</span>
    <span class="token key atrule">syslog address</span><span class="token punctuation">:</span> <span class="token string">"tcp://192.168.0.42:123"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者使用 json-file 格式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>
  <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"json-file"</span>
  <span class="token key atrule">options</span><span class="token punctuation">:</span>
    max<span class="token punctuation">-</span>size<span class="token punctuation">:</span><span class="token string">"lOOOk"</span>
    max<span class="token punctuation">-</span>file<span class="token punctuation">:</span><span class="token string">"20"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="network-mode"><a class="markdownIt-Anchor" href="#network-mode"></a> network mode</h2>
<p>设置网络模式：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">network mode</span><span class="token punctuation">:</span> <span class="token string">"none"</span>
<span class="token key atrule">network mode</span><span class="token punctuation">:</span> <span class="token string">"bridge"</span>
<span class="token key atrule">network mode</span><span class="token punctuation">:</span> <span class="token string">"host"</span>
<span class="token key atrule">network mode</span><span class="token punctuation">:</span> <span class="token string">"service: [service name]"</span>
<span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"container:[name or id]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="networks"><a class="markdownIt-Anchor" href="#networks"></a> networks</h2>
<p>要加入的网络，使用顶级 networks 下的条目：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">some-service</span><span class="token punctuation">:</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> some<span class="token punctuation">-</span>network
     <span class="token punctuation">-</span> other<span class="token punctuation">-</span>network
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">some-network</span><span class="token punctuation">:</span>
  other<span class="token punctuation">-</span>network<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="pid"><a class="markdownIt-Anchor" href="#pid"></a> pid</h2>
<p>与主机系统共享进程命名空间。打开该选项的容器之间，以及和宿主机系统之间，可以通过进程 ID 来相互访问和操作：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">pid</span><span class="token punctuation">:</span> <span class="token string">"host"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ports"><a class="markdownIt-Anchor" href="#ports"></a> ports</h2>
<p>暴露端口信息。使用 <code>宿主端口:容器端口（HOST:CONTAINER）</code>格式，或者仅指定容器的端口（宿主将随机选择端口）均可：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">"3000"</span>
  <span class="token punctuation">-</span> <span class="token string">"8000:8000"</span>
  <span class="token punctuation">-</span> <span class="token string">"49100:22"</span>
  <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:8001:8001"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者可以指定详细设置：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">target</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">published</span><span class="token punctuation">:</span> <span class="token number">8080</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> tcp
    <span class="token key atrule">mode</span><span class="token punctuation">:</span> ingress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果使用的容器端口小于 60 并且没有放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
<h2 id="restart"><a class="markdownIt-Anchor" href="#restart"></a> restart</h2>
<p>指定重启策略，可以为 <code>no</code>（不重启），<code>always</code>（总是），<code>on-failure</code>（失败时），<code>unless-stopped</code>（除非停止）。例如：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="sysctls"><a class="markdownIt-Anchor" href="#sysctls"></a> sysctls</h2>
<p>配置容器内的内核参数。例如指定连接数为 4096 和开启 TCP 的 syncookies：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">sysctls</span><span class="token punctuation">:</span>
  <span class="token key atrule">net.core.somaxconn</span><span class="token punctuation">:</span> <span class="token number">4096</span>
  <span class="token key atrule">net.ipv4.tcp_syncookies</span><span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="ulimits"><a class="markdownIt-Anchor" href="#ulimits"></a> ulimits</h2>
<p>指定容器的 ulimits 限制值。例如指定最大进程数为 65535，指定文件旬柄数为 20000（软限制）和 40000（系统硬限制）：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ulimits</span><span class="token punctuation">:</span>
  <span class="token key atrule">nproc</span><span class="token punctuation">:</span> <span class="token number">65535</span>
  <span class="token key atrule">nofile</span><span class="token punctuation">:</span>
    <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">20000</span>
    <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">40000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="volumes"><a class="markdownIt-Anchor" href="#volumes"></a> volumes</h2>
<p>数据卷所挂载路径设置。可以设置宿主机路径（<code>HOST:CONTAINER</code>）或加上访问模式（<code>HOST:CONTAINER:ro</code>）。 支持如 <code>ver</code>，<code>driver_opts</code>，<code>external</code>，<code>labels</code>，<code>name</code> 等子配置，该指令中路径支持相对路径：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> /var/lib/mysql
  <span class="token punctuation">-</span> cache/<span class="token punctuation">:</span>/tmp/cache
  <span class="token punctuation">-</span> ~/configs<span class="token punctuation">:</span>/etc/configs/<span class="token punctuation">:</span>ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>卷的 <code>bind</code> 和 <code>volume</code> 的混合使用示例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.2"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token comment"># 卷 (volume)</span>
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> volume
        <span class="token key atrule">source</span><span class="token punctuation">:</span> mydata
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /data
        <span class="token key atrule">volume</span><span class="token punctuation">:</span>
          <span class="token key atrule">nocopy</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
      <span class="token comment"># 挂载 (bind)</span>
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> bind
        <span class="token key atrule">source</span><span class="token punctuation">:</span> ./static
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /opt/app/static
<span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span>latest
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock"</span>
      <span class="token punctuation">-</span> <span class="token string">"dbdata:/var/lib/postgresql/data"</span>
<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">mydata</span><span class="token punctuation">:</span>
  dbdata<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="操作命令"><a class="markdownIt-Anchor" href="#操作命令"></a> 操作命令</h1>
<p>使用 <code>docker-compose</code> 或 <code>docker compose</code> 命令执行。常见选项如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f, --file FILE</td>
<td>指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可多次指定。</td>
</tr>
<tr>
<td>-p, --project-name NAME</td>
<td>指定项目名称，默认将使用所在目录名称作为项目名。</td>
</tr>
<tr>
<td>-H, --host HOST</td>
<td>指定所操作的 Docker 服务地址。</td>
</tr>
<tr>
<td>–tls</td>
<td>启用 TLS，如果指定 <code>-tlsverify</code> 则默认开启。</td>
</tr>
<tr>
<td>–tlscacert CA_PATH</td>
<td>信任的 TLS CA 的证书。</td>
</tr>
<tr>
<td>–tlscert CLIENT_CERT_PATH</td>
<td>客户端使用的 TLS 证书。</td>
</tr>
<tr>
<td>–tlskey TLS_KEY_PATH</td>
<td>TLS 的私钥文件路径。</td>
</tr>
<tr>
<td>–tlsverify</td>
<td>使用 TLS 校验连接对方。</td>
</tr>
<tr>
<td>–project-directory PATH</td>
<td>指定工作目录，默认为 Compose 文件所在路径。</td>
</tr>
</tbody>
</table>
<h2 id="运行命令"><a class="markdownIt-Anchor" href="#运行命令"></a> 运行命令</h2>
<p>使用 <code>docker-compose up</code> 命令，可以让 Compose 完成 Docker Compose 项目的镜像构建、容器创建、容器启动和连接容器等操作。下面使用一个最简化的 WordPress 项目示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">vi</span> docker-compose.yml
version: <span class="token string">"3"</span>
services:
  wordpress:
    image: wordpress
    depends_on:
      - db
    ports:
      - <span class="token number">8080</span>:80
    links:
      - db
  db:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: example<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认情况下，<code>docker-compose up</code> 启动的容器都在前台，终端会同时打印所有容器的输出信息，非常方便调试。可以使用快捷键 <code>Ctrl+c</code> 停止前台运行的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">docker</span> compose up
docker-db-1         <span class="token operator">|</span> <span class="token number">2021</span>-10-31 <span class="token number">22</span>:28:26 <span class="token number">0</span> <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> <span class="token string">'proxies_priv'</span> entry <span class="token string">'@% root@2b59c74426dd'</span> ignored <span class="token keyword">in</span> --skip-name-resolve mode.
docker-db-1         <span class="token operator">|</span> <span class="token number">2021</span>-10-31 <span class="token number">22</span>:28:26 <span class="token number">0</span> <span class="token punctuation">[</span>Note<span class="token punctuation">]</span> mysqld: ready <span class="token keyword">for</span> connections.
docker-db-1         <span class="token operator">|</span> Version: <span class="token string">'10.6.4-MariaDB-1:10.6.4+maria~focal'</span>  socket: <span class="token string">'/run/mysqld/mysqld.sock'</span>  port: <span class="token number">3306</span>  mariadb.org binary distribution
^CGracefully stopping<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl+C again to force<span class="token punctuation">)</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">2</span>/2
 ⠿ Container docker-wordpress-1  Stopped                                          <span class="token number">1</span>.6s
 ⠿ Container docker-db-1         Stopped                                          <span class="token number">0</span>.4s
canceled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要在后台启动并运行所有容器，可以使用 <code>docker-compose up -d</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">docker</span> compose up <span class="token parameter variable">-d</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">2</span>/2
 ⠿ Container docker-db-1         Started                                     <span class="token number">0</span>.6s
 ⠿ Container docker-wordpress-1  Started                                     <span class="token number">1</span>.6s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果服务容器已存在，会尝试停止容器后重新创建，也可以使用 <code>--no-recreate</code> 命令控制只启动停止状态的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">docker</span> compose <span class="token parameter variable">-f</span> docker-compose.yml up --no-recreate <span class="token parameter variable">-d</span>
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">3</span>/3
 ⠿ Network docker_default        Created                                       <span class="token number">0</span>.1s
 ⠿ Container docker-db-1         Started                                       <span class="token number">0</span>.7s
 ⠿ Container docker-wordpress-1  Started                                       <span class="token number">1</span>.7s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="停止命令"><a class="markdownIt-Anchor" href="#停止命令"></a> 停止命令</h2>
<p>通过 <code>docker-compose down</code> 命令，可以让所有通过 <code>up</code> 启动的容器停止，并删除所创建的镜像及网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">docker</span> compose <span class="token parameter variable">-f</span> docker-compose.yml down
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Running <span class="token number">3</span>/3
 ⠿ Container docker-wordpress-1  Removed                                   <span class="token number">1</span>.2s
 ⠿ Container docker-db-1         Removed                                   <span class="token number">0</span>.4s
 ⠿ Network docker_default        Removed                                   <span class="token number">0</span>.1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="示例样本"><a class="markdownIt-Anchor" href="#示例样本"></a> 示例样本</h1>
<p>下面创建一个 Web 服务，包含 Python 程序和 Redis 服务两个容器。</p>
<p>首先准备 <code>web.py</code> 文件，连接 Redis 服务，并显示访问量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> app/web
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> app/web/web.py
from flask <span class="token function">import</span> Flask
from redis <span class="token function">import</span> Redis

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>

@app.route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
def hello<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    redis.incr<span class="token punctuation">(</span><span class="token string">'number'</span><span class="token punctuation">)</span>
    <span class="token builtin class-name">return</span> <span class="token string">'Hello Vi! # %s'</span> % redis.get<span class="token punctuation">(</span><span class="token string">'number'</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token builtin class-name">:</span>
    app.run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"0.0.0.0"</span>, <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">80</span>, <span class="token assign-left variable">debug</span><span class="token operator">=</span>True<span class="token punctuation">)</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编辑依赖第三方库包的名称和版本信息说明文件 <code>requirements.txt</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> app/web/requirements.txt
<span class="token assign-left variable">flask</span><span class="token operator">==</span><span class="token number">0.10</span>
<span class="token assign-left variable">redis</span><span class="token operator">==</span><span class="token number">2.10</span>.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>建立 <code>Dockerfile</code> 文件用来构建 Web 应用镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> app/web/Dockerfile
FROM python:2.7
COPY ./ /web/
WORKDIR /web
RUN pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt
CMD python web.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后配置 <code>docker-compose.yml</code> 文件，将两个服务写进去：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> app/docker-compose.yml
version: <span class="token string">'3.0'</span>
services:
  redis:
    image: redis:3.2
  web:
    build:
      context: /root/app/web
    depends_on:
    - redis
    ports:
    - <span class="token number">8001</span>:80/tcp
    volumes:
    - /root/app/web:/web:rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>docker-compose up</code> 命令来启动应用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> compose <span class="token parameter variable">-f</span> app/docker-compose.yml up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动之后可以通过 <a href="http://192.168.2.206:8001/">http://192.168.2.206:8001/</a> 来访问。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 安全与监控</title>
    <url>/1472106291/</url>
    <content><![CDATA[<h1 id="tls-加密配置"><a class="markdownIt-Anchor" href="#tls-加密配置"></a> TLS 加密配置</h1>
<p>Docker Daemon 监听 Socket 有三种方式，分别是 unix、tcp 和 fd。其中，监听 fd 文件是使用 system 的系统专用。</p>
<p>在默认配置中，Docker Remote API 通过 Socket 监听来自本地的连接，监听地址位于 <code>unix:///var/run/docker.sock</code>。可以通过 <code>curl</code> 发送一个简单的请求来测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 .docker<span class="token punctuation">]</span>$ <span class="token function">curl</span> --unix-socket /var/run/docker.sock http://localhost/info <span class="token operator">|</span> python <span class="token parameter variable">-mjson.tool</span>
<span class="token punctuation">&#123;</span>
    <span class="token string">"Architecture"</span><span class="token builtin class-name">:</span> <span class="token string">"x86_64"</span>,
    <span class="token string">"BridgeNfIp6tables"</span><span class="token builtin class-name">:</span> false,
    <span class="token string">"BridgeNfIptables"</span><span class="token builtin class-name">:</span> false,
    <span class="token string">"CPUSet"</span><span class="token builtin class-name">:</span> true,
    <span class="token string">"CPUShares"</span><span class="token builtin class-name">:</span> true,
    <span class="token string">"CgroupDriver"</span><span class="token builtin class-name">:</span> <span class="token string">"cgroupfs"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过 <code>-H</code> 选项来修改监听方式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ dockerd <span class="token parameter variable">-H</span> <span class="token number">192.168</span>.2.234:5999 <span class="token parameter variable">-H</span> unix:///var/run/docker.sock <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>客户端可以通过 <code>docker -H</code> 指定服务端地址来操作服务端。也可以设置 Docker_HOST 变量固定服务器地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token parameter variable">-H</span> tcp://192.168.2.234:5999 pull ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 Docker 中规定 2375 作为非加密端口，2376 作为加密端口。如果没有启用 TLS，则服务端与客户端的通信没有认证和加密，任何客户端口可以向服务端发送命令。</p>
<p>使用 TLS 通信需要在服务端和客户端中加入 TLS 相关的配置。首先创建 RSA 私钥 <code>ca.key</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ openssl genrsa <span class="token parameter variable">-aes256</span> <span class="token parameter variable">-out</span> ca.key <span class="token number">4096</span>
Generating RSA private key, <span class="token number">4096</span> bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
Enter pass phrase <span class="token keyword">for</span> ca.key:
Verifying - Enter pass phrase <span class="token keyword">for</span> ca.key:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 RSA 私钥创建 CA 证书 <code>ca.pem</code>。参数 <code>-x509</code> 是生成自签名 CA 证书，参数 <code>-days 365</code> 设置证书有效期：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-key</span> ca.key <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-out</span> ca.pem
Enter pass phrase <span class="token keyword">for</span> ca.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="token string">'.'</span>, the field will be left blank.
-----
Country Name <span class="token punctuation">(</span><span class="token number">2</span> letter code<span class="token punctuation">)</span> <span class="token punctuation">[</span>XX<span class="token punctuation">]</span>:CN
State or Province Name <span class="token punctuation">(</span>full name<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:BeiJing
Locality Name <span class="token punctuation">(</span>eg, city<span class="token punctuation">)</span> <span class="token punctuation">[</span>Default City<span class="token punctuation">]</span>:BeiJing
Organization Name <span class="token punctuation">(</span>eg, company<span class="token punctuation">)</span> <span class="token punctuation">[</span>Default Company Ltd<span class="token punctuation">]</span>:server1
Organizational Unit Name <span class="token punctuation">(</span>eg, section<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:Dev
Common Name <span class="token punctuation">(</span>eg, your name or your server<span class="token string">'s hostname) []:server1
Email Address []:root@server1.com
[root@server1 ~]$ scp ca.* root@192.168.2.241:/root
root@192.168.2.241'</span>s password: 
ca.key                                                 <span class="token number">100</span>% <span class="token number">3326</span>     <span class="token number">2</span>.7MB/s   00:00    
ca.pem                                                 <span class="token number">100</span>% <span class="token number">2094</span>     <span class="token number">2</span>.4MB/s   00:00    
ca.srl                                                 <span class="token number">100</span>%   <span class="token number">17</span>    <span class="token number">24</span>.3KB/s   00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建服务器私钥和 CSR。其中 <code>server.key</code> 是服务器私钥的文件名，<code>server.csr</code> 是服务器 CSR 文件名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ openssl genrsa <span class="token parameter variable">-out</span> server.key <span class="token number">4096</span>
Generating RSA private key, <span class="token number">4096</span> bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ openssl req <span class="token parameter variable">-subj</span> <span class="token string">"/CN=server1"</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> server.key <span class="token parameter variable">-out</span> server.csr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 CA 证书创建服务器证书文件，可以限制连接客户端 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> subjectAltName <span class="token operator">=</span> IP:192.168.2.234,IP:192.168.2.241,IP:127.0.0.1 <span class="token operator">></span> allowip.cnf
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> server.csr <span class="token parameter variable">-CA</span> ca.pem <span class="token parameter variable">-CAkey</span> ca.key <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> server.pem <span class="token parameter variable">-extfile</span> allowip.cnf
Signature ok
<span class="token assign-left variable">subject</span><span class="token operator">=</span>/CN<span class="token operator">=</span>server1
Getting CA Private Key
Enter pass phrase <span class="token keyword">for</span> ca.key:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建客户端私钥和 CSR：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ openssl genrsa <span class="token parameter variable">-out</span> client.key <span class="token number">4096</span>
Generating RSA private key, <span class="token number">4096</span> bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.++
e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ openssl req <span class="token parameter variable">-subj</span> <span class="token string">'/CN=server4'</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> client.key <span class="token parameter variable">-out</span> client.csr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 CA 证书创建客户端证书文件，需要加入 <code>extendedKeyUsage</code> 选项：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> extendedKeyUsage <span class="token operator">=</span> clientAuth <span class="token operator">></span> client.cnf
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> client.csr <span class="token parameter variable">-CA</span> ca.pem <span class="token parameter variable">-CAkey</span> ca.key <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> client.pem <span class="token parameter variable">-extfile</span> client.cnf 
Signature ok
<span class="token assign-left variable">subject</span><span class="token operator">=</span>/CN<span class="token operator">=</span>server4
Getting CA Private Key
Enter pass phrase <span class="token keyword">for</span> ca.key:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 PEM 文件之后可以删除 CSR 文件。修改证书权限并移动到 <code>~/.docker/</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> client.cnf client.csr 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-v</span> 0400 *.key
mode of ‘ca.key’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0244 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
mode of ‘client.key’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0244 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-v</span> 0444 *.pem
mode of ‘ca.pem’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0444 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
mode of ‘client.pem’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0444 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> .docker
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> ca.pem client.* .docker/
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> server.csr allowip.cnf 
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-v</span> 0400 *.key
mode of ‘ca.key’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0244 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
mode of ‘server.key’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0244 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-v</span> 0444 *.pem
mode of ‘ca.pem’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0444 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
mode of ‘server.pem’ changed from 0644 <span class="token punctuation">(</span>rw-r--r--<span class="token punctuation">)</span> to 0444 <span class="token punctuation">(</span>r--r--r--<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> .docker
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> ca.pem server.* .docker/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改服务端配置文件并重启：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/docker/daemon.json
<span class="token punctuation">&#123;</span>
    <span class="token string">"tlsverify"</span><span class="token builtin class-name">:</span> true,
    <span class="token string">"tlscacert"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/ca.pem"</span>,
    <span class="token string">"tlscert"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/server.pem"</span>,
    <span class="token string">"tlskey"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/server.key"</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改客户端配置文件并重启：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/docker/daemon.json
<span class="token punctuation">&#123;</span>
    <span class="token string">"tlsverify"</span><span class="token builtin class-name">:</span> true,
    <span class="token string">"tlscacert"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/ca.pem"</span>,
    <span class="token string">"tlscert"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/client.pem"</span>,
    <span class="token string">"tlskey"</span><span class="token builtin class-name">:</span> <span class="token string">"/root/.docker/client.key"</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端测试连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /root/.docker/
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token parameter variable">--tlsverify</span> <span class="token parameter variable">--tlscacert</span><span class="token operator">=</span>ca.pem <span class="token parameter variable">--tlscert</span><span class="token operator">=</span>client.pem <span class="token parameter variable">--tlskey</span><span class="token operator">=</span>client.key <span class="token parameter variable">-H</span> tcp://192.168.2.234:5999 <span class="token function">ps</span> <span class="token parameter variable">-a</span>
CONTAINER ID   IMAGE           COMMAND           CREATED       STATUS                      PORTS     NAMES
7198e1cdf396   pytest/volume   <span class="token string">"/bin/sleep 60"</span>   <span class="token number">5</span> hours ago   Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">5</span> hours ago                clever_aryabhata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="docker-bench"><a class="markdownIt-Anchor" href="#docker-bench"></a> Docker Bench</h1>
<p>Docker Bench 是一个开源项目，该项目按照互联网安全中心（CIS，Center for Internet Security）对于 Docker 的安全规范进行一系列环境检查。</p>
<p>可以利用 Docker 镜像快速进行检查：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--pid</span> <span class="token function">host</span> <span class="token parameter variable">--userns</span> <span class="token function">host</span> --cap-add audit_control <span class="token parameter variable">-e</span> <span class="token assign-left variable">DOCKER_CONTENT_TRUST</span><span class="token operator">=</span><span class="token variable">$DOCKER_CONTENT_TRUST</span> <span class="token parameter variable">-v</span> /var/lib:/bar/lib <span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="token parameter variable">-v</span> /usr/lib/systemd:/usr/lib/systemd <span class="token parameter variable">-v</span> /etc:/etc <span class="token parameter variable">--label</span> docker_bench_security docker/docker-bench-security<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="sysdig"><a class="markdownIt-Anchor" href="#sysdig"></a> Sysdig</h1>
<p>Sysdig 是一个轻量级的系统监控工具，原生支持容器。可以使用容器来运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>sysdig <span class="token parameter variable">--privileged</span> <span class="token parameter variable">--volume</span><span class="token operator">=</span>/var/run/docker.sock:/host/var/run/docker.sock <span class="token parameter variable">--volume</span><span class="token operator">=</span>/dev/:/host/dev/ <span class="token parameter variable">--volume</span><span class="token operator">=</span>/proc/:/host/proc/:ro <span class="token parameter variable">--volume</span><span class="token operator">=</span>/boot/:/host/boot/:ro <span class="token parameter variable">--volume</span><span class="token operator">=</span>/lib/modules/:/host/lib/modules/:ro <span class="token parameter variable">--volume</span><span class="token operator">=</span>/usr/:/host/usr/:ro sysdig/sysdig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动后进入容器执行 <code>csysdig</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@213496097e95:/<span class="token comment"># csysdig</span>
   PID   <span class="token environment constant">PPID</span>     CPU <span class="token environment constant">USER</span>          TH     VIRT      RES    FILE     NET Command
  <span class="token number">1250</span>      <span class="token number">1</span>    <span class="token number">0.50</span> root          <span class="token number">16</span>       1G      40M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/bin/contain
  <span class="token number">5459</span>   <span class="token number">5298</span>    <span class="token number">0.50</span> root           <span class="token number">2</span>     362M      15M       <span class="token number">0</span>    <span class="token number">0.00</span> csysdig
  <span class="token number">1500</span>      <span class="token number">1</span>    <span class="token number">0.00</span> root           <span class="token number">1</span>      88M       2M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/libexec/pos
  <span class="token number">1506</span>   <span class="token number">1500</span>    <span class="token number">0.00</span>                <span class="token number">1</span>      88M       4M       <span class="token number">0</span>    <span class="token number">0.00</span> pickup <span class="token parameter variable">-l</span> <span class="token parameter variable">-t</span> uni
  <span class="token number">4624</span>   <span class="token number">4511</span>    <span class="token number">0.00</span> www-data       <span class="token number">1</span>     222M       9M       <span class="token number">0</span>    <span class="token number">0.00</span> apache2 <span class="token parameter variable">-DFOREGR</span>
   <span class="token number">954</span>      <span class="token number">1</span>    <span class="token number">0.00</span>                <span class="token number">2</span>      65M       3M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/bin/dbus-da
  <span class="token number">4475</span>   <span class="token number">1477</span>    <span class="token number">0.00</span> root           <span class="token number">7</span>     806M      10M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/bin/docker-
   <span class="token number">947</span>      <span class="token number">1</span>    <span class="token number">0.00</span> root           <span class="token number">3</span>     267M       5M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/bin/vmtools
  <span class="token number">5254</span>   <span class="token number">5233</span>    <span class="token number">0.00</span> root          <span class="token number">11</span>       1G      39M      4K    <span class="token number">0.00</span> <span class="token function">docker</span> run <span class="token parameter variable">-it</span> -
  <span class="token number">4291</span>   <span class="token number">4272</span>    <span class="token number">0.00</span>                <span class="token number">8</span>       1G      74M       <span class="token number">0</span>    <span class="token number">0.00</span> mysqld
  <span class="token number">1036</span>      <span class="token number">1</span>    <span class="token number">0.00</span> root           <span class="token number">1</span>     108M     860K       <span class="token number">0</span>    <span class="token number">0.00</span> /sbin/agetty <span class="token parameter variable">--n</span>
  <span class="token number">1507</span>   <span class="token number">1500</span>    <span class="token number">0.00</span>                <span class="token number">1</span>      88M       4M       <span class="token number">0</span>    <span class="token number">0.00</span> qmgr <span class="token parameter variable">-l</span> <span class="token parameter variable">-t</span> unix
   <span class="token number">948</span>      <span class="token number">1</span>    <span class="token number">0.00</span>                <span class="token number">7</span>     598M      14M       <span class="token number">0</span>    <span class="token number">0.00</span> /usr/lib/polkit-
F1Help  F2Views F4FilterF5Echo  F6Dig   F7LegendF8ActionsF9Sort  F12Spe       <span class="token number">8</span>/43<span class="token punctuation">(</span><span class="token number">18.6</span>%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="weave-scope"><a class="markdownIt-Anchor" href="#weave-scope"></a> Weave Scope</h1>
<p>Weave Scope 可以将 Docker 容器分布生成一张地图，看起来很直观：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">curl</span> <span class="token parameter variable">-L</span> https://github.com/weaveworks/scope/releases/download/latest_release/scope <span class="token parameter variable">-o</span> /usr/local/bin/scope
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> a+x /usr/local/bin/scope 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ scope launch
Scope probe started
Weave Scope is listening at the following URL<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:
  * http://192.168.2.204:4040/
  * http://172.18.0.1:4040/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>scope launch</code> 将以容器方式启动 Weave Scope，之后通过 <code>http://192.168.2.204:4040/</code> 在浏览器访问。</p>
<p>如果需要监控多台主机，在 <code>scope launch</code> 后面加上对应主机的 IP 地址，并在每台主机上运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ scope launch <span class="token number">192.168</span>.2.204 <span class="token number">192.168</span>.2.205 <span class="token number">192.168</span>.2.206<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>加入基本账号验证：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ scope launch <span class="token parameter variable">-app.basicAuth</span> <span class="token parameter variable">-app.basicAuth.password</span> <span class="token number">123456</span> <span class="token parameter variable">-app.basicAuth.username</span> user <span class="token parameter variable">-probe.basicAuth</span> <span class="token parameter variable">-probe.basicAuth.password</span> <span class="token number">123456</span> <span class="token parameter variable">-probe.basicAuth.username</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="elk"><a class="markdownIt-Anchor" href="#elk"></a> ELK</h1>
<p>ELK 套件是三个软件的合称：Elasticsearch（搜索引擎）、Logstash（日志分析）和 Kibana（可视化）。</p>
<p>下面采用最小部署。其中，5601 是 Kibana web 接口，9200 是 Elasticsearch JSON 接口，5044 是 Logstash 日志接口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5601</span>:5601 <span class="token parameter variable">-p</span> <span class="token number">9200</span>:9200 <span class="token parameter variable">-p</span> <span class="token number">5044</span>:5044 <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> elk sebp/elk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果启动报错 “vm.max_map_count [65530] is too low”，需要修改 <code>/etc/sysctl.conf</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/sysctl.conf
<span class="token assign-left variable">vm.max_map_count</span><span class="token operator">=</span><span class="token number">262144</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">sysctl</span> <span class="token parameter variable">-p</span>
net.ipv4.ip_forward <span class="token operator">=</span> <span class="token number">1</span>
vm.max_map_count <span class="token operator">=</span> <span class="token number">262144</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动之后通过 <a href="http://192.168.2.204:5601/">http://192.168.2.204:5601/</a> 来访问。由于目前没有任何日志，所以还需要使用 Filebeat 来配合，它能将指定路径下的日志文件转发给 ELK：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-O</span> https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.3.0-x86_64.rpm
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-vi</span> filebeat-7.3.0-x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之后修改 Filebeat 配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/filebeat/filebeat.yml 
<span class="token comment">#=========================== Filebeat inputs =============================</span>
- type: log
  enabled: <span class="token boolean">true</span>
  paths:
    - /var/lib/docker/containers/*/*.log
    - /var/log/*.log
<span class="token comment">#-------------------------- Elasticsearch output ------------------------------</span>
output.elasticsearch:
  <span class="token comment"># Array of hosts to connect to.</span>
  hosts: <span class="token punctuation">[</span><span class="token string">"localhost:9200"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ filebeat setup <span class="token parameter variable">-e</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动 Filebeat 后，监控的日志会发送给 Elasticsearch：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl start filebeat.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>访问 <a href="http://192.168.2.204:5601/">http://192.168.2.204:5601</a>，进入 Kibana 的 Discover 页面，即可查看日志。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker API</title>
    <url>/2670657393/</url>
    <content><![CDATA[<h1 id="restful"><a class="markdownIt-Anchor" href="#restful"></a> RESTful</h1>
<p>Docker API 是一套基于 RESTful（Representational State Transfer，表述性状态转移）设计的 HTTP 接口，用于操作 Docker 服务。它实现在 Docker 服务程序中，并由 Docker 服务程序向外提供。</p>
<p>RESTful 设计中有几个比较关键的概念：</p>
<ul>
<li>
<p>资源（Resource）</p>
<p>RESTful 接口操作或获取的对象就是资源，在 Docker 中可以是容器、镜像、数据卷等实体。</p>
</li>
<li>
<p>表述（Representation）</p>
<p>由于资源形式各式各样，因此在 RESTful 设计中要求采用可读性的格式来展示资源。在 Docker API 中，大多数资源以 JSON 文本的形式进行表述。</p>
</li>
<li>
<p>状态转移（State Transfer）</p>
<p>对于资源的修改可以理解为资源状态的变化，即状态转移。在 RESTful 设计中，强调使用 HTTP 方法来确定资源的操作方式，例如使用 GET 获取、POST 新增、PUT 修改、DELETE 删除等。</p>
</li>
</ul>
<h1 id="docker-api"><a class="markdownIt-Anchor" href="#docker-api"></a> Docker API</h1>
<p>采用 Docker API 进行通信可以省去 Docker 客户端的安装，并且能够提供更高效和更自由的操作。</p>
<p>为了区分不同功能模块提供的接口，Docker API 进行了划分。例如，用于操作 Docker 镜像和容器等模块的接口称为 Docker Remote API，用于操作和管理 Docker Registry 远程仓库的服务接口称为 Docker Registry API，用于操作 Docker Cloud 云服务的接口称为 Docker Cloud API。</p>
<h1 id="docker-remote-api"><a class="markdownIt-Anchor" href="#docker-remote-api"></a> Docker Remote API</h1>
<p>Docker Remote API 是由 Docker 服务程序提供的，是 Docker API 的核心部分，它可以控制 Docker 服务以及其中镜像、容器、网络等功能的运行。</p>
<p>以下是一些常用的操作方法：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>列出容器</td>
<td>GET /containers/json</td>
</tr>
<tr>
<td>创建容器</td>
<td>POST /containers/create</td>
</tr>
<tr>
<td>查看容器信息</td>
<td>GET /containers/(id)/json</td>
</tr>
<tr>
<td>查看容器进程</td>
<td>GET /containers/(id)/top</td>
</tr>
<tr>
<td>查看容器日志</td>
<td>GET /containers/(id)/logs</td>
</tr>
<tr>
<td>查看文件变更</td>
<td>GET /containers/(id)/changes</td>
</tr>
<tr>
<td>导出容器</td>
<td>GET /containers/(id)/export</td>
</tr>
<tr>
<td>启动容器</td>
<td>POST /containers/(id)/start</td>
</tr>
<tr>
<td>停止容器</td>
<td>POST /containers/(id)/stop</td>
</tr>
<tr>
<td>重启容器</td>
<td>POST /containers/(id)/restart</td>
</tr>
<tr>
<td>杀死容器</td>
<td>POST /containers/(id)/kill</td>
</tr>
<tr>
<td>附加终端</td>
<td>POST /containers/(id)/attach</td>
</tr>
<tr>
<td>暂停容器</td>
<td>POST /containers/(id)/pause</td>
</tr>
<tr>
<td>恢复容器</td>
<td>POST /containers/(id)/unpause</td>
</tr>
<tr>
<td>等待容器停止</td>
<td>POST /containers/(id)/wait</td>
</tr>
<tr>
<td>删除容器</td>
<td>DELETE /containers/(id)</td>
</tr>
<tr>
<td>从容器复制文件</td>
<td>POST /containers/(id)/copy</td>
</tr>
<tr>
<td>列出镜像</td>
<td>GET /images/json</td>
</tr>
<tr>
<td>创建镜像</td>
<td>POST /images/create</td>
</tr>
<tr>
<td>查看镜像信息</td>
<td>GET /images/(name)/json</td>
</tr>
<tr>
<td>获取镜像历史</td>
<td>GET /images/(name)/history</td>
</tr>
<tr>
<td>推送镜像</td>
<td>POST /images/(name)/push</td>
</tr>
<tr>
<td>镜像贴标</td>
<td>POST /images/(name)/tag</td>
</tr>
<tr>
<td>删除镜像</td>
<td>DELETE /images/(name)</td>
</tr>
<tr>
<td>搜索镜像</td>
<td>GET /images/search</td>
</tr>
</tbody>
</table>
<p>也可以使用 <code>curl -X</code> 发送请求来测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> --unix-socket /var/run/docker.sock http://localhost/_ping
OK
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> GET http://192.168.2.234:5999/containers/json?all<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"Id"</span><span class="token builtin class-name">:</span><span class="token string">"4608034f24faa0fde74fe3a53f89bd98af58bcc98c1d82ff51d8f19a9493ce15"</span>,<span class="token string">"Names"</span>:<span class="token punctuation">[</span><span class="token string">"/heuristic_ishizaka"</span><span class="token punctuation">]</span>,<span class="token string">"Image"</span><span class="token builtin class-name">:</span><span class="token string">"alpine"</span>,<span class="token string">"ImageID"</span><span class="token builtin class-name">:</span><span class="token string">"sha256:14119a10abf4669e8cdbdff324a9f9605d99697215a0d21c360fe8dfa8471bab"</span>,<span class="token string">"Command"</span><span class="token builtin class-name">:</span><span class="token string">"/bin/sh"</span>,<span class="token string">"Created"</span>:1635662347,<span class="token string">"Ports"</span>:<span class="token punctuation">[</span><span class="token punctuation">]</span>,<span class="token string">"Labels"</span>:<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,<span class="token string">"State"</span><span class="token builtin class-name">:</span><span class="token string">"exited"</span>,<span class="token string">"Status"</span><span class="token builtin class-name">:</span><span class="token string">"Exited (0) 2 seconds ago"</span>,<span class="token string">"HostConfig"</span>:<span class="token punctuation">&#123;</span><span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span><span class="token string">"default"</span><span class="token punctuation">&#125;</span>,<span class="token string">"NetworkSettings"</span>:<span class="token punctuation">&#123;</span><span class="token string">"Networks"</span>:<span class="token punctuation">&#123;</span><span class="token string">"bridge"</span>:<span class="token punctuation">&#123;</span><span class="token string">"IPAMConfig"</span>:null,<span class="token string">"Links"</span>:null,<span class="token string">"Aliases"</span>:null,<span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span><span class="token string">"c441e7f297764fe10f2ded3a955f4c86f263210a56e77b7a19ce36ef300f44c0"</span>,<span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"Gateway"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"IPPrefixLen"</span>:0,<span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"GlobalIPv6PrefixLen"</span>:0,<span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span><span class="token string">""</span>,<span class="token string">"DriverOpts"</span>:null<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>,<span class="token string">"Mounts"</span>:<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> POST http://192.168.2.234:5999/containers/4608034f24faa/start
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-X</span> DELETE http://192.168.2.234:5999/containers/4608034?v<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token assign-left variable">force</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">74386</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有关详细用法，请参考：<a href="https://docs.docker.com/engine/api/">官方文档</a>。</p>
<h1 id="docker-registry-api"><a class="markdownIt-Anchor" href="#docker-registry-api"></a> Docker Registry API</h1>
<p>Docker Registry API 用于管理和使用远程镜像仓库 Docker Registry。主要提供以下功能：</p>
<ul>
<li>
<p>镜像信息操作：</p>
<p>镜像信息包括镜像 ID、仓库名称、标签、启动命令等，用于全面描述镜像的内容。在推送或拉取镜像之前，需要进行镜像信息的推送和拉取操作。</p>
</li>
<li>
<p>镜像验证：</p>
<p>可以通过 Docker Registry API 提供的镜像信息中的相关字段进行校验，以确保镜像数据完整且未被篡改。</p>
</li>
<li>
<p>镜像推送：</p>
<p>Docker Registry API 提供了分块方式将镜像数据推送到 Docker Registry 服务器，以提高传输速度。镜像服务器在接收到镜像数据后，会先进行数据组装，并可补充上传缺失部分。</p>
</li>
<li>
<p>镜像拉取：</p>
<p>镜像拉取也采用分块方式进行，然后在本地进行组装，以提高镜像传输效率。</p>
</li>
<li>
<p>镜像层控制：</p>
<p>在推送镜像层到仓库时，Docker Registry API 会通过传输的镜像散列值来判断镜像层是否已存在于仓库中，如果存在，则无需传输。</p>
</li>
</ul>
<h1 id="docker-api-调用"><a class="markdownIt-Anchor" href="#docker-api-调用"></a> Docker API 调用</h1>
<p>docker-py 是 Docker 官方提供的 Python 版本的 API 接口库，<a href="https://docker-py.readthedocs.io/en/stable/">参考文档</a>。</p>
<h2 id="安装库"><a class="markdownIt-Anchor" href="#安装库"></a> 安装库</h2>
<p>使用 <code>pip install docker</code> 来安装：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">C:\Users\assassing>pip install docker
Successfully installed docker-5<span class="token punctuation">.</span>0<span class="token punctuation">.</span>3 pywin32-227 websocket-client-1<span class="token punctuation">.</span>2<span class="token punctuation">.</span>1
C:\Users\assassing>python
Python 3<span class="token punctuation">.</span>8<span class="token punctuation">.</span>1 <span class="token punctuation">(</span>tags/v3<span class="token punctuation">.</span>8<span class="token punctuation">.</span>1:1b293b6<span class="token punctuation">,</span> Dec 18 2019<span class="token punctuation">,</span> 23:11:46<span class="token punctuation">)</span> <span class="token namespace">[MSC v.1916 64 bit (AMD64)]</span> on win32
<span class="token function">Type</span> <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> or <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span>
>>> import docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="镜像查询"><a class="markdownIt-Anchor" href="#镜像查询"></a> 镜像查询</h2>
<p>简单查看一下服务端信息：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker

cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'docker info:'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cli<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'docker images:'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cli<span class="token punctuation">.</span>images<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="镜像构建"><a class="markdownIt-Anchor" href="#镜像构建"></a> 镜像构建</h2>
<p>尝试使用 Dockerfile 构建一个简单的镜像：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker
<span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO

dockerfile <span class="token operator">=</span> <span class="token triple-quoted-string string">'''
#Share
FROM busybox
VOLUME /data
CMD ["/bin/sh"]
'''</span>
f <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span>dockerfile<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
response <span class="token operator">=</span> <span class="token punctuation">[</span>line <span class="token keyword">for</span> line <span class="token keyword">in</span> cli<span class="token punctuation">.</span>images<span class="token punctuation">.</span>build<span class="token punctuation">(</span>fileobj<span class="token operator">=</span>f<span class="token punctuation">,</span> rm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> tag<span class="token operator">=</span><span class="token string">'pytest/volume'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建容器"><a class="markdownIt-Anchor" href="#创建容器"></a> 创建容器</h2>
<p>启动刚才建立的镜像：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> docker

cli <span class="token operator">=</span> docker<span class="token punctuation">.</span>DockerClient<span class="token punctuation">(</span>base_url<span class="token operator">=</span><span class="token string">'tcp://192.168.2.234:5999'</span><span class="token punctuation">)</span>
container<span class="token operator">=</span>cli<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>run<span class="token punctuation">(</span>image<span class="token operator">=</span><span class="token string">'pytest/volume'</span><span class="token punctuation">,</span>command<span class="token operator">=</span><span class="token string">'/bin/sleep 60'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>用 Docker 运行数据库</title>
    <url>/350907895/</url>
    <content><![CDATA[<h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h1>
<p>MySQL 是最流行的开源关系型数据库。</p>
<h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2>
<p>下载最常用的 5.7 版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true mysql
NAME         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql        MySQL is a widely used, open-source relation…   <span class="token number">11582</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>  
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull mysql:5.7.28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>MySQL 服务中主要使用的目录如下：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/mysql/conf.d/</td>
<td>MySQL 配置文件目录。</td>
</tr>
<tr>
<td>/var/lib/mysql/</td>
<td>MySQL 数据文件目录。</td>
</tr>
<tr>
<td>/var/log/mysql/</td>
<td>MySQL 日志文件目录。</td>
</tr>
</tbody>
</table>
<p>MySQL 服务使用的端口如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>3306</td>
<td>服务端口</td>
</tr>
</tbody>
</table>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>启动一个随机的 MySQL 容器，将配置目录复制出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--name</span> tempm <span class="token parameter variable">-d</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ALLOW_EMPTY_PASSWORD</span><span class="token operator">=</span><span class="token number">1</span> mysql:5.7.28
bcf418aec03085c97aeb4336b6cecbb4157dfcaa2f9affbc1a4b64f47a93ca12
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> mysql
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">cp</span> <span class="token parameter variable">-a</span> tempm:/etc/mysql/conf.d mysql/conf.d
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> tempm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件 <code>mysql.cnf</code> 内容参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>
pid-file        <span class="token operator">=</span> /var/run/mysqld/mysqld.pid
socket          <span class="token operator">=</span> /var/run/mysqld/mysqld.sock
datadir         <span class="token operator">=</span> /var/lib/mysql
log-error      <span class="token operator">=</span> /var/log/mysql/error.log

sql_mode <span class="token operator">=</span> STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION

symbolic-links<span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">lower_case_table_names</span><span class="token operator">=</span><span class="token number">1</span>
max_allowed_packet <span class="token operator">=</span> 32M
interactive_timeout <span class="token operator">=</span> <span class="token number">120</span>
wait_timeout <span class="token operator">=</span> <span class="token number">120</span>
innodb_flush_log_at_trx_commit <span class="token operator">=</span> <span class="token number">0</span>
character-set-server<span class="token operator">=</span>utf8mb4
collation-server<span class="token operator">=</span>utf8mb4_general_ci
server-id<span class="token operator">=</span><span class="token number">100</span>
log-bin<span class="token operator">=</span>/var/log/mysql/mysql-bin 
skip_ssl
<span class="token comment"># disable_ssl</span>

expire_logs_days <span class="token operator">=</span> <span class="token number">4</span>
slow_query_log <span class="token operator">=</span> ON
slow_query_log_file <span class="token operator">=</span> /var/log/mysql/slow_query.log
long_query_time <span class="token operator">=</span> <span class="token number">5</span>
query_cache_limit <span class="token operator">=</span> 10M
query_cache_min_res_unit <span class="token operator">=</span> <span class="token number">4096</span>
query_cache_size <span class="token operator">=</span> 1G
query_cache_type <span class="token operator">=</span> <span class="token number">1</span>
query_cache_wlock_invalidate <span class="token operator">=</span> <span class="token number">0</span>
log_bin_trust_function_creators <span class="token operator">=</span> <span class="token number">1</span>

<span class="token punctuation">[</span>client<span class="token punctuation">]</span>
default-character-set<span class="token operator">=</span>utf8mb4

<span class="token punctuation">[</span>mysql<span class="token punctuation">]</span>
default-character-set<span class="token operator">=</span>utf8mb4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2>
<p>修改好配置文件后，挂载目录和映射端口启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> mysql <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>mysqlpass <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">-v</span> mysql/conf.d:/etc/mysql/conf.d:ro <span class="token parameter variable">-v</span> mysql/data:/var/lib/mysql mysql:5.7.28
903380791a9ce92461c76fe794b51296312cd685d2cf761bd85fe07d0d86bb2d
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                  NAMES
903380791a9c   mysql          <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">11</span> seconds ago   Up <span class="token number">10</span> seconds   <span class="token number">0.0</span>.0.0:3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, :::3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 Docker-Compose 启动的配置文件参考如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.9'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>5.7.28
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> mysql
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> MYSQL_ROOT_PASSWORD=QeqAr<span class="token punctuation">:</span>%R+s5<span class="token punctuation">:</span>pYnr
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./config/mysql.cnf<span class="token punctuation">:</span>/etc/mysql/conf.d/mysql.cnf
      <span class="token punctuation">-</span> ./data<span class="token punctuation">:</span>/var/lib/mysql
      <span class="token punctuation">-</span> ./log<span class="token punctuation">:</span>/var/log/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，日志目录 <code>log</code> 要手动配置属主和数组，否则会启动报错：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-204:~/mysql$ <span class="token function">chown</span> lxd:docker log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<p>可以使用 MySQL 镜像作为客户端连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> mysql mysql <span class="token parameter variable">-h192.168.2.241</span> <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span>
Enter password: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改 MySQL 的 root 用户密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'mysqlpass'</span><span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>或者用 <code>set</code> 命令。修改完毕用 <code>FLUSH PRIVILEGES</code> 来生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> password <span class="token keyword">for</span> <span class="token string">'root'</span>@<span class="token string">'%'</span> <span class="token operator">=</span> password<span class="token punctuation">(</span><span class="token string">'密码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
FLUSH PRIVILEGES<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h1>
<p>MongoDB 是一款开源文档数据库（Document-Oriented），是当前最流行的 NoSQL 数据库。</p>
<h2 id="下载-2"><a class="markdownIt-Anchor" href="#下载-2"></a> 下载</h2>
<p>MongoDB 5 以上版本，要求 CPU 必须支持 AVX 指令集，否则启动会失败。为了适用性这里使用 4.4.9 版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true mongo
NAME            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mongo           MongoDB document databases provide high avai…   <span class="token number">8243</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
mongo-express   Web-based MongoDB admin interface, written w…   <span class="token number">1071</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>  
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull mongo:4.4.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>MongoDB 服务中主要使用的目录如下：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/data/db/</td>
<td>MongDB 数据库存放目录</td>
</tr>
</tbody>
</table>
<p>MongoDB 服务使用的端口如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>27017</td>
<td>服务端口</td>
</tr>
<tr>
<td>28017</td>
<td>HTTP 访问端口</td>
</tr>
</tbody>
</table>
<h2 id="启动-2"><a class="markdownIt-Anchor" href="#启动-2"></a> 启动</h2>
<p>可以不修改配置文件，挂载目录和映射端口启动，并设置 root 账号密码为 root：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">27017</span>:27017 <span class="token parameter variable">-p</span> <span class="token number">28017</span>:28017 <span class="token parameter variable">--name</span> mongo <span class="token parameter variable">-v</span> /docker/mongodb/db:/data/db <span class="token parameter variable">-e</span> <span class="token assign-left variable">MONGO_INITDB_ROOT_USERNAME</span><span class="token operator">=</span>root <span class="token parameter variable">-e</span> <span class="token assign-left variable">MONGO_INITDB_ROOT_PASSWORD</span><span class="token operator">=</span>root mongo:4.4.9
14d297ff4282ea50bbcb0383ebb51e0fc6da0685dd83cfa9775892803da1b7a5
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                                                                          NAMES
14d297ff4282   mongo          <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">7</span> seconds ago   Up <span class="token number">5</span> seconds   <span class="token number">0.0</span>.0.0:27017-<span class="token operator">></span><span class="token number">27017</span>/tcp, :::27017-<span class="token operator">></span><span class="token number">27017</span>/tcp, <span class="token number">0.0</span>.0.0:28017-<span class="token operator">></span><span class="token number">28017</span>/tcp, :::28017-<span class="token operator">></span><span class="token number">28017</span>/tcp   mongo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 Docker-Compose 启动的配置文件参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3.9'</span>

services:
  mongo:
    image: mongo:4.4.9
    container_name: mongo
    restart: always
    ports:
      - <span class="token string">"27017:27017"</span>
    volumes:
      - ./data:/data/db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>用 Docker 运行网站服务</title>
    <url>/717387216/</url>
    <content><![CDATA[<h1 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> Nginx</h1>
<p>Nginx 是一款功能强大的开源反向代理服务器，支持 HTTP、HTTPS、SMTP、POP3、IMAP 等协议。同时，它还可以作为负载均衡器、HTTP 缓存或 Web 服务器。</p>
<h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2>
<p>可以放心使用官方最新版本镜像，不同版本没有兼容性问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true nginx
NAME      DESCRIPTION                STARS     OFFICIAL   AUTOMATED
nginx     Official build of Nginx.   <span class="token number">15698</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Nginx 服务中主要使用的目录如下：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/share/nginx/html/</td>
<td>网页数据存放处。</td>
</tr>
<tr>
<td>/etc/nginx/</td>
<td>配置文件目录。</td>
</tr>
<tr>
<td>/var/log/nginx/</td>
<td>日志存放目录。</td>
</tr>
</tbody>
</table>
<p>Nginx 作为 Web 服务使用的端口如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td>HTTP 端口</td>
</tr>
<tr>
<td>443</td>
<td>HTTPS 端口</td>
</tr>
</tbody>
</table>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>启动一个临时的 Nginx 容器，将要挂载的目录复制出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> tempn nginx
fb67cb1fce9f32b57729cb62c2a5d716edc1d42d39fcd1faae1bc57f6bab6a9d
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">cp</span> tempn:/etc/nginx/ ~/nginx/config
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> tempn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Nginx 主配置文件 <code>nginx.conf</code> 参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user  nginx<span class="token punctuation">;</span>
worker_processes  auto<span class="token punctuation">;</span>

error_log  /var/log/nginx/error.log notice<span class="token punctuation">;</span>
pid        /var/run/nginx.pid<span class="token punctuation">;</span>


events <span class="token punctuation">&#123;</span>
    use epoll<span class="token punctuation">;</span>
    accept_mutex on<span class="token punctuation">;</span>
    multi_accept on<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>

http <span class="token punctuation">&#123;</span>
    include       /etc/nginx/mime.types<span class="token punctuation">;</span>
    default_type  application/octet-stream<span class="token punctuation">;</span>

    log_format  main  <span class="token string">'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span class="token string">'$status $body_bytes_sent "$http_referer" '</span>
                      <span class="token string">'"$http_user_agent" "$http_x_forwarded_for"'</span><span class="token punctuation">;</span>

    access_log  /var/log/nginx/access.log  main<span class="token punctuation">;</span>
    
    <span class="token comment">#上传文件相关参数</span>
    client_max_body_size 200M<span class="token punctuation">;</span>
    client_body_buffer_size 1024K<span class="token punctuation">;</span>
    client_header_timeout    1m<span class="token punctuation">;</span>
    client_body_timeout      1m<span class="token punctuation">;</span>
    proxy_connect_timeout     60s<span class="token punctuation">;</span>
    proxy_read_timeout      1m<span class="token punctuation">;</span>
    proxy_send_timeout      1m<span class="token punctuation">;</span>

    <span class="token comment">#gzip压缩参数</span>
    <span class="token function">gzip</span>  on<span class="token punctuation">;</span>                 <span class="token comment"># 开启gzip功能</span>
    gzip_min_length  1k<span class="token punctuation">;</span>      <span class="token comment"># 响应页数据上限</span>
    gzip_buffers     <span class="token number">4</span> 16k<span class="token punctuation">;</span>   <span class="token comment"># 缓存空间大小</span>
    gzip_comp_level <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token comment"># 设置压缩级别为6</span>
    gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json<span class="token punctuation">;</span> <span class="token comment"># 压缩文件类型</span>
    gzip_disable <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span> <span class="token comment"># IE 1-6关闭gzip压缩</span>
    gzip_vary on<span class="token punctuation">;</span>             <span class="token comment"># 启用压缩标识</span>


    sendfile        on<span class="token punctuation">;</span>
    <span class="token comment">#tcp_nopush     on;</span>

    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>
    <span class="token comment">#在一次长连接上所允许请求的资源的最大数量</span>
    keepalive_requests <span class="token number">5</span><span class="token punctuation">;</span>

    set_real_ip_from   <span class="token number">0.0</span>.0.0/0<span class="token punctuation">;</span>
    real_ip_header     X-Forwarded-For<span class="token punctuation">;</span>
    real_ip_recursive on<span class="token punctuation">;</span>
    
    include /etc/nginx/conf.d/*.conf<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>个性化主机配置文件一般放在 <code>config/conf.d</code> 目录中。例如，本站配置文件 <code>blog.x2b.net.conf</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    listen <span class="token number">443</span> ssl<span class="token punctuation">;</span>
    server_name blog.x2b.net<span class="token punctuation">;</span>

    ssl_certificate   /etc/nginx/certs/x2b.net.pem<span class="token punctuation">;</span>
    ssl_certificate_key  /etc/nginx/certs/x2b.net.key<span class="token punctuation">;</span>
    ssl_session_timeout 5m<span class="token punctuation">;</span>
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span class="token operator">!</span>NULL:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5:<span class="token operator">!</span>ADH:<span class="token operator">!</span>RC4<span class="token punctuation">;</span>
    ssl_protocols TLSv1.2 TLSv1.3 SSLv3<span class="token punctuation">;</span>
    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>
    location / <span class="token punctuation">&#123;</span>
        root   /usr/share/nginx/html/x2b.net-deploy/<span class="token punctuation">;</span>
        index  index.html index.htm<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>x2b.net</code> 的 SSL 证书上传到服务器，并修改权限为只读：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> nginx
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token parameter variable">-R</span> nginx:nginx cert
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">400</span> cert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2>
<p>修改好配置文件后，挂载目录和映射端口启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> nginx <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-p</span> <span class="token number">443</span>:443 <span class="token parameter variable">-v</span> /docker/nginx/html:/usr/share/nginx/html:ro <span class="token parameter variable">-v</span> /docker/nginx/conf.d:/etc/nginx/conf.d:ro nginx
220f821e4fed6e1cc421509bbfbaf6b36a71739b69c89c14d929a34e27ab0524
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                                                      NAMES
220f821e4fed   nginx          <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">21</span> seconds ago   Up <span class="token number">19</span> seconds   <span class="token number">0.0</span>.0.0:80-<span class="token operator">></span><span class="token number">80</span>/tcp, :::80-<span class="token operator">></span><span class="token number">80</span>/tcp, <span class="token number">0.0</span>.0.0:443-<span class="token operator">></span><span class="token number">443</span>/tcp, :::443-<span class="token operator">></span><span class="token number">443</span>/tcp   nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 Docker Compose 启动配置文件内容参考：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'2'</span>

services:
  nginx:
    image: nginx:1.23.4
    container_name: nginx
    restart: always
    ports:
      - <span class="token string">"80:80"</span>
      - <span class="token string">"443:443"</span>
    volumes:
      - ./config:/etc/nginx
      - ./html:/usr/share/nginx/html
      - ./logs:/var/log/nginx
      - ./certs:/etc/nginx/certs
    environment:
      - <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Asia/Shanghai
      - <span class="token assign-left variable">NGINX_WORKER_PROCESSES</span><span class="token operator">=</span>auto
      - <span class="token assign-left variable">NGINX_HTTP_KEEPALIVE_TIMEOUT</span><span class="token operator">=</span><span class="token number">65</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里额外挂载了配置文件中指定的日志目录，因为有时需要对 Nginx 日志做分析。</p>
<h2 id="隧道"><a class="markdownIt-Anchor" href="#隧道"></a> 隧道</h2>
<p>本地环境可以配合 cloudflared 隧道来发布网站。使用 Docker Compose 启动配置参考：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3.9'</span>

services:
  cloudflare:
    image: cloudflare/cloudflared:2023.4.0
    container_name: cloudflared
    restart: always
    network_mode: <span class="token string">"host"</span>
    volumes:
      - ./certs/cert.pem:/home/nonroot/.cloudflared/cert.pem
    command: tunnel run <span class="token parameter variable">--token</span> <span class="token string">"eyJhIjoiZWEyZjE2MTE4NjkyMzFlYmYzMWZjNDI0Zj1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>网络模式必须为 host 才可正常连接服务器。</p>
<h1 id="wordpress"><a class="markdownIt-Anchor" href="#wordpress"></a> WordPress</h1>
<p>WordPress 是基于 PHP 和 MySQL 构建的一款开源内容管理系统 (CMS)，用于创建和管理网站、博客和应用程序。</p>
<h2 id="下载-2"><a class="markdownIt-Anchor" href="#下载-2"></a> 下载</h2>
<p>WordPress 服务中主要使用的目录如下：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/www/html/</td>
<td>网页数据存放处。</td>
</tr>
<tr>
<td>/etc/apache2/</td>
<td>Apache 配置文件目录。</td>
</tr>
<tr>
<td>/usr/local/etc/php/conf.d/</td>
<td>PHP 配置文件目录。</td>
</tr>
</tbody>
</table>
<p>WordPress 默认使用的端口如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td>HTTP 端口</td>
</tr>
</tbody>
</table>
<h2 id="配置-2"><a class="markdownIt-Anchor" href="#配置-2"></a> 配置</h2>
<p>由于 WordPress 配置文件太多，因此最好只挂载需要修改的文件，否则在升级 WordPress 版本后可能会出兼容性问题。</p>
<h3 id="修改上传限制"><a class="markdownIt-Anchor" href="#修改上传限制"></a> 修改上传限制</h3>
<p>修改默认文件上传限制，配置文件 <code>uploads.ini</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">file_uploads <span class="token operator">=</span> On
memory_limit <span class="token operator">=</span> 300M
post_max_size <span class="token operator">=</span> 200M
upload_max_filesize <span class="token operator">=</span> 100M
max_execution_time <span class="token operator">=</span> <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="获取访客真实地址"><a class="markdownIt-Anchor" href="#获取访客真实地址"></a> 获取访客真实地址</h3>
<p>添加 <code>remoteip.conf</code> 和 <code>remoteip.load</code> 配置文件用于获取用户真实 IP 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RemoteIPHeader HTTP-X-Forwarded-For
RemoteIPProxiesHeader X-Forwarded-By<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>载入模块配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LoadModule remoteip_module /usr/lib/apache2/modules/mod_remoteip.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="nginx-配置"><a class="markdownIt-Anchor" href="#nginx-配置"></a> Nginx 配置</h3>
<p>在 Nginx 上新增配置文件 <code>wordpress.x2b.net.conf</code> ，参考内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    listen <span class="token number">443</span> ssl<span class="token punctuation">;</span>
    server_name wordpress.x2b.net<span class="token punctuation">;</span>

    ssl_certificate   /etc/nginx/certs/x2b.net.pem<span class="token punctuation">;</span>
    ssl_certificate_key  /etc/nginx/certs/x2b.net.key<span class="token punctuation">;</span>
    ssl_session_timeout 5m<span class="token punctuation">;</span>
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span class="token operator">!</span>NULL:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5:<span class="token operator">!</span>ADH:<span class="token operator">!</span>RC4<span class="token punctuation">;</span>
    ssl_protocols TLSv1.2 TLSv1.3 SSLv3<span class="token punctuation">;</span>

    ssl_prefer_server_ciphers off<span class="token punctuation">;</span>
    ssl_stapling on<span class="token punctuation">;</span>
    ssl_stapling_verify on<span class="token punctuation">;</span>

    location / <span class="token punctuation">&#123;</span>
        proxy_pass http://192.168.2.204:8080<span class="token punctuation">;</span>
        proxy_redirect default<span class="token punctuation">;</span>
        proxy_read_timeout <span class="token number">86400</span><span class="token punctuation">;</span>
        
        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
        proxy_set_header Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
        proxy_set_header Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span>
        
        <span class="token comment"># 保证获取到真实IP</span>
        proxy_set_header X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        <span class="token comment"># 真实端口号</span>
        proxy_set_header X-Real-Port <span class="token variable">$remote_port</span><span class="token punctuation">;</span>
        <span class="token comment"># X-Forwarded-For 是一个 HTTP 扩展头部。</span>
        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        <span class="token comment"># 在多级代理的情况下，记录每次代理之前的客户端真实ip</span>
        proxy_set_header HTTP_X_FORWARDED_FOR <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        <span class="token comment"># 获取到真实协议</span>
        proxy_set_header X-Forwarded-Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>
        <span class="token comment"># 真实主机名</span>
        proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>
        <span class="token comment"># 设置变量</span>
        proxy_set_header X-NginX-Proxy <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主要是加入获取访客真实 IP 地址的相关配置。</p>
<h2 id="启动-2"><a class="markdownIt-Anchor" href="#启动-2"></a> 启动</h2>
<p>使用 Docker Compose 启动配置文件参考：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3.9'</span>

services:
  wordpress:
    image: wordpress:6.2.0
    container_name: wordpress
    restart: always
    ports:
      - <span class="token string">"8080:80"</span>
    environment:
      - <span class="token assign-left variable">WORDPRESS_DB_HOST</span><span class="token operator">=</span><span class="token number">192.168</span>.2.204
      - <span class="token assign-left variable">WORDPRESS_DB_USER</span><span class="token operator">=</span>root
      - <span class="token assign-left variable">WORDPRESS_DB_PASSWORD</span><span class="token operator">=</span>root密码
      - <span class="token assign-left variable">WORDPRESS_DB_NAME</span><span class="token operator">=</span>wordpress
      - <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Asia/Shanghai
    volumes:
      - ./html:/var/www/html
      - ./config/remoteip.conf:/etc/apache2/mods-enabled/remoteip.conf
      - ./config/remoteip.load:/etc/apache2/mods-enabled/remoteip.load
      - ./config/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="tinyproxy"><a class="markdownIt-Anchor" href="#tinyproxy"></a> Tinyproxy</h1>
<p>Tinyproxy 是一个轻量级的开源代理服务器，旨在提供快速、高效的代理服务。它主要用于在本地网络中转发 HTTP 和 HTTPS 请求，以便用户可以通过代理服务器访问互联网资源。</p>
<p>用 Docker Compose 启动的配置文件参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'3.9'</span>

services:
  tinyproxy:
    image: monokal/tinyproxy:latest
    container_name: tinyproxy
    restart: always
    network_mode: <span class="token string">"host"</span>
    command: /bin/bash /opt/docker-tinyproxy/run.sh ANY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于使用属主机网络，所以不需要配置端口。默认配置中对外监听的代理端口号为 8888。</p>
<h1 id="frp"><a class="markdownIt-Anchor" href="#frp"></a> FRP</h1>
<p>frp（Fast Reverse Proxy）是一个快速、现代化的反向代理工具。通过使用 frp 可以方便地将内网服务暴露给外部网络，实现远程访问内网服务的需求。</p>
<p>服务端 frps 配置文件 <code>config/frps.ini</code> 极简化配置内容参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>common<span class="token punctuation">]</span>
bind_addr <span class="token operator">=</span> <span class="token number">0.0</span>.0.0
bind_port <span class="token operator">=</span> <span class="token number">7000</span>
bind_udp_port <span class="token operator">=</span> <span class="token number">7001</span>
kcp_bind_port <span class="token operator">=</span> <span class="token number">7000</span>
dashboard_addr <span class="token operator">=</span> <span class="token number">0.0</span>.0.0
dashboard_port <span class="token operator">=</span> <span class="token number">7002</span>
dashboard_user <span class="token operator">=</span> hxz393
dashboard_pwd <span class="token operator">=</span> nopasswd
log_file <span class="token operator">=</span> ./logs/frps.log
log_level <span class="token operator">=</span> info
log_max_days <span class="token operator">=</span> <span class="token number">3</span>
token <span class="token operator">=</span> <span class="token comment">#Zu1RY#uc@z::z.HA&lt;N&#123;^4F</span>
max_pool_count <span class="token operator">=</span> <span class="token number">10</span>
max_ports_per_client <span class="token operator">=</span> <span class="token number">0</span>
tcp_mux <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 Docker Compose 启动 frp 服务器端的配置文件参考如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">'2'</span>

services:
  nginx:
    image: snowdreamtech/frps:0.48.0
    container_name: frps
    restart: always
    ports:
      - <span class="token string">"7000:7000"</span>
      - <span class="token string">"7001:7001"</span>
      - <span class="token string">"7002:7002"</span>
      - <span class="token string">"10101:10101"</span>
      - <span class="token string">"10102:10102"</span>
    volumes:
      - ./config/:/etc/frp/
      - ./logs/:/logs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 10101 和 10102 端口为预留给客户端连接的端口。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>用 Docker 运行操作系统</title>
    <url>/962831535/</url>
    <content><![CDATA[<h1 id="busybox"><a class="markdownIt-Anchor" href="#busybox"></a> Busybox</h1>
<p>BusyBox 是一个集成了一百多个常用 Linux 命令的精简工具箱，总大小只有不到 2MB。通过在 Docker 中运行 Busybox 容器，可以快速创建一个轻量级的测试环境，用于验证命令的使用和测试脚本的运行。</p>
<p>在 Docker Hub 上搜索并下载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true busybox
NAME      DESCRIPTION           STARS     OFFICIAL   AUTOMATED
busybox   Busybox base image.   <span class="token number">2379</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span> 
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull busybox
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images busybox
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
busybox      latest    16ea53ea7c65   <span class="token number">5</span> weeks ago   <span class="token number">1</span>.24MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-it</code> 方式启动交互式容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> busybox
/ <span class="token comment"># vi</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped <span class="token punctuation">(</span>signal<span class="token punctuation">)</span>           <span class="token function">vi</span>
/ <span class="token comment"># ls /bin</span>
<span class="token punctuation">[</span>                  dnsdomainname      <span class="token function">id</span>                 mkfs.minix         <span class="token function">rev</span>                <span class="token function">tee</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>                 dos2unix           <span class="token function">ifconfig</span>           mkfs.vfat          <span class="token function">rm</span>                 telnet
acpid              dpkg               <span class="token function">ifdown</span>             <span class="token function">mknod</span>              <span class="token function">rmdir</span>              telnetd
add-shell          dpkg-deb           ifenslave          mkpasswd           rmmod              <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>甚至带有 <code>httpd</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-204:~$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">18080</span>:80 busybox httpd <span class="token parameter variable">-f</span> <span class="token parameter variable">-p</span> <span class="token number">80</span> <span class="token parameter variable">-h</span> /var/www
root@k8s-204:~<span class="token comment"># curl 127.0.0.1:18080</span>
<span class="token operator">&lt;</span>HTML<span class="token operator">></span><span class="token operator">&lt;</span>HEAD<span class="token operator">></span><span class="token operator">&lt;</span>TITLE<span class="token operator">></span><span class="token number">404</span> Not Found<span class="token operator">&lt;</span>/TITLE<span class="token operator">></span><span class="token operator">&lt;</span>/HEAD<span class="token operator">></span>
<span class="token operator">&lt;</span>BODY<span class="token operator">></span><span class="token operator">&lt;</span>H<span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token number">404</span> Not Found<span class="token operator">&lt;</span>/H<span class="token operator"><span class="token file-descriptor important">1</span>></span>
The requested URL was not found
<span class="token operator">&lt;</span>/BODY<span class="token operator">></span><span class="token operator">&lt;</span>/HTML<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="alpine"><a class="markdownIt-Anchor" href="#alpine"></a> Alpine</h1>
<p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版，它采用 musl libc 和 BusyBox 来减小系统体积和资源消耗，比 BusyBox 功能更完善。</p>
<p>Alpine Docker 镜像仅 5 MB 左右大小，由于 Alpine 还提供了包管理工具 <code>apk</code> 查询和安装软件包。所以被 Docker 官方推荐为默认基础环境镜像。使用 alpine 作为基础镜像的镜像名会在后面加上 -alpine，例如 python:3.5-alpine。</p>
<p>可以在 Docker Hub 上搜索下载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true alpine
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
alpine    A minimal Docker image based on Alpine Linux…   <span class="token number">8012</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull alpine
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images alpine
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
alpine       latest    14119a10abf4   <span class="token number">8</span> weeks ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行时可以将需要在 alpine 中运行的命令写在 <code>docker run</code> 最后：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run alpine <span class="token builtin class-name">echo</span> <span class="token string">'555'</span>
<span class="token number">555</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 alpine 容器中安装软件使用 <code>apk add</code> 命令，软件包名可以到 <a href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages</a> 搜索到：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~ <span class="token comment"># apk add vim</span>
<span class="token punctuation">(</span><span class="token number">1</span>/5<span class="token punctuation">)</span> Installing xxd <span class="token punctuation">(</span><span class="token number">8.2</span>.3437-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span>/5<span class="token punctuation">)</span> Installing lua5.3-libs <span class="token punctuation">(</span><span class="token number">5.3</span>.6-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span>/5<span class="token punctuation">)</span> Installing ncurses-terminfo-base <span class="token punctuation">(</span><span class="token number">6</span>.2_p20210612-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">4</span>/5<span class="token punctuation">)</span> Installing ncurses-libs <span class="token punctuation">(</span><span class="token number">6</span>.2_p20210612-r0<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span> Installing <span class="token function">vim</span> <span class="token punctuation">(</span><span class="token number">8.2</span>.3437-r0<span class="token punctuation">)</span>
Executing busybox-1.33.1-r3.trigger
OK: <span class="token number">25</span> MiB <span class="token keyword">in</span> <span class="token number">19</span> packages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="debianubuntu"><a class="markdownIt-Anchor" href="#debianubuntu"></a> Debian/Ubuntu</h1>
<p>Debian 和 Ubuntu 都属于 Debian 系列的服务器操作系统。在一些大型软件镜像中，被作为基础镜像使用。</p>
<p>在 Docker Hub 上搜索并下载相应镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true debian
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu    Ubuntu is a Debian-based Linux operating sys…   <span class="token number">12999</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
debian    Debian is a Linux distribution that's compos…   <span class="token number">4039</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull debian
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>docker run</code> 命令可以直接运行镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> debian
root@67c7d35efc34:/<span class="token comment"># echo $SHELL</span>
/bin/bash
root@67c7d35efc34:/<span class="token comment"># cat /etc/issue</span>
Debian GNU/Linux <span class="token number">11</span> <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果考虑以 Ubuntu 作为基础镜像，通常首先使用 <code>apt-get</code> 命令来更新和安装软件包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> ubuntu
root@a5c5f0b0a7d5:/<span class="token comment"># cat /etc/lsb-release </span>
<span class="token assign-left variable">DISTRIB_ID</span><span class="token operator">=</span>Ubuntu
<span class="token assign-left variable">DISTRIB_RELEASE</span><span class="token operator">=</span><span class="token number">20.04</span>
<span class="token assign-left variable">DISTRIB_CODENAME</span><span class="token operator">=</span>focal
<span class="token assign-left variable">DISTRIB_DESCRIPTION</span><span class="token operator">=</span><span class="token string">"Ubuntu 20.04.3 LTS"</span>
root@a5c5f0b0a7d5:/<span class="token comment"># apt-get update</span>
Fetched <span class="token number">19.5</span> MB <span class="token keyword">in</span> 5s <span class="token punctuation">(</span><span class="token number">3616</span> kB/s<span class="token punctuation">)</span>                
Reading package lists<span class="token punctuation">..</span>. Done
root@a5c5f0b0a7d5:/<span class="token comment"># apt-get install -y curl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="centosfedora"><a class="markdownIt-Anchor" href="#centosfedora"></a> CentOS/Fedora</h1>
<p>CentOS 和 Fedora 都是基于 Red Hat 的 Linux 发行版：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true centos
NAME      DESCRIPTION                     STARS     OFFICIAL   AUTOMATED
centos    The official build of CentOS.   <span class="token number">6810</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>CentOS 最新版为 8.4 版本,一般使用的是 CentOS:7 版本.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> centos
<span class="token punctuation">[</span>root@be4eb8a8025a /<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/centos-release
CentOS Linux release <span class="token number">8.4</span>.2105
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> centos:7
<span class="token punctuation">[</span>root@e6de73058535 /<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/centos-release
CentOS Linux release <span class="token number">7.9</span>.2009 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>3.最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Dockerfile 构建 Docker 镜像</title>
    <url>/2014855778/</url>
    <content><![CDATA[<h1 id="构建基础镜像"><a class="markdownIt-Anchor" href="#构建基础镜像"></a> 构建基础镜像</h1>
<p>想要构建一个系统基础镜像，可以借助 debootstrap 工具：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">debootstrap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下载所需文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token function">debootstrap</span> <span class="token parameter variable">--arch</span> amd64 trusty ubutu-trusty http://mirrors.163.com/ubuntu/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>提交生成基础镜像，名为 <code>ubase:0.1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 docker<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> ubutu-trusty/
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-c</span> <span class="token builtin class-name">.</span><span class="token operator">|</span><span class="token function">docker</span> <span class="token function">import</span> - ubase:0.1
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY                     TAG       IMAGE ID       CREATED         SIZE
ubase                          <span class="token number">0.1</span>       75d5ee4917e0   <span class="token number">8</span> seconds ago   228MB
<span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubase:0.1 /bin/bash
root@e85c74d94582:/<span class="token comment"># cat /etc/os-release     </span>
<span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu"</span>
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">"14.04, Trusty Tahr"</span>
<span class="token assign-left variable">ID</span><span class="token operator">=</span>ubuntu
<span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span>debian
<span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">"Ubuntu 14.04 LTS"</span>
<span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">"14.04"</span>
<span class="token assign-left variable">HOME_URL</span><span class="token operator">=</span><span class="token string">"http://www.ubuntu.com/"</span>
<span class="token assign-left variable">SUPPORT_URL</span><span class="token operator">=</span><span class="token string">"http://help.ubuntu.com/"</span>
<span class="token assign-left variable">BUG_REPORT_URL</span><span class="token operator">=</span><span class="token string">"http://bugs.launchpad.net/ubuntu/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1>
<p>Dockerfile 是由 Docker 提供的进行镜像自动化构建的配置文件，包含所有用于构建镜像所执行的命令。</p>
<p>Dockerfile 本质上是一个简单的文本文件，使用 DSL (Domain Specific Language) 语法，其内容包括三种形式：</p>
<ul>
<li>注释行：使用 <code>#</code> 开头的文本行，用于记录一些额外的说明文字。例如：<code># Echo message</code></li>
<li>指令行：指令行分两部分，行首是指令名称 (INSTRUCTION)，一般采用全部大写字母格式。后面是参数 (arguments)。例如：<code>RUN echo 'Building'</code></li>
<li>解析指令行：解析指令行 (Parser Directives) 也是使用 <code>#</code> 作为开头，主要作用是提供一些解析 Dockerfile 需要使用的参数，一般很少用到。例如：<code># directive=value</code></li>
</ul>
<p>通过 Dockerfile 建立镜像的每一步操作（执行类似 <code>docker commit</code> 操作）都会生成一层镜像，在建立镜像层时本地已存在的镜像层会直接采用。无论什么时候，只要某层发生变化，其上面所有层的缓存都会失效。</p>
<p>当使用 Dockerfile 构建失败时，可以使用 <code>docker run</code> 命令运行基于构建已经成功的最后一步创建的镜像来启动容器，调试失败的构建命令。之后修改 Dockerfile 文件再次尝试构建。</p>
<p>为了减少镜像层数量，可以通过 <code>&amp;&amp;</code> 合并一些构建过程中的脚本命令。</p>
<h1 id="基础指令"><a class="markdownIt-Anchor" href="#基础指令"></a> 基础指令</h1>
<p>基础指令是控制 Dockerfile 整体性质的指令。</p>
<h2 id="from"><a class="markdownIt-Anchor" href="#from"></a> FROM</h2>
<p>FROM 指令用来指定要构建的镜像是基于哪个镜像建立。作为必备指令，FROM 指令必须作为 Dockerfile 的第一条指令。允许出现多个 FROM 指令，以每个 FROM 指令为界限生成不同的镜像。</p>
<p>FROM 指令的格式为：<code>FROM &lt;image&gt;:&lt;tag&gt;</code> 或 <code>FROM &lt;image&gt;@&lt;digest&gt;</code>，其中 <code>&lt;tag&gt;</code> 和 <code>&lt;digest&gt;</code> 都是可选项。</p>
<p>例如以 mysql:5.6 镜像作为基础镜像：<code>FROM mysql:5.6</code>。</p>
<p>如果不以任何镜像为基础，那么写法为：<code>FROM scratch</code>。</p>
<p>为了保证镜像精简，可以选择体积较小的镜像如 <code>Alpine</code> 或 <code>Debian</code> 作为基础镜像。</p>
<h2 id="maintainer"><a class="markdownIt-Anchor" href="#maintainer"></a> MAINTAINER</h2>
<p>MAINTAINER 指令用于提供镜像的作者信息，不是必须提供的。</p>
<p>其格式为：<code>MAINTAINER &lt;name&gt;</code>。</p>
<p>例如填写制作者的联系方式：<code>MAINTAINER bbq@123.com</code>。</p>
<h1 id="控制指令"><a class="markdownIt-Anchor" href="#控制指令"></a> 控制指令</h1>
<p>控制指令是 Dockerfile 的核心部分，通过控制指令来描述整个镜像的构建过程。</p>
<h2 id="run"><a class="markdownIt-Anchor" href="#run"></a> RUN</h2>
<p>RUN 指令用于指定构建镜像时需要执行的操作。每条 RUN 指令执行后，在当前镜像层创建一个新的镜像层。</p>
<ul>
<li>
<p>指令格式：<code>RUN command param1 param2 ...</code></p>
<p>此种形式下的命令是以 shell 来执行操作，在 Linux 上默认选择 <code>/bin/sh</code> 作为 shell 程序。当指令较长时，可以使用 <code>\</code> 来拆分成多行。例如，执行安装多个程序的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token punctuation">\</span>
        gcc <span class="token punctuation">\</span>
        <span class="token function">make</span> <span class="token punctuation">\</span>
        <span class="token function">curl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>指令格式：<code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>此种形式下的命令是将命令和参数都使用双引号进行引用，并逐个传递。使用这种方式可以避免基础镜像中没有 shell 程序或临时切换 shell 程序的问题。例如，使用 <code>/bin/bash</code> 作为 shell：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span>, <span class="token string">"-c"</span>, <span class="token string">"echo build"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>在使用 RUN 指令时，Docker 判断是否采用缓存构建的依据是给出的指令是否与生成缓存所使用的指令一致。如果执行结果有差异，也会采用缓存中的数据。如果希望忽略缓存，可以在执行 <code>docker build</code> 命令时加入 <code>--no-cache</code> 选项。</p>
<p>在构建时安装程序后，需要及时清理缓存和临时文件，以减少镜像体积。</p>
<h2 id="workdir"><a class="markdownIt-Anchor" href="#workdir"></a> WORKDIR</h2>
<p>WORKDIR 指令用于在构建过程中切换工作目录，可以多次指定。可以使用绝对路径或相对路径来指定目录。</p>
<p>指令格式：<code>WORKDIR /root/bin</code></p>
<p>也可以在 WORKDIR 指令中使用环境变量。例如，调用 BASEDIR 变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENV BASEDIR /project
WORKDIR <span class="token variable">$BASEDIR</span>/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果目录不存在，会自动创建。</p>
<h2 id="onbuild"><a class="markdownIt-Anchor" href="#onbuild"></a> ONBUILD</h2>
<p>ONBUILD 可以为镜像添加触发器（trigger），后面指定的指令不会在当前镜像构建时执行，而是在其他镜像通过 FROM 调用时执行。一般对于使用 ONBUILD 指令的镜像，在镜像名后会加上 <code>-onbuild</code>。</p>
<p>指令格式：<code>ONBUILD INSTRUCTION arguments</code></p>
<p>ONBUILD 指令只会在构建子镜像中执行。子镜像构建完成后，指令会消失而不会继承到后续的镜像中。</p>
<p>例如：<code>ONBUILD ADD . /app/src</code></p>
<h1 id="引入指令"><a class="markdownIt-Anchor" href="#引入指令"></a> 引入指令</h1>
<p>主要作用是将文件加入到构建镜像中。</p>
<h2 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h2>
<p>可以使用 ADD 指令将文件从外部传递到镜像内部。</p>
<p>指令格式：<code>ADD &lt;src&gt;... &lt;dest&gt;</code> 或 <code>ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>。后一种形式用于处理带空格的文件名。</p>
<p>指令用法如下：</p>
<ul>
<li>指定源目标时，需要使用相对路径。也就是以 Dockerfile 文件所在路径为基准目录，源目标不能超出基准目录。</li>
<li>如果指定的源目标是压缩文件（gzip、bzip2、xz），Docker 会自动解压文件内容到目标目录。</li>
<li>如果指定的源目标是目录，目录本身不会被复制到镜像中，只会复制目录中的内容。</li>
<li>可以指定 URL 地址作为源目标。</li>
<li>可以使用多个源目标和通配符，此时目标目录必须以 <code>/</code> 结尾。</li>
<li>如果指定的源目标与构建缓存中的文件不一致，Docker 会忽略缓存。</li>
<li>可以使用绝对路径或相对路径来指定目标目录，相对路径是以使用 <code>WORKDIR</code> 指令设置的工作目录为基准。</li>
<li>如果目标目录不存在，会自动创建。</li>
</ul>
<p>例如，将当前目录下的所有 txt 格式文件复制到镜像的 <code>/work/</code> 目录下：<code>ADD *.txt /work/</code>。</p>
<h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> COPY</h2>
<p><code>COPY</code> 指令与 <code>ADD</code> 指令的用法相同，主要区别是 <code>COPY</code> 指令不能指定 URL 地址，也不会自动解压文件。</p>
<h1 id="执行指令"><a class="markdownIt-Anchor" href="#执行指令"></a> 执行指令</h1>
<p>执行指令能够指定通过镜像建立容器时，容器默认执行的命令。Dockerfile 中至少有一条 CMD 或 ENTRYPOINT 指令。</p>
<h2 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h2>
<p>CMD 指令用来指定由镜像创建的容器中的主体程序，也就是配置镜像的默认入口程序。有两种调用格式：</p>
<ul>
<li>
<p>指令格式：<code>CMD command param1 param2 ...</code> 或 <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>用法和 RUN 指令类似，都是取决于是否使用 Shell 程序来执行命令。前一种示例：<code>CMD echo &quot;test.&quot; | wc -</code></p>
<p>一般用后一种格式绑定执行程序，例如：<code>CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</code></p>
</li>
<li>
<p>指令格式：<code>CMD [&quot;param1&quot;,&quot;param2&quot;, ...]</code></p>
<p>将给出的参数传给 ENTRYPOINT 指令给出的程序。</p>
</li>
</ul>
<p>因为容器只会绑定一个应用程序，所以 Dockerfile 中只存在一个 CMD 指令。设置多个 CMD 指令则以最后一个为准。</p>
<p>此外，CMD 指令可以被创建容器时自定义的启动指令给覆盖掉。</p>
<h2 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> ENTRYPOINT</h2>
<p>ENTRYPOINT 指令用于设置主程序启动前的准备工作。例如要在容器中额外启动 <code>sshd</code> 服务，可以把这些服务写到脚本中，通过 ENTRYPOINT 指令来启动。在启动脚本中通过 exec 命令启动的服务，可让服务在容器中使用 PID 1 作为进程号。</p>
<p>Dockerfile 中同样只能有一个 ENTRYPOINT。可以被创建容器时加入的 --entrypoint 参数给覆盖掉。</p>
<p>指令格式：<code>ENTRYPOINT command params ...</code> 或 <code>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;, ...]</code>。两种指令格式在效果上同 CMD 一样。使用 Shell 方式运行时，入口程序不能接收 SIGTERM。</p>
<p>如果同时存在 CMD 和 ENTRYPOINT 指令指定可执行命令，CMD 会在 ENTRYPOINT 之前运行。当 CMD 指令不可执行时，所有 CMD 指令或通过 <code>docker run</code> 方式指定的命令作为参数拼接到 ENTRYPOINT 指令给出的命令之后，传给 ENTRYPOINT 指令给出的程序。</p>
<p>当需要把容器当作一个命令行工具使用时，可以通过 ENTRYPOINT 设置镜像的入口程序。例如配合 CMD 命令启动时显示帮助文档：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"Pygame"</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">"--help"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="配置指令"><a class="markdownIt-Anchor" href="#配置指令"></a> 配置指令</h1>
<p>若要对容器进行相关环境或网络等配置，可以通过配置指令来实现。</p>
<h2 id="expose"><a class="markdownIt-Anchor" href="#expose"></a> EXPOSE</h2>
<p>如果容器中的应用程序需要让其他客户端访问到它提供的端口，需要通过 EXPOSE 指令显式给出对外提供的端口号。</p>
<p>指令格式：<code>EXPOSE &lt;port&gt;</code>。</p>
<p>只需要将开放端口逐一传入即可，多个端口用空格隔开。例如开放容器的 22、80 和 443 端口：<code>EXPOSE 22 80 443</code>。</p>
<p>还可以设置开放的端口协议：<code>EXPOSE 11211/tcp 11211/udp</code>。</p>
<p>创建容器时使用 <code>-P</code> 参数能将 EXPOSE 中端口映射到主机上随机端口。使用 <code>-p</code> 可以映射 EXPOSE 中没有列出的端口。</p>
<h2 id="env"><a class="markdownIt-Anchor" href="#env"></a> ENV</h2>
<p>使用 ENV 指令来设置环境变量，有两种设置格式：</p>
<ul>
<li>
<p>指令格式：<code>ENV &lt;key&gt; &lt;value&gt;</code>。</p>
<p>在键名 key 之后的数据都会被视为环境变量的值。例如设置 myName 值为 John Doe：<code>ENV myName John Doe</code>。</p>
</li>
<li>
<p>指令格式：<code>ENV &lt;key&gt;=&lt;value&gt;</code>。</p>
<p>可以一次指定多个环境变量，并且可以使用 \ 进行换行连接。由于每使用一次 ENV 指令都会生成镜像层，因此建议使用此格式来定义环境变量。例如：<code>ENV myCat=fluffy</code></p>
</li>
</ul>
<p>环境变量能够被继承，基础镜像中的环境变量会继承到构建镜像中。此外，环境变量会存在基于构建镜像运行的容器中。</p>
<p>容器创建时，可以通过 <code>--env</code> 参数来新增或修改环境变量。</p>
<h2 id="label"><a class="markdownIt-Anchor" href="#label"></a> LABEL</h2>
<p>LABEL 指令用来设置镜像的标签。</p>
<p>指令格式：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code>。</p>
<p>每个 LABEL 指令都会产生一个新的镜像层，所以尽量将标签记录在一个 LABEL 指令中。</p>
<p>例如：<code>LABEL version=&quot;1.0&quot; description=&quot;Web Server&quot;</code>。</p>
<h2 id="volume"><a class="markdownIt-Anchor" href="#volume"></a> VOLUME</h2>
<p>创建一个数据挂载点用于持久化。</p>
<p>指令格式：<code>VOLUME [&quot;/DIR&quot;]</code> 或 <code>VOLUME /SRC /DST</code>。</p>
<p>运行容器时可以从本地或其他容器挂载数据卷。例如把 <code>/data</code> 挂载到容器中的 <code>/etc/dfs</code>：<code>VOLUME /data /etc/dfs</code>。</p>
<p>如果容器中的目标目录不存在，会自动新建。</p>
<h2 id="healthcheck"><a class="markdownIt-Anchor" href="#healthcheck"></a> HEALTHCHECK</h2>
<p>配置容器的健康检查。</p>
<p>指令格式：<code>HEALTHCHECK [OPTIONS] CMD command</code></p>
<p>根据所执行命令返回值是否为 0 来判断。若返回值为 1，则容器无法正常工作。</p>
<p>OPTIONS 可以指定以下参数：</p>
<ul>
<li>–interval=DURATION（默认值：30s）：检查的时间间隔。</li>
<li>–timeout=DURATION（默认值：30s）：每次检查等待结果的超时时间。</li>
<li>–retries=N（默认值：3）：重试尝试次数。</li>
</ul>
<p>例如：<code>HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1</code>。</p>
<h2 id="user"><a class="markdownIt-Anchor" href="#user"></a> USER</h2>
<p>USER 指令用于设置执行用户或 UID。如果容器中的应用程序在运行时不需要特权，可以通过 USER 指令将应用程序的所有者设为非 root 用户。此时，在容器中新建用户和组需要指定 UID 和 GID，因为每次构建镜像时系统会分配不同的 UID/GID。</p>
<p>指令格式：<code>USER root</code>。</p>
<p>USER 指令对其后的 RUN、CMD 和 ENTRYPOINT 指令都会起作用。</p>
<h2 id="arg"><a class="markdownIt-Anchor" href="#arg"></a> ARG</h2>
<p>和 ENV 的作用类似，ARG 用于定义只在镜像构建过程中使用的局部变量。</p>
<p>指令格式：<code>ARG &lt;name&gt;=&lt;default&gt;</code>。</p>
<p>ARG 从定义它的地方开始生效，而不是调用的地方。例如：<code>ARG build_user=www</code>。</p>
<p>也可以仅声明变量名而不指定变量值，通过外部传递变量（使用 <code>docker build --build-arg</code> 来赋值）。例如：<code>ARG site</code>。</p>
<p>如果 ENV 指令和 ARG 指令定义了相同的变量，以 ENV 定义的环境变量为准。</p>
<p>Docker 内置了一些镜像创建变量：HTTP_PROXY、HTTPS_PROXY、FTP_PROXY、NO_PROXY。</p>
<h2 id="stopsignal"><a class="markdownIt-Anchor" href="#stopsignal"></a> STOPSIGNAL</h2>
<p>用来定义程序停止的信号，例如：<code>STOPSIGNAL 9</code>。</p>
<h2 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> SHELL</h2>
<p>使用 SHELL 指令可以设定 CMD 和 ENTRYPOINT 等指令默认使用的 shell 程序。</p>
<p>指令格式：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code>。</p>
<p>例如，修改默认执行 shell 为 <code>/bin/bash</code>：<code>SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]</code>。</p>
<h1 id="特殊用法"><a class="markdownIt-Anchor" href="#特殊用法"></a> 特殊用法</h1>
<p>在 Dockerfile 中除了指令外的一些特殊的使用方法。</p>
<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2>
<p>通过 ENV 定义的环境变量，可以在之后的命令中调用，调用方式有以下几种：</p>
<ul>
<li>$变量名：这是最普通的调用方法，例如：<code>RUN echo $HOME</code>。</li>
<li>${变量名}：用花括号将变量名括起来，可避免出现歧义。例如：<code>RUN echo $&#123;HOME&#125;</code>。</li>
<li>${变量:-替换内容}：当变量不存在时，用替换内容代替变量。</li>
<li>${变量:+替换内容}：当变量已定义和复制时，替换内容会替换占位符。变量不存在时，占位符会被直接清除。</li>
</ul>
<h2 id="指令解析"><a class="markdownIt-Anchor" href="#指令解析"></a> 指令解析</h2>
<p>针对不同系统使用的特殊符号不同，而引用解析指令行功能来消除歧义。</p>
<p>例如在 Linux 中使用 <code>\</code> 符号来进行命令换行，而在 Windows 系统中作为目录分隔符使用。可以设置 escape 的值来将换行分隔符设置为 <code>@</code>，这样 Windows 路径中的 <code>\</code> 就不会被错误解析了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># escape=@</span>

FROM windowsservercore
COPY test.txt c:<span class="token punctuation">\</span>
RUN <span class="token function">dir</span> c:<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件"></a> 忽略文件</h2>
<p>可以使用类似 Git 忽略功能的文件 <code>.dockerignore</code>，来对构建镜像时的一些敏感信息或无用文件进行忽略。</p>
<p>在 Docker 中，通常倾向于忽略掉所有文件，只保留确定需要传入镜像的文件。</p>
<p>例如保留 <code>conf.xml</code> 文件和 <code>config/user.xml</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Keep files</span>
*
<span class="token operator">!</span>conf.xml
<span class="token operator">!</span>config/user.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="示例样本"><a class="markdownIt-Anchor" href="#示例样本"></a> 示例样本</h1>
<p>以下是一些 Dockerfile 示例样本。</p>
<h2 id="普通样本"><a class="markdownIt-Anchor" href="#普通样本"></a> 普通样本</h2>
<p>带说明内容的构建样本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># This my first nginx Dockerfile</span>
<span class="token comment"># Version 1.0</span>
<span class="token comment"># Base images 基础镜像</span>
FROM centos
<span class="token comment">#MAINTAINER 维护者信息</span>
MAINTAINER tianfeiyu 
<span class="token comment">#ENV 设置环境变量</span>
ENV <span class="token environment constant">PATH</span> /usr/local/nginx/sbin:<span class="token environment constant">$PATH</span>
<span class="token comment">#ADD  文件放在当前目录下，拷过去会自动解压</span>
ADD nginx-1.8.0.tar.gz /usr/local/  
ADD epel-release-latest-7.noarch.rpm /usr/local/  
<span class="token comment">#RUN 执行以下命令 </span>
RUN <span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> /usr/local/epel-release-latest-7.noarch.rpm
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">wget</span> lftp gcc gcc-c++ <span class="token function">make</span> openssl-devel pcre-devel pcre <span class="token operator">&amp;&amp;</span> yum clean all
RUN <span class="token function">useradd</span> <span class="token parameter variable">-s</span> /sbin/nologin <span class="token parameter variable">-M</span> www
<span class="token comment">#WORKDIR 相当于cd</span>
WORKDIR /usr/local/nginx-1.8.0 
RUN ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx <span class="token parameter variable">--user</span><span class="token operator">=</span>www <span class="token parameter variable">--group</span><span class="token operator">=</span>www --with-http_ssl_module --with-pcre <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
RUN <span class="token builtin class-name">echo</span> <span class="token string">"daemon off;"</span> <span class="token operator">>></span> /etc/nginx.conf
<span class="token comment">#EXPOSE 映射端口</span>
EXPOSE <span class="token number">80</span>
<span class="token comment">#CMD 运行以下命令</span>
CMD <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="说明样本"><a class="markdownIt-Anchor" href="#说明样本"></a> 说明样本</h2>
<p>另外一个 <code>Nginx</code> 镜像构建样本:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## Set the base image to CentOS  基于centos镜像</span>
FROM centos
<span class="token comment"># File Author / Maintainer  作者信息</span>
MAINTAINER <span class="token builtin class-name">test</span> test@example.com
<span class="token comment"># Install necessary tools  安装一些依赖的包</span>
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> pcre-devel <span class="token function">wget</span> net-tools gcc zlib zlib-devel <span class="token function">make</span> openssl-devel
<span class="token comment"># Install Nginx  安装nginx</span>
ADD http://nginx.org/download/nginx-1.8.0.tar.gz <span class="token builtin class-name">.</span>  <span class="token comment"># 添加nginx的压缩包到当前目录下</span>
RUN <span class="token function">tar</span> zxvf nginx-1.8.0.tar.gz  <span class="token comment"># 解包</span>
RUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /usr/local/nginx  <span class="token comment"># 创建nginx目录</span>
RUN <span class="token builtin class-name">cd</span> nginx-1.8.0 <span class="token operator">&amp;&amp;</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>  <span class="token comment"># 编译安装</span>
RUN <span class="token function">rm</span> <span class="token parameter variable">-fv</span> /usr/local/nginx/conf/nginx.conf  <span class="token comment"># 删除自带的nginx配置文件</span>
ADD http://www.apelearn.com/study_v2/.nginx_conf /usr/local/nginx/conf/nginx.conf  <span class="token comment"># 添加nginx配置文件</span>
<span class="token comment"># Expose ports  开放80端口出来</span>
EXPOSE <span class="token number">80</span>
<span class="token comment"># Set the default command to execute when creating a new container  这里是因为防止服务启动后容器会停止的情况，所以需要多执行一句tail命令</span>
ENTRYPOINT /usr/local/nginx/sbin/nginx <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> <span class="token parameter variable">-f</span> /etc/passwd
<span class="token comment">#如果你本地的宿主机上，已经有nginx配置文件了，则可以把ADD更改为使用COPY来进行拷贝</span>
COPY /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多步骤创建"><a class="markdownIt-Anchor" href="#多步骤创建"></a> 多步骤创建</h2>
<p>首先创建一段 Go 语言程序源码，仅输出 “Hello” 信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> main.go
// main.go will output <span class="token string">"Hello, Docker"</span>
package main

<span class="token function">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

func <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt.Println<span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编写 Dockerfile 文件，将编译和运行合并到一起：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> Dockerfile_builder
FROM golang as builder
RUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /go/src/test
WORKDIR /go/src/test
COPY main.go <span class="token builtin class-name">.</span>
RUN go <span class="token function">env</span> <span class="token parameter variable">-w</span> <span class="token assign-left variable">GO111MODULE</span><span class="token operator">=</span>auto
RUN <span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span>O <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux go build <span class="token parameter variable">-o</span> app <span class="token builtin class-name">.</span>

FROM alpine:latest
WORKDIR /root/
COPY <span class="token parameter variable">--from</span><span class="token operator">=</span>builder /go/src/test/app <span class="token builtin class-name">.</span>
CMD <span class="token punctuation">[</span><span class="token string">"./app"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，在一个单独的构建阶段使用 Go 语言编译源码生成可执行文件。然后，在另一个阶段使用 Alpine 镜像作为基础镜像，将编译好的可执行文件复制到容器中，并运行它。</p>
<p>构建并测试运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> builder/go_app:1.0.0 <span class="token parameter variable">-f</span> Dockerfile_builder <span class="token builtin class-name">.</span>
<span class="token punctuation">[</span>root@server6 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> builder/go_app:1.0.0
Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 网络模式</title>
    <url>/1910773265/</url>
    <content><![CDATA[<h1 id="原生网络模式"><a class="markdownIt-Anchor" href="#原生网络模式"></a> 原生网络模式</h1>
<p>Docker 自带了三种常用的网络模式：none、host 和 bridge，用于同一宿主机容器间通信，默认使用 bridge 网络。</p>
<h2 id="none-网络"><a class="markdownIt-Anchor" href="#none-网络"></a> None 网络</h2>
<p>None 网络表示没有网络，挂载在该网络下的容器除了 lo（回环接口）之外没有网卡。适用于一些对安全性要求较高的单机应用。</p>
<h2 id="host-网络"><a class="markdownIt-Anchor" href="#host-网络"></a> Host 网络</h2>
<p>使用 host 网络的容器与宿主机共享网络配置，Docker 不会为容器创建单独的网络命名空间。适用于对网络性能要求较高的应用。另外一种用途是允许容器直接配置宿主机网络（<code>--privileged=true</code>），适用于某些跨主机网络解决方案。</p>
<p>由于与宿主机共享网络，需要考虑端口冲突问题。同时，与宿主机位于同一子网的机器也能发现容器的存在。</p>
<h2 id="bridge-网络"><a class="markdownIt-Anchor" href="#bridge-网络"></a> Bridge 网络</h2>
<p>Docker 通过网络命名空间（Network Namespace）为每个容器建立独立的网络，实现与宿主机完全隔离的环境。</p>
<p>默认情况下，Docker 在宿主机上创建一个名为 docker0 的虚拟网桥，用于连接宿主机与容器。容器与 docker0 之间通过虚拟以太网对（Veth Pair）进行连接，所有连接到 docker0 的容器都属于同一个子网。宿主机也通过虚拟网卡连接到 docker0：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> docker0
docker0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>
        inet <span class="token number">172.17</span>.0.1  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">172.17</span>.255.255
        inet6 fe80::42:b4ff:fe98:85d5  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>
        ether 02:42:b4:98:85:d5  txqueuelen <span class="token number">0</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets <span class="token number">794</span>  bytes <span class="token number">2870284</span> <span class="token punctuation">(</span><span class="token number">2.7</span> MiB<span class="token punctuation">)</span>
        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>
        TX packets <span class="token number">934</span>  bytes <span class="token number">5709678</span> <span class="token punctuation">(</span><span class="token number">5.4</span> MiB<span class="token punctuation">)</span>
        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ brctl show docker0
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0         <span class="token number">8000</span>.0242b49885d5       no              veth5f73575
                                                        veth8125268<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="跨主机网络"><a class="markdownIt-Anchor" href="#跨主机网络"></a> 跨主机网络</h1>
<p>Docker 原生支持跨主机网络方案 overlay 和 macvlan，常用第三方跨主机网络方案有：flannel，weave 和 calico。</p>
<h2 id="overlay-网络"><a class="markdownIt-Anchor" href="#overlay-网络"></a> Overlay 网络</h2>
<p>Overlay 是一种虚拟交换技术，主要是解决不同 IP 地址段之间的网络通信问题。Docker 使用的 Overlay 技术是借助于 libnetwork 实现的 VxLAN。</p>
<p>在 Overlay 网络中，网桥 br0 除了连接所有的 endpoint 还会连接一个 vxlan 设备，用于与其他 host 建立 vxlan tunnel，容器之间通过这个隧道来通信。</p>
<p>Overlay 网络需要一个 K-V 服务器，比如 Consul，zookeeper 或 etcd 来储存相关主机信息。</p>
<h2 id="macvlan-网络"><a class="markdownIt-Anchor" href="#macvlan-网络"></a> Macvlan 网络</h2>
<p>macvlan 本身是 Linux 内核模块，其功能是允许同一个物理网卡配置多个 MAC 地址，本质上是一种网卡虚拟化技术。其优点是性能好，因为不需要创建网桥，直接通过以太端口连接到物理网络。</p>
<p>在 macvlan 中，容器的网口直接与宿主机的网卡连接，容器无需通过 NAT 和端口映射就能与外网直接通信，在网络上与其他独立主机没有区别，因此一个网卡只能创建一个 macvlan 网络。</p>
<p>可以通过 Vlan 将物理的二层网络划分成最多 4094 个逻辑网络，每个 VLAN 由 ID 区分，互相隔离。也就是 <code>eth0.xxx</code> 的形式，可供 macvlan 连接。</p>
<h2 id="flannel-网络"><a class="markdownIt-Anchor" href="#flannel-网络"></a> Flannel 网络</h2>
<p>flannel 是 CoreOS 开发的容器网络解决方案。它为每个 host 分配一个 subnet，容器从此 subnet 中分配 IP，这些 IP 可以在 host 间路由。每个 subnet 都是从一个更大的 IP 池中划分的，flannel 会在每个主机上运行 <code>flanneld</code> 的 agent，从池子中分配 subnet。</p>
<p>flannel 使用 etcd 存放网络配置信息，数据包转发由基于 vxlan 或 host-gw 的 backend 实现。</p>
<p>flannel 没有 DNS 服务，容器无法通过 hostname 通信。</p>
<p>flannel 网络利用默认 bridge 网络，容器通过 <code>docker0</code> 访问外网。</p>
<h2 id="weave-网络"><a class="markdownIt-Anchor" href="#weave-网络"></a> Weave 网络</h2>
<p>weave 创建的虚拟网路可以将多主机的容器连接起来，就像在一个交换机中。</p>
<p>此外，weave 的 DNS 模块可以使容器通过 hostname 访问。</p>
<h2 id="calico-网络"><a class="markdownIt-Anchor" href="#calico-网络"></a> Calico 网络</h2>
<p>Calico 是一个纯三层的虚拟网络方案。Calico 为每个容器分配一个 IP，每个 host 都是 router，把不同 host 的容器连接起来。与 VxLAN 不同的是，Calico 不对数据包做额外封装，不需要 NAT，此外还能动态定义 ACL 规则</p>
<h1 id="网络方案比较"><a class="markdownIt-Anchor" href="#网络方案比较"></a> 网络方案比较</h1>
<p>从下面几个方面进行比较，根据不同场景选择最适合的方案：</p>
<table>
<thead>
<tr>
<th></th>
<th>Overlay</th>
<th>Macvlan</th>
<th>Flannel (v)</th>
<th>Flannel (h)</th>
<th>Weave</th>
<th>Calico</th>
</tr>
</thead>
<tbody>
<tr>
<td>网络模型</td>
<td>VxLAN</td>
<td>Underlay</td>
<td>VxLAN</td>
<td>Underlay 纯三层</td>
<td>VxLAN</td>
<td>Underlay 纯三层</td>
</tr>
<tr>
<td>数据库</td>
<td>etcd</td>
<td>-</td>
<td>etcd</td>
<td>etcd</td>
<td>-</td>
<td>etcd</td>
</tr>
<tr>
<td>IPAM</td>
<td>单子网</td>
<td>自定义</td>
<td>每主机一子网</td>
<td>每主机一子网</td>
<td>单子网</td>
<td>每主机一子网</td>
</tr>
</tbody>
</table>
<h2 id="网络模型比较"><a class="markdownIt-Anchor" href="#网络模型比较"></a> 网络模型比较</h2>
<p>跨主机网络将不同主机上的容器连接到同一个虚拟网络中，这个虚拟网络的拓扑结构和实现技术即为网络模型：</p>
<ul>
<li>Overlay：通过建立主机间的 VxLAN 隧道，原始数据包在发送端被封装成 VxLAN 数据包，在目的地到达后在接收端解包。</li>
<li>Macvlan：网络通过二层的 VLAN 连接容器，在三层上依赖外部网关连接不同的 macvlan，不需要封装数据包。</li>
<li>Flannel：使用两种 backend，vxlan 与 overlay 类似，host-gw 将主机作为网关依赖三层 IP 转发，不需要封装数据包。</li>
<li>Weave：通过 VxLAN 实现。</li>
<li>Calico：与 Flannel 的 host-gw 类似，依赖三层 IP 转发。</li>
</ul>
<h2 id="储存依赖"><a class="markdownIt-Anchor" href="#储存依赖"></a> 储存依赖</h2>
<p>其中，Overlay、Flannel 和 Calico 都需要额外的 etcd 或 consul 服务支持，Macvlan 是简单的 local 网络，不需要保存和共享网络信息。Weave 自己负责在主机间交换网络配置信息。</p>
<h2 id="ipam"><a class="markdownIt-Anchor" href="#ipam"></a> IPAM</h2>
<p>在驱动管理 IP 地址的分配（IPAM）方面：</p>
<ul>
<li>Overlay：网络中所有主机共享同一个子网，容器启动时会顺序分配 IP，可以通过 <code>--subnet</code> 来设置子网空间。</li>
<li>Macvlan：需要用户自己管理子网空间，为容器分配 IP，不同子网通信依赖外部网关。</li>
<li>Flannel：为每个主机分配独立子网空间，用户只需要指定一个大的 IP 池。不同子网之间的路由会自动配置。</li>
<li>Weave：默认配置下所有容器使用 10.32.0.0/12 子网，可以通过 <code>--ipalloc-range</code> 设置子网空间。</li>
<li>Calico：从 IP Pool 中为每个主机分配自己的子网空间，可自定义 IP 池。</li>
</ul>
<h2 id="连通与隔离"><a class="markdownIt-Anchor" href="#连通与隔离"></a> 连通与隔离</h2>
<p>容器的通信和与外网的隔离和通信方面：</p>
<ul>
<li>Overlay：同一网络中容器可通信，不同网络之间可将容器加入多个网络来实现通信。外网通信依赖 Docker 网桥。</li>
<li>Macvlan：网络的连通或隔离完全取决于二层 VLAN 和三层路由。</li>
<li>Flannel：不同网络中容器可直接通信，没有提供隔离。外网通信依赖 Docker 网桥。</li>
<li>Weave：默认所有容器在同一网络，为容器指定不同子网来隔离。外网通信需将主机加入 Weave 网络并作为网关。</li>
<li>Calico：默认只允许同一网络中容器通信。通过 Policy 设定可以实现自由控制网络访问。</li>
</ul>
<h2 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h2>
<p>使用 Underlay 的网络性能优于使用 Overlay（VxLAN）的网络。Overlay 网络利用隧道技术，将数据包封装到 UDP 中进行传输，封装与解包存在额外开销。</p>
<p>不过，Overlay 较 Underlay 可以支持更多的二层网段，能更好地利用已有网络，以及可以避免物理交换机 MAC 表耗尽等优势。</p>
<h1 id="网络设置"><a class="markdownIt-Anchor" href="#网络设置"></a> 网络设置</h1>
<p>在容器内部修改的 <code>/etc/hostname</code>、<code>/etc/hosts</code> 和 <code>/etc/resolve.conf</code> 文件内容仅在本次容器运行期间有效，容器退出后修改会丢失。即使使用 <code>docker commit</code> 命令保存成镜像，也不会保留修改。</p>
<h2 id="端口映射"><a class="markdownIt-Anchor" href="#端口映射"></a> 端口映射</h2>
<p>容器与宿主机通过 <code>docker0</code> 网桥进行通信，而容器与外网的访问可以通过 <code>docker0</code> 转发到宿主机的外网网卡上。只要宿主机开启了端口转发功能，容器就能够访问宿主机外部的网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">sysctl</span> net.ipv4.conf.all.forwarding
net.ipv4.conf.all.forwarding <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-L</span> <span class="token parameter variable">-n</span>
Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination              
DNAT       tcp  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0      tcp dpt:5000 to:172.17.0.3:5000
DNAT       tcp  --  <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0      tcp dpt:49156 to:172.17.0.5:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而，默认情况下，外部网络无法访问容器。可以通过端口映射的方式，将容器的端口与宿主机的端口绑定，这样外部网络就能够通过指定的端口访问容器中的应用和服务。</p>
<p>在建立容器时，可以使用 <code>-P</code> 参数进行端口映射，将容器需要暴露的端口随机映射到主机的空闲端口上（默认在 49000~49900 端口范围内）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> nginx
555e6a418454ecbb450e519e09ec483645d97d56569627b827e1b54781f6afde
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect <span class="token parameter variable">-f</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.NetworkSettings.Ports<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> 555e6a41
map<span class="token punctuation">[</span><span class="token number">80</span>/tcp:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token number">0.0</span>.0.0 <span class="token number">49153</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>:: <span class="token number">49153</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-p</code> 参数可以固定映射到宿主机的端口，并且可以指定端口类型为 UDP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">192.168</span>.2.241:8001:80/udp nginx
38769e47eebdc96ce3f0eded75e6b8c3de90609e42f01a09148911dc4ea025bb
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect <span class="token parameter variable">-f</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>.NetworkSettings.Ports<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> 38769e47
map<span class="token punctuation">[</span><span class="token number">80</span>/tcp:<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token number">80</span>/udp:<span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token number">192.168</span>.2.241 <span class="token number">8001</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="容器连接"><a class="markdownIt-Anchor" href="#容器连接"></a> 容器连接</h2>
<p>有时，一个容器中运行的应用程序需要通过网络与另一个容器中运行的应用程序交换数据，这时需要通过容器连接来实现。</p>
<p>要设置容器间通信，可以在创建容器时使用 <code>--link</code> 参数指定要连接的容器，这样会打开对被连接容器的网络访问。</p>
<p>例如，创建一个 MySQL 容器，并让一个 Web 服务容器连接到它：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> mysql <span class="token parameter variable">--env</span><span class="token operator">=</span><span class="token string">'MYSQL_ALLOW_EMPTY_PASSWORD=1'</span> mysql
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-p</span> <span class="token number">443</span>:443 <span class="token parameter variable">--name</span> web <span class="token parameter variable">--link</span> mysql:db nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>连接容器时，不需要指定或映射被连接容器 MySQL 的端口。被连接容器的端口仅在容器间通信中使用，不会暴露在外网中，其他容器也无法访问。建立连接的唯一条件是连接和被连接的容器都必须处于运行状态。</p>
<p>此外，为了避免连接容器名与连接容器内某些配置重名，Docker 支持使用别名进行容器间连接。例如，上述示例中使用了 <code>db</code> 作为 MySQL 容器的别名。在 Web 容器中，可以使用 <code>db</code> 作为访问时的主机名。可以查看 Web 容器中的 <code>/etc/hosts</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> web <span class="token function">cat</span> /etc/hosts
<span class="token number">127.0</span>.0.1       localhost
<span class="token number">172.17</span>.0.4      db f2159e1085ed mysql
<span class="token number">172.17</span>.0.5      1286ab689c48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Web 容器中可以通过 <code>env</code> 命令查看 MySQL 容器的环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> web <span class="token function">env</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>1286ab689c48
<span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span>xterm
<span class="token assign-left variable">DB_PORT</span><span class="token operator">=</span>tcp://172.17.0.4:3306
<span class="token assign-left variable">DB_PORT_3306_TCP</span><span class="token operator">=</span>tcp://172.17.0.4:3306
<span class="token assign-left variable">DB_PORT_3306_TCP_ADDR</span><span class="token operator">=</span><span class="token number">172.17</span>.0.4
<span class="token assign-left variable">DB_PORT_3306_TCP_PORT</span><span class="token operator">=</span><span class="token number">3306</span>
<span class="token assign-left variable">DB_PORT_3306_TCP_PROTO</span><span class="token operator">=</span>tcp
<span class="token assign-left variable">DB_PORT_33060_TCP</span><span class="token operator">=</span>tcp://172.17.0.4:33060
<span class="token assign-left variable">DB_PORT_33060_TCP_ADDR</span><span class="token operator">=</span><span class="token number">172.17</span>.0.4
<span class="token assign-left variable">DB_PORT_33060_TCP_PORT</span><span class="token operator">=</span><span class="token number">33060</span>
<span class="token assign-left variable">DB_PORT_33060_TCP_PROTO</span><span class="token operator">=</span>tcp
<span class="token assign-left variable">DB_NAME</span><span class="token operator">=</span>/web/db
<span class="token assign-left variable">DB_ENV_MYSQL_ALLOW_EMPTY_PASSWORD</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">DB_ENV_GOSU_VERSION</span><span class="token operator">=</span><span class="token number">1.12</span>
<span class="token assign-left variable">DB_ENV_MYSQL_MAJOR</span><span class="token operator">=</span><span class="token number">8.0</span>
<span class="token assign-left variable">DB_ENV_MYSQL_VERSION</span><span class="token operator">=</span><span class="token number">8.0</span>.27-1debian10
<span class="token assign-left variable">NGINX_VERSION</span><span class="token operator">=</span><span class="token number">1.21</span>.3
<span class="token assign-left variable">NJS_VERSION</span><span class="token operator">=</span><span class="token number">0.6</span>.2
<span class="token assign-left variable">PKG_RELEASE</span><span class="token operator">=</span><span class="token number">1</span>~buster
<span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2>
<p>Docker 服务端自带一个内嵌 DNS 服务器，使容器可以通过容器名进行通信。</p>
<p>但是使用 Docker DNS 有一个限制，只能在用户自定义网络中使用。换句话说，默认的桥接网络 docker0 中无法使用 DNS 解析。</p>
<h2 id="查看网络"><a class="markdownIt-Anchor" href="#查看网络"></a> 查看网络</h2>
<p>可以使用 <code>docker network ls</code> 命令查看 Docker 中定义的网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network <span class="token function">ls</span>
NETWORK ID     NAME      DRIVER    SCOPE
3b3d933326d5   bridge    bridge    <span class="token builtin class-name">local</span>
9c9f9149deef   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>
76306c358978   none      null      <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进一步可以通过 <code>docker network inspect</code> 命令查看网络的详细信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network inspect bridge 
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"3b3d933326d5a4dc198970d76c88ae265a09aab3edd12c1eb44d141c769628c8"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-22T06:08:04.744492282+08:00"</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次运行一个容器时，都会在全局注册相关的网络信息。</p>
<h2 id="创建网络"><a class="markdownIt-Anchor" href="#创建网络"></a> 创建网络</h2>
<p>可以使用 <code>docker network create</code> 命令自建一个桥接网络，并将容器连接到该网络中，以隔离不相关的应用容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network create <span class="token parameter variable">--driver</span> bridge mybridge
83a3f95af6b114c139f8887f48ac4d5dca739bfc310b8b209c5336cf211706d1
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--net</span><span class="token operator">=</span>mybridge ubuntu:18.04 
root@b476cb94f196:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>自建网络时，可以使用 <code>--subnet</code> 和 <code>--gateway</code> 参数自定义网段和网关。</p>
<h2 id="删除网络"><a class="markdownIt-Anchor" href="#删除网络"></a> 删除网络</h2>
<p>删除未被使用的自建网络，可以使用 <code>docker network rm</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network <span class="token function">rm</span> mybridge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以使用 <code>docker network prune</code> 命令自动清理未被使用的网络。</p>
<h2 id="加入网络"><a class="markdownIt-Anchor" href="#加入网络"></a> 加入网络</h2>
<p>处于不同 bridge 网络的容器，虽然具有互通的路由表规则，但在容器内部的 iptables 中会隔离访问。可以通过添加一块连接到对方网桥的网卡来实现通信。使用 <code>docker network connect</code> 命令将容器 <code>dshell</code> 连接到名为 <code>mybridge</code> 的网桥上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network connect mybridge dshell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同时，也可以使用 <code>docker network disconnect</code> 命令随时断开容器与网络的连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> network disconnect mybridge dshell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="加入容器"><a class="markdownIt-Anchor" href="#加入容器"></a> 加入容器</h2>
<p>加入容器是一种特殊的容器间通信方式，它可以使两个以上的容器共享一个网络栈、共享网卡和配置信息。</p>
<p>使用加入容器功能，不仅可以让程序通过 <code>lo</code> 接口进行高速通信，还可以用于监控网络程序的容器部署。</p>
<p>例如，将新建的容器加入到容器 <code>dshell</code> 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--network</span><span class="token operator">=</span>container:dshell alpine
/ <span class="token comment"># ip addr show</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">48</span>: eth0@if49: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="token number">103</span>: eth1@if104: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.18</span>.0.2/16 brd <span class="token number">172.18</span>.255.255 scope global eth1
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 数据卷使用</title>
    <url>/2894555783/</url>
    <content><![CDATA[<h1 id="数据卷特点"><a class="markdownIt-Anchor" href="#数据卷特点"></a> 数据卷特点</h1>
<p>在容器中，文件环境是由 UFS（Union File System）提供的临时层。所有在容器中进行的操作都会随着容器的删除而被丢弃。为了实现从外部获取文件并进行持久化存储的目标，Docker 提出了数据卷（Data Volume）的概念。数据卷是一个挂载在容器内文件系统中的文件或目录，每次启动容器时都会自动挂载到容器中，并且它可以脱离容器的生命周期而独立存在。</p>
<p>数据卷作为容器中的一个特殊文件或目录，与其他文件或目录有很大的区别：</p>
<ul>
<li>数据卷中的数据不继承自镜像，也不受容器临时层管理的范围。因此，数据卷没有写时复制机制，文件操作的效果会立即生效。这些数据也不会被 <code>docker commit</code> 命令提交到新的镜像中。</li>
<li>数据卷不依赖于容器，它独立于容器之外。多个容器可以共享同一个数据卷，通过数据卷可以实现容器之间的文件共享和数据交互。</li>
</ul>
<p>数据卷提供了一种方便的方式来处理容器内文件的持久化和共享需求。通过使用数据卷，我们可以更灵活地管理容器中的数据，并实现容器之间的文件共享。</p>
<h1 id="创建数据卷"><a class="markdownIt-Anchor" href="#创建数据卷"></a> 创建数据卷</h1>
<p>在创建容器时，可以同时创建数据卷。通过 <code>-v</code> 参数向容器中挂载一个数据卷，Docker 会自动创建该数据卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> create <span class="token parameter variable">--name</span> vdisk <span class="token parameter variable">-v</span> /disk alpine
000385b2005b5f79c1d1d05df5c981ac4dd3cffe1cc4d272691660151aebd26c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>以上命令为名为 <code>vdisk</code> 的容器创建了一个路径为 <code>/disk</code> 的数据卷。如果需要，可以多次使用 <code>-v</code> 参数来挂载多个数据卷。</p>
<p>此外，可以使用 <code>docker volume create</code> 命令创建一个自定义名称为 <code>disk1</code> 的数据卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume create <span class="token parameter variable">--name</span> disk1
disk1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所有创建的数据卷默认存放在 <code>/var/lib/docker/volumes/</code> 路径下。</p>
<h1 id="查询数据卷"><a class="markdownIt-Anchor" href="#查询数据卷"></a> 查询数据卷</h1>
<p>可以使用 <code>docker volume ls</code> 命令查看已创建的数据卷列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume <span class="token function">ls</span>
DRIVER    VOLUME NAME
<span class="token builtin class-name">local</span>     21470509cc37589319a7eab45bdb9ca12ad4d500ff49228ce0b65cd985fb62fb
<span class="token builtin class-name">local</span>     disk1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>docker volume inspect</code> 命令查看指定数据卷的基本信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume inspect disk1
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-22T09:58:06+08:00"</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/disk1/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"disk1"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="挂载数据卷"><a class="markdownIt-Anchor" href="#挂载数据卷"></a> 挂载数据卷</h1>
<p>在创建容器时，已创建的数据卷会自动挂载到容器中。而使用 <code>docker create</code> 或 <code>docker run</code> 命令创建容器时，可以使用 <code>-v</code> 选项指定挂载数据卷，格式为：<code>-v &lt;volume_name&gt;:&lt;container_path&gt;</code>。数据卷可以绕过分层的联合文件系统，为 Docker 提供持久数据或共享数据。这也意味着对数据卷的修改会直接生效，但当提交或创建镜像时，数据卷不会被包含在镜像中。</p>
<p>在将宿主机目录或文件挂载到容器时，默认权限是读写（rw），可以对数据的权限进行限制。例如，以只读（ro）的方式挂载目录 <code>/root/disk1</code>，可以保证容器内的程序无法修改该目录中的数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> create <span class="token parameter variable">--name</span> vdisk2 <span class="token parameter variable">-v</span> /root/disk1:/disk1:ro alpine
d44ab826d5ddd43bcdfa966648acb57d19f1982f22b28053f6e4b3b223118351<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>有时候，希望将数据保存在内存中而非宿主机或容器中，可以使用 <code>--tmpfs</code> 参数来挂载只存在于内存中的 tmpfs 数据卷。</p>
<h1 id="删除数据卷"><a class="markdownIt-Anchor" href="#删除数据卷"></a> 删除数据卷</h1>
<p>可以使用 <code>docker volume rm</code> 命令来删除数据卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume <span class="token function">rm</span> disk1
disk1
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ ll /var/lib/docker/volumes/disk1/
ls: cannot access /var/lib/docker/volumes/disk1/: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除数据卷时，对应的本地目录也会被一并删除。</p>
<p>如果是与容器一同创建的数据卷，最好使用 <code>-v</code> 参数一起删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-v</span> 000385b <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>批量删除数据卷可以先使用 <code>docker volume ls -q</code> 命令查询数据卷的 ID，然后再进行删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ubutu-trusty<span class="token punctuation">]</span>$ <span class="token function">docker</span> volume <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> volume <span class="token function">ls</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="数据卷容器"><a class="markdownIt-Anchor" href="#数据卷容器"></a> 数据卷容器</h1>
<p>数据卷容器是专门用于存放数据卷的容器，它并不直接管理或控制数据卷，只是作为其他容器使用数据卷的桥梁。其作用是为了保证数据卷的安全性，防止随着其他容器的删除而被删除。</p>
<p>创建数据卷容器的方法与普通容器的创建方法没有区别，数据卷容器不需要保持运行。创建数据卷容器时所使用的数据卷目录，将作为其他容器连接到该数据卷容器时访问数据卷的目录。</p>
<p>例如，创建一个专门用于存放日志的数据卷容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> create <span class="token parameter variable">--name</span> logdata <span class="token parameter variable">-v</span> /logs alpine 
118002bf522df93e5e31011c74f0760d317ae235f23dca24f413068a1abe2d7a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在需要使用数据卷的容器中，可以使用 <code>--volumes-from</code> 参数挂载指定数据卷容器中的所有数据卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> --volumes-from logdata ubuntu:18.04 /bin/bash
root@7baf237b2484:/<span class="token comment"># ll -d /logs</span>
drwxr-xr-x. <span class="token number">2</span> root root <span class="token number">6</span> Oct <span class="token number">22</span> 02:49 /logs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以多次使用 <code>--volumes-from</code> 参数来挂载多个不同的数据卷容器，以同时使用多个数据卷。</p>
<h1 id="数据卷备份"><a class="markdownIt-Anchor" href="#数据卷备份"></a> 数据卷备份</h1>
<p>使用数据卷容器可以方便地备份数据卷的内容。通过创建一个新的容器，将数据卷容器和宿主机目录连接起来，然后执行打包命令即可快速备份数据卷：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --volumes-from logdata <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/backup <span class="token parameter variable">--rm</span> ubuntu:18.04 <span class="token function">tar</span> cf /backup/logdata.tar /logs
tar: Removing leading `/' from member names
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ ll logdata.tar 
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">10240</span> Oct <span class="token number">22</span> <span class="token number">11</span>:10 logdata.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要恢复数据，则需要反向操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --volumes-from logdata <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/backup <span class="token parameter variable">--rm</span> ubuntu:18.04 <span class="token function">tar</span> xf /backup/logdata.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>2.进阶操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 容器操作</title>
    <url>/2679776821/</url>
    <content><![CDATA[<h1 id="创建容器"><a class="markdownIt-Anchor" href="#创建容器"></a> 创建容器</h1>
<p>创建容器可以使用 <code>docker create</code> 命令或 <code>docker run</code> 命令。</p>
<h2 id="创建静止容器"><a class="markdownIt-Anchor" href="#创建静止容器"></a> 创建静止容器</h2>
<p>使用 <code>docker create</code> 命令可以创建一个处于停止状态的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> create alpine
53b658ada694f5d5a5a5ba8e1bf656db4de8bacd79d4ae49857fe1ce27f60292<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>创建容器后，Docker 会立即返回容器的 ID。每个容器的 ID 都是唯一的。</p>
<p>在大多数镜像中已经设定了基于这个镜像的容器，在启动时要运行的程序，也可以在创建容器时重新指定容器所绑定的应用程序。例如，指定运行 <code>tail -f /var/log/messages</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> create ubuntu:18.04 <span class="token function">tail</span> <span class="token parameter variable">-f</span> /var/log/messages
a7420c78df7388b3317364e0089491928ff0e2d184261d49b8315bc4fce8ed0d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="创建运行容器"><a class="markdownIt-Anchor" href="#创建运行容器"></a> 创建运行容器</h2>
<p>使用 <code>docker run</code> 命令可以创建两种类型的容器：</p>
<ul>
<li>
<p><strong>交互型容器</strong></p>
<p>容器运行默认在前台，通常会指定有交互的控制台，可以给容器输入，得到容器输出。如果创建容器的终端被关闭，容器内部使用 <code>exit</code> 命令退出，或调用 <code>docker stop</code>（<code>kill</code>）命令后，容器会变成停止状态。</p>
<p>创建一个交互式容器，需要加入 <code>-t</code> 选项让 Docker 为容器创建一个伪终端并绑定到容器标准输入上。加入 <code>-i</code> 选项让容器的标准输入保持打开。例如，创建启动一个名为 myshell 的 <code>Ubuntu</code> 容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>myshell ubuntu:18.04 /bin/bash
root@fffa37ac6638:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>容器启动以后进入 bash shell，由提示符可得用户名为 root，主机名也就是容器短 ID 为 fffa37ac6638。</p>
<p>要退出容器可以使用快捷键 <code>Ctrl+D</code> 或 <code>exit</code> 命令，之后容器会停止。要让容器继续运行可以使用快捷键 <code>Ctrl+PQ</code> 来退出交互模式。</p>
</li>
<li>
<p><strong>后台型容器</strong></p>
<p>容器运行在后台，创建启动之后和终端无关。只有调用 <code>docker stop</code> 或 <code>docker kill</code> 命令才能使容器变成停止状态。</p>
<p>在实际应用中，大多数容器都是后台运行式容器，在创建时使用 <code>-d</code> 参数。例如，创建后台运行的 <code>Ubuntu</code> 容器，并指定一个不会终止的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--name</span> dshell <span class="token parameter variable">-d</span> ubuntu:18.04 /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do echo sleeping; sleep 1; done"</span>
bb018e9f0619a23f0e4cdc23cee2b738ecc3dc34dc8c7d3eaa4b93c9ddcd2b7e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="容器启动参数"><a class="markdownIt-Anchor" href="#容器启动参数"></a> 容器启动参数</h1>
<p>使用 <code>docker run</code> 命令启动容器时可以指定一些启动参数。</p>
<h2 id="常用参数"><a class="markdownIt-Anchor" href="#常用参数"></a> 常用参数</h2>
<p>常用启动参数如下：</p>
<ul>
<li><code>-d</code>：设置容器在后台运行。</li>
<li><code>-i</code>：保持标准输入打开。</li>
<li><code>-t</code>：分配一个伪终端。</li>
<li>-<code>-name=''</code>：设定容器名称，如果不指定系统会随机分配一个名称。最大用途是用在两个容器之间建立 link 通信。</li>
<li><code>--restart=&quot;&quot;</code>：重启策略，可以设置为以下几种策略。
<ul>
<li>No：默认选项，没有任何重启操作。</li>
<li>Always：无论容器处于什么状态都执行重启。同时容器会在 Docker 服务端启动时自启动。</li>
<li>On-failure：当容器的命令返回非 0 值时重启。</li>
<li>Unless-stopped：和 Always 类似，但不会自启动。</li>
</ul>
</li>
<li><code>--rm</code>：容器退出后，自动删除容器。不能和 <code>-d</code> 与 <code>--rm</code> 同时使用。</li>
<li><code>--privileged</code>：特权模式。容器可以访问除 AppArmor 和 SELinux 之外的主机所有进程。</li>
<li><code>--env=[]</code>：指定容器内环境变量。</li>
</ul>
<h2 id="网络参数"><a class="markdownIt-Anchor" href="#网络参数"></a> 网络参数</h2>
<p>与网络相关的启动参数如下：</p>
<ul>
<li><code>--net=&quot;&quot;</code>: 设置容器采用的网络方式，默认为 bridge。有以下几种模式：
<ul>
<li>none: 不使用网络。容器不能访问外部网络，但内部存在回环地址。</li>
<li>bridge: 桥接模式。容器通常连接到 docker0 网桥的 veth 口，网桥再连接到宿主机网络端口上。</li>
<li>host: 主机模式。直接使用宿主机网络，共享端口。容器所有暴露的端口和容器连接将失效。</li>
<li>container: 容器模式。将容器的网络栈合并在一起，容器可以不需要 IP 来进行通信。</li>
<li>自定义网络: 对于 Overlay 和用户定义的多主机模式，Docker 可以采用此选项。</li>
</ul>
</li>
<li><code>-p</code>: 设置容器映射到主机的端口，设置格式为 <code>-p 主机端口:容器端口</code>。</li>
<li><code>--link=&quot;&quot;</code>: 链接到其他容器。更推荐使用 <code>--net</code> 参数为需要连接的容器分配一个专有网络。</li>
<li><code>--expose=[]</code>: 设置容器暴露的端口或端口范围。</li>
<li><code>-P</code>: 通过 NAT 将容器设置的暴露端口自动映射到本机临时端口，默认选取端口号范围为 49153~65535。</li>
<li><code>--dns=[]</code>: 设置容器使用的 DNS 服务器。</li>
<li><code>--add-host=&quot;&quot;</code>: 在容器内的 <code>/etc/hosts</code> 文件中添加自定义主机名解析。</li>
<li><code>--ip=&quot;&quot;</code>: 设置容器的 IP 地址。</li>
<li><code>--hostname=&quot;&quot;</code>: 设置容器的主机名。</li>
</ul>
<h2 id="文件参数"><a class="markdownIt-Anchor" href="#文件参数"></a> 文件参数</h2>
<p>与文件系统挂载相关的参数如下：</p>
<ul>
<li><code>-v</code>: 将主机上的文件挂载到容器中，格式为 <code>-v 主机路径:容器路径</code>。</li>
<li><code>--tmpfs=[]</code>: 将临时文件系统挂载到容器中。</li>
<li><code>--device=&quot;&quot;</code>: 将宿主机设备挂载到容器内，默认可读写，可以自定义权限。</li>
<li><code>--volumes-from=[]</code>: 从其他容器挂载卷。</li>
<li><code>--workdir=&quot;&quot;</code>: 设置容器内的默认工作目录。</li>
</ul>
<h2 id="其他参数"><a class="markdownIt-Anchor" href="#其他参数"></a> 其他参数</h2>
<p>其他一些不常用的启动参数：</p>
<ul>
<li><code>--pid=&quot;&quot;</code> 控制容器中进程使用的 PID。容器中执行的程序 PID 从 1 开始计算。常用 <code>--pid=host</code> 来与宿主机共享 PID。</li>
<li><code>-ust=&quot;&quot;</code>: 设置容器中使用的主机名和域名模式。</li>
<li><code>--ipc=&quot;&quot;</code>: 设置进程间通信模式。</li>
<li><code>--log-driver</code>: 设置容器的日志等级，可以设置为以下等级：
<ul>
<li>none: 不显示日志。</li>
<li>json-file: 默认输出格式。</li>
<li>syslog: 将日志输出到系统日志 <code>/var/log/message</code> 中。</li>
<li>journald: 将日志写入 journald。</li>
</ul>
</li>
<li><code>--isolation=&quot;&quot;</code>: 设置容器使用的隔离机制。</li>
<li><code>-h</code>: 设置容器的主机名。</li>
</ul>
<h1 id="管理容器"><a class="markdownIt-Anchor" href="#管理容器"></a> 管理容器</h1>
<p>除了创建容器之外的管理容器命令.</p>
<h2 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h2>
<p>想要启动一个停止状态的容器，使用 <code>docker start</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> start fffa37ac663
fffa37ac663<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>针对一个运行中的容器，可以使用 <code>docker restart</code> 命令来重启：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> restart myshell
myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此外，使用 <code>docker unpause</code> 命令来恢复一个暂停的容器运行。</p>
<h2 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h2>
<p>使用 <code>docker stop</code> 命令可以给容器中的进程发送 SIGTERM 信号，默认等待 10 秒后，会发送 SIGKILL 信号来终止容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> stop 74b23cb72
74b23cb72<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>要发送 SIGKILL 信号来立即强行停止容器，使用 <code>docker kill</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">kill</span> fffa37a
fffa37a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此外还可以使用 <code>docker pause</code> 命令来暂停容器。</p>
<h2 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h2>
<p>当容器不再需要时，可以使用 <code>docker rm</code> 命令删除停止状态的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">rm</span> 74b23cb722 myshell
74b23cb722
myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当然，也支持使用 -f 参数来强行删除运行中的容器。</p>
<h2 id="重命名容器"><a class="markdownIt-Anchor" href="#重命名容器"></a> 重命名容器</h2>
<p>可以使用 <code>docker rename</code> 命令来对容器进行重命名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 .docker<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">rename</span> 86e7325c7729 cent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="清理容器"><a class="markdownIt-Anchor" href="#清理容器"></a> 清理容器</h2>
<p>使用 <code>docker container prune</code> 命令会清除所有处于停止状态的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> container prune
WARNING<span class="token operator">!</span> This will remove all stopped containers.
Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Deleted Containers:
525899c2d8701ca12d44ac21d28beca50356c92cefe7d2c7159904c15dc41344

Total reclaimed space: 0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="导出容器"><a class="markdownIt-Anchor" href="#导出容器"></a> 导出容器</h2>
<p>导出容器使用 <code>docker export</code> 命令。正在运行中的容器也可以导出，并且不用担心容器依赖的镜像问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">export</span> 53b658ada <span class="token operator">></span> a.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>与导出镜像类似，可以同时导出多个容器到一个文件。</p>
<h2 id="导入容器"><a class="markdownIt-Anchor" href="#导入容器"></a> 导入容器</h2>
<p>可以使用 <code>docker import</code> 命令导入通过 <code>docker export</code> 命令导出的容器作为镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">import</span> a.tar user1:0.1
sha256:7549e3270b729e1e908cde70ba3e0f2f9bf1b5abff2482fefa13775c2c62de2e
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
user1                     <span class="token number">0.1</span>       7549e3270b72   <span class="token number">7</span> seconds ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与导入镜像的功能相比，容器快照文件会丢弃所有的历史记录和元数据信息。</p>
<p>另外，<code>docker import</code> 命令还可以用来导入模板创建镜像。</p>
<h1 id="查询容器"><a class="markdownIt-Anchor" href="#查询容器"></a> 查询容器</h1>
<p>查询容器信息的常用操作如下。</p>
<h2 id="查询容器列表"><a class="markdownIt-Anchor" href="#查询容器列表"></a> 查询容器列表</h2>
<p>查看正在运行中的容器使用 <code>docker ps</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID IMAGE        COMMAND                CREATED        STATUS    PORTS    NAMES
74b23cb722cb ubuntu:18.04 <span class="token string">"/bin/sh -c 'while t…"</span> <span class="token number">22</span> seconds ago Up <span class="token number">21</span> seconds      dshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其结果显示标头含义如下：</p>
<ul>
<li>CONTAINER ID: 容器 ID，全长为 64 位的十六进制。可以使用容器 ID 的前几位来操作容器。</li>
<li>IMAGE: 创建容器时使用的镜像。</li>
<li>COMMAND: 容器最后运行的命令。</li>
<li>CREATED: 创建容器的时间。</li>
<li>STATUS: 容器的状态，其 UP 后的时间表示容器已经运行的时长。如果是 Exited(0) 的形式，括号内的数字表示容器退出时的状态码，常见的有：0（执行完正常退出）、125（docker 命令参数错误）、126（权限限制命令无法执行）、127（容器内的命令无法找到）。</li>
<li>PORTS: 对外开放的端口。</li>
<li>NAMES: 容器名，和容器 ID 一样标识容器，所以不能重名。</li>
</ul>
<p>要查看所有容器，使用 <code>-a</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
CONTAINER ID IMAGE         COMMAND           CREATED        STATUS  PORTS  NAMES
74b23cb722cb ubuntu:18.04  <span class="token string">"/bin/sh -c 'wh"</span>  <span class="token number">9</span> minutes ago  Up <span class="token number">9</span> minutes   dshell
fffa37ac6638 ubuntu:18.04  <span class="token string">"/bin/bash"</span>       <span class="token number">25</span> minutes ago Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span>   myshell
53b658ada694 alpine        <span class="token string">"/bin/sh"</span>         <span class="token number">36</span> minutes ago Created        charming_jones<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要查看最近创建的 2 个容器，使用 <code>-n=x</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-n</span><span class="token operator">=</span><span class="token number">2</span>
CONTAINER ID IMAGE         COMMAND           CREATED        STATUS  PORTS  NAMES
74b23cb722cb ubuntu:18.04  <span class="token string">"/bin/sh -c 'wh"</span>  <span class="token number">9</span> minutes ago  Up <span class="token number">9</span> minutes   dshell
fffa37ac6638 ubuntu:18.04  <span class="token string">"/bin/bash"</span>       <span class="token number">25</span> minutes ago Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span>   myshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外还有 <code>-f</code> 过滤参数，在容器较多时可以快速过滤。可以使用以下方法进行过滤：</p>
<ul>
<li>id: 容器 ID。</li>
<li>label: 容器的标记，可以来源于创建容器的镜像，或者在创建容器时通过 <code>--label</code> 参数设置。</li>
<li>name: 容器的名称。</li>
<li>exited: 容器停止时主进程的返回码。注意要与 <code>-a</code> 参数配合使用。</li>
<li>status: 容器的状态，可以是以下状态中一种：created、restarting、running、paused、exited、dead。</li>
<li>ancestor: 创建容器的镜像，可以指定镜像名或镜像 ID。</li>
<li>before: 给出一个容器名或容器 ID，返回给定容器之前创建的容器。</li>
<li>since: 给出一个容器名或容器 ID，返回给定容器之后创建的容器。</li>
<li>isolation: 隔离性，可以是 default、process、hyperv 等机制，只对 Windows 有用。</li>
<li>volume: 显示使用指定数据卷或挂载点的容器。</li>
<li>network: 显示使用指定网络 ID 或网络名称的容器。</li>
</ul>
<h2 id="查询容器进程"><a class="markdownIt-Anchor" href="#查询容器进程"></a> 查询容器进程</h2>
<p>使用 <code>docker top</code> 命令，可以查看容器中正在运行的进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">top</span> dshell 
<span class="token environment constant">UID</span>  PID   <span class="token environment constant">PPID</span>  C  STIME  TTY TIME      CMD
root <span class="token number">6625</span>  <span class="token number">6605</span>  <span class="token number">0</span>  <span class="token number">22</span>:29  ?   00:00:00  /bin/sh <span class="token parameter variable">-c</span> <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> sp<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
root <span class="token number">7736</span>  <span class="token number">6625</span>  <span class="token number">0</span>  <span class="token number">22</span>:38  ?   00:00:00  <span class="token function">sleep</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>docker top</code> 命令显示结果类似于 <code>ps</code> 命令，它还可以套用 <code>ps</code> 命令的参数。</p>
<h2 id="查询统计信息"><a class="markdownIt-Anchor" href="#查询统计信息"></a> 查询统计信息</h2>
<p>使用 <code>docker stats</code> 命令来实时查询容器内进程对系统资源的使用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> stats
CONTAINER ID NAME             CPU %  MEM USAGE / LIMIT MEM %  NET I/O     BLOCK I/O  PIDS
69e11c2ea066 reverent_vaughan <span class="token number">0.00</span>%  408KiB / <span class="token number">3</span>.682GiB <span class="token number">0.01</span>%  656B / 0B   0B / 0B       <span class="token number">1</span>
c2382935fd0b dshell           <span class="token number">0.16</span>%  600KiB / <span class="token number">3</span>.682GiB <span class="token number">0.02</span>%  656B / 0B   <span class="token number">2</span>.26MB / 0B   <span class="token number">2</span>
099bc0337b97 myshell          <span class="token number">0.00</span>%  404KiB / <span class="token number">3</span>.682GiB <span class="token number">0.01</span>%  656B / 0B   0B / 0B       <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查询容器详情"><a class="markdownIt-Anchor" href="#查询容器详情"></a> 查询容器详情</h2>
<p>同样可以使用 <code>docker inspect</code> 来查看容器的配置信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect dshell
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"c2382935fd0b1ea40949266e0818da70c0518c0ed340558c68fd97987be5fc2f"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-10-21T14:29:54.535612575Z"</span>,
        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/sh"</span>,
        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"-c"</span>,
            <span class="token string">"while true; do echo sleeping; sleep 1; done"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>
            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查询容器日志"><a class="markdownIt-Anchor" href="#查询容器日志"></a> 查询容器日志</h2>
<p>对于后台型容器，可以使用 <code>docker logs</code> 命令来查看容器的日志。它将输出到标准输出的数据作为日志输出到运行 <code>docker logs</code> 命令的终端上。</p>
<p>默认情况下，<code>logs</code> 输出的是从容器启动到调用执行 <code>logs</code> 命令时的所有输出。使用 <code>-f</code> 参数可以持续打印输出日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> logs <span class="token parameter variable">-f</span> dshell
sleeping
sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>--tail</code> 参数来查看日志末尾输出行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> logs <span class="token parameter variable">--tail</span><span class="token operator">=</span><span class="token number">5</span> dshell 
sleeping
sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>加入 <code>-t</code> 参数能显示日志输出时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> logs <span class="token parameter variable">--tail</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-t</span> dshell 
<span class="token number">2021</span>-10-21T14:36:55.905640558Z sleeping
<span class="token number">2021</span>-10-21T14:36:56.907301372Z sleeping
<span class="token number">2021</span>-10-21T14:36:57.908906032Z sleeping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="操作容器"><a class="markdownIt-Anchor" href="#操作容器"></a> 操作容器</h1>
<p>一些常用的操作容器方式.</p>
<h2 id="依附容器"><a class="markdownIt-Anchor" href="#依附容器"></a> 依附容器</h2>
<p>在使用 <code>docker start</code> 或 <code>docker restart</code> 启动的交互型容器中，并没有具体的终端可以依附，这时需要通过 <code>docker attach</code> 命令将终端依附到容器上，相当于将容器切换到前台交互模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> start 099bc03
099bc03
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> attach 099bc03
root@099bc0337b97:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用快捷键 <code>Ctrl+P+Q</code> 来退出容器，这样容器会保持运行。</p>
<p>后台型容器（只有 <code>-d</code> 没有 <code>-it</code> 参数）无法依附终端，因为它本身就不接受用户交互式输入。</p>
<h2 id="容器内执行命令"><a class="markdownIt-Anchor" href="#容器内执行命令"></a> 容器内执行命令</h2>
<p>可以使用 <code>docker exec</code> 命令在容器中运行新的任务。任务可以指定在后台运行或为交互型任务。</p>
<p>例如，在后台执行创建文件时，使用 <code>-d</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-d</span> dshell <span class="token function">touch</span> /root/data.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建一个交互型任务时，使用 <code>-it</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> dshell /bin/bash
root@c2382935fd0b:/<span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="复制文件"><a class="markdownIt-Anchor" href="#复制文件"></a> 复制文件</h2>
<p>可以使用 <code>docker cp</code> 命令在容器与主机之间进行文件复制。命令格式如下：<code>docker cp &lt;源地址&gt; &lt;目标地址&gt;</code>。</p>
<p>例如，将本地文件 <code>/root/ftp.sh</code> 复制到容器 <code>myshell</code> 的 <code>/home/</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">cp</span> /root/ftp.sh myshell:/home/
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> myshell <span class="token function">ls</span> /home
ftp.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将容器 <code>myshell</code> 下的文件 <code>/home/ftp.sh</code> 复制到本地 <code>/root/bin/</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">cp</span> myshell:/home/ftp.sh /root/bin/
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ ll /root/bin
total <span class="token number">4</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">52</span> Sep <span class="token number">23</span> <span class="token number">19</span>:18 ftp.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="资源限制"><a class="markdownIt-Anchor" href="#资源限制"></a> 资源限制</h1>
<p>Docker 通过 cgroup 来限制容器可使用的资源。</p>
<h2 id="内存限额"><a class="markdownIt-Anchor" href="#内存限额"></a> 内存限额</h2>
<p>默认情况下，对容器的资源使用没有限制。可以在创建容器时使用 <code>-m</code> 参数限制容器最大可使用的内存，并使用 <code>--memory-swap</code> 参数限制最大虚拟内存（默认为内存的两倍）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-m</span> 20M --memory-swap<span class="token operator">=</span>30M alpine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="cpu-限额"><a class="markdownIt-Anchor" href="#cpu-限额"></a> CPU 限额</h2>
<p>Docker 通过设置 CPU 使用权重来分配容器可使用的 CPU 资源。通常只有在 CPU 资源紧张的情况下，才会实际限制。可以使用 <code>-c</code> 参数来设置 CPU 使用权重，默认值为 1024：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-c</span> <span class="token number">128</span> alpine
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/1ffdbd1af1c64/cpu.shares 
<span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="读写限制"><a class="markdownIt-Anchor" href="#读写限制"></a> 读写限制</h2>
<p>Docker 可以通过 Block IO 来限制容器对磁盘的读写带宽。有以下三种设置方式：</p>
<ul>
<li>
<p>设置权重</p>
<p>默认情况下，容器可以平等地读写磁盘，可以通过设置 <code>--blkio-weight</code> 参数来改变读写优先级，默认值为 500：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run --blkio-weight <span class="token number">300</span> alpine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>限制读写速度（bps）</p>
<p>bps（byte per second）表示每秒读写的字节数。可以使用 <code>--device-read-bps</code> 和 <code>--device-write-bps</code> 参数来限制对特定设备的读写速度。</p>
<p>例如，限制容器对 <code>/dev/sda</code> 的写入速度为 10 MB/s：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --device-write-bps /dev/sda:10MB alpine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>限制 IOPS 次数</p>
<p>IOPS（io per second） 表示每秒的输入输出次数。可以使用 <code>--device-read-iops</code> 和 <code>--device-write-iops</code> 参数来限制对特定设备的每秒 IO 次数。</p>
<p>例如，限制容器对 <code>/dev/sda</code> 每秒的 IO 次数为 100：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> --device-write-iops /dev/sda:100 alpine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 仓库操作</title>
    <url>/3229018848/</url>
    <content><![CDATA[<h1 id="登录仓库"><a class="markdownIt-Anchor" href="#登录仓库"></a> 登录仓库</h1>
<p>登录仓库使用 <code>docker login</code> 命令：<code>docker login -u 用户名 -p 密码 服务器地址</code>。如果没有给出镜像仓库服务器的地址，会采用 Docker Daemon 中的默认值。</p>
<p>例如，不使用账号参数登录 Docker Hub:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, <span class="token function">head</span> over to https://hub.docker.com to create one.
Username: assassing
Password: 
WARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/<span class="token comment">#credentials-store</span>

Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="仓库配置"><a class="markdownIt-Anchor" href="#仓库配置"></a> 仓库配置</h1>
<p>由于从 Docker Hub 下载慢，可以配置镜像仓库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://mirror.ccs.tencentyun.com"</span>,
    <span class="token string">"http://docker.mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://5ifniqg5.mirror.aliyuncs.com"</span>,
    <span class="token string">"https://registry.docker-cn.com"</span>,
    <span class="token string">"http://hub-mirror.c.163.com"</span>,
    <span class="token string">"https://mirror.ccs.tencentyun.com"</span>
    <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>自建的私有仓库一般不会设置 TLS，需要把仓库地址添加到信任列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"192.168.2.241:5000"</span>,
    <span class="token string">"192.168.2.234:5999"</span>
    <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="docker-registry"><a class="markdownIt-Anchor" href="#docker-registry"></a> Docker Registry</h1>
<p>可以通过官方提供的开源镜像分发工具 Docker Registry 来简单搭建一套本地私有仓库环境。</p>
<p>镜像存储模块与本地镜像存储相似，Registry 将镜像记录在清单文件中，并同时记录验证信息，形成镜像数据库。</p>
<h2 id="创建仓库"><a class="markdownIt-Anchor" href="#创建仓库"></a> 创建仓库</h2>
<p>创建镜像仓库时，需要把镜像存放目录挂载出来，例如挂载到 <code>/var/docker_registry</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token parameter variable">-v</span> /var/docker_registry:/var/lib/registry registry:2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以通过浏览器访问 <code>http://192.168.2.241:5000/v2/</code> 来确认镜像已经正确启动。</p>
<h2 id="修改配置"><a class="markdownIt-Anchor" href="#修改配置"></a> 修改配置</h2>
<p>要想通过 HTTP 来使用本地私有仓库，需要修改启动配置文件 <code>/etc/docker/daemon.json</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/docker/daemon.json
<span class="token punctuation">&#123;</span>
    <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://mirror.ccs.tencentyun.com"</span><span class="token punctuation">]</span>,
    <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"192.168.2.241:5000"</span>
   <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="上传镜像"><a class="markdownIt-Anchor" href="#上传镜像"></a> 上传镜像</h2>
<p>上传同样使用 <code>tag</code> 修改镜像标记后用 <code>push</code> 上传：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> tag user1:0.1 <span class="token number">192.168</span>.2.241:5000/user241:v1.0
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> push <span class="token number">192.168</span>.2.241:5000/user241:v1.0
The push refers to repository <span class="token punctuation">[</span><span class="token number">192.168</span>.2.241:5000/user241<span class="token punctuation">]</span>
c49567fcf544: Pushed 
v1.0: digest: sha256:50e4c287c3287307a0af663b479db763335aeb444f64bb00eb19f547553e38c0 size: <span class="token number">527</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="下载镜像"><a class="markdownIt-Anchor" href="#下载镜像"></a> 下载镜像</h2>
<p>在另外一台主机上使用 <code>docker pull</code> 来拉取仓库中的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull <span class="token number">192.168</span>.2.241:5000/user241:v1.0
v1.0: Pulling from user241
01b4f4cd1c49: Pull complete 
Digest: sha256:50e4c287c3287307a0af663b479db763335aeb444f64bb00eb19f547553e38c0
Status: Downloaded newer image <span class="token keyword">for</span> <span class="token number">192.168</span>.2.241:5000/user241:v1.0
<span class="token number">192.168</span>.2.241:5000/user241:v1.0
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY                   TAG       IMAGE ID       CREATED       SIZE
<span class="token number">192.168</span>.2.241:5000/user241   v1.0      7549e3270b72   <span class="token number">7</span> hours ago   <span class="token number">5</span>.6MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="其他操作"><a class="markdownIt-Anchor" href="#其他操作"></a> 其他操作</h2>
<p>对于镜像的创建、更新、分发等操作，Docker Registry 提供 HTTP API 接口来实现操作调用。主要功能如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/v2/</code></td>
<td>检查是否支持 2.0 接口。</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/&lt;name&gt;/tags/list</code></td>
<td>获得镜像的标签列表。</td>
</tr>
<tr>
<td>GET/PUT/DELETE</td>
<td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
<td>获得/修改/删除镜像的主要信息。</td>
</tr>
<tr>
<td>GET/DELETE</td>
<td><code>/v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></td>
<td>获得/删除镜像层。</td>
</tr>
<tr>
<td>POST</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/</code></td>
<td>开始分块上传。</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/catalog</code></td>
<td>获得镜像列表。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 镜像操作</title>
    <url>/1103407806/</url>
    <content><![CDATA[<h1 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h1>
<p>一般镜像通过 Docker Hub 来获取。</p>
<h2 id="搜索镜像"><a class="markdownIt-Anchor" href="#搜索镜像"></a> 搜索镜像</h2>
<p>通过 <code>docker search</code> 命令可以搜索公共仓库 Docker Hub 中的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search python
NAME                       DESCRIPTION               STARS     OFFICIAL   AUTOMATED
python                     Python is an interpreted, <span class="token number">6632</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
pypy                       PyPy is a fast, compliant <span class="token number">290</span>       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       
nikolaik/python-nodejs     Python with Node.js       <span class="token number">86</span>                   <span class="token punctuation">[</span>OK<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>搜索结果以 STARS 排序，默认显示 25 个结果。其字段说明如下：</p>
<ul>
<li>NAME：镜像名称。</li>
<li>DESCRIPTION：创建者对镜像的简单描述。</li>
<li>STARS：镜像在官方镜像仓库中受欢迎程度。</li>
<li>OFFICIAL：是否由 Docker 官方提供。</li>
<li>AUTOMATED：镜像是否使用了自动构建。</li>
</ul>
<p>设置搜索结果数目限制到 100 个：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--limit</span> <span class="token number">100</span> centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>--filter</code> 参数来限制搜索结果只显示官方构建的 <code>nginx</code> 镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>is-official<span class="token operator">=</span>true nginx
NAME      DESCRIPTION                STARS     OFFICIAL   AUTOMATED
nginx     Official build of Nginx.   <span class="token number">15666</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>过滤收藏数小于 10 的镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> search <span class="token parameter variable">--filter</span><span class="token operator">=</span>stars<span class="token operator">=</span><span class="token number">10</span> linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="拉取镜像"><a class="markdownIt-Anchor" href="#拉取镜像"></a> 拉取镜像</h2>
<p>在运行 Docker 容器之前，需要在本地获取相应的镜像，可以使用 <code>docker pull</code> 命令进行镜像拉取。</p>
<p>例如，从 Docker Hub 拉取 <code>Ubuntu 18.04</code> 系统的基础镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull ubuntu:18.04
<span class="token number">18.04</span>: Pulling from library/ubuntu
<span class="token number">284055322776</span>: Pull complete 
Digest: sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6
Status: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04
docker.io/library/ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Docker 利用镜像的分层机制，将镜像分为多个包进行下载。当所有镜像层的下载和解压等操作完成后，镜像会出现在本地镜像仓库中。</p>
<p>如果不指定标签，默认使用 latest 标签。例如，从网易镜像站下载最新版本的 <code>Ubuntu</code> 镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> pull hub-mirror.c.163.com/public/ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此外，可以使用 <code>-a</code> 参数一次性下载所有标签版本的镜像。</p>
<h1 id="管理镜像"><a class="markdownIt-Anchor" href="#管理镜像"></a> 管理镜像</h1>
<p>镜像管理命令和容器管理命令类似。</p>
<h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2>
<p>可以使用 <code>docker commit</code> 将容器转换为镜像，以保存容器中所做的更改：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> commit c238293 newimage:v1
sha256:392f66f55bace6d10def28028edc90eebc3bb1e23e8e30a030aeb8f96e98ac8e
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
newimage                  v1        392f66f55bac   <span class="token number">4</span> seconds ago   <span class="token number">63</span>.1MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种手动创建镜像的方法容易出错且可重复性较差，因此最好使用 <code>docker build</code> 命令结合 Dockerfile 来构建镜像。</p>
<p>默认情况下，<code>docker build</code> 命令会自动在指定目录下查找名为 Dockerfile 的文件，并使用该文件进行构建。也可以通过 <code>-f</code> 参数指定要使用的文件名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> Dockerfile
FROM ubuntu:18.04
CMD <span class="token builtin class-name">echo</span> <span class="token string">"Hello Dockerfile"</span>
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> build <span class="token builtin class-name">.</span>
Sending build context to Docker daemon  <span class="token number">5</span>.938MB
Step <span class="token number">1</span>/2 <span class="token builtin class-name">:</span> FROM ubuntu:18.04
 ---<span class="token operator">></span> 5a214d77f5d7
Step <span class="token number">2</span>/2 <span class="token builtin class-name">:</span> CMD <span class="token builtin class-name">echo</span> <span class="token string">"Hello Dockerfile"</span>
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> 2fe4d2fa8be2
Removing intermediate container 2fe4d2fa8be2
 ---<span class="token operator">></span> 4e73bed1428a
Successfully built 4e73bed1428a
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
<span class="token operator">&lt;</span>none<span class="token operator">></span>                    <span class="token operator">&lt;</span>none<span class="token operator">></span>    4e73bed1428a   <span class="token number">12</span> seconds ago   <span class="token number">63</span>.1MB
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> 4e73
Hello Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-t</code> 参数可以指定构建镜像的名称和标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> assassing/redis:2.3 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h2>
<p>要删除本地镜像，可以使用 <code>docker rmi</code> 命令。如果一个镜像有多个标签，只有在最后一个标签被删除时，镜像才会被真正删除：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> rmi 5a214d77
Error response from daemon: conflict: unable to delete 5a214d77f5d7 <span class="token punctuation">(</span>must be forced<span class="token punctuation">)</span> - image is referenced <span class="token keyword">in</span> multiple repositories
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> rmi base:1.0
Untagged: base:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果镜像中包含与其他镜像共享的镜像层，那些层将被保留下来，只删除未被使用的层。</p>
<p>当镜像被容器使用时，可以使用 <code>-f</code> 参数强制删除镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> nginx
Untagged: nginx:latest
Untagged: nginx@sha256:644a70516a26004c97d0d85c7fe1d0c3a67ea8ab7ddf4aff193d9f301670cf36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是，强制删除镜像不会自动停止或删除使用该镜像的容器，这可能会导致一些难以处理的问题。最好先停止或清理使用该镜像的容器，然后再删除镜像。</p>
<h2 id="清理镜像"><a class="markdownIt-Anchor" href="#清理镜像"></a> 清理镜像</h2>
<p>要清理系统中残留的临时镜像文件或未使用的镜像，可以使用 <code>docker image prune</code> 命令进行清理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image prune
WARNING<span class="token operator">!</span> This will remove all dangling images.
Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Total reclaimed space: 0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="导出镜像"><a class="markdownIt-Anchor" href="#导出镜像"></a> 导出镜像</h2>
<p>要导出镜像，可以使用 <code>docker save</code> 命令。例如，将 <code>alpine</code> 镜像导出到本地的 <code>a.tar</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images alpine
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
alpine       latest    14119a10abf4   <span class="token number">7</span> weeks ago   <span class="token number">5</span>.6MB
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> save <span class="token parameter variable">-o</span> a.tar alpine
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ ll a.tar 
-rw-------. <span class="token number">1</span> root root <span class="token number">5874688</span> Oct <span class="token number">20</span> <span class="token number">23</span>:22 a.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用输出重定向将导出内容保存到指定文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> save alpine <span class="token operator">></span> a1.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以一次将多个镜像导出到单个文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> save <span class="token parameter variable">-o</span> docker.tar alpine hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="导入镜像"><a class="markdownIt-Anchor" href="#导入镜像"></a> 导入镜像</h2>
<p>可以使用 <code>docker load</code> 命令从文件中导入镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> load <span class="token parameter variable">-i</span> docker.tar 
e2eb06d8af82: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">5</span>.865MB/5.865MB
Loaded image: alpine:latest
e07ee1baac5f: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">14</span>.85kB/14.85kB
Loaded image: hello-world:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用输入重定向符号从文件中导入镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> load <span class="token operator">&lt;</span> <span class="token number">2</span>.tar 
2653d992f4ef: Loading layer <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>  <span class="token number">216</span>.5MB/216.5MB
Loaded image ID: sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="查询镜像"><a class="markdownIt-Anchor" href="#查询镜像"></a> 查询镜像</h1>
<p>镜像以分层文件的形式存储在文件系统中。</p>
<h2 id="查询镜像列表"><a class="markdownIt-Anchor" href="#查询镜像列表"></a> 查询镜像列表</h2>
<p>使用 <code>docker images</code> 命令可以列出本地镜像列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
ubuntu        <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示字段的含义如下：</p>
<ul>
<li>REPOSITORY: 镜像名或镜像来源仓库。如果有 Namespace，也会一同显示。</li>
<li>TAG: 镜像标签，用于标记不同的版本信息。</li>
<li>IMAGE ID: 镜像的 ID，也是镜像的唯一标识。可以使用前几个字符代替完整的 ID。</li>
<li>CREATED: 镜像的创建时间。</li>
<li>SIZE: 镜像的大小，包括共享的镜像层。实际占用的存储空间可能较小。</li>
</ul>
<p>可以使用通配符来过滤镜像列表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images ubu*
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="查询镜像详情"><a class="markdownIt-Anchor" href="#查询镜像详情"></a> 查询镜像详情</h2>
<p>可以使用 <code>docker inspect</code> 命令获取镜像的详细信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect ubuntu:18.04
<span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:5a214d77f5d747e6ed81632310baa6190301feeb875cf6bf9da560108fa09972"</span>,
        <span class="token string">"RepoTags"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"base:1.0"</span>,
            <span class="token string">"ubuntu:18.04"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"RepoDigests"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"ubuntu@sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6"</span>
        <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以通过镜像的 ID 进行查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect 5a21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查询结果以 JSON 格式返回，可以使用输出格式化工具进行过滤：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> inspect <span class="token parameter variable">-f</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token string">".ContainerConfig.Hostname"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> alpine
330289c649db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="查询镜像修改历史"><a class="markdownIt-Anchor" href="#查询镜像修改历史"></a> 查询镜像修改历史</h2>
<p>可以使用 <code>docker history</code> 命令查看镜像的每一层具体内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> <span class="token function">history</span> --no-trunc alpine
IMAGE          CREATED       CREATED BY                            SIZE      COMMENT
14119a10abf4   <span class="token number">7</span> weeks ago   /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop)  CMD ["/bin/sh"]    0B        </span>
<span class="token operator">&lt;</span>missing<span class="token operator">></span>      <span class="token number">7</span> weeks ago   /bin/sh <span class="token parameter variable">-c</span> <span class="token comment">#(nop) ADD file:aad4290d   5.6MB </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="操作镜像"><a class="markdownIt-Anchor" href="#操作镜像"></a> 操作镜像</h1>
<p>涉及到镜像操作的内容包括镜像改名和上传镜像。</p>
<h2 id="镜像改名"><a class="markdownIt-Anchor" href="#镜像改名"></a> 镜像改名</h2>
<p>可以使用 <code>docker tag</code> 命令为本地镜像添加标签，并删除原始镜像，从而实现改名的目的。</p>
<p>例如，为 <code>ubuntu:18.04</code> 镜像添加一个新标签 <code>base:1.0</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> tag ubuntu:18.04 base:1.0
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
base          <span class="token number">1.0</span>       5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
ubuntu        <span class="token number">18.04</span>     5a214d77f5d7   <span class="token number">2</span> weeks ago   <span class="token number">63</span>.1MB
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在可以看到多了一个名为 <code>base:1.0</code> 的镜像，其镜像 ID 与 <code>ubuntu:18.04</code> 相同。通过添加标签，类似于创建文件的硬链接。</p>
<h2 id="上传镜像"><a class="markdownIt-Anchor" href="#上传镜像"></a> 上传镜像</h2>
<p>要将镜像上传到仓库，可以使用 <code>docker push</code> 命令。在上传之前，需要为目标镜像打上标签。如果要上传到 Docker Hub，则目标镜像的命名空间为用户的用户名；如果要上传到私有仓库，则命名空间变为仓库的地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> tag alpine:latest assassing/a1:latest
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> push assassing/a1:latest
The push refers to repository <span class="token punctuation">[</span>docker.io/assassing/a1<span class="token punctuation">]</span>
e2eb06d8af82: Mounted from library/alpine 
latest: digest: sha256:69704ef328d05a9f806b6b8502915e6a0a4faa4d72018dc42343f511490daf8a size: <span class="token number">528</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 安装与配置</title>
    <url>/4130112682/</url>
    <content><![CDATA[<h1 id="前置条件"><a class="markdownIt-Anchor" href="#前置条件"></a> 前置条件</h1>
<p>由于 Docker 运行于 Linux 内核中，因此对于系统要求如下：</p>
<ul>
<li>系统必须为 64 位操作系统。</li>
<li>系统内核版本需要大于 3.10。</li>
<li>硬盘空间推荐为 100 GB 以上。</li>
</ul>
<p>可以使用以下命令查询系统位数和内核版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">uname</span> <span class="token parameter variable">-r</span>
<span class="token number">3.10</span>.0-1160.42.2.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Docker 引擎分为两个版本，社区版本（CE，Community Edition）和企业版本（EE，Enterprise Edition）。通常安装社区稳定版。</p>
<h1 id="安装-docker"><a class="markdownIt-Anchor" href="#安装-docker"></a> 安装 Docker</h1>
<p>对于之前安装过 Docker 的主机，需要先卸载干净后再进行安装。</p>
<p>在全新安装时，需要先修改仓库配置，增加 Docker CE 的安装源：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
Loaded plugins: fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing <span class="token function">file</span> https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要安装 Nightly 或 Test 版本，可以使用以下命令启用相应的仓库。要关闭，使用 <code>--disable</code> 参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum-config-manager <span class="token parameter variable">--enable</span> docker-ce-nightly
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum-config-manager <span class="token parameter variable">--enable</span> docker-ce-test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安装最新版 Docker CE：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要安装特定版本，可以使用 <code>yum list</code> 命令进行查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum list docker-ce <span class="token parameter variable">--showduplicates</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-r</span>
docker-ce.x86_64            <span class="token number">3</span>:20.10.9-3.el7                    docker-ce-stable 
docker-ce.x86_64            <span class="token number">3</span>:20.10.9-3.el7                    @docker-ce-stable
docker-ce.x86_64            <span class="token number">3</span>:20.10.8-3.el7                    docker-ce-stable <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如，安装 20.10.10 版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce-20.10.10 docker-ce-cli-20.10.10 containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Docker 安装完成后会创建一个 Docker 组，可以将普通用户加入该组，这样普通用户就可以直接运行 Docker 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-p</span> user10 user10
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-l</span> user10
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image <span class="token function">ls</span>
Got permission denied <span class="token keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="token string">"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/images/json"</span><span class="token builtin class-name">:</span> dial unix /var/run/docker.sock: connect: permission denied
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">'usermod -G docker user10'</span>
<span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   <span class="token number">3</span> weeks ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="更新-docker"><a class="markdownIt-Anchor" href="#更新-docker"></a> 更新 Docker</h1>
<p>在 Docker 仓库源已启用的情况下，可以使用 <code>yum upgrade</code> 命令来更新 Docker：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="卸载-docker"><a class="markdownIt-Anchor" href="#卸载-docker"></a> 卸载 Docker</h1>
<p>使用以下命令完全卸载旧版本的 Docker 及相关程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ yum remove <span class="token function">docker</span> docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除新版 Docker 引擎：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user10@server4 ~<span class="token punctuation">]</span>$ yum remove docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除 Docker 使用的库、镜像和容器等数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/docker
<span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/containerd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="启动-docker"><a class="markdownIt-Anchor" href="#启动-docker"></a> 启动 Docker</h1>
<p>启动服务并设置开机启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> <span class="token function">docker</span>
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动之后，可以使用 <code>hello-world</code> 镜像来测试 Docker 功能是否正常：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> run hello-world
Unable to <span class="token function">find</span> image <span class="token string">'hello-world:latest'</span> locally
latest: Pulling from library/hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="查询-docker-版本"><a class="markdownIt-Anchor" href="#查询-docker-版本"></a> 查询 Docker 版本</h1>
<p>使用 <code>docker version</code> 命令来查询 Docker 服务端和客户端的版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> version
Client: Docker Engine - Community
 Version:           <span class="token number">20.10</span>.9
 API version:       <span class="token number">1.41</span>
 Go version:        go1.16.8
 Git commit:        c2ea9bc
 Built:             Mon Oct  <span class="token number">4</span> <span class="token number">16</span>:08:14 <span class="token number">2021</span>
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      <span class="token boolean">true</span>

Server: Docker Engine - Community
 Engine:
  Version:          <span class="token number">20.10</span>.9
  API version:      <span class="token number">1.41</span> <span class="token punctuation">(</span>minimum version <span class="token number">1.12</span><span class="token punctuation">)</span>
  Go version:       go1.16.8
  Git commit:       79ea9d3
  Built:            Mon Oct  <span class="token number">4</span> <span class="token number">16</span>:06:37 <span class="token number">2021</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="token boolean">false</span>
 containerd:
  Version:          <span class="token number">1.4</span>.11
  GitCommit:        5b46e404f6b9f661a205e28d59c982d3634148f8
 runc:
  Version:          <span class="token number">1.0</span>.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          <span class="token number">0.19</span>.0
  GitCommit:        de40ad0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查看-docker-信息"><a class="markdownIt-Anchor" href="#查看-docker-信息"></a> 查看 Docker 信息</h1>
<p>可以使用 <code>docker info</code> 命令来查看 Docker 的运行状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> info
Client:
 Context:    default
 Debug Mode: <span class="token boolean">false</span>
 Plugins:
  app: Docker App <span class="token punctuation">(</span>Docker Inc., v0.9.1-beta3<span class="token punctuation">)</span>
  buildx: Build with BuildKit <span class="token punctuation">(</span>Docker Inc., v0.6.3-docker<span class="token punctuation">)</span>
  scan: Docker Scan <span class="token punctuation">(</span>Docker Inc., v0.8.0<span class="token punctuation">)</span>

Server:
 Containers: <span class="token number">1</span>
  Running: <span class="token number">0</span>
  Paused: <span class="token number">0</span>
  Stopped: <span class="token number">1</span>
 Images: <span class="token number">5</span>
 Server Version: <span class="token number">20.10</span>.9
 Storage Driver: overlay2
  Backing Filesystem: xfs
  Supports d_type: <span class="token boolean">true</span>
  Native Overlay Diff: <span class="token boolean">true</span>
  userxattr: <span class="token boolean">false</span>
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: <span class="token number">1</span>
 Plugins:
  Volume: <span class="token builtin class-name">local</span>
  Network: bridge <span class="token function">host</span> ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file <span class="token builtin class-name">local</span> logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 5b46e404f6b9f661a205e28d59c982d3634148f8
 runc version: v1.0.2-0-g52b36a2
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: <span class="token number">3.10</span>.0-1160.42.2.el7.x86_64
 Operating System: CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
 OSType: linux
 Architecture: x86_64
 CPUs: <span class="token number">16</span>
 Total Memory: <span class="token number">3</span>.682GiB
 Name: server4
 ID: 7YVL:YG7U:BI3Q:BOVZ:XRWD:7BQO:6H3R:2BUW:OCQO:7JKZ:2OWC:UL2Q
 Docker Root Dir: /var/lib/docker
 Debug Mode: <span class="token boolean">false</span>
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: <span class="token boolean">false</span>
 Insecure Registries:
  <span class="token number">127.0</span>.0.0/8
 Registry Mirrors:
  https://mirror.ccs.tencentyun.com/
 Live Restore Enabled: <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>docker system df</code> 命令来查询 Docker 的磁盘空间使用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@UAT1542 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> system <span class="token function">df</span>
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          <span class="token number">21</span>        <span class="token number">8</span>         <span class="token number">7</span>.737GB   <span class="token number">3</span>.526GB <span class="token punctuation">(</span><span class="token number">45</span>%<span class="token punctuation">)</span>
Containers      <span class="token number">10</span>        <span class="token number">9</span>         <span class="token number">18</span>.21GB   175B <span class="token punctuation">(</span><span class="token number">0</span>%<span class="token punctuation">)</span>
Local Volumes   <span class="token number">10</span>        <span class="token number">3</span>         <span class="token number">135</span>.9kB   <span class="token number">101</span>.9kB <span class="token punctuation">(</span><span class="token number">74</span>%<span class="token punctuation">)</span>
Build Cache     <span class="token number">0</span>         <span class="token number">0</span>         0B        0B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="清理数据"><a class="markdownIt-Anchor" href="#清理数据"></a> 清理数据</h1>
<p>使用 <code>docker system prune</code> 命令来安全清理没用到的数据，比如停止状态的容器、没有被使用的中间镜像层、没被使用的 Docker 虚拟网络：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@UAT1542 ~<span class="token punctuation">]</span>$ <span class="token function">docker</span> system prune
WARNING<span class="token operator">!</span> This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache

Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> y
Deleted Containers:
5c6cdebbb209507a4886debe278f59cdf1dbebd6a8cfbf3b1ea32828cf3adbfa

Total reclaimed space: 175B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还能加入 <code>-a</code> 参数进一步删除没有被使用的镜像（不包括被停止状态容器使用的镜像）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-204:~<span class="token comment"># docker system prune -a</span>
WARNING<span class="token operator">!</span> This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="启动参数"><a class="markdownIt-Anchor" href="#启动参数"></a> 启动参数</h1>
<p>Docker 服务启动实际上是调用了 <code>dockerd</code> 命令，Docker Daemon 常用启动参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–api-cors-header=“”</td>
<td>设定远程访问 API 所需的 cors-header。</td>
</tr>
<tr>
<td>–authorization-plugin=[]</td>
<td>设置认证插件列表。</td>
</tr>
<tr>
<td>-b, --bridge=“”</td>
<td>设置容器使用的网桥。</td>
</tr>
<tr>
<td>–bip=“”</td>
<td>设定网络桥 IP 和子网掩码。</td>
</tr>
<tr>
<td>-D, --debug=false</td>
<td>启动 Debug 模式。</td>
</tr>
<tr>
<td>-d, --daemon=false</td>
<td>启动守护进程模式。</td>
</tr>
<tr>
<td>–default-gateway=“”</td>
<td>设置容器使用的 IPv4 网关。</td>
</tr>
<tr>
<td>–dns=[]</td>
<td>设置容器使用的 DNS 服务器列表。</td>
</tr>
<tr>
<td>–default-ulimit=[]</td>
<td>设定容器默认的 <code>ulimit</code> 参数。</td>
</tr>
<tr>
<td>-exec-opt=[]</td>
<td>设定管理容器使用的参数。</td>
</tr>
<tr>
<td>–exec-root=“/var/run/docker”</td>
<td>设定 <code>exec-driver</code> 默认根目录地址。</td>
</tr>
<tr>
<td>–fixed-cidr=“”</td>
<td>设定容器使用的 IPv4 子网段。</td>
</tr>
<tr>
<td>-G, --group=“docker”</td>
<td>设定 UNIX Socket 文件用户所属组。</td>
</tr>
<tr>
<td>-g, --graph=“/var/lib/docker”</td>
<td>设定 Docker 服务运行时的根目录。</td>
</tr>
<tr>
<td>-H, --host=[]</td>
<td>设定 Docker 服务监听地址。</td>
</tr>
<tr>
<td>–icc=true</td>
<td>允许容器之间互相通信。</td>
</tr>
<tr>
<td>–insecure-registry=[]</td>
<td>设定可信任仓库地址。</td>
</tr>
<tr>
<td>–ip=0.0.0.0</td>
<td>设定绑定容器端口信息时的默认 IP。</td>
</tr>
<tr>
<td>–ip-forward=true</td>
<td>允许转发 IPv4 数据包。</td>
</tr>
<tr>
<td>–ip-masq=true</td>
<td>允许 IP 伪装。</td>
</tr>
<tr>
<td>–iptables=true</td>
<td>允许修改 iptables 规则。</td>
</tr>
<tr>
<td>–ipv6=true</td>
<td>允许使用 IPv6 网络。</td>
</tr>
<tr>
<td>-l, --log-level=“info”</td>
<td>设定日志输出等级。</td>
</tr>
<tr>
<td>–label=[]</td>
<td>按照 Key=Value 设定 Daemon 标签。</td>
</tr>
<tr>
<td>–log-driver=“json-file”</td>
<td>设定日志驱动格式。</td>
</tr>
<tr>
<td>–log-opt=[]</td>
<td>设定日志记录驱动参数。</td>
</tr>
<tr>
<td>–mtu=0</td>
<td>设定容器 MTU 值。</td>
</tr>
<tr>
<td>-p, --pidfile=“/var/run/docker.pid”</td>
<td>设定 <code>Docker.pid</code> 文件路径。</td>
</tr>
<tr>
<td>–registry-mirror=[]</td>
<td>设定优先访问的仓库镜像地址。</td>
</tr>
<tr>
<td>-s, --storage-driver=“”</td>
<td>设定数据储存驱动方式。</td>
</tr>
<tr>
<td>–selinux-enabled=false</td>
<td>启用或禁用 SELinux</td>
</tr>
<tr>
<td>–storage-opt=[]</td>
<td>设置数据存储驱动的参数</td>
</tr>
<tr>
<td>–tls=false</td>
<td>启用或禁用 TLS，但不启用客户端认证</td>
</tr>
<tr>
<td>–tlscacert=“~/.docker/ca.pem”</td>
<td>设置 CA 证书的位置</td>
</tr>
<tr>
<td>–tlscert=“~/.docker/cert.pem”</td>
<td>设置 TLS 证书的位置</td>
</tr>
<tr>
<td>–tlskey=“~/.docker/key.pem”</td>
<td>设置 TLS 密钥的位置</td>
</tr>
<tr>
<td>–tlsverify=false</td>
<td>启用或禁用 TLS 验证远程访问请求</td>
</tr>
<tr>
<td>–userland-proxy=true</td>
<td>启用或禁用用户空间代理</td>
</tr>
<tr>
<td>-v, --version=false</td>
<td>输出 Docker 版本信息</td>
</tr>
</tbody>
</table>
<p>如果参数后面有 <code>[]</code>标记，表示该参数可以多次使用。例如，要启用 Debug 模式并监听本地 2376 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ dockerd <span class="token parameter variable">-D</span> <span class="token parameter variable">-H</span> tcp:/127.0.0.1:2376<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以将启动参数写入 <code>/etc/docker/daemon.json</code> 文件中，在 dockerd 服务启动时读取该文件。请注意，该配置文件中不能有与启动参数重复的配置项，否则会导致启动错误：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server4 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/docker/daemon.json
<span class="token punctuation">&#123;</span>
        <span class="token string">"debug"</span><span class="token builtin class-name">:</span> true,
        <span class="token string">"hosts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"tcp://127.0.0.1:2376"</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以修改 <code>/usr/lib/systemd/system/docker.service</code> 文件中 <code>ExecStart</code> 后面的参数来配置启动参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /usr/lib/systemd/system/docker.service 
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd <span class="token parameter variable">-H</span> fd:// <span class="token parameter variable">--containerd</span><span class="token operator">=</span>/run/containerd/containerd.sock <span class="token parameter variable">-H</span> tcp://192.168.2.234:5999
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl daemon-reload
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Docker</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Postfix 服务</title>
    <url>/1516343977/</url>
    <content><![CDATA[<h1 id="邮件服务器"><a class="markdownIt-Anchor" href="#邮件服务器"></a> 邮件服务器</h1>
<p>架设邮件服务器（Mail Server）首先需要有一个合法注册的域名，然后需要申请 IP 反解策略。最后是设置 MX 和 A 类型记录，来对应到邮件服务器的 IP 地址上。</p>
<p>邮件传输过程中所需要的组件和协议如下：</p>
<ul>
<li>
<p>MUA（Mail User Agent）</p>
<p>MUA，顾名思义就是邮件用户代理人，用来将用户信件送到邮件服务器上。最常见的 MUA 有 Thunderbird、Kmail、Outlook Express 等所谓邮件客户端。</p>
</li>
<li>
<p>MTA（Mail Transfer Agent）</p>
<p>MTA 是邮件发送代理人，它可以使用简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）来接受用户邮件，并具有中继转发（Relay）功能。常见的 MTA 有 sendmail、postfix 等所谓邮件服务端。</p>
</li>
<li>
<p>MDA（Mail Delivery Agent）</p>
<p>MDA 是邮件传送代理人，其实是 MTA 下面的组件。主要功能是分析由 MTA 所收到的邮件表头或内容等数据，来决定这份邮件的去向。此外，MDA 还有分析与过滤邮件和自动回复功能。</p>
</li>
</ul>
<p>用户收信过程中所需的组件和协议如下：</p>
<ul>
<li>
<p>MRA（Mail Retrieval Agent）</p>
<p>MRA 也是 MTA 下面的组件，用户可以通过邮政服务协议（POP，Post Office Protocol）来接收自己的邮件，也可以通过 IMAP（Internet Message Access Protocol）将邮件保留在邮件主机上面。</p>
</li>
<li>
<p>Mailbox</p>
<p>电子邮箱就是某个账号专用的邮件收取文件。在 Linux 下默认放在 <code>/var/spool/mail/</code> 下面。</p>
</li>
</ul>
<h1 id="邮件收发流程"><a class="markdownIt-Anchor" href="#邮件收发流程"></a> 邮件收发流程</h1>
<p>电子邮件的内容分为标题（header）和内容（body）两部分。下面是一份测试邮件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"testmail"</span> <span class="token operator">|</span> mail <span class="token parameter variable">-s</span> <span class="token string">"mailheader1"</span> user1
<span class="token punctuation">[</span>user1@server1 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /var/spool/mail/user1 
From root@server1  Sun Oct <span class="token number">17</span> <span class="token number">20</span>:53:33 <span class="token number">2021</span>
Return-Path: <span class="token operator">&lt;</span>root@server<span class="token operator"><span class="token file-descriptor important">1</span>></span>
Received: from server1 <span class="token punctuation">(</span>localhost <span class="token punctuation">[</span><span class="token number">127.0</span>.0.1<span class="token punctuation">]</span><span class="token punctuation">)</span>
        by server1 <span class="token punctuation">(</span><span class="token number">8.14</span>.7/8.14.7<span class="token punctuation">)</span> with ESMTP <span class="token function">id</span> 19HCrXob053690
        <span class="token keyword">for</span> <span class="token operator">&lt;</span>user1@server<span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token punctuation">;</span> Sun, <span class="token number">17</span> Oct <span class="token number">2021</span> <span class="token number">20</span>:53:33 +0800
Received: <span class="token punctuation">(</span>from root@localhost<span class="token punctuation">)</span>
        by server1 <span class="token punctuation">(</span><span class="token number">8.14</span>.7/8.14.7/Submit<span class="token punctuation">)</span> <span class="token function">id</span> 19HCrX7P053605
        <span class="token keyword">for</span> user1<span class="token punctuation">;</span> Sun, <span class="token number">17</span> Oct <span class="token number">2021</span> <span class="token number">20</span>:53:33 +0800
From: root <span class="token operator">&lt;</span>root@server<span class="token operator"><span class="token file-descriptor important">1</span>></span>
Message-Id: <span class="token operator">&lt;</span><span class="token number">202110171253</span>.19HCrX7P053605@server<span class="token operator"><span class="token file-descriptor important">1</span>></span>
Date: Sun, <span class="token number">17</span> Oct <span class="token number">2021</span> <span class="token number">20</span>:52:33 +0800
To: user1@server1
Subject: mailheader1
User-Agent: Heirloom mailx <span class="token number">12.5</span> <span class="token number">7</span>/5/10
MIME-Version: <span class="token number">1.0</span>
Content-Type: text/plain<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>us-ascii
Content-Transfer-Encoding: 7bit

testmail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>邮件传输流程的流程如下：</p>
<ol>
<li>本地 MUA 想要使用 MTA 来发送邮件时，首先需要取得 MTA 的权限。一般是注册对应的 Email 账号。</li>
<li>用户在 MUA 上编写邮件后发送到 MTA 上，邮件包括标题和内容。</li>
<li>如果 MTA 收到邮件的目标是自己的用户，直接通过 MDA 将邮件送往对应 Mailbox。如果目标是其他 MTA，则 MDA 会开始进行邮件转发，发往下一台 MTA 的 SMTP 端口（25）。邮件顺利发送出去后，该邮件会从队列当中删除掉。</li>
<li>对方 MTA 收到转发信件后，发往对应的用户 Mailbox 中。</li>
</ol>
<p>通过 POP3 来收取邮件流程如下：</p>
<ol>
<li>MMUA 通过 POP3 协议连接到 MRA 的 110 端口，并输入账号和密码来取得正确认证与授权。</li>
<li>MRA 确认用户密码正确后，会前往用户的 Mailbox 取得邮件，并发送到用户 MUA 上面。</li>
<li>当所有邮件传送完毕后，用户的 Mailbox 内数据将被删除。</li>
</ol>
<p>对于 MTA 来说邮件传送的流程如下：</p>
<ol>
<li>发信端与收信端主机会先经过一个握手（ehlo）阶段，此时发信端被记录为发信来源，将邮件标题进行传送。</li>
<li>收信端主机会分析标题信息，若邮件 Mail to 地址为收信端主机，且名称符合 mydestination 的值，则邮件会开始被接受到队列，并送到 Mailbox 中。若不符合 mydestination 的值，则终止连接不接受后续的正文内容传送。</li>
<li>若 Mail to 地址不是收信端本身，继续进行中继转发（relay）分析。先判断邮件来源是否是信任客户端（mynetworks 的值），若不是则继续分析邮件来源或目标是否符合 relay_domains 的设置，以上任意符合的话开始接收邮件至队列中，并等待 MDA 将邮件转发出去。否则会终止连接不接受后续的正文内容传送。</li>
</ol>
<h1 id="postfix-邮件服务"><a class="markdownIt-Anchor" href="#postfix-邮件服务"></a> Postfix 邮件服务</h1>
<p>Postfix 为完全兼容于 SendMail 所设计出来的一个邮件服务器软件，在外部配置文件的支持度上与 SendMail 没有区别。所以在 CentOS 中作为内建功能提供。</p>
<p>其主要的配置文件有：</p>
<ul>
<li>
<p><code>/etc/postfix/main.cf</code></p>
<p>最主要的 Postfix 配置文件，修改配置文件后需要重启 Postfix。</p>
</li>
<li>
<p><code>/etc/postfix/master.cf</code></p>
<p>规定 Postfix 每个程序的工作参数。通常不需要改动。</p>
</li>
<li>
<p><code>/etc/postfix/access</code></p>
<p>设置开放 Relay 或拒绝连接的来源与目标地址等信息的外部配置文件。需要以 postmap 来处理成为数据库文件。</p>
</li>
<li>
<p><code>/etc/aliases</code></p>
<p>作为邮件别名的用途，也可以作为邮件组的设置。</p>
</li>
</ul>
<h1 id="postfix-配置文件"><a class="markdownIt-Anchor" href="#postfix-配置文件"></a> Postfix 配置文件</h1>
<p>配置文件 <code>/etc/postfix/main.cf</code> 中设置值格式如 <code>myhostname = www.hxz.ass</code>，等号两边必须要有空格。多个设置值之间用逗号分开。此外还可以使用 <code>$</code> 来使用变量。</p>
<p>常用的设置选项如下：</p>
<ul>
<li>
<p><code>myhostname: 主机名（FQDN）</code></p>
<p>此设置值会被后续很多参数引用，例如 <code>myhostname = www.hxz.ass</code></p>
</li>
<li>
<p><code>myorigin = $myhostname</code></p>
<p>设置寄信地址，如果寄信时没有设置 Mail from 字段，会以此值作为默认值。</p>
</li>
<li>
<p><code>inet_interfaces = all</code></p>
<p>设置监听网口。默认情况下 postfix 仅针对本机进行监听，可以修改成 all 来监听所有网口。</p>
</li>
<li>
<p><code>mydestination = $myhostname</code></p>
<p>设置本机收信地址，要与 MX 记录指向相匹配。</p>
</li>
<li>
<p><code>mynetworks = 10.1.1.0/24</code></p>
<p>设置信任的客户端来源地址。可以对信任区域帮忙进行 Relay 转发。</p>
</li>
</ul>
<p>整个配置文件内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/postfix/main.cf
myhostname <span class="token operator">=</span> www.hxz.ass
myorigin <span class="token operator">=</span> <span class="token variable">$myhostname</span>
inet_interfaces <span class="token operator">=</span> all
mydestination <span class="token operator">=</span> <span class="token variable">$myhostname</span>, localhost.<span class="token variable">$mydomain</span>, localhost
mynetworks <span class="token operator">=</span> <span class="token number">10.1</span>.1.0/24, <span class="token number">127.0</span>.0.0/8
relay_domains <span class="token operator">=</span> <span class="token variable">$mydestination</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="postfix-服务启动"><a class="markdownIt-Anchor" href="#postfix-服务启动"></a> Postfix 服务启动</h1>
<p>先使用 <code>postmap</code> 和 <code>postalias</code> 来重建和转换数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postmap hash:/etc/postfix/access 
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postalias hash:/etc/aliases<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后使用 <code>postfix check</code> 命令检查配置文件是否有错误。之后就可以启动服务了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postfix check
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postfix stop
postfix/postfix-script: stopping the Postfix mail system
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postfix start
postfix/postfix-script: starting the Postfix mail system
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span><span class="token function">grep</span> <span class="token number">25</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:25              <span class="token number">0.0</span>.0.0:*       LISTEN      <span class="token number">117183</span>/master <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="邮件主机过滤"><a class="markdownIt-Anchor" href="#邮件主机过滤"></a> 邮件主机过滤</h1>
<p>基本上制定了 mynetworks 的信任来源就能够让用户 Relay 了。此外还可以利用 access 文件来额外管理邮件过滤。</p>
<p>例如想让 <code>10.1.1.0/24</code> 和 <code>.hxz.ass</code> 使用这台 MTA 来转发邮件，不允许 <code>192.168.1.0/24</code> 使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/postfix/access
<span class="token number">10.1</span>.1          OK
.hxz.ass        OK
<span class="token number">192.168</span>.1       REJECT
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postmap hash:/etc/postfix/access
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ll /etc/postfix/acces*
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">20920</span> Oct <span class="token number">17</span> <span class="token number">23</span>:03 /etc/postfix/access
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">12288</span> Oct <span class="token number">17</span> <span class="token number">23</span>:04 /etc/postfix/access.db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用这个数据库文件的好处是，修改以后不必重启 Postfix。</p>
<h1 id="设定邮件别名"><a class="markdownIt-Anchor" href="#设定邮件别名"></a> 设定邮件别名</h1>
<p>当一些系统账号运行的服务出现问题时，会将错误通过邮件发送给 root 用户，这里面就使用了 aliases 邮件别名配置文件来处理。</p>
<p>查看文件的内容，可以看到系统账号都对应到实体的 root 账号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/aliases
bin:            root
daemon:         root
adm:            root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以设置普通账号 hxz 来接收 root 的邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/aliases
root:           root,hxz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以设置一个用户组别名 ass 来代替 user01，user02，<code>hxz@ass.com</code>，这样发信时可通过发给 ass 来群发邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/aliases
ass:            user01,user02,hxz@ass.com
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postalias hash:/etc/aliases<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>普通用户可以在用户主目录下新建 <code>.forward</code> 文件，来定义转发自己的邮件地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user01@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> .forward
user02
user01@mail.com
<span class="token punctuation">[</span>user01@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">644</span> .forward <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>.forward</code> 文件的权限一定得 644。</p>
<h1 id="邮件队列信息"><a class="markdownIt-Anchor" href="#邮件队列信息"></a> 邮件队列信息</h1>
<p>有时候因为网络问题，导致某些邮件无法送出而被暂存在队列中。可以通过 <code>postquere -p</code> 命令来查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user01@server2 ~<span class="token punctuation">]</span>$ postquere <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要查看邮件内容可以使用 <code>postcat</code> 命令来读取：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postcat 5CF324312<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要立即将队列中得邮件发出去可以使用 <code>postfix flush</code> 命令操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ postfix flush<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="收件设置"><a class="markdownIt-Anchor" href="#收件设置"></a> 收件设置</h1>
<p>CentOS 中使用 dovecot 来实现 MRA 的相关通信协议。使用 yum 安装后修改配置文件 <code>/etc/dovecot/dovecot.conf</code>，设置只使用 POP3/IMAP 协议：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> dovecot
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/dovecot/dovecot.conf 
protocols <span class="token operator">=</span> imap pop3 
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/dovecot/conf.d/10-ssl.conf 
<span class="token comment">#ssl = required</span>
ssl <span class="token operator">=</span> no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后就可以启动 dovecot 了。检查下 POP3 端口 110 和 IMAP 端口 143：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> dovecot
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span><span class="token function">grep</span> dovecot
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:110             <span class="token number">0.0</span>.0.0:*         LISTEN      <span class="token number">122037</span>/dovecot 
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:143             <span class="token number">0.0</span>.0.0:*         LISTEN      <span class="token number">122037</span>/dovecot <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="防火墙设置"><a class="markdownIt-Anchor" href="#防火墙设置"></a> 防火墙设置</h1>
<p>整个 MTA 主要通过 SMTP 端口进行邮件发送，因此放行 25 端口就可以：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">25</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果启动了 dovecot，还要将 110 和 143 端口放行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">110</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">143</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="邮件信箱"><a class="markdownIt-Anchor" href="#邮件信箱"></a> 邮件信箱</h1>
<p>每个账号都有一个 mailbox，用来收取信件。可以使用 <code>mail</code> 命令来收发信件。</p>
<p>发送邮件的命令格式：<code>mail 用户名 -s &quot;邮件标题&quot;</code></p>
<p>例如给 user1 发送一份邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mail user1 <span class="token parameter variable">-s</span> <span class="token string">"Hello user1"</span>
Subject: <span class="token number">1</span>
Hello dear, 
        welcome to my world.
see u~    
<span class="token builtin class-name">.</span>
EOT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>邮件内容输入完毕，最后一行以 <code>.</code> 结束按回车，信件便发出去了。也可以用重定向 <code>&lt; 文件名</code> 来将信件内容传给 mail。</p>
<p>收取信件直接输入 <code>mail</code> 进入邮件程序，会有交互式界面。输入 <code>h</code> 查看所有标题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 ~<span class="token punctuation">]</span>$ mail
Heirloom Mail version <span class="token number">12.5</span> <span class="token number">7</span>/5/10.  Type ? <span class="token keyword">for</span> help.
<span class="token string">"/var/spool/mail/user1"</span><span class="token builtin class-name">:</span> <span class="token number">1</span> message <span class="token number">1</span> new
<span class="token operator">></span>N  <span class="token number">1</span> root                  Mon Sep <span class="token number">13</span> <span class="token number">12</span>:05  <span class="token number">21</span>/684   <span class="token string">"1"</span>
<span class="token operator">&amp;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入 <code>?</code> 可以查询所有命令，符号 <code>&gt;</code> 指向的是当前邮件位置，可以按回车查看邮件内容，也可输入对应邮件编号来查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&amp;</span> <span class="token number">1</span>
Message  <span class="token number">1</span>:
From root@101c7.localdomain  Mon Sep <span class="token number">13</span> <span class="token number">12</span>:05:27 <span class="token number">2021</span>
Return-Path: <span class="token operator">&lt;</span>root@101c7.localdomain<span class="token operator">></span>
X-Original-To: user1
Delivered-To: user1@101c7.localdomain
Date: Mon, <span class="token number">13</span> Sep <span class="token number">2021</span> <span class="token number">12</span>:05:27 <span class="token parameter variable">-0400</span>
To: user1@101c7.localdomain, Hello@101c7.localdomain,
        -s@101c7.localdomain, user1@101c7.localdomain
Subject: <span class="token number">1</span>
User-Agent: Heirloom mailx <span class="token number">12.5</span> <span class="token number">7</span>/5/10
Content-Type: text/plain<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>us-ascii
From: root@101c7.localdomain <span class="token punctuation">(</span>root<span class="token punctuation">)</span>
Status: R

Hello dear,
        welcome to my world.
see u~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入 <code>R</code> 来回复 <code>&gt;</code> 指向的邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&amp;</span> R
To: root@server1.localdomain
Subject: Re: Cron <span class="token operator">&lt;</span>root@server<span class="token operator"><span class="token file-descriptor important">1</span>></span> /usr/bin/yum <span class="token parameter variable">-y</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输入 <code>d 编号</code> 来删除对应邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&amp;</span> d <span class="token number">3</span> <span class="token number">4</span>
<span class="token operator">&amp;</span> h
 A  <span class="token number">1</span> <span class="token punctuation">(</span>Cron Daemon<span class="token punctuation">)</span>         Sat Sep <span class="token number">25</span> 02:15  <span class="token number">34</span>/1134  <span class="token string">"Cron &lt;root@server1> /usr/bin/yum -y update"</span>
 A  <span class="token number">2</span> <span class="token punctuation">(</span>Cron Daemon<span class="token punctuation">)</span>         Sun Sep <span class="token number">26</span> 02:16  <span class="token number">38</span>/1287  <span class="token string">"Cron &lt;root@server1> /usr/bin/yum -y update"</span>
<span class="token operator">></span>U  <span class="token number">5</span> <span class="token punctuation">(</span>Cron Daemon<span class="token punctuation">)</span>         Wed Sep <span class="token number">29</span> 02:16  <span class="token number">37</span>/1275  <span class="token string">"Cron &lt;root@server1> /usr/bin/yum -y update"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>储存邮件到文件输入 <code>s 编号 文件名</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&amp;</span> s <span class="token number">1</span> first
<span class="token string">"first"</span> <span class="token punctuation">[</span>New file<span class="token punctuation">]</span> <span class="token number">34</span>/1134<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>输入 <code>q</code> 退出，刚才读过的信件会存入收件箱 <code>~/mbox</code> 中。</p>
<h1 id="邮件客户端"><a class="markdownIt-Anchor" href="#邮件客户端"></a> 邮件客户端</h1>
<p>在命令行下除了 <code>mail</code> 命令，还可以使用 mutt 软件来收发邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">mutt</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>发送邮件使用的命令格式为：</p>
<p><code>mutt [-a 附件] [-i 邮件内容文件] [-b 秘密副本地址] [-c 一般副本地址] [-s 邮件标题] 收件地址</code></p>
<p>例如编写一封信寄给 <code>assassing@ass.com</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mutt</span> <span class="token parameter variable">-s</span> <span class="token string">'mutt mail'</span> assassing@ass.com
To: assassing@ass.com
Subject: <span class="token function">mutt</span> mail   
a mail from mutt<span class="token operator">!</span>
y:Send  q:Abort  t:To  c:CC  s:Subj  a:Attach <span class="token function">file</span>  d:Descrip  ?:Help                                                              
    From: root <span class="token operator">&lt;</span>root@server<span class="token operator"><span class="token file-descriptor important">2</span>></span>
      To: assassing@ass.com
      Cc:
     Bcc:
 Subject: <span class="token function">mutt</span> mail
Reply-To:
     Fcc: ~/sent
Security: None


-- Attachments                                                                                                                     
- I     <span class="token number">1</span> /var/tmp/mutt-server2-0-123262-123667749   <span class="token punctuation">[</span>text/plain, 7bit, us-ascii, <span class="token number">0</span>.1K<span class="token punctuation">]</span> 


-- Mutt: Compose  <span class="token punctuation">[</span>Approx. msg size: <span class="token number">0</span>.1K   Atts: <span class="token number">1</span><span class="token punctuation">]</span>-----------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>mutt</code> 收取外部邮件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mutt</span> <span class="token parameter variable">-f</span> imaps://mail.ass.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>vsftpd 服务</title>
    <url>/1853961938/</url>
    <content><![CDATA[<h1 id="ftp-协议"><a class="markdownIt-Anchor" href="#ftp-协议"></a> FTP 协议</h1>
<p>文件传输协议（FTP，File Transfer Protocol）主要功能是在服务器与客户端之间进行文件传输。它使用明文传输方式，所以建议只在局域网内使用。</p>
<p>FTP 服务器提供以下功能：</p>
<ul>
<li>身份验证：默认情况下分为三种用户：用户 <code>user</code>，访客 <code>guest</code> 和匿名用户 <code>anonymous</code>。</li>
<li>日志记录：FTP 可以利用 <code>syslogd</code> 来进行数据记录，存放于 <code>/var/log/</code> 下面。</li>
<li>限制用户活动目录：<code>change root</code> 简称 <code>chroot</code>，将用户的工作范围局限在用户主目录下。</li>
</ul>
<h1 id="ftp-工作流程"><a class="markdownIt-Anchor" href="#ftp-工作流程"></a> FTP 工作流程</h1>
<p>FTP 协议使用 TCP 数据包协议，并建立两个连接：命令通道与数据流通道（<code>ftp-data</code>）。</p>
<h2 id="主动模式"><a class="markdownIt-Anchor" href="#主动模式"></a> 主动模式</h2>
<p>FTP 默认的主动模式（Active）连接流程如下：</p>
<ol>
<li>客户端随机选取一个大于 1024 的端口来与服务端的 21 端口实现连接。实现连接后客户端可以通过这个连接来对服务器执行命令。</li>
<li>当客户端需要传输数据时，会随机启用一个端口，并告诉服务端使用主动模式，通过此端口传输（通过 21 端口）。</li>
<li>服务端接收到消息后，会主动使用 20 端口与客户端告之的端口建立连接，传输数据。</li>
</ol>
<p>在防火墙后面的客户端要想连接服务端下载数据时，会因为防火墙端口被拒绝而收不到回应，造成无法建立数据流通道。可以使用 <code>modprobe</code> 命令来加载 <code>ip_conntrack_ftp</code> 和 <code>ip_nat_ftp</code> 等模块，来让 <code>iptables</code> 分析目标是 21 端口的连接信息，由此放行数据传输端口。</p>
<h2 id="被动模式"><a class="markdownIt-Anchor" href="#被动模式"></a> 被动模式</h2>
<p>FTP 的被动模式（Passive）连接流程如下：</p>
<ol>
<li>客户端同样使用大于 1024 号的随机端口与服务端 21 端口建立连接。</li>
<li>当客户端要传输数据时，只发送 <code>PASV</code> 的被动式连接请求，等待服务器回应。</li>
<li>服务端收到请求后，会启动一个随机的被动监听端口，并告知客户端使用此端口来传输数据。</li>
<li>客户端使用大于 1024 号的随机端口与主机被动端口连接，传输数据。</li>
</ol>
<h1 id="用户身份"><a class="markdownIt-Anchor" href="#用户身份"></a> 用户身份</h1>
<p>FTP 提供的三种身份适用情况如下。</p>
<h2 id="用户"><a class="markdownIt-Anchor" href="#用户"></a> 用户</h2>
<p>此用户为服务器中存在的实体用户，以实体用户作为 FTP 登录者身份时，系统默认没有针对实体用户来进行限制，用户可以针对整个文件系统进行任何有权限的操作。</p>
<p>因此建议实体用户模式使用 <code>sftp</code> 服务来代替。</p>
<h2 id="访客"><a class="markdownIt-Anchor" href="#访客"></a> 访客</h2>
<p>通常见于网页空间服务，用户需要管理自己的网页空间，但不需要实体用户的权限。</p>
<p>在服务器的设置中，需要针对不同访客设置不同用户主目录，并且用户主目录与用户的权限设置需要符合。此外还有诸多如容量、时间、命令等需要限制。</p>
<h2 id="匿名用户"><a class="markdownIt-Anchor" href="#匿名用户"></a> 匿名用户</h2>
<p>匿名用户可以被所有人使用，所以开放匿名登录时需要限制上传和最大连接数量。</p>
<h1 id="vsftpd-服务器"><a class="markdownIt-Anchor" href="#vsftpd-服务器"></a> vsftpd 服务器</h1>
<p><code>vsftpd</code> 的全名是 Very Secure FTP，它针对操作系统的程序权限（privilege）来设计，具有以下特点：</p>
<ul>
<li><code>vsftpd</code> 服务的启动者身份为一般用户，对系统的权限较低。此外 <code>vsftpd</code> 利用 <code>chroot</code> 来更换根目录，使得系统工具不会被 <code>vsftpd</code> 服务所误用。</li>
<li>任何需要具有较高执行权限的 <code>vsftpd</code> 命令均由一个特殊的上层程序控制，此上层程序享有的权限已被限制得很低，并且确保不会影响到系统。</li>
<li>绝大部分 FTP 命令都已被整合到 <code>vsftpd</code> 主程序中了，不需要再调用外部命令。</li>
<li>所有客户端想使用上层程序提供的较高执行权限的 <code>vsftpd</code> 命令（例如 <code>chown</code>，<code>login</code>），均被视作不可信任的要求处理，必须经过身份确认。</li>
</ul>
<p>使用 <code>yum</code> 来安装 <code>vsftpd</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 cgi-bin<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> vsftpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>和 <code>vsftpd</code> 配置有关的文件有：</p>
<ul>
<li>
<p><code>/etc/vsftpd/vsftpd.conf</code></p>
<p><code>vsftpd</code> 主要配置文件。以参数 = 设置值来设置，等号 = 两边不能有空格。</p>
</li>
<li>
<p><code>/etc/pam.d/vsftpd</code></p>
<p><code>vsftpd</code> 使用 PAM 模块时的相关配置文件，主要可设置拒绝用户文件 <code>/etc/vsftpd/ftpusers</code> 路径。</p>
</li>
<li>
<p><code>/etc/vsftpd/ftpusers</code></p>
<p>由 PAM 模块指定的拒绝用户列表记录文件，只需要一行一个记录拒绝用户账号即可。默认已经填入了系统账号。</p>
</li>
<li>
<p><code>/etc/vsftpd/user_list</code></p>
<p><code>vsftpd</code> 提供的访问控制，由 <code>userlist_enable</code> 和 <code>userlist_deny</code> 的设置控制。如 <code>userlist_deny=NO</code> 为用户白名单。</p>
</li>
<li>
<p><code>/etc/vsftpd/chroot_list</code></p>
<p>此文件需手动建立，作用是将用户 <code>chroot</code> 建立在用户主目录下。由 <code>chroot_list_enable</code> 和 <code>chroot_list_file</code> 设置启用。</p>
</li>
<li>
<p><code>/var/ftp</code></p>
<p>默认匿名用户登录的根目录。与 <code>ftp</code> 账号的用户主目录有关。</p>
</li>
</ul>
<h1 id="vsftpd-配置"><a class="markdownIt-Anchor" href="#vsftpd-配置"></a> vsftpd 配置</h1>
<p>配置文件 <code>/etc/vsftpd/vsftpd.conf</code> 中一些常用的选项如下：</p>
<ul>
<li>
<p><code>connect_from_port_20=YES</code></p>
<p>主动模式使用的数据传输端口。</p>
</li>
<li>
<p><code>listen_port=21</code></p>
<p>命令通道端口。如果使用非正规端口号，需要同时开启 <code>listen=YES</code> 来以 stand alone 的方式启动。</p>
</li>
<li>
<p><code>listen=YES</code></p>
<p>默认为 NO，设置为 YES 表示以 stand alone 的方式来启动。</p>
</li>
<li>
<p><code>pasv_enable=YES</code></p>
<p>设置传输使用被动模式。</p>
</li>
<li>
<p><code>write_enable=YES</code></p>
<p>允许用户上传。</p>
</li>
<li>
<p><code>max_clients=0</code></p>
<p>设置同时最多连接客户端数量。</p>
</li>
<li>
<p><code>max_per_ip=0</code></p>
<p>设置同一个 IP 同时最多允许的连接数。</p>
</li>
<li>
<p><code>pasv_min_port=0, pasv_max_port=0</code></p>
<p>设置被动模式下可使用的传输端口范围。</p>
</li>
<li>
<p><code>guest_enable=YES</code></p>
<p>设置为 YES 时，任何实体账号都会被假设成访客。访客在 <code>vsftpd</code> 中默认取得 <code>ftp</code> 用户的权限。</p>
</li>
<li>
<p><code>local_enable=YES</code></p>
<p>设置为 YES 时，实体账号才可以登录 <code>vsftpd</code> 服务器。</p>
</li>
<li>
<p><code>chroot_local_user=YES</code></p>
<p>设置是否将用户限制在主目录内。</p>
</li>
<li>
<p><code>anonymous_enable=YES</code></p>
<p>是否允许匿名用户登录，默认为 YES。</p>
</li>
</ul>
<h1 id="vsftpd-测试"><a class="markdownIt-Anchor" href="#vsftpd-测试"></a> vsftpd 测试</h1>
<p><code>vsftpd</code> 启动使用 <code>systemctl</code> 控制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 cgi-bin<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> vsftpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>新建一个账号，并测试 <code>ftp</code> 连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 cgi-bin<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-p</span> user02 user02
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ftp</span> <span class="token number">192.168</span>.2.254
Connected to <span class="token number">192.168</span>.2.254 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.254<span class="token punctuation">)</span>.
<span class="token number">220</span> <span class="token punctuation">(</span>vsFTPd <span class="token number">3.0</span>.2<span class="token punctuation">)</span>
Name <span class="token punctuation">(</span><span class="token number">192.168</span>.2.254:root<span class="token punctuation">)</span>: user02
<span class="token number">331</span> Please specify the password.
Password:
<span class="token number">230</span> Login successful.
Remote system <span class="token builtin class-name">type</span> is UNIX.
Using binary mode to transfer files.
ftp<span class="token operator">></span> <span class="token builtin class-name">pwd</span>
<span class="token number">257</span> <span class="token string">"/home/user02"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将用户 <code>user02</code> 添加进 <code>/etc/vsftpd/ftpusers</code> 后再次测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /etc/vsftpd/
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/vsftpd/ftpusers
user02
<span class="token punctuation">[</span>root@server2 home<span class="token punctuation">]</span>$ systemctl reload sshd
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ftp</span> <span class="token number">192.168</span>.2.254
Connected to <span class="token number">192.168</span>.2.254 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.254<span class="token punctuation">)</span>.
<span class="token number">220</span> <span class="token punctuation">(</span>vsFTPd <span class="token number">3.0</span>.2<span class="token punctuation">)</span>
Name <span class="token punctuation">(</span><span class="token number">192.168</span>.2.254:root<span class="token punctuation">)</span>: user02
<span class="token number">331</span> Please specify the password.
Password:
<span class="token number">530</span> Login incorrect.
Login failed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>httpd 服务</title>
    <url>/2334204318/</url>
    <content><![CDATA[<h1 id="url-网址"><a class="markdownIt-Anchor" href="#url-网址"></a> URL 网址</h1>
<p>浏览器中使用网址（URL，Uniform Resource Locator）来定位服务器中数据存放的位置并访问。URL 格式如下：<code>&lt;协议&gt;://&lt;主机地址或主机名&gt;[:port]/&lt;目录资源&gt;</code>。以斜线作为分段，各段解释如下：</p>
<ul>
<li>
<p><strong>协议</strong></p>
<p>浏览器支持比较常见的协议有 http、https、ftp、telnet 等，还有不太常见的 news、gopher 等。如果服务器启用的是非标准端口，必须在主机地址后面写明。</p>
</li>
<li>
<p><strong>主机地址或主机名</strong></p>
<p>主机地址是服务器的 IP 地址，主机名是域名，通过 DNS 来解析成 IP。</p>
</li>
<li>
<p><strong>目录资源</strong></p>
<p>在 Apache 中默认将 html 文件存放在 <code>/var/www/html/</code> 目录内。</p>
</li>
</ul>
<h1 id="传输数据方法"><a class="markdownIt-Anchor" href="#传输数据方法"></a> 传输数据方法</h1>
<p>在 http 的服务端和客户端之间数据传递的基本方法有下面几种：</p>
<ul>
<li>
<p><strong>GET</strong></p>
<p>最常用的方法，浏览器直接向服务器请求网址上面的资源。使用 GET 方式可以直接在 URL 中输入变量。</p>
</li>
<li>
<p><strong>POST</strong></p>
<p>客户端向服务端发送请求的方法。</p>
</li>
<li>
<p><strong>HEAD</strong></p>
<p>服务端响应给客户端的一些数据头文件。</p>
</li>
<li>
<p><strong>OPTIONS</strong></p>
<p>服务端响应给客户端一些允许的功能与方法。</p>
</li>
<li>
<p><strong>DELETE</strong></p>
<p>删除某些资源的方法。</p>
</li>
</ul>
<h1 id="ssl-证书"><a class="markdownIt-Anchor" href="#ssl-证书"></a> SSL 证书</h1>
<p>SSL（Secure Socket Layer）是 HTTPS 使用的加密方式之一，和 SSH 一样使用非对称的密钥对，用对方的公钥加密数据后传输，以此保证数据在传输过程中的安全。</p>
<p>为了加强网络安全，提高网站信任等级，网站可以把生成的密钥通过第三方公证单位（CA，Certificate Authorities）注册，客户端的浏览器访问时可以自动比对 CA 单位注册时信息，确认证书是否正确有效。</p>
<h1 id="lamp-服务器安装"><a class="markdownIt-Anchor" href="#lamp-服务器安装"></a> LAMP 服务器安装</h1>
<p>由于 Linux 上面 Apache 仅能提供最基本的静态网站支持，要想实现动态网站需要 PHP 和 MySQL 的支持。整个 LAMP 环境总共需要安装以下软件与模块：</p>
<ul>
<li>httpd：提供 Apache 主程序。</li>
<li>mysql：MySQL 客户端程序。</li>
<li>mysql-server：MySQL 服务端程序。</li>
<li>php：PHP 主程序，包含给 Apache 使用的模块。</li>
<li>php-devel：PHP 开发工具，与 PHP 外挂的加速软件有关。</li>
<li>php-mysql：提供 PHP 程序读取 MySQL 数据库的模块。</li>
</ul>
<p>整合安装如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> httpd mysql mysql-server php php-mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="相关配置目录"><a class="markdownIt-Anchor" href="#相关配置目录"></a> 相关配置目录</h1>
<p>三个软件主要的配置文件路径。</p>
<h2 id="apache"><a class="markdownIt-Anchor" href="#apache"></a> Apache</h2>
<p>在 Apache 中主要的配置文件或目录如下：</p>
<ul>
<li>
<p><strong>/etc/httpd/conf/httpd.conf</strong></p>
<p>httpd 最主要的配置文件，有时也会被拆成数个小文件分别管理不同参数。</p>
</li>
<li>
<p><strong>/etc/httpd/conf.d/*.conf</strong></p>
<p>可以将自定义额外参数单独写成配置文件，放到 <code>/etc/httpd/conf.d</code> 目录下。在 httpd 启动时，这个文件内容就会被读入主要配置文件当中。</p>
</li>
<li>
<p><strong>/usr/lib64/httpd/modules/，/etc/httpd/modules/</strong></p>
<p>Apache 支持很多外挂模块，PHP 和 SSL 都是 Apache 外挂的一种。所有要使用的模块文件默认放到以上目录中。</p>
</li>
<li>
<p><strong>/var/www/html/</strong></p>
<p>默认存放 html 数据文件位置。</p>
</li>
<li>
<p><strong>/var/www/error/</strong></p>
<p>当服务器设置错误或客户端请求的数据错误时，在浏览器上显示此目录下对应的错误页面。</p>
</li>
<li>
<p><strong>/var/www/icons/</strong></p>
<p>存放一些 Apache 提供的小 icon 文件。</p>
</li>
<li>
<p><strong>/var/www/cgi-bin/</strong></p>
<p>给一些可执行的 CGI 程序放置的目录。</p>
</li>
<li>
<p><strong>/var/log/httpd/</strong></p>
<p>默认的 Apache 日志文件存放目录，需要注意用量大小。</p>
</li>
</ul>
<h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h2>
<p>MySQL 相关的配置文件和目录有：</p>
<ul>
<li>
<p><strong>/etc/my.cnf</strong></p>
<p>MySQL 的配置文件，可以对 MySQL 数据库进行优化或指定额外的运行参数。</p>
</li>
<li>
<p><strong>/var/lib/mysql/</strong></p>
<p>MySQL 数据库文件存放位置。</p>
</li>
</ul>
<h2 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h2>
<p>在 LAMP 环境中和 PHP 有关的配置和目录有：</p>
<ul>
<li>
<p><strong>/etc/httpd/conf.d/php.conf</strong></p>
<p>PHP 设置参数存放此文件中，在 Apache 重新启动时会被读取，因此不需要手动将 php 模块写入 httpd.conf 中。</p>
</li>
<li>
<p><strong>/etc/php.ini</strong></p>
<p>PHP 的主要配置文件，包括是否允许用户上传，能否允许某些低安全性的标志等。</p>
</li>
<li>
<p><strong>/usr/lib64/httpd/modules/libphp5.so</strong></p>
<p>PHP 提供给 Apache 使用的模块。</p>
</li>
<li>
<p><strong>/etc/php.d/mysql.ini，/usr/lib64/php/modules/mysql.so</strong></p>
<p>PHP 操作 MySQL 使用的模块。</p>
</li>
<li>
<p><strong>/usr/bin/phpize，/usr/include/php/</strong></p>
<p>安装 PHP 加速器所需文件。</p>
</li>
</ul>
<h1 id="apache-配置文件"><a class="markdownIt-Anchor" href="#apache-配置文件"></a> Apache 配置文件</h1>
<p>Apache 配置文件 <code>/etc/httpd/conf/httpd.conf</code> 中分以下几个部分。</p>
<h2 id="服务器环境设置"><a class="markdownIt-Anchor" href="#服务器环境设置"></a> 服务器环境设置</h2>
<p>针对服务器环境设置方面，包括主机名，服务器配置文件顶层目录等：</p>
<ul>
<li>
<p><strong>ServerRoot “/etc/httpd”</strong></p>
<p>服务器设置的最顶层目录，包括日志，模块等数据都放于此处（链接文件）。</p>
</li>
<li>
<p><strong>ServerTokens OS</strong></p>
<p>告知客户端服务器的版本和操作系统，一般不需要设置。</p>
</li>
<li>
<p><strong>PidFile run/httpd.pid</strong></p>
<p>设置 PID 文件路径。</p>
</li>
<li>
<p><strong>Timeout 60</strong></p>
<p>发送或接受数据时的等待超时时间，一般不需要设置。</p>
</li>
<li>
<p><strong>KeepAlive On</strong></p>
<p>是否允许持续性的连接，也就是一个 TCP 连接可以有多个文件传送请求，默认为 Off。</p>
</li>
<li>
<p><strong>MaxKeepAliveRequests 500</strong></p>
<p>设置能够传输的最大传输数量，0 代表不限制。</p>
</li>
<li>
<p><strong>KeepAliveTimeout 15</strong></p>
<p>在设置保持连接的条件下，连接在最后一次传输后等待延迟的秒数。</p>
</li>
<li>
<p><strong>Listen 80</strong></p>
<p>默认监听 80 端口，也可以修改绑定网口或端口。</p>
</li>
<li>
<p><strong>User apache，Group apache</strong></p>
<p>设置 httpd 进程启动的属主和属组。</p>
</li>
<li>
<p><strong>ServerAdmin root@localhost</strong></p>
<p>设置管理员邮箱。</p>
</li>
<li>
<p><strong>ServerName <a href="http://www1.example.com:80">www1.example.com:80</a></strong></p>
<p>设置主机名。</p>
</li>
</ul>
<h2 id="目录相关设置"><a class="markdownIt-Anchor" href="#目录相关设置"></a> 目录相关设置</h2>
<p>默认网页存放目录 <code>/var/www/html</code> 由 DocumentRoot 设置。需要注意 SELinux 相关规则和类型的正确性。</p>
<p>首页文件名由 <code>&lt;IfModule dir_module&gt;</code> 内的 DirectoryIndex 设置。文件读取由文件名参数顺序决定。</p>
<p>和目录有关的设置写在 <code>&lt;Directory&gt;</code> 段落内，主要有下面一些设置：</p>
<ul>
<li>
<p><strong>Options</strong>（目录参数）</p>
<p>此设置值表示这个目录内能让 Apache 进行的操作，也就是震度 Apache 的程序权限设置。主要参数有：</p>
<ul>
<li>Indexes: 如果找不到首页文件，便显示整个目录下的文件名。</li>
<li>FollowSymLinks: 让连接文件可以生效。</li>
<li>ExecCGI: 让此目录具有执行 CGI 程序的权限。</li>
<li>Includes: 让一些 Server-Side Include 程序可以运行。</li>
<li>MultiViews: 与多语言支持有关。</li>
</ul>
</li>
<li>
<p><strong>AllowOverride</strong>（允许覆盖参数）</p>
<p>表示是否允许额外配置文件 .htaccess 的某些参数覆盖。常见参数有：</p>
<ul>
<li>ALL: 所有权限均可被覆盖。</li>
<li>AuthConfig: 仅有网页认证账号可覆盖。</li>
<li>Indexes: 仅允许 Indexes 方面的覆盖。</li>
<li>Limits: 允许用户利用 Allow，Deny 与 Order 管理可浏览的权限。</li>
<li>None: 不可覆盖。</li>
</ul>
</li>
</ul>
<h2 id="php-模块参数修改"><a class="markdownIt-Anchor" href="#php-模块参数修改"></a> PHP 模块参数修改</h2>
<p>PHP 模块配置文件位于 <code>/etc/httpd/conf.d/php.conf</code>，其内容不需要有任何修改，主要修改的是 PHP 配置文件 <code>/etc/php.ini</code>：</p>
<ul>
<li>
<p>log_errors = On, ignore_repeated_errors = Off, ignore_repeated_source = Off</p>
<p>设置记录日志，忽略重复错误记录默认为 Off，可以设置为 On。</p>
</li>
<li>
<p>display_errors = Off, display_startup_errors = Off</p>
<p>设置出现错误时，是否在浏览器上显示相关错误信息。debug 时可以设置为 On。</p>
</li>
<li>
<p>post_max_size = 8M, file_uploads = On, upload_max_filesize = 2M, memory_limit = 128M</p>
<p>设置 PHP 程序上传文件大小限制和内存占用数值。</p>
</li>
</ul>
<h1 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h1>
<p>使用 <code>systemctl</code> 直接启动 <code>httpd</code>，或者可以用 <code>apache</code> 自带的 <code>apachectl</code> 命令操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> httpd
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ apachectl status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>测试 PHP 模块是否驱动，可以建立一个 <code>phpinfo.php</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">'&lt;?php phpinfo (); ?>'</span> <span class="token operator">></span> /var/www/html/phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在浏览器中使用 <code>http://192.168.2.254/phpinfo.php</code> 地址访问，可以看到 PHP 版本等信息。</p>
<p><code>MySQL</code> 需要手动启动，使用 <code>mysql</code> 命令测试连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl start mysqld
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ mysqladmin <span class="token parameter variable">-u</span> root pass <span class="token string">'mypass'</span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> mypass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="防火墙设置"><a class="markdownIt-Anchor" href="#防火墙设置"></a> 防火墙设置</h1>
<p><code>iptables</code> 放行 80 和 443 端口设置如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">443</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>设置 <code>SELinux</code> 的放行规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ setsebool <span class="token parameter variable">-P</span> <span class="token assign-left variable">httpd_can_network_connect</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>新建一个网页文件后需要恢复 <code>SELinux</code> 类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"HOME"</span> <span class="token operator">></span> index.html
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mv</span> index.html /var/www/html
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span> /var/www/html/
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 index.html
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 phpinfo.php
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ restorecon <span class="token parameter variable">-Rv</span> /var/www/html/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="基本身份认证"><a class="markdownIt-Anchor" href="#基本身份认证"></a> 基本身份认证</h1>
<p><code>Apache</code> 可以通过目录下的 <code>.htaccess</code> 文件来设置保护目录。首先建立目录和文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /var/www/html/pro
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">'PROTECT!'</span> <span class="token operator">></span> /var/www/html/pro/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在主配置文件 <code>/etc/httpd/conf/httpd.conf</code> 中，增加一段配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/httpd/conf/httpd.conf
<span class="token operator">&lt;</span>Directory <span class="token string">"/var/www/html/pro"</span><span class="token operator">></span>
    AllowOverride AuthConfig
    Require all granted
<span class="token operator">&lt;</span>/Directory<span class="token operator">></span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ apachectl restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/var/www/html/pro</code> 目录下建立 <code>.htaccess</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 httpd<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/www/html/pro/.htaccess
AuthName        <span class="token string">"protect test"</span>
Authtype        Basic
AuthUserFile    /var/www/apache.passwd
require user user11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件配置选项说明如下：</p>
<ul>
<li><code>AuthName</code>：出现在账号密码提示对话框中的内容。</li>
<li><code>AuthType</code>：认证类型。</li>
<li><code>AuthUserFile</code>：账号密码配置文件。</li>
<li><code>require</code>：设置通行账号。可以设为 <code>valid-user</code>，即所有在 <code>apache.passwd</code> 内定义的用户都可以访问。</li>
</ul>
<p>下面是建立账号密码文件。使用 <code>htpasswd</code> 命令加入账号 <code>user11</code> 和 <code>user12</code>，密码为 <code>passwd</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ htpasswd <span class="token parameter variable">-c</span> /var/www/apache.passwd user11
New password: 
Re-type new password: 
Adding password <span class="token keyword">for</span> user user11
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ htpasswd /var/www/apache.passwd user12
New password: 
Re-type new password: 
Adding password <span class="token keyword">for</span> user user12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在浏览器中输入地址 <code>http://192.168.2.254/pro/</code> 测试。</p>
<h1 id="虚拟主机设置"><a class="markdownIt-Anchor" href="#虚拟主机设置"></a> 虚拟主机设置</h1>
<p>虚拟主机就是让多个主机名对应到不同的主网页目录（<code>DocumentRoot</code> 参数）。例如 <code>ftp.hxz.ass</code> 和 <code>www.hxz.ass</code> 都指向 <code>192.168.2.254</code>，需要在 <code>DNS</code> 服务商网页设置好对应关系。</p>
<p>这里新建一个 <code>ftp</code> 目录，来对应 <code>ftp.hxz.ass</code> 域名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /var/www/ftp
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"FTPftp"</span> <span class="token operator">></span> /var/www/ftp/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>配置对应的虚拟主机设置文件，然后重启 <code>httpd</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/httpd/conf.d/virtual.conf
<span class="token operator">&lt;</span>Directory <span class="token string">"/var/www/ftp"</span><span class="token operator">></span>
    AllowOverride None
    Require all granted
<span class="token operator">&lt;</span>/Directory<span class="token operator">></span>

<span class="token operator">&lt;</span>VirtualHost *:8<span class="token operator"><span class="token file-descriptor important">0</span>></span>
    ServerName www.hxz.ass
    DocumentRoot /var/www/html
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">></span>
<span class="token operator">&lt;</span>VirtualHost *:8<span class="token operator"><span class="token file-descriptor important">0</span>></span>
    ServerName ftp.hxz.ass
    DocumentRoot /var/www/ftp
    CustomLog /var/log/httpd/ftp.acess_log combined
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">></span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面使用 <code>CustomLog</code> 来指定写入日志的路径，这样可以更方便管理。</p>
<p>在客户端测试一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> www.hxz.ass
<span class="token environment constant">HOME</span>
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">wget</span> ftp.hxz.ass
--2021-10-16 <span class="token number">23</span>:22:07--  http://ftp.hxz.ass/
Resolving ftp.hxz.ass <span class="token punctuation">(</span>ftp.hxz.ass<span class="token punctuation">)</span><span class="token punctuation">..</span>. <span class="token number">10.1</span>.1.1
Connecting to ftp.hxz.ass <span class="token punctuation">(</span>ftp.hxz.ass<span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">10.1</span>.1.1<span class="token operator">|</span>:80<span class="token punctuation">..</span>. connected.
HTTP request sent, awaiting response<span class="token punctuation">..</span>. <span class="token number">200</span> OK
Length: <span class="token number">7</span> <span class="token punctuation">[</span>text/html<span class="token punctuation">]</span>
Saving to: <span class="token string">'index.html'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="服务器测试"><a class="markdownIt-Anchor" href="#服务器测试"></a> 服务器测试</h1>
<p><code>Apache</code> 提供了一个叫做 <code>ab</code> 的程序来测试网站效率。例如指定 110 个同时连接，200 个每连接线程测试 <code>phpinfo.php</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ab <span class="token parameter variable">-dkS</span> <span class="token parameter variable">-c110</span> <span class="token parameter variable">-n200</span> http://127.0.0.1/phpinfo.php
This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1430300</span> $<span class="token operator">></span>
Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking <span class="token number">127.0</span>.0.1 <span class="token punctuation">(</span>be patient<span class="token punctuation">)</span>
Completed <span class="token number">100</span> requests
Completed <span class="token number">200</span> requests
Finished <span class="token number">200</span> requests


Server Software:        Apache/2.4.6
Server Hostname:        <span class="token number">127.0</span>.0.1
Server Port:            <span class="token number">80</span>

Document Path:          /phpinfo.php
Document Length:        <span class="token number">47649</span> bytes

Concurrency Level:      <span class="token number">110</span>
Time taken <span class="token keyword">for</span> tests:   <span class="token number">0.070</span> seconds
Complete requests:      <span class="token number">200</span>
Failed requests:        <span class="token number">17</span>
   <span class="token punctuation">(</span>Connect: <span class="token number">0</span>, Receive: <span class="token number">0</span>, Length: <span class="token number">17</span>, Exceptions: <span class="token number">0</span><span class="token punctuation">)</span>
Write errors:           <span class="token number">0</span>
Keep-Alive requests:    <span class="token number">0</span>
Total transferred:      <span class="token number">9566380</span> bytes
HTML transferred:       <span class="token number">9529780</span> bytes
Requests per second:    <span class="token number">2863.57</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">38.414</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
Time per request:       <span class="token number">0.349</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>
Transfer rate:          <span class="token number">133759.55</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> received

Connection Times <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>
              min   avg   max
Connect:        <span class="token number">0</span>     <span class="token number">3</span>    <span class="token number">8</span>
Processing:    <span class="token number">12</span>    <span class="token number">22</span>   <span class="token number">25</span>
Total:         <span class="token number">12</span>    <span class="token number">25</span>   <span class="token number">33</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="日志分析"><a class="markdownIt-Anchor" href="#日志分析"></a> 日志分析</h1>
<p><code>Apache</code> 日志文件有两个：<code>/var/log/httpd/access_log</code> 和 <code>/var/log/httpd/error_log</code>。</p>
<p>由于日志文件增速很快，所以需要修改 <code>logrotate</code> 的 <code>httpd</code> 配置文件，加入压缩功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/logrotate.d/httpd
/var/log/httpd/*log <span class="token punctuation">&#123;</span>
    missingok
    notifempty
    sharedscripts
    compress
    delaycompress
    postrotate
        /bin/systemctl reload httpd.service <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null <span class="token operator">||</span> <span class="token boolean">true</span>
    endscript
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>日志文件分析软件可以使用 <code>webalizer</code>，软件配置文件位于 <code>/etc/webalizer.conf</code>，生成的图标位于 <code>/var/www/usage</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> webalizer
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/webalizer.conf
OutputDir      /var/www/html/pro/
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ webalizer
Warning: Truncating oversized <span class="token function">hostname</span>
Skipping bad record <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后就可以通过 <code>http://192.168.2.254/pro/</code> 来访问了。</p>
<p>另外一个日志文件分析软件是 <code>awstats</code>，它采用 Perl 语言编写，所以需要 <code>mod_perl</code> 的支持：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> awstats
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/httpd/conf.d/awstats.conf 
<span class="token operator">&lt;</span>Directory <span class="token string">"/usr/share/awstats/wwwroot"</span><span class="token operator">></span>
    Options None
    AllowOverride AuthConfig
    <span class="token operator">&lt;</span>IfModule mod_authz_core.c<span class="token operator">></span>
        <span class="token comment"># Apache 2.4</span>
        Require all granted
    <span class="token operator">&lt;</span>/IfModule<span class="token operator">></span>
    <span class="token operator">&lt;</span>IfModule <span class="token operator">!</span>mod_authz_core.c<span class="token operator">></span>
        <span class="token comment"># Apache 2.2</span>
        Order allow,deny
        Allow from all
        Allow from ::1
    <span class="token operator">&lt;</span>/IfModule<span class="token operator">></span>
<span class="token operator">&lt;</span>/Directory<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件中修改了 CGI 运行方式，网页认证，允许访问的客户端地址。另外还需要配置针对域名的配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> /etc/awstats/awstats.model.conf /etc/awstats/awstats.www.conf
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/awstats/awstats.www.conf
<span class="token assign-left variable">SiteDomain</span><span class="token operator">=</span><span class="token string">"www.hxz.ass"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>测试生成分析资料与访问账号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /usr/share/awstats/wwwroot/cgi-bin/
<span class="token punctuation">[</span>root@server2 cgi-bin<span class="token punctuation">]</span>$ ./awstats.pl now
<span class="token punctuation">[</span>root@server2 wwwroot<span class="token punctuation">]</span>$ <span class="token function">vi</span> /usr/share/awstats/wwwroot/.htaccess
AuthName        <span class="token string">"awstats test"</span>
Authtype        Basic
AuthUserFile    /var/www/apache.passwd
require         valid-user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后浏览器通过 <code>http://192.168.2.254/awstats/awstats.pl?config=www</code> 并输入账号密码之后，就可以访问 <code>awstats</code> 的报表了。</p>
<h1 id="https-加密"><a class="markdownIt-Anchor" href="#https-加密"></a> HTTPS 加密</h1>
<p>加密需要通过 <code>mod_ssl</code> 来进行，可以使用 <code>yum</code> 安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> mod_ssl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装好以后就可以通过浏览器访问 <code>https://192.168.2.254/</code> 了。和 SSL 加密有关的文件如下：</p>
<ul>
<li><code>/etc/httpd/conf.d/ssl.conf</code>：软件 <code>mode_ssl</code> 提供的 <code>Apache</code> 配置文件。</li>
<li><code>/etc/pki/tls/private/localhost.key</code>：系统私钥文件，可以用来制作证书。</li>
<li><code>/etc/pki/tls/certs/localhost.crt</code>：加密过的证书文件。</li>
</ul>
<p>如果要自建证书，例如建立一个名为 <code>hxz.ass</code> 的证书，步骤如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /etc/pki/tls/certs/
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ <span class="token function">make</span> my.key
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ openssl rsa <span class="token parameter variable">-in</span> my.key <span class="token parameter variable">-out</span> hxz.ass.key
Enter pass phrase <span class="token keyword">for</span> my.key:
writing RSA key
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> my.key
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">400</span> hxz.ass.key 
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ <span class="token function">make</span> hxz.ass.crt <span class="token assign-left variable">SERIAL</span><span class="token operator">=</span><span class="token number">20210101</span>
Country Name <span class="token punctuation">(</span><span class="token number">2</span> letter code<span class="token punctuation">)</span> <span class="token punctuation">[</span>XX<span class="token punctuation">]</span>:CN
State or Province Name <span class="token punctuation">(</span>full name<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:CN
Locality Name <span class="token punctuation">(</span>eg, city<span class="token punctuation">)</span> <span class="token punctuation">[</span>Default City<span class="token punctuation">]</span>:CN
Organization Name <span class="token punctuation">(</span>eg, company<span class="token punctuation">)</span> <span class="token punctuation">[</span>Default Company Ltd<span class="token punctuation">]</span>:CN
Organizational Unit Name <span class="token punctuation">(</span>eg, section<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:CN
Common Name <span class="token punctuation">(</span>eg, your name or your server's <span class="token function">hostname</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:www.hxz.ass
Email Address <span class="token punctuation">[</span><span class="token punctuation">]</span>:admin@hxz.ass
<span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ ll hxz*
-rw-------. <span class="token number">1</span> root root <span class="token number">1379</span> Oct <span class="token number">17</span> 04:08 hxz.ass.crt
-r--------. <span class="token number">1</span> root root <span class="token number">1679</span> Oct <span class="token number">17</span> 04:06 hxz.ass.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终生成的证书是 <code>hxz.ass.crt</code>，对应私钥为 <code>hxz.ass.key</code>。其有效期为一年，如果想要十年，可以修改 <code>make</code> 脚本中的内容。</p>
<p>修改 <code>ssl.conf</code> 中证书和私钥的位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 certs<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/httpd/conf.d/ssl.conf 
SSLCertificateFile /etc/pki/tls/certs/hxz.ass.crt
SSLCertificateKeyFile /etc/pki/tls/certs/hxz.ass.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后重启 <code>httpd</code> 服务，并在浏览器中刷新查看新的证书。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>iSCSI 服务</title>
    <url>/3959662341/</url>
    <content><![CDATA[<h1 id="nas-与-san"><a class="markdownIt-Anchor" href="#nas-与-san"></a> NAS 与 SAN</h1>
<p>网络附加储存服务器（NAS，Network Attached Storage）其实就是一台定制好的文件服务器，将 NAS 连上网络，在网络内的主机就能访问 NAS 上的数据。</p>
<p>储存局域网（SAN，Storage Area Networks）可以被视为一个外接式的储存设备，可以为局域网内所有主机提供磁盘而不是文件系统访问。</p>
<h1 id="iscsi-接口"><a class="markdownIt-Anchor" href="#iscsi-接口"></a> iSCSI 接口</h1>
<p>通过 TCP/IP 技术而不是光纤接口来连接 SAN 就是 iSCSI（Internet SCSI）。iSCSI 分为两部分：</p>
<ul>
<li>iSCSI target：储存设备端，存放磁盘或 RAID 的设备。</li>
<li>iSCSI initiator：使用 target 的客户端，通常是服务器。</li>
</ul>
<h1 id="iscsi-服务安装"><a class="markdownIt-Anchor" href="#iscsi-服务安装"></a> iSCSI 服务安装</h1>
<p>iSCSI 所需的软件有下面两个：</p>
<ul>
<li><code>scsi-target-utils</code>：用来将 Linux 系统仿真成为 iSCSI target 的功能。</li>
<li><code>iscsi-initiator-utils</code>：挂载来自 target 的磁盘到本地。</li>
</ul>
<p>直接使用 <code>yum</code> 安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> scsi-target-utils
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> iscsi-initiator-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="iscsi-target-设置"><a class="markdownIt-Anchor" href="#iscsi-target-设置"></a> iSCSI target 设置</h1>
<p>建立一个 100 MB 大小的文件 <code>/srv/iscsi/disk.img</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /srv/iscsi
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/srv/iscsi/disk.img <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">-Rv</span> <span class="token parameter variable">-t</span> tgtd_var_lib_t /srv/iscsi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>建立一个 200 MB 大小实际的分区 <code>/dev/sda3</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> /dev/sda
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ partprobe
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> <span class="token parameter variable">-l</span>
   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        <span class="token number">2048</span>      <span class="token number">411647</span>      <span class="token number">204800</span>   <span class="token number">83</span>  Linux
/dev/sda2          <span class="token number">411648</span>    <span class="token number">33187839</span>    <span class="token number">16388096</span>   8e  Linux LVM
/dev/sda3        <span class="token number">33187840</span>    <span class="token number">33579007</span>      <span class="token number">195584</span>   <span class="token number">83</span>  Linux
/dev/sda4        <span class="token number">33579008</span>    <span class="token number">41943039</span>     <span class="token number">4182016</span>    <span class="token number">5</span>  Extended
/dev/sda5        <span class="token number">33581056</span>    <span class="token number">34195455</span>      <span class="token number">307200</span>   8e  Linux LVM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>建立一个 300 MB 大小的 LV 设备 <code>/dev/centos/iscsi01</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ pvcreate /dev/sda5
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ vgextend centos /dev/sda5
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-L</span> 296M  <span class="token parameter variable">-n</span> iscsi01 centos
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ lvscan
  ACTIVE            <span class="token string">'/dev/centos/home'</span> <span class="token punctuation">[</span><span class="token number">4.88</span> GiB<span class="token punctuation">]</span> inherit
  ACTIVE            <span class="token string">'/dev/centos/iscsi01'</span> <span class="token punctuation">[</span><span class="token number">296.00</span> MiB<span class="token punctuation">]</span> inherit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>iSCSI target 文件名以 iqn（iSCSI Qualified Name）开头，命名格式为 <code>iqn.yyyy-mm.&lt;reversed domain&gt;:id</code>。这里使用名称 <code>iqn.2000-01.server2:mydisk</code>。</p>
<p>每个 target 能够拥有数个磁盘设备，这些磁盘被叫做逻辑单位编号（LUN，Logical Unit Number）。iSCSI initiator 就是跟 target 协调后才取得 LUN 的访问权。</p>
<p><code>tgt</code> 的配置文件 <code>/etc/tgt/targets.conf</code> 可以很简单，将上面新建的三个 LUN 加入到 iqn 中即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/tgt/targets.conf 
<span class="token operator">&lt;</span>target iqn.2000-01.server2:mydisk<span class="token operator">></span>
        backing-store /srv/iscsi/disk.img
        backing-store /dev/sda3
        backing-store /dev/centos/iscsi01
        initiator-address <span class="token number">10.1</span>.1.0/24
        incominguser iuser ipass
        write-cache off
<span class="token operator">&lt;</span>/target<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数说明如下：</p>
<ul>
<li><code>backing-store/direct-store</code>：一般用 <code>backing-store</code> 设置虚拟设备，想整块硬盘都被使用可以用 <code>direct-store</code>。</li>
<li><code>initiator-address</code>：限制客户端地址，一般也不用设置而用 <code>iptables</code> 来规划。</li>
<li><code>incominguser</code>：设置通过账号密码来使用 iSCSI target。</li>
<li><code>write-cache</code>：是否使用缓存，默认使用缓存来提高读写速度，有数据丢失风险。</li>
</ul>
<p>如果没有使用 <code>initiator-address</code> 参数，使用 <code>ipbatles</code> 防火墙来规定只有 <code>10.1.1.0/24</code> 可以访问 target 设置如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">-s</span> <span class="token number">10.1</span>.1.0/24 <span class="token parameter variable">--dport</span> <span class="token number">3260</span> <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="iscsi-target-启动"><a class="markdownIt-Anchor" href="#iscsi-target-启动"></a> iSCSI target 启动</h1>
<p>启动 <code>tgtd</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> tgtd
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span><span class="token function">grep</span> tgt
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:3260            <span class="token number">0.0</span>.0.0:*         LISTEN      <span class="token number">23981</span>/tgtd   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>tgt-admin</code> 命令查看运行状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ tgt-admin <span class="token parameter variable">--show</span>
Target <span class="token number">1</span>: iqn.2000-01.server2:mydisk
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
        I_T nexus: <span class="token number">2</span>
            Initiator: iqn.1994-05.com.redhat:bf38cf4ccf5 alias: server3
            Connection: <span class="token number">0</span>
                IP Address: <span class="token number">10.1</span>.1.2
    LUN information:
        LUN: <span class="token number">0</span>
            Type: controller
            SCSI ID: IET     00010000
            SCSI SN: beaf10
            Size: <span class="token number">0</span> MB, Block size: <span class="token number">1</span>
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags: 
        LUN: <span class="token number">1</span>
            Type: disk
            SCSI ID: IET     00010001
            SCSI SN: beaf11
            Size: <span class="token number">310</span> MB, Block size: <span class="token number">512</span>
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/centos/iscsi01
            Backing store flags: 
        LUN: <span class="token number">2</span>
            Type: disk
            SCSI ID: IET     00010002
            SCSI SN: beaf12
            Size: <span class="token number">200</span> MB, Block size: <span class="token number">512</span>
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sda3
            Backing store flags: 
        LUN: <span class="token number">3</span>
            Type: disk
            SCSI ID: IET     00010003
            SCSI SN: beaf13
            Size: <span class="token number">105</span> MB, Block size: <span class="token number">512</span>
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /srv/iscsi/disk.img
            Backing store flags: 
    Account information:
        iuser
    ACL information:
        <span class="token number">10.1</span>.1.0/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到和配置文件设定的一致，并且有一个已经连接的主机<code>10.1.1.2</code>。</p>
<h1 id="iscsi-initiator-设置"><a class="markdownIt-Anchor" href="#iscsi-initiator-设置"></a> iSCSI initiator 设置</h1>
<p>安装好 <code>iscsi-initiator-utils</code> 之后，修改配置文件 <code>/etc/iscsi/iscsid.conf</code> 内容，主要是设置访问账号密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/iscsi/iscsid.conf
node.session.auth.username <span class="token operator">=</span> iuser
node.session.auth.password <span class="token operator">=</span> ipass
discovery.sendtargets.auth.username <span class="token operator">=</span> iuser
discovery.sendtargets.auth.password <span class="token operator">=</span> ipass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="iscsi-initiator-操作"><a class="markdownIt-Anchor" href="#iscsi-initiator-操作"></a> iSCSI initiator 操作</h1>
<p>设置好之后，使用 <code>iscsiadm</code> 命令来检测 <code>10.1.1.1</code> 中的 iSCSI 设备：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> discovery <span class="token parameter variable">-t</span> sendtargets <span class="token parameter variable">-p</span> <span class="token number">10.1</span>.1.1
<span class="token number">10.1</span>.1.1:3260,1 iqn.2000-01.server2:mydisk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动 <code>iscsi</code> 程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ systemctl start iscsi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>登录目标 target：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> <span class="token function">node</span>
<span class="token number">10.1</span>.1.1:3260,1 iqn.2000-01.server2:mydisk
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> <span class="token function">node</span> <span class="token parameter variable">-T</span> iqn.2000-01.server2:mydisk <span class="token parameter variable">--login</span>
Logging <span class="token keyword">in</span> to <span class="token punctuation">[</span>iface: default, target: iqn.2000-01.server2:mydisk, portal: <span class="token number">10.1</span>.1.1,3260<span class="token punctuation">]</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span>
Login to <span class="token punctuation">[</span>iface: default, target: iqn.2000-01.server2:mydisk, portal: <span class="token number">10.1</span>.1.1,3260<span class="token punctuation">]</span> successful.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询 iSCSI 磁盘：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> <span class="token parameter variable">-l</span>

Disk /dev/sdb: <span class="token number">310</span> MB, <span class="token number">310378496</span> bytes, <span class="token number">606208</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes


Disk /dev/sdc: <span class="token number">200</span> MB, <span class="token number">200278016</span> bytes, <span class="token number">391168</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes


Disk /dev/sdd: <span class="token number">104</span> MB, <span class="token number">104857600</span> bytes, <span class="token number">204800</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">4096</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">4096</span> bytes / <span class="token number">4096</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注销 target，但并不删除连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> <span class="token function">node</span> <span class="token parameter variable">-T</span> iqn.2000-01.server2:mydisk <span class="token parameter variable">--logout</span>
Logging out of session <span class="token punctuation">[</span>sid: <span class="token number">1</span>, target: iqn.2000-01.server2:mydisk, portal: <span class="token number">10.1</span>.1.1,3260<span class="token punctuation">]</span>
Logout of <span class="token punctuation">[</span>sid: <span class="token number">1</span>, target: iqn.2000-01.server2:mydisk, portal: <span class="token number">10.1</span>.1.1,3260<span class="token punctuation">]</span> successful.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>删除 target 连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> <span class="token function">node</span> <span class="token parameter variable">-o</span> delete <span class="token parameter variable">-T</span> iqn.2000-01.server2:mydisk
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ iscsiadm <span class="token parameter variable">-m</span> <span class="token function">node</span>
iscsiadm: No records found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>直接将 target 中的磁盘组成 LV 并格式化：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ pvcreate /dev/sd<span class="token punctuation">&#123;</span>b,c,d<span class="token punctuation">&#125;</span>
  Physical volume <span class="token string">"/dev/sdb"</span> successfully created.
  Physical volume <span class="token string">"/dev/sdc"</span> successfully created.
  Physical volume <span class="token string">"/dev/sdd"</span> successfully created.
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ vgcreate iscsi /dev/sd<span class="token punctuation">&#123;</span>b,c,d<span class="token punctuation">&#125;</span>
  Volume group <span class="token string">"iscsi"</span> successfully created
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ vgdisplay
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-l</span> <span class="token number">144</span> <span class="token parameter variable">-n</span> disk iscsi
  Logical volume <span class="token string">"disk"</span> created.
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ lvdisplay
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">mkfs</span> <span class="token parameter variable">-t</span> ext4 /dev/iscsi/disk
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /data/iscsi
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/dev/iscsi/disk /data/iscsi ext4 defaults,_netdev 1 2"</span> <span class="token operator">>></span> /etc/fstab
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-a</span>
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-Th</span>
/dev/mapper/iscsi-disk  ext4      551M  876K  510M   <span class="token number">1</span>% /data/iscsi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>挂载时使用 <code>_netdev</code> 参数的意思是，开机后需要网络启动完毕后再挂载。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Squid 服务</title>
    <url>/1886159042/</url>
    <content><![CDATA[<h1 id="代理服务器"><a class="markdownIt-Anchor" href="#代理服务器"></a> 代理服务器</h1>
<p>代理服务器（Proxy Server）是以类似代理人的身份去获取用户所需数据。通过代理服务器可以实现防火墙与用户浏览数据分析功能。此外，还能充当 CDN（Content Delivery Network），即内容分发网络功能，加速网络访问。</p>
<p>一般代理服务器会搭建在局域网的单点对外防火墙上。</p>
<p>Linux 下常用的代理服务使用 Squid 软件。</p>
<h1 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h1>
<p>先使用 <code>yum</code> 安装 <code>squid</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> squid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>squid</code> 服务使用的配置文件有：</p>
<ul>
<li><code>/etc/squid/squid.conf</code>：<code>squid</code> 的主要配置文件。</li>
<li><code>/etc/squid/mime.conf</code>：设置 <code>squid</code> 所支持的文件格式，一般不需要改动。</li>
</ul>
<p><code>squid</code> 服务相关目录有：</p>
<ul>
<li><code>/var/spool/squid</code>：默认 <code>squid</code> 缓存储存目录。</li>
<li><code>/usr/lib64/squid</code>：提供 <code>squid</code> 额外的控制模块。</li>
</ul>
<h1 id="默认配置"><a class="markdownIt-Anchor" href="#默认配置"></a> 默认配置</h1>
<p>在默认情况下，<code>squid</code> 配置有下面一些设置：</p>
<ul>
<li>仅有本机（localhost，127.0.0.1）来源可以使用 <code>squid</code> 功能。</li>
<li><code>squid</code> 所监听的代理服务端口为 3128。</li>
<li><s>缓存目录 /var/spool/squid/ 仅有 100 MB 缓存量。</s></li>
<li><s>内存分配 8 MB 大小作为高速缓存使用。</s></li>
<li>启动 <code>squid</code> 程序的用户为 <code>squid</code> 账号。</li>
</ul>
<p>默认配置文件内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/squid/squid.conf
<span class="token comment"># 信任用户与目标控制</span>
acl localnet src <span class="token number">10.0</span>.0.0/8     
acl localnet src <span class="token number">172.16</span>.0.0/12  
acl localnet src <span class="token number">192.168</span>.0.0/16 <span class="token comment"># 定义局域网来源</span>
acl localnet src fc00::/7       <span class="token comment"># RFC 4193 local private network range</span>
acl localnet src fe80::/10      <span class="token comment"># RFC 4291 link-local (directly plugged) machines</span>

<span class="token comment"># 定义安全端口</span>
acl SSL_ports port <span class="token number">443</span>
acl Safe_ports port <span class="token number">80</span>          <span class="token comment"># http</span>
acl Safe_ports port <span class="token number">21</span>          <span class="token comment"># ftp</span>
acl Safe_ports port <span class="token number">443</span>         <span class="token comment"># https</span>
acl Safe_ports port <span class="token number">70</span>          <span class="token comment"># gopher</span>
acl Safe_ports port <span class="token number">210</span>         <span class="token comment"># wais</span>
acl Safe_ports port <span class="token number">1025</span>-65535  <span class="token comment"># unregistered ports</span>
acl Safe_ports port <span class="token number">280</span>         <span class="token comment"># http-mgmt</span>
acl Safe_ports port <span class="token number">488</span>         <span class="token comment"># gss-http</span>
acl Safe_ports port <span class="token number">591</span>         <span class="token comment"># filemaker</span>
acl Safe_ports port <span class="token number">777</span>         <span class="token comment"># multiling http</span>
acl CONNECT method CONNECT

<span class="token comment"># 拒绝非正规端口连接请求</span>
http_access deny <span class="token operator">!</span>Safe_ports

<span class="token comment"># 拒绝非正规加密端口连接请求</span>
http_access deny CONNECT <span class="token operator">!</span>SSL_ports

<span class="token comment"># 允许本机管理,拒绝其他来源地址管理</span>
http_access allow localhost manager
http_access deny manager

<span class="token comment"># 放行本机与内部网络的用户来源,其他予以拒绝</span>
http_access allow localnet
http_access allow localhost
http_access deny all

<span class="token comment"># 监听客户端请求的端口.如果想加密连接可改为https_port 923</span>
http_port <span class="token number">3128</span>

<span class="token comment"># 磁盘缓存放置目录与大小,内存高速缓存的大小</span>
cache_dir ufs /var/spool/squid <span class="token number">100</span> <span class="token number">16</span> <span class="token number">256</span>
cache_mem <span class="token number">8</span> MB

<span class="token comment"># Leave coredumps in the first cache dir</span>
coredump_dir /var/spool/squid

<span class="token comment"># 额外设置</span>
refresh_pattern ^ftp:           <span class="token number">1440</span>    <span class="token number">20</span>%     <span class="token number">10080</span>
refresh_pattern ^gopher:        <span class="token number">1440</span>    <span class="token number">0</span>%      <span class="token number">1440</span>
refresh_pattern <span class="token parameter variable">-i</span> <span class="token punctuation">(</span>/cgi-bin/<span class="token operator">|</span><span class="token punctuation">\</span>?<span class="token punctuation">)</span> <span class="token number">0</span>     <span class="token number">0</span>%      <span class="token number">0</span>
refresh_pattern <span class="token builtin class-name">.</span>               <span class="token number">0</span>       <span class="token number">20</span>%     <span class="token number">4320</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="服务启动"><a class="markdownIt-Anchor" href="#服务启动"></a> 服务启动</h1>
<p>可以使用默认配置启动 <code>squid</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl start squid
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span><span class="token function">grep</span> squid
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::3128                 :::*             LISTEN      <span class="token number">101226</span>/<span class="token punctuation">(</span>squid-1<span class="token punctuation">)</span>
udp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:56694           <span class="token number">0.0</span>.0.0:*                    <span class="token number">101226</span>/<span class="token punctuation">(</span>squid-1<span class="token punctuation">)</span>
udp6       <span class="token number">0</span>      <span class="token number">0</span> :::53318                :::*                         <span class="token number">101226</span>/<span class="token punctuation">(</span>squid-1<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="缓存目录"><a class="markdownIt-Anchor" href="#缓存目录"></a> 缓存目录</h1>
<p>磁盘缓存设置 <code>cache_dir ufs /var/spool/squid 100 16 256</code> 后三数字代表：大小 MB、一层索引数、二层索引数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /var/spool/squid/
00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  swap.state
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> /var/spool/squid/00
00  0B  <span class="token number">16</span>  <span class="token number">21</span>  2C  <span class="token number">37</span>  <span class="token number">42</span>  4D  <span class="token number">58</span>  <span class="token number">63</span>  6E  <span class="token number">79</span>  <span class="token number">84</span>  8F  9A  A5  B0  BB  C6  D1  DC  E7  F2  FD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为 <code>squid</code> 会将数据分成多个小块，这样便于索引。</p>
<p>可以多加一行配置来增加磁盘缓存目录。例如：<code>cache_dir ufs /cache 2000 64 64</code>。同时需要修改目录权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /cache
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">750</span> /cache
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> squid:squid /cache
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">--reference</span> /var/spool/squid/ /cache
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Zd</span> /cache
drwxr-x---. squid squid system_u:object_r:squid_cache_t:s0 /cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了防止缓存占满硬盘，可以在配置中设置下面两个值，当磁盘使用率达到 95% 时删除旧数据，直到磁盘用量降至 90%：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cache_swap_low <span class="token number">90</span>
cache_swap_high <span class="token number">95</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>cache_mem</code> 的值指额外提供给 <code>squid</code> 作为缓存使用的内存大小。默认 1 GB 磁盘高速缓存会占用约 10 M 内存。</p>
<h1 id="信任来源"><a class="markdownIt-Anchor" href="#信任来源"></a> 信任来源</h1>
<p><code>Squid</code> 中来源与目标过滤使用 <code>acl</code> 来定义列表，用 <code>http_access</code> 来对 <code>acl</code> 采取动作。设置 <code>acl</code> 的语法为：</p>
<p><code>acl &lt;自定义acl名称&gt; &lt;要控制acl类型&gt; &lt;设置内容&gt;</code></p>
<p>重要的 <code>acl</code> 类型设置如下：</p>
<ul>
<li>设置请求客户端列表方式有下面几种：
<ul>
<li><code>src ip-address/netmask</code>：通过 IP 设置网段，例如<code>acl plan src 10.1.1.0/24 10.1.2.0/24</code>。</li>
<li><code>src addr1-addr2/netmask</code>：连续 IP 地址设置，例如<code>acl plan src 10.1.1.100-10.1.1.200/24</code>。</li>
<li><code>srcdomain .domain.name</code>：通过主机名设置，例如<code>acl pdo srcdomain .ere.edu.us</code>。</li>
</ul>
</li>
<li>设置访问目标列表方式有下面几种：
<ul>
<li><code>dst ip-addr/netmask</code>：通过 IP 设置，例如<code>acl drp dst 134.144.2.54/32</code>。</li>
<li><code>dstdomain .domain.name</code>：通过域名设置，例如<code>acl drp dstdomain .facebook.com</code>。</li>
<li><code>url_regex [-i] ^http://url</code>：用正则表达式匹配网址，例如<code>acl kurl url_regex ^http://baidu.com/.*</code>。</li>
<li><code>urlpath_regex [-i] \.gif\$</code>：用正则匹配 url 内容，例如<code>acl sx urlpath_regex /sex.*\.jpg$</code>。</li>
<li>匹配文件：可以将地址按行保存到文件来调用，例如<code>acl drplst dstdomain &quot;/root/dpl.txt&quot;</code>。</li>
</ul>
</li>
</ul>
<p>设置好 <code>acl</code> 后，可以用 <code>http_access</code> 来对 acl 列表执行允许（allow）与拒绝（deny）操作，<code>http_access</code> 严格按顺序执行。</p>
<p>例如放行内部网络 10.1.1.0/24，拒绝访问 <code>facebook.com</code> 网站的设置如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">acl lanet src <span class="token number">10.1</span>.1.0/24
acl drpdm dstdomain .facebook.com
http_access deny drpdm
http_access allow lanet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="其他设置"><a class="markdownIt-Anchor" href="#其他设置"></a> 其他设置</h1>
<p>可以设置不要对某些网页进行缓存操作，否则客户端无法请求到网页最新副本。例如，不要对 php 网页进行缓存：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">acl denyphp urlpath_regex <span class="token punctuation">\</span>.php$
cache deny denyphp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 <code>refresh_pattern</code> 段设置，例如：<code>refresh_pattern ^ftp: 1440 20% 10080</code>。从第二列开始代表：</p>
<ul>
<li>regex：用正则表达式分析网址数据，例如 <code>^ftp</code> 表示以 ftp 开头的网址。</li>
<li>最小时间：单位分钟，表示缓存数据存放到达这一时间后失效，新请求会从网络重新获取数据。</li>
<li>百分比：与最大时间有关，当数据被获取到缓存后，经过最大时间的百分比后，数据会被重新获取。</li>
<li>最大时间：数据存在缓存内的最大时间，到达这一时间后数据会被删除。</li>
</ul>
<p>管理员的邮箱地址可以通过 <code>cache_mgr</code> 来设置，在发生错误时会发送邮件。例如设置邮箱为 <code>root@server2</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cache_mgr root@server2
visible_hostname server2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="安全设置"><a class="markdownIt-Anchor" href="#安全设置"></a> 安全设置</h1>
<p>针对防火墙，需要开放 3128 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens37 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">-s</span> <span class="token number">10.1</span>.1.0/24 <span class="token parameter variable">--dport</span> <span class="token number">3128</span> <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>SELinux 中没有规则限制，其中 <code>/etc/squid/</code> 内配置文件类型是 <code>squid_conf_t</code>，缓存目录类型 <code>squid_cache_t</code>。</p>
<p>通过将拒绝网站写入文件中调用处理起来更灵活。例如使用 <code>/root/drp.txt</code> 来记录禁止网站：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /root/drp.txt
.facebook.com
.google.com
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/squid/squid.conf
acl drplist dstdomain <span class="token string">"/root/drp.txt"</span>
http_access deny drplist
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl reload squid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="客户端测试"><a class="markdownIt-Anchor" href="#客户端测试"></a> 客户端测试</h1>
<p>这里使用 <code>curl</code> 来测试。默认情况下可以访问百度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> baidu.com
<span class="token operator">&lt;</span>html<span class="token operator">></span>
<span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"refresh"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">"0;url=http://www.baidu.com/"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>/html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>squid</code> 中添加规则后重新载入配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/squid/squid.conf
acl nobaidu dstdomain .baidu.com
http_access deny nobaidu
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl reload squid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>再用 <code>curl</code> 通过代理访问百度：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token parameter variable">-x</span> <span class="token number">10.1</span>.1.1:3128 baidu.com
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/strict.dtd"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>meta <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"copyright"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">"Copyright (C) 1996-2016 The Squid Software Foundation and contributors"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">"text/html; charset=utf-8"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>title<span class="token operator">></span>ERROR: The requested URL could not be retrieved<span class="token operator">&lt;</span>/title<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>出现 <code>squid</code> 页面提示禁止访问。</p>
<h1 id="上层代理"><a class="markdownIt-Anchor" href="#上层代理"></a> 上层代理</h1>
<p>可以在 <code>squid</code> 中设置上层代理，来将网络访问分流。设置上层代理服务器参数如下：</p>
<ul>
<li>
<p><strong>cache_peer</strong></p>
<p>用法：<code>cache_peer [上层代理主机] [代理角色] [代理端口] [icp端口] [额外参数]</code></p>
<ul>
<li>
<p>上层代理主机名：例如 192.168.1.101。</p>
</li>
<li>
<p>代理角色：角色一般为上层（parent）。还有临近（sibling）协同运行角色。</p>
</li>
<li>
<p>代理端口：上层代理的端口，默认是 3128。</p>
</li>
<li>
<p>icp 端口：默认是 3130。</p>
</li>
<li>
<p>额外参数: 针对上层代理的行为设置，主要选项有：</p>
<ul>
<li>proxy-only：数据不缓存到本地。</li>
<li>weight：权重设置,有多台上层代理时用更高权重表示优先选择。</li>
<li>no-query：可以不需要发送 icp 数据包。</li>
<li>no-digest：不向附近主机要求建立 digest 记录表格。</li>
<li>no-netdb-exchange：不向附近代理主机发送 IMCP 数据包。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>cache_peer_domain</strong></p>
<p>用法：<code>cache_peer_domain [上层代理主机名] [请求的域名]</code></p>
<p>设置请求用上层代理服务器访问的域名。</p>
</li>
<li>
<p><strong>cache_peer_access</strong></p>
<p>用法：<code>cache_peer_access [上层代理主机名] [allow|deny] [acl名称]</code></p>
<p>与 <code>cache_peer_domain</code> 作用类似，不过用 <code>acl</code> 来规范访问行为。</p>
</li>
</ul>
<p>例如设置使用代理 <code>DESKTOP-QU8VM21:3213</code> 去访问谷歌：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/squid/squid.conf
cache_peer DESKTOP-QU8VM21 parent <span class="token number">3213</span> <span class="token number">3130</span> proxy-only
cache_peer_domain DESKTOP-QU8VM21 .google.com
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl reload squid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="透明代理"><a class="markdownIt-Anchor" href="#透明代理"></a> 透明代理</h1>
<p>可以在对外防火墙服务器 nat 上安装代理，在代理上启动 transparent 功能，最后加上 80 端口转 3128 端口的规则，那么所有通过 nat 转发的内网主机上网都会强制通过代理访问 http。客户端的浏览器也不需要做任何额外设置。</p>
<p>开启透明代理功能只需要在 <code>http_port 3128</code> 后面加上 <code>transparent</code> 参数即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/squid/squid.conf
http_port <span class="token number">3128</span> transparent
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl reload squid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接着增加一条防火墙转发规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-i</span> ens37 <span class="token parameter variable">-s</span> <span class="token number">10.1</span>.1.0/24 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> REDIRECT --to-ports <span class="token number">3128</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此便完成了。</p>
<h1 id="代理认证"><a class="markdownIt-Anchor" href="#代理认证"></a> 代理认证</h1>
<p><code>squid</code> 使用 <code>ncsa_auth</code> 认证模块，可以配合 <code>apache</code> 提供的 <code>htpasswd</code> 制作的密码文件作为验证依据，来对代理使用进行身份认证：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">rpm</span> <span class="token parameter variable">-ql</span> squid <span class="token operator">|</span> <span class="token function">grep</span> ncsa
/usr/lib64/squid/basic_ncsa_auth
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> httpd
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">whereis</span> htpasswd
htpasswd: /usr/bin/htpasswd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置 <code>squid.conf</code> 内容，账号密码保存在 <code>/root/squid_user.txt</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/squid/squid.conf
auth_param basic program /usr/lib64/squid/basic_ncsa_auth /root/squid_user.txt
auth_param basic children <span class="token number">5</span>
<span class="token comment">#acl localnet src 10.0.0.0/8    # RFC1918 possible internal network</span>
auth_param basic program /usr/lib64/squid/basic_ncsa_auth /root/squid_user.txt
auth_param basic children <span class="token number">5</span>
acl squid_user proxy_auth REQUIRED
http_access allow squid_user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>htpasswd</code> 建立用户 <code>sqq</code>，密码为 <code>1234</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ htpasswd <span class="token parameter variable">-c</span> /root/squid_user.txt sqq
New password: 
Re-type new password: 
Adding password <span class="token keyword">for</span> user sqq
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart squid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>SAMBA 服务</title>
    <url>/1516343977/</url>
    <content><![CDATA[<h1 id="samba-简介"><a class="markdownIt-Anchor" href="#samba-简介"></a> SAMBA 简介</h1>
<p>Linux 上面使用 NFS 服务器来共享文件，Windows 上使用的是 CIFS（Common Internet File System）服务（网上邻居）来共享文件。这两种服务都不能跨系统共享文件，SAMBA 就是为了解决这一问题而存在。</p>
<p>SAMBA（Server Message Block）服务的主要功能：</p>
<ul>
<li>共享文件与打印机服务。</li>
<li>提供用户登录 SAMBA 主机时的身份认证。</li>
<li>可以进行 Windows 网络上的主机名解析（NetBIOS Name）。</li>
<li>可以进行设备的共享（例如 CD-ROM）。</li>
</ul>
<h1 id="netbios-协议"><a class="markdownIt-Anchor" href="#netbios-协议"></a> NetBIOS 协议</h1>
<p>SAMBA 构架在 NetBIOS（Network Basic Input/Output System）通信协议上。</p>
<p>NetBIOS 是无法跨路由（Router/Gateway）使用，只能用于局域网。数据传输时使用 NetBIOS Name 而不是 IP 来识别对方。后来发展出 NetBIOS over TCP/IP 技术突破了这一限制。</p>
<p>Windows 网上邻居也使用 NetBIOS，工作流程如下：</p>
<ol>
<li>要想在网上邻居访问某台主机时，必须加入对方主机的工作组（Workgroup），并且本机要设置一个主机名。这个主机名是构架在 NetBIOS 协议上的，也叫 NetBIOS Name。在同一个工作组，NetBIOS Name 必须唯一。</li>
<li>找到对方主机后，能否登录或使用主机资源，还要看对方主机上的权限配置。</li>
</ol>
<p>SAMBA 通过两个服务来控制上面两步骤：</p>
<ul>
<li><strong>nmbd</strong>：用来管理工作组，NetBIOS Name 的解析，主要利用 UDP 协议开启 137 和 138 端口来做名称解析。</li>
<li><strong>smbd</strong>：用来管理 SAMBA 主机共享的目录，文件与打印机等。主要利用 TCP 协议开机 139 和 445 端口来传输数据。</li>
</ul>
<h1 id="连接模式"><a class="markdownIt-Anchor" href="#连接模式"></a> 连接模式</h1>
<p>局域网内最常见的连接模式有两种：对等模式和主控模式。这两种模式 SAMBA 都可以实现。</p>
<h2 id="对等模式"><a class="markdownIt-Anchor" href="#对等模式"></a> 对等模式</h2>
<p>对等模式（Workgroup Model, Peer/Peer）指局域网内两台主机的地位相等，均有各自的账号，可以独立工作。当两台主机之间需要共享数据时，需要使用对方主机内记录的账号来访问对方主机。</p>
<p>这种模式比较适合小型网络内数据共享。</p>
<h2 id="主控模式"><a class="markdownIt-Anchor" href="#主控模式"></a> 主控模式</h2>
<p>主控模式（Domain Model）是将所有账号密码都放置在一台主控计算机（PDC, Primary Domain Controller）上面，任何人使用计算机时需要通过 PDC 服务器认证后，给与对应权限。</p>
<p>这种模式适合企业构架，只需维护好 PDC 上面的账号资源，再分配给人员使用。</p>
<h1 id="samba-安装"><a class="markdownIt-Anchor" href="#samba-安装"></a> SAMBA 安装</h1>
<p>SAMBA 所需的基本组件有下面三个：</p>
<ul>
<li><strong>samba</strong>：提供 SMB 服务器所需各项服务程序（smbd 和 nmbd），其他与 SAMBA 相关的 logrotate 配置文件及开机默认选项文件等。</li>
<li><strong>samba-client</strong>：提供 SAMBA 客户端所需工具命令，例如 mout.cifs，smbtree 等。</li>
<li><strong>samba-common</strong>：提供客户端和服务端通用数据，例如 smb.conf，testparm 等。</li>
<li><strong>cifs-utils</strong>：提供挂载 cifs 支持等。</li>
</ul>
<p>可以使用 <code>yum</code> 来安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> samba
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> samba-client
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> cifs-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>samba 包内已包含 samba-common。</p>
<h1 id="配置文件路径"><a class="markdownIt-Anchor" href="#配置文件路径"></a> 配置文件路径</h1>
<p>和 SAMBA 有关的配置文件有下面这些：</p>
<ul>
<li>
<p><strong>/etc/samba/smb.conf</strong></p>
<p>SAMBA 的主要配置文件。主要内容有全局设置和共享目录相关设置。</p>
</li>
<li>
<p><strong>/etc/samba/lmhosts</strong></p>
<p>早期 NetBIOS Name 所需额外设置，用来设置 NetBIOS Name 对应的 IP 地址。现在 SAMBA 默认使用 hostname 作为 NetBIOS Name，因此可以不用设置。</p>
</li>
<li>
<p><strong>/etc/sysconfig/samba</strong></p>
<p>设置启动 smbd，nmbd 时，想要加入的额外服务参数。</p>
</li>
<li>
<p><strong>/etc/samba/smbusers</strong></p>
<p>可以用来设置 Windows 与 Linux 中管理员与匿名用户名称之间的对应关系。例如 administrator 对应 root 用户。</p>
</li>
<li>
<p><strong>/var/lib/samba/private/{passdb.tdb,secrets.tdb}</strong></p>
<p>管理 SAMBA 账号与密码的数据库文件。</p>
</li>
<li>
<p><strong>/usr/share/doc/samba-</strong>*</p>
<p>这个目录包含 SAMBA 的所有相关技术手册。</p>
</li>
</ul>
<h1 id="samba-命令"><a class="markdownIt-Anchor" href="#samba-命令"></a> SAMBA 命令</h1>
<p>和 SAMBA 有关的命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>smbd</code></td>
<td>服务器权限管理。</td>
</tr>
<tr>
<td><code>nmbd</code></td>
<td>NetBIOS Name 查询。</td>
</tr>
<tr>
<td><code>tdbdump</code></td>
<td>查询 SAMBA 数据库 TDB（Trivial-DataBase）的内容。</td>
</tr>
<tr>
<td><code>tdbtool</code></td>
<td>直接修改数据库中账号和密码参数，需要安装 tdb-tools。</td>
</tr>
<tr>
<td><code>smbstatus</code></td>
<td>服务端列出当前 SAMBA 的连接状态。</td>
</tr>
<tr>
<td><code>smbpasswd</code></td>
<td>早期修改 SAMBA 用户密码的命令，已被 pdbedit 取代。</td>
</tr>
<tr>
<td><code>pdbedit</code></td>
<td>修改 SAMBA 用户密码命令。</td>
</tr>
<tr>
<td><code>testparm</code></td>
<td>服务端用来检验配置文件语法错误工具。</td>
</tr>
<tr>
<td><code>mount.cifs</code></td>
<td>客户端用来挂载远程共享目录的命令。</td>
</tr>
<tr>
<td><code>smbclient</code></td>
<td>客户端用来搜索其他主机共享目录命令。</td>
</tr>
<tr>
<td><code>nmblookup</code></td>
<td>客户端查询 NetBIOS Name 的命令。</td>
</tr>
<tr>
<td><code>smbtree</code></td>
<td>客户端用来查询工作组与计算机名称树形目录分布图。</td>
</tr>
</tbody>
</table>
<h1 id="服务器配置流程"><a class="markdownIt-Anchor" href="#服务器配置流程"></a> 服务器配置流程</h1>
<p>SAMBA 服务器配置流程如下：</p>
<ol>
<li>服务器全局设置：在 <code>smb.conf</code> 中设置好工作组，NetBIOS 主机名，密码使用状态等；</li>
<li>规划共享目录参数：在 <code>smb.conf</code> 中设置好预计要共享的目录或设备以及可供使用的账号数据；</li>
<li>奖励所需文件系统：在系统中建立好共享出去的目录或设备，设置好权限参数；</li>
<li>建立 SAMBA 用账号：在系统中建立好共享时使用的账号，用 <code>pdbedit</code> 建立 SAMBA 密码；</li>
<li>启动服务：启动 <code>smbd</code> 和 <code>nmbd</code> 服务。</li>
</ol>
<h1 id="配置文件参数"><a class="markdownIt-Anchor" href="#配置文件参数"></a> 配置文件参数</h1>
<p>配置文件 <code>smb.conf</code> 中全局配置 [global] 部分主要设置参数如下：</p>
<ul>
<li>workgroup：工作组名称。</li>
<li>netbios name：主机 NetBIOS 名称。</li>
<li>server string：主机的简易说明。</li>
<li>display charset：终端所使用的编码。</li>
<li>unix charset：在 Linux 服务器上使用的编码。</li>
<li>dos charset：在 Windows 客户端的编码。</li>
<li>log file：日志文件名。</li>
<li>max log size：日志大小限制，达到最大值会被 rotate 掉。</li>
<li>security：有三种设置 share（不用密码，已废弃），user（用 SAMBA 服务器认证），domain（指定认证 SAMBA 服务器）。</li>
<li>encrypt passwords：Yes（密码加密）。</li>
<li>passdb backend：数据库格式，默认为 tdbsam。</li>
</ul>
<p>配置文件 <code>smb.conf</code> 中共享资源 [homes] 部分相关设置参数如下：</p>
<ul>
<li>comment：目录的说明。</li>
<li>path：共享的实际目录。</li>
<li>browseable：是否让所有用户可见。</li>
<li>writable：是否可写入。</li>
<li>create mode/directory mode：设置权限。</li>
<li>writelist：设置可使用此资源的用户或用户组（@ 开头）。</li>
</ul>
<p>配置文件 <code>smb.conf</code> 中可用的变量功能：</p>
<ul>
<li>%S：取代当前的设置项目值。</li>
<li>%m：代表客户端的 NetBIOS 主机名。</li>
<li>%M：代表客户端的 Hostname。</li>
<li>%I：代表客户端的 IP</li>
<li>%L：代表 SAMBA 主机的 NetBIOS 主机名。</li>
<li>%h：代表 SAMBA 主机的 Hostname。</li>
<li>%H：代表用户的主目录。</li>
<li>%U：代表当前登录的用户名。</li>
<li>%g：代表登录的用户组名。</li>
<li>%T：代表当前的日期和时间。</li>
</ul>
<p>另外在配置文件内除了 <code>#</code> 代表注释，还可以使用分号 <code>;</code> 代表注释。</p>
<h1 id="服务端配置示例"><a class="markdownIt-Anchor" href="#服务端配置示例"></a> 服务端配置示例</h1>
<p>下面列出一些常见的使用场景和对应 <code>smb.conf</code> 配置文件内容。</p>
<h2 id="无密码共享"><a class="markdownIt-Anchor" href="#无密码共享"></a> 无密码共享</h2>
<p>假设 SMB 服务器（192.168.2.254）要配置成如下参数：</p>
<ul>
<li>局域网内计算机工作组为 WORKGROUP。</li>
<li>服务器的 NetBIOS 为 smbserver2。</li>
<li>用户认证等级设置为无密码 share。</li>
<li>取消原本有共享的 <code>[homes]</code> 目录。</li>
<li>仅共享 <code>/tmp</code> 目录，取名也为 temp。</li>
<li>Linux 服务器的编码格式设置为 utf8。</li>
<li>Windows 客户端的编码格式设置为 GB2312。</li>
</ul>
<p>整个配置文件如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/samba/smb.conf
<span class="token punctuation">[</span>global<span class="token punctuation">]</span>
        workgroup <span class="token operator">=</span> WORKGROUP
        netbios name <span class="token operator">=</span> smbserver2
        server string <span class="token operator">=</span> This is OPEN SAMBA server
        security <span class="token operator">=</span> user
        map to guest <span class="token operator">=</span> Bad User

        unix charset <span class="token operator">=</span> utf8
        display charset <span class="token operator">=</span> utf8
        dos charset <span class="token operator">=</span> cp936

        log <span class="token function">file</span> <span class="token operator">=</span> /var/log/samba/log.%m
        max log size <span class="token operator">=</span> <span class="token number">50</span>

        passdb backend <span class="token operator">=</span> tdbsam

        load printers <span class="token operator">=</span> no

<span class="token punctuation">[</span>temp<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> TEMP DIR
        path <span class="token operator">=</span> /tmp
        writable <span class="token operator">=</span> <span class="token function">yes</span>
        browseable <span class="token operator">=</span> <span class="token function">yes</span>
        guest ok <span class="token operator">=</span> <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>testparm</code> 检查下 <code>smb.conf</code> 配置文件语法设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ testparm
Load smb config files from /etc/samba/smb.conf
Unknown parameter encountered: <span class="token string">"display charset"</span>
Ignoring unknown parameter <span class="token string">"display charset"</span>
Loaded services <span class="token function">file</span> OK.
Server role: ROLE_STANDALONE

Press enter to see a dump of your <span class="token function">service</span> definitions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="有密码共享"><a class="markdownIt-Anchor" href="#有密码共享"></a> 有密码共享</h2>
<p>假设要设置基于用户密码访问的 SAMBA 服务器：</p>
<ul>
<li>用户认证等级设置为 user。</li>
<li>用户密码文件使用 TDB 数据库格式，存放于 <code>/var/lib/samba/private/</code> 内。</li>
<li>密码需要加密。</li>
<li>每个 SAMBA 的用户拥有自己的用户主目录。</li>
<li>设置一个用户 smbuser，登录密码为 1111，SAMBA 密码为 4444。</li>
<li>共享 <code>/home/sharedir</code> 目录，共享资源名称为 sharedir。</li>
<li>用户组 smbuser 对 <code>/home/sharedir</code> 具有写入权限。</li>
</ul>
<p>先建立相关用户和目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> smbuser <span class="token parameter variable">-p</span> <span class="token number">1111</span>
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /home/sharedir
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chgrp</span> smbuser /home/sharedir/
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">2770</span> /home/sharedir/
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-d</span> /home/sharedir/
drwxrws---. <span class="token number">2</span> root smbuser <span class="token number">6</span> Oct <span class="token number">11</span> <span class="token number">23</span>:25 /home/sharedir/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要使用 <code>pdbedit</code> 来处理 SAMBA 用户，命令常用选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-L</td>
<td>列出数据库中对应账号与 UID 等信息</td>
</tr>
<tr>
<td>-v</td>
<td>搭配 -L 参数显示更多详细信息</td>
</tr>
<tr>
<td>-w</td>
<td>搭配 -L 参数显示 smbpasswd 格式数据</td>
</tr>
<tr>
<td>-a</td>
<td>设置一个可使用 SAMBA 的用户账号</td>
</tr>
<tr>
<td>-r</td>
<td>修改一个账号相关信息</td>
</tr>
<tr>
<td>-x</td>
<td>删除一个可使用 SAMBA 的用户账号</td>
</tr>
<tr>
<td>-m</td>
<td>后接机器的代码（machine account），与 PDC 有关</td>
</tr>
</tbody>
</table>
<p>例如将用户 smbuser 加入到 SAMBA 的数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ pdbedit <span class="token parameter variable">-a</span> <span class="token parameter variable">-u</span> smbuser
new password:
retype new password:
Unix username:        smbuser
NT username:          
Account Flags:        <span class="token punctuation">[</span>U          <span class="token punctuation">]</span>
User SID:             S-1-5-21-4293618527-3344052101-3349617220-1000
Primary Group SID:    S-1-5-21-4293618527-3344052101-3349617220-513
Full Name:            
Home Directory:       <span class="token punctuation">\</span><span class="token punctuation">\</span>smbserver2<span class="token punctuation">\</span>smbuser
HomeDir Drive:        
Logon Script:         
Profile Path:         <span class="token punctuation">\</span><span class="token punctuation">\</span>smbserver2<span class="token punctuation">\</span>smbuser<span class="token punctuation">\</span>profile
Domain:               SMBSERVER2
Account desc:         
Workstations:         
Munged dial:          
Logon time:           <span class="token number">0</span>
Logoff time:          Wed, 06 Feb <span class="token number">2036</span> <span class="token number">23</span>:06:39 CST
Kickoff time:         Wed, 06 Feb <span class="token number">2036</span> <span class="token number">23</span>:06:39 CST
Password last set:    Mon, <span class="token number">11</span> Oct <span class="token number">2021</span> <span class="token number">23</span>:36:23 CST
Password can change:  Mon, <span class="token number">11</span> Oct <span class="token number">2021</span> <span class="token number">23</span>:36:23 CST
Password must change: never
Last bad password   <span class="token builtin class-name">:</span> <span class="token number">0</span>
Bad password count  <span class="token builtin class-name">:</span> <span class="token number">0</span>
Logon hours         <span class="token builtin class-name">:</span> FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ pdbedit <span class="token parameter variable">-L</span>
smbuser:1001:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改密码与删除用户示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ smbpasswd smbuser
New SMB password:
Retype new SMB password:
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ pdbedit <span class="token parameter variable">-x</span> <span class="token parameter variable">-u</span> smbuser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>共享用户目录需要在 SELinux 中放行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ setsebool <span class="token parameter variable">-P</span> samba_enable_home_dirs on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>局域网内可完全放开 SAMBA 对文件系统的读写：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ setsebool <span class="token parameter variable">-P</span> samba_export_all_rw <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>否则需要修改目录的类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">-t</span> samba_share_t /home/sharedir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>smb.conf</code> 配置文件如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/samba/smb.conf
<span class="token punctuation">[</span>global<span class="token punctuation">]</span>
        workgroup <span class="token operator">=</span> WORKGROUP
        netbios name <span class="token operator">=</span> smbserver2
        server string <span class="token operator">=</span> This is OPEN SAMBA server
        security <span class="token operator">=</span> user

        unix charset <span class="token operator">=</span> utf8
        display charset <span class="token operator">=</span> utf8
        dos charset <span class="token operator">=</span> cp936

        log <span class="token function">file</span> <span class="token operator">=</span> /var/log/samba/log.%m
        max log size <span class="token operator">=</span> <span class="token number">50</span>

        passdb backend <span class="token operator">=</span> tdbsam

        load printers <span class="token operator">=</span> no

<span class="token punctuation">[</span>homes<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> Home DIR
        writable <span class="token operator">=</span> <span class="token function">yes</span>
        browseable <span class="token operator">=</span> no
        create mode <span class="token operator">=</span> 0664
        directory mode <span class="token operator">=</span> 0775
<span class="token punctuation">[</span>sharedir<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> sharedir<span class="token punctuation">(</span>server2<span class="token punctuation">)</span>
        path <span class="token operator">=</span> /home/sharedir
        browseable <span class="token operator">=</span> <span class="token function">yes</span>
        writable <span class="token operator">=</span> <span class="token function">yes</span>
        <span class="token function">write</span> list <span class="token operator">=</span> @smbuser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="服务端启动"><a class="markdownIt-Anchor" href="#服务端启动"></a> 服务端启动</h2>
<p>设置好配置文件和相关账号权限后，就可以启动 SAMBA 服务了（nmb 有可能被 SELinux 阻拦）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> smb
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> nmb
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span> <span class="token function">grep</span> mbd
Active Internet connections <span class="token punctuation">(</span>only servers<span class="token punctuation">)</span>
Proto Recv-Q Send-Q Local Address     Foreign Address  State       PID/Program name 
tcp   <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0.0</span>.0.0:445       <span class="token number">0.0</span>.0.0:*        LISTEN      <span class="token number">80761</span>/smbd
tcp   <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0.0</span>.0.0:139       <span class="token number">0.0</span>.0.0:*        LISTEN      <span class="token number">80761</span>/smbd
udp   <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0.0</span>.0.0:137       <span class="token number">0.0</span>.0.0:*                    <span class="token number">80786</span>/nmbd
udp   <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0.0</span>.0.0:138       <span class="token number">0.0</span>.0.0:*                    <span class="token number">80786</span>/nmbd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="服务状态查询"><a class="markdownIt-Anchor" href="#服务状态查询"></a> 服务状态查询</h2>
<p>在启动后和运行中可以使用 <code>smbstatus</code> 命令来查看 SAMBA 服务的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 samba<span class="token punctuation">]</span>$ smbstatus

Samba version <span class="token number">4.10</span>.16
PID   Username Group    Machine                                   Protocol Version  Encryption           Signing              
-----------------------------------------------------------------------------------------
<span class="token number">85520</span> smbuser  smbuser  <span class="token number">192.168</span>.2.101 <span class="token punctuation">(</span>ipv4:192.168.2.101:62317<span class="token punctuation">)</span>  SMB3_11           -                    partial<span class="token punctuation">(</span>AES-128-CMAC<span class="token punctuation">)</span>
<span class="token number">84217</span> smbuser  smbuser  <span class="token number">192.168</span>.2.234 <span class="token punctuation">(</span>ipv4:192.168.2.234:41716<span class="token punctuation">)</span>  SMB3_02           -                    partial<span class="token punctuation">(</span>AES-128-CMAC<span class="token punctuation">)</span>

Service      pid     Machine       Connected at                     Encryption   Signing 
-----------------------------------------------------------------------------------------
smbuser      <span class="token number">84217</span>   <span class="token number">192.168</span>.2.234 Mon Oct <span class="token number">11</span> <span class="token number">11</span>:48:11 PM <span class="token number">2021</span> CST  -            -       
IPC$         <span class="token number">85520</span>   <span class="token number">192.168</span>.2.101 Tue Oct <span class="token number">12</span> <span class="token number">12</span>:10:30 AM <span class="token number">2021</span> CST  -            -       
sharedir     <span class="token number">84217</span>   <span class="token number">192.168</span>.2.234 Tue Oct <span class="token number">12</span> <span class="token number">12</span>:02:55 AM <span class="token number">2021</span> CST  -            -       
IPC$         <span class="token number">84217</span>   <span class="token number">192.168</span>.2.234 Mon Oct <span class="token number">11</span> <span class="token number">11</span>:48:11 PM <span class="token number">2021</span> CST  -            -       
sharedir     <span class="token number">85520</span>   <span class="token number">192.168</span>.2.101 Tue Oct <span class="token number">12</span> <span class="token number">12</span>:40:25 AM <span class="token number">2021</span> CST  -            -       

Locked files:
Pid    User<span class="token punctuation">(</span>ID<span class="token punctuation">)</span>  DenyMode   Access    R/W     Oplock  SharePath   Name   Time
-----------------------------------------------------------------------------------------
<span class="token number">85520</span>  <span class="token number">1001</span>      DENY_NONE  0x100081  RDONLY  NONE    /home/sharedir   <span class="token builtin class-name">.</span> Tue Oct <span class="token number">12</span> 00:40:32 <span class="token number">2021</span>
<span class="token number">85520</span>  <span class="token number">1001</span>      DENY_NONE  0x100081  RDONLY  NONE    /home/sharedir   <span class="token builtin class-name">.</span> Tue Oct <span class="token number">12</span> 01:06:15 <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="客户端操作"><a class="markdownIt-Anchor" href="#客户端操作"></a> 客户端操作</h1>
<p>一些最常见的客户端操作命令。</p>
<h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2>
<p>可以通过 <code>nmblookup</code> 命令来查询 NetBIOS Name 与 IP 对应信息，例如查询 I5-103 对应的 IP 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 sss<span class="token punctuation">]</span>$ nmblookup <span class="token parameter variable">-S</span> I5-103
<span class="token number">192.168</span>.2.103 I5-10<span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span><span class="token number">0</span><span class="token operator"><span class="token file-descriptor important">0</span>></span>
Looking up status of <span class="token number">192.168</span>.2.103
        I5-103          <span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator"><span class="token file-descriptor important">0</span>></span> -         B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 
        WORKGROUP       <span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator"><span class="token file-descriptor important">0</span>></span> - <span class="token operator">&lt;</span>GROUP<span class="token operator">></span> B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 
        I5-103          <span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator"><span class="token file-descriptor important">0</span>></span> -         B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 
        WORKGROUP       <span class="token operator">&lt;</span>1e<span class="token operator">></span> - <span class="token operator">&lt;</span>GROUP<span class="token operator">></span> B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 
        WORKGROUP       <span class="token operator">&lt;</span>1d<span class="token operator">></span> -         B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 
        <span class="token punctuation">..</span>__MSBROWSE__. <span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator"><span class="token file-descriptor important">1</span>></span> - <span class="token operator">&lt;</span>GROUP<span class="token operator">></span> B <span class="token operator">&lt;</span>ACTIVE<span class="token operator">></span> 

        MAC Address <span class="token operator">=</span> <span class="token number">30</span>-85-A9-4C-F1-86<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>smbtree</code> 用树状图列出 SAMBA 服务器情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 sss<span class="token punctuation">]</span>$ smbtree
Enter SAMBA<span class="token punctuation">\</span>root's password: 
WORKGROUP
        <span class="token punctuation">\</span><span class="token punctuation">\</span>X9-102         
        <span class="token punctuation">\</span><span class="token punctuation">\</span>SMBSERVER2                    This is OPEN SAMBA server
                <span class="token punctuation">\</span><span class="token punctuation">\</span>SMBSERVER2<span class="token punctuation">\</span>IPC$               IPC Service <span class="token punctuation">(</span>This is OPEN SAMBA server<span class="token punctuation">)</span>
                <span class="token punctuation">\</span><span class="token punctuation">\</span>SMBSERVER2<span class="token punctuation">\</span>sharedir           sharedir<span class="token punctuation">(</span>server2<span class="token punctuation">)</span>
        <span class="token punctuation">\</span><span class="token punctuation">\</span>I5-103         
        <span class="token punctuation">\</span><span class="token punctuation">\</span>DESKTOP-QU8VM21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h2>
<p>可以通过 <code>smbclient</code> 程序来查询 SAMBA 服务是否正常：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ smbclient <span class="token parameter variable">-L</span> //192.168.2.254
Enter SAMBA<span class="token punctuation">\</span>root's password: 
Anonymous login successful

        Sharename       Type      Comment
        ---------       ----      -------
        sharedir        Disk      sharedir<span class="token punctuation">(</span>server2<span class="token punctuation">)</span>
        IPC$            IPC       IPC Service <span class="token punctuation">(</span>This is OPEN SAMBA server<span class="token punctuation">)</span>
Reconnecting with SMB1 <span class="token keyword">for</span> workgroup listing.
Anonymous login successful

        Server               Comment
        ---------            -------
        Workgroup            Master
        ---------            -------
        WORKGROUP     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>指定使用 smbuser 账号连接 smb 服务器 192.168.2.254：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 sss<span class="token punctuation">]</span>$ smbclient //192.168.2.254/sharedir <span class="token parameter variable">-U</span> smbuser
Enter SAMBA<span class="token punctuation">\</span>smbuser's password: 
Try <span class="token string">"help"</span> to get a list of possible commands.
smb: <span class="token punctuation">\</span><span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h2>
<p>可以直接使用 <code>mount</code> 命令来挂载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> cifs //192.168.2.254/temp /root/111/
Password <span class="token keyword">for</span> root@//192.168.2.254/temp:  
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> cifs //192.168.2.254/smbuser /root/myhome <span class="token parameter variable">-o</span> <span class="token assign-left variable">username</span><span class="token operator">=</span>smbuser
Password <span class="token keyword">for</span> smbuser@//192.168.2.254/smbuser:  ****
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> cifs //192.168.2.254/sharedir /root/sss <span class="token parameter variable">-o</span> <span class="token assign-left variable">username</span><span class="token operator">=</span>smbuser
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">df</span>
Filesystem              1K-blocks    Used Available Use% Mounted on
//192.168.2.254/temp      <span class="token number">1020580</span>   <span class="token number">33092</span>    <span class="token number">987488</span>   <span class="token number">4</span>% /root/111
//192.168.2.254/smbuser   <span class="token number">5109760</span>   <span class="token number">33084</span>   <span class="token number">5076676</span>   <span class="token number">1</span>% /root/myhome
//192.168.2.254/sharedir   <span class="token number">5109760</span>   <span class="token number">33120</span>   <span class="token number">5076640</span>   <span class="token number">1</span>% /root/sss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>针对 Windows 下文件系统中使用中文字符，可以指定 <code>mount</code> 挂载参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> ntfs <span class="token parameter variable">-o</span> <span class="token assign-left variable">iocharset</span><span class="token operator">=</span>utf8,codepage<span class="token operator">=</span><span class="token number">936</span> //192.168.2.101/temp <span class="token number">222</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Windows 下也可以直接使用 <code>\\192.168.2.254\</code> 来访问 SAMBA 服务器（不支持匿名模式）。</p>
<h1 id="pdc-服务器搭建"><a class="markdownIt-Anchor" href="#pdc-服务器搭建"></a> PDC 服务器搭建</h1>
<p>SAMBA PDC 的作用很简单，就是让 PDC 成为整个局域网的域管理员（Domain Controller），然后把主机加入到这个域中。域内的用户账户和用户数据都由 PDC 来管理。</p>
<p>PDC 服务器的搭建步骤如下。</p>
<h2 id="设置本地解析"><a class="markdownIt-Anchor" href="#设置本地解析"></a> 设置本地解析</h2>
<p>将 NetBIOS Name 与 IP 的对应填入 <code>/etc/samba/lmosts</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.254 smbserver2"</span> <span class="token operator">>></span> /etc/samba/lmhosts
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.234 smblinux"</span> <span class="token operator">>></span> /etc/samba/lmhosts
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.101 DESKTOP-QU8VM21"</span> <span class="token operator">>></span> /etc/samba/lmhosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于 NetBIOS Name 和 Hostname 不一样，因此还要修改 <code>/etc/hosts</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/192.168.2.254  server2/192.168.2.254  server2 smbserver2/g"</span> /etc/hosts
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/192.168.2.234  server1/192.168.2.234  server1 smblinux/g"</span> /etc/hosts
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.101 DESKTOP-QU8VM21"</span> <span class="token operator">>></span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="配置-smbconf"><a class="markdownIt-Anchor" href="#配置-smbconf"></a> 配置 smb.conf</h2>
<p>需要让 PDC 客户端登录时可以取得用户主目录。<code>smb.conf</code> 文件内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/samba/smb.conf
<span class="token punctuation">[</span>global<span class="token punctuation">]</span>
        workgroup <span class="token operator">=</span> WORKGROUP
        netbios name <span class="token operator">=</span> smbserver2
        server string <span class="token operator">=</span> This is OPEN SAMBA server
        security <span class="token operator">=</span> user
        unix charset <span class="token operator">=</span> utf8
        dos charset <span class="token operator">=</span> cp936
        log <span class="token function">file</span> <span class="token operator">=</span> /var/log/samba/log.%m
        max log size <span class="token operator">=</span> <span class="token number">50</span>
        passdb backend <span class="token operator">=</span> tdbsam
        load printers <span class="token operator">=</span> no

        preferred master <span class="token operator">=</span> <span class="token function">yes</span>
        domain master <span class="token operator">=</span> <span class="token function">yes</span>
        <span class="token builtin class-name">local</span> master <span class="token operator">=</span> <span class="token function">yes</span>
        wins support <span class="token operator">=</span> <span class="token function">yes</span>
        os level <span class="token operator">=</span> <span class="token number">100</span>
        domain logons <span class="token operator">=</span> <span class="token function">yes</span>
        logon drive <span class="token operator">=</span> K:
        logon script <span class="token operator">=</span> startup.bat
        <span class="token function">time</span> server <span class="token operator">=</span> <span class="token function">yes</span>
        admin <span class="token function">users</span> <span class="token operator">=</span> root
        logon path <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token punctuation">\</span>%N<span class="token punctuation">\</span>%U<span class="token punctuation">\</span>profile
        logon home <span class="token operator">=</span> <span class="token punctuation">\</span><span class="token punctuation">\</span>%N<span class="token punctuation">\</span>%U
<span class="token punctuation">[</span>netlogon<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> Network Logon
        path <span class="token operator">=</span> /winhome/netlogon
        writable <span class="token operator">=</span> no
        <span class="token function">write</span> list <span class="token operator">=</span> root
        follow symlinks <span class="token operator">=</span> <span class="token function">yes</span>
        guest ok <span class="token operator">=</span> <span class="token function">yes</span>

<span class="token punctuation">[</span>homes<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> Home DIR
        writable <span class="token operator">=</span> <span class="token function">yes</span>
        browseable <span class="token operator">=</span> no
        create mode <span class="token operator">=</span> 0664
        directory mode <span class="token operator">=</span> 0775
<span class="token punctuation">[</span>sharedir<span class="token punctuation">]</span>
        comment <span class="token operator">=</span> sharedir<span class="token punctuation">(</span>server2<span class="token punctuation">)</span>
        path <span class="token operator">=</span> /home/sharedir
        browseable <span class="token operator">=</span> <span class="token function">yes</span>
        writable <span class="token operator">=</span> <span class="token function">yes</span>
        <span class="token function">write</span> list <span class="token operator">=</span> @smbuser
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ testparm
Load smb config files from /etc/samba/smb.conf
Loaded services <span class="token function">file</span> OK.
idmap range not specified <span class="token keyword">for</span> domain <span class="token string">'*'</span>
ERROR: Invalid idmap range <span class="token keyword">for</span> domain *<span class="token operator">!</span>

Server role: ROLE_DOMAIN_PDC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和 PDC 有关的参数：</p>
<ul>
<li>time server：设置 SAMBA 与 Windows 主机的时间同步。</li>
<li>logon script：当用户通过 Windows 客户端登录后运行的批处理文件。文件需要放置到指定目录内。</li>
<li>logon drive：用户主目录挂载到的分区盘符。</li>
<li>admin users：指定 SAMBA PDC 的管理员身份。</li>
<li>[netlogon]：指定利用网络登录后使用的目录资源。</li>
<li>logon path：用户登录后，环境配置文件所在目录。</li>
<li>logon home：用户的主目录，默认放置到与 Linux 的用户主目录相同位置。</li>
</ul>
<p>配置文件没问题后重启 smb 和 nmb 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart smb
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart nmb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="建立对应目录"><a class="markdownIt-Anchor" href="#建立对应目录"></a> 建立对应目录</h2>
<p>预计将所有的 PDC 数据放到 <code>/winhome</code> 内：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /winhome/netlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>建立用户脚本文件，主要设置时间同步和用户目录挂载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /winhome/netlogon/startup.bat
net <span class="token function">time</span> <span class="token punctuation">\</span><span class="token punctuation">\</span>smbserver2 /set /yes
net use K: /home
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ unix2dos /winhome/netlogon/startup.bat 
unix2dos: converting <span class="token function">file</span> /winhome/netlogon/startup.bat to DOS <span class="token function">format</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立对应用户"><a class="markdownIt-Anchor" href="#建立对应用户"></a> 建立对应用户</h2>
<p>建立一个 smbwin 的用户并指定用户目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-d</span> /winhome/smbwin <span class="token parameter variable">-p</span> <span class="token number">3333</span> smbwin
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /winhome/smbwin/profile
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token parameter variable">-R</span> smbwin:smbwin /winhome/smbwin/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将用户加入到 SAMBA 数据库，设置密码为 2222：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ smbpasswd <span class="token parameter variable">-a</span> root
New SMB password:
Retype new SMB password:
Added user root.
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ smbpasswd <span class="token parameter variable">-a</span> smbwin
New SMB password:
Retype new SMB password:
Added user smbwin.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立机器码账号"><a class="markdownIt-Anchor" href="#建立机器码账号"></a> 建立机器码账号</h2>
<p>由于 PDC 会针对 Windows 客户端的主机名（NetBIOS Name）进行主机账号检查，所以要为客户端的主机名进行账号的设置。主机账号在主机名后加个 <code>$</code> 即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-M</span> <span class="token parameter variable">-s</span> /sbin/nologin <span class="token parameter variable">-d</span> /dev/null DESKTOP-QU8VM21$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>账号被设置为不能登录，将其加入到 SAMBA 数据库中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ smbpasswd <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> DESKTOP-QU8VM21$
Added user DESKTOP-QU8VM21$.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="修改安全性配置"><a class="markdownIt-Anchor" href="#修改安全性配置"></a> 修改安全性配置</h2>
<p>由于 <code>/winhome</code> 为自建目录，需要修改目录的 SELinux 类型为 <code>samba_share_t</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">-R</span> <span class="token parameter variable">-t</span> samba_share_t /winhome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="pdc-客户端操作"><a class="markdownIt-Anchor" href="#pdc-客户端操作"></a> PDC 客户端操作</h1>
<p>客户端需要一些系统设置才能登录。</p>
<h2 id="修改注册表"><a class="markdownIt-Anchor" href="#修改注册表"></a> 修改注册表</h2>
<p>在 Win10 中需要修改注册表才支持通过 SAMBA 登录。修改位置为：<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters</code>。</p>
<p>添加两个 DWORD 值：<code>DomainCompatibilityMode = 1</code> 和 <code>DNSNameResolutionRequired = 0</code>。</p>
<h2 id="设置主机名与域名"><a class="markdownIt-Anchor" href="#设置主机名与域名"></a> 设置主机名与域名</h2>
<p>在 “计算机属性 – 高级系统设置 – 计算机名” 页面中，点击 “网络 ID” 按钮进入加入域或工作组页面。</p>
<p>在描述网络选项中，选择办公网络，单击下一步。</p>
<p>选择使用域的网络，单击下一步两次。</p>
<p>在键入域账户的用户名，密码和域名页面，填写用户名 root，密码为记录在 SAMBA 中的 root 密码。单击下一步。</p>
<p>在填写计算机名和域名页面，填写计算机域名 WORKGROUP。单击下一步。</p>
<p>在弹出域用户名和密码页面，填入 root 用户和密码，域名依然是 WORKGROUP。单击确定按钮。</p>
<p>在是否要启用域用户账户页面，选择目前不添加，由 PDC 来管控。单击下一步。</p>
<p>单击完成后重启计算机。</p>
<h2 id="用户登录"><a class="markdownIt-Anchor" href="#用户登录"></a> 用户登录</h2>
<p>重启之后便可选择域名，以及使用 PDC 记录的用户名 smbwin 来登录，本机账号不受影响。</p>
<p>用户登陆后，会将 K 盘挂载成用户主目录，可以在里头工作，数据将直接保存在 <code>/winhome/smbwin</code> 中。</p>
<p>用户注销之后，在桌面上进行的各项个人化设置会被移动到 <code>/winhome/smbwin/profile.v6</code> 目录中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 smbwin<span class="token punctuation">]</span>$ ll profile.V6/Desktop/
total <span class="token number">16</span>
-rw-rw-r--+ <span class="token number">1</span> smbwin smbwin   <span class="token number">282</span> Oct <span class="token number">12</span> 03:38 desktop.ini
-rw-rw----+ <span class="token number">1</span> smbwin smbwin <span class="token number">11613</span> Oct <span class="token number">12</span> 03:44 新建 Microsoft Word 文档.docx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 中引导与启动流程</title>
    <url>/4291230975/</url>
    <content><![CDATA[<h1 id="bios-启动流程"><a class="markdownIt-Anchor" href="#bios-启动流程"></a> BIOS 启动流程</h1>
<p>当前，主机系统在载入硬件驱动方面的程序有两种：使用 BIOS 和 UEFI。简单的启动流程可以分为以下步骤：</p>
<ol>
<li>载入 BIOS 或 UEFI 的硬件信息与自检（POST，Power-On Self-Test），并根据设置选择第一个可启动的设备。</li>
<li>对于 BIOS，通过硬件的 INT 13 中断功能，读取并执行第一个可启动设备内 MBR 的引导加载程序（Boot Loader）；对于 UEFI，读取并执行第一个可启动设备内 EFI 分区的引导加载程序。</li>
<li>根据引导加载程序的设置，识别文件系统格式，并加载核心文件。内核开始检测硬件与驱动程序。</li>
<li>启动初始进程管理程序（systemd 或 System V），最终目的是启动基础服务和用户设置的启动程序。</li>
</ol>
<p>在使用 BIOS 时，通常搭配 MBR（Master Boot Record）分区表。而在使用 UEFI 时，通常搭配 GPT（GUID Partition Table）分区表。GPT 格式的启动过程与 MBR 类似，不同之处在于开机管理程序是否支持 GPT。</p>
<p>当引导加载程序读取到内核文件后，Linux 将内核解压缩到内存中，并开始测试和驱动硬件。此时，Linux 内核将以自己的检测结果为准，而不考虑 BIOS 的硬件检测结果。也就是说，内核此时开始接管 BIOS 后的工作。</p>
<h1 id="多系统引导"><a class="markdownIt-Anchor" href="#多系统引导"></a> 多系统引导</h1>
<p>引导加载程序除了可以安装在 MBR 外，还可以安装到每个文件系统的引导扇区（Boot Sector）。</p>
<p>例如，硬盘第一和第二分区分别安装了 Windows 和 Linux。开机装载第一个分区引导加载程序，此时会出现分支选项：</p>
<ul>
<li>选择启动 Windows，直接加载第一个分区中的 Windows 核心文件。</li>
<li>选择启动 Linux，则转到第二个分区的引导扇区，由第二个分区的引导加载程序完成 Linux 系统启动工作。</li>
</ul>
<p>如果要安装多重开机，一般先安装 Windows 再安装 Linux，因为 Windows 安装时会直接覆盖掉 MBR 以及自己所在分区的引导扇区，并且 Windows 的引导程序默认没有转移引导功能。而 Linux 安装时可以选择引导加载程序不安装到 MBR，只装在指定分区的引导扇区。之后修改引导程序加入 Windows 开机选项，完成双系统引导功能。</p>
<h1 id="引导目录说明"><a class="markdownIt-Anchor" href="#引导目录说明"></a> 引导目录说明</h1>
<p>如果使用 GRUB 引导，需要在 <code>/boot</code> 分区中存放开机过程所需的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll /boot
total <span class="token number">149232</span>
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">153596</span> Aug <span class="token number">31</span> <span class="token number">10</span>:57 config-3.10.0-1160.41.1.el7.x86_64
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">147819</span> Apr <span class="token number">20</span>  <span class="token number">2018</span> config-3.10.0-862.el7.x86_64
drwxr-xr-x. <span class="token number">3</span> root root       <span class="token number">17</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:34 efi
drwxr-xr-x. <span class="token number">2</span> root root       <span class="token number">27</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:35 grub
drwx------. <span class="token number">5</span> root root      <span class="token number">132</span> Sep  <span class="token number">7</span> 05:55 grub2
-rw-------. <span class="token number">1</span> root root <span class="token number">55385253</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:37 initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
-rw-------. <span class="token number">1</span> root root <span class="token number">21322754</span> Sep  <span class="token number">7</span> 05:55 initramfs-3.10.0-1160.41.1.el7.x86_64.img
-rw-------. <span class="token number">1</span> root root <span class="token number">13851614</span> Sep <span class="token number">18</span> <span class="token number">23</span>:13 initramfs-3.10.0-1160.41.1.el7.x86_64kdump.img
-rw-------. <span class="token number">1</span> root root <span class="token number">21288233</span> Sep  <span class="token number">7</span> 05:56 initramfs-3.10.0-862.el7.x86_64.img
-rw-------. <span class="token number">1</span> root root <span class="token number">13761710</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:00 initramfs-3.10.0-862.el7.x86_64kdump.img
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">320757</span> Aug <span class="token number">31</span> <span class="token number">10</span>:57 symvers-3.10.0-1160.41.1.el7.x86_64.gz
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">304926</span> Apr <span class="token number">20</span>  <span class="token number">2018</span> symvers-3.10.0-862.el7.x86_64.gz
-rw-------. <span class="token number">1</span> root root  <span class="token number">3620596</span> Aug <span class="token number">31</span> <span class="token number">10</span>:57 System.map-3.10.0-1160.41.1.el7.x86_64
-rw-------. <span class="token number">1</span> root root  <span class="token number">3409143</span> Apr <span class="token number">20</span>  <span class="token number">2018</span> System.map-3.10.0-862.el7.x86_64
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">6224704</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:37 vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">6773352</span> Aug <span class="token number">31</span> <span class="token number">10</span>:57 vmlinuz-3.10.0-1160.41.1.el7.x86_64
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">6224704</span> Apr <span class="token number">20</span>  <span class="token number">2018</span> vmlinuz-3.10.0-862.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>/boot</code> 内文件与目录说明如下所示：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>config-*</td>
<td>此版本内核被编译时选择的功能与模块配置文件。</td>
</tr>
<tr>
<td>grub、grub2</td>
<td>开机管理程序 grub 相关数据目录。</td>
</tr>
<tr>
<td>initramfs-0-rescue-*</td>
<td>救援模式的虚拟文件系统。</td>
</tr>
<tr>
<td>initramfs-*.img</td>
<td>正常模式的虚拟文件系统。</td>
</tr>
<tr>
<td>initramfs-*kdump.img</td>
<td>内核出问题时用到的虚拟文件系统。</td>
</tr>
<tr>
<td>System.map-*</td>
<td>内核功能放置到内存地址的对应表。</td>
</tr>
<tr>
<td>vmlinuz-0-rescue-*</td>
<td>救援模式的内核文件。</td>
</tr>
<tr>
<td>vmlinuz-*</td>
<td>正常模式的内核文件。</td>
</tr>
</tbody>
</table>
<h1 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h1>
<p>Linux 内核可以动态载入内核模块（驱动），这些内核模块放置在 <code>/lib/modules/</code> 目录内。由于模块放置到根目录内，因此开机过程中内核必须要以只读方式挂载根目录，才可以读取到驱动程序。</p>
<p>但是在挂载根目录时，很大可能 Linux 内核并不认识 SATA 设备。为了让内核顺利执行下去，引用了一个虚拟文件系统（Initial RAM Disk 或 Initial RAM Filesystem）来处理，就是在 <code>/boot</code> 目录内以 initramfs 开头命名的 img 文件。</p>
<p>虚拟文件系统的 img 文件也能被引导加载程序载入到内存中，解压后在内存中仿真成一个根目录。内核会读取虚拟文件系统内的驱动，通常是与磁盘接口和文件系统格式支持有关的驱动程序。</p>
<p>等驱动载入完毕，根目录所在分区信息被正确识别后，此虚拟文件系统被卸载，并挂载实际的根目录文件系统，继续后续开机流程。</p>
<p>可以使用 <code>lsinitrd</code> 命令查看 initramfs 镜像的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lsinitrd /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img 
Image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img: 21M
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Early CPIO image
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
drwxr-xr-x   <span class="token number">3</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 <span class="token builtin class-name">.</span>
-rw-r--r--   <span class="token number">1</span> root     root            <span class="token number">2</span> Sep  <span class="token number">7</span> 05:55 early_cpio
drwxr-xr-x   <span class="token number">3</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 kernel
drwxr-xr-x   <span class="token number">3</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 kernel/x86
drwxr-xr-x   <span class="token number">2</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 kernel/x86/microcode
-rw-r--r--   <span class="token number">1</span> root     root         <span class="token number">6476</span> Sep  <span class="token number">7</span> 05:55 kernel/x86/microcode/AuthenticAMD.bin
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Version: dracut-033-572.el7

Arguments: <span class="token parameter variable">-f</span>

dracut modules:
<span class="token function">bash</span>
nss-softokn
i18n
microcode_ctl-fw_dir_override
<span class="token function">shutdown</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
drwxr-xr-x  <span class="token number">12</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 <span class="token builtin class-name">.</span>
crw-r--r--   <span class="token number">1</span> root     root       <span class="token number">5</span>,   <span class="token number">1</span> Sep  <span class="token number">7</span> 05:55 dev/console
crw-r--r--   <span class="token number">1</span> root     root       <span class="token number">1</span>,  <span class="token number">11</span> Sep  <span class="token number">7</span> 05:55 dev/kmsg
crw-r--r--   <span class="token number">1</span> root     root       <span class="token number">1</span>,   <span class="token number">3</span> Sep  <span class="token number">7</span> 05:55 dev/null
lrwxrwxrwx   <span class="token number">1</span> root     root            <span class="token number">7</span> Sep  <span class="token number">7</span> 05:55 bin -<span class="token operator">></span> usr/bin
drwxr-xr-x   <span class="token number">2</span> root     root            <span class="token number">0</span> Sep  <span class="token number">7</span> 05:55 dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，这个 img 文件可以分为两部分。前半部分包括一些预先声明的数据，其中包括一个可执行的 bin 文件；而后半部分才是内核会去读取的重要文件。</p>
<p>进一步解压整个 img 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ <span class="token function">cp</span> /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img init.img
<span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ <span class="token function">file</span> init.img 
init.img: ASCII cpio archive <span class="token punctuation">(</span>SVR4 with no CRC<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ /usr/lib/dracut/skipcpio init.img <span class="token operator">|</span> zcat <span class="token operator">|</span> cpio <span class="token parameter variable">-div</span>
init
<span class="token function">shutdown</span>
<span class="token number">88189</span> blocks
<span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ ll
total <span class="token number">8</span>
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">7</span> Sep <span class="token number">19</span> 09:10 bin -<span class="token operator">></span> usr/bin
drwxr-xr-x.  <span class="token number">2</span> root root   <span class="token number">45</span> Sep <span class="token number">19</span> 09:10 dev
drwxr-xr-x. <span class="token number">12</span> root root <span class="token number">4096</span> Sep <span class="token number">19</span> 09:10 etc
lrwxrwxrwx.  <span class="token number">1</span> root root   <span class="token number">23</span> Sep <span class="token number">19</span> 09:10 init -<span class="token operator">></span> usr/lib/systemd/systemd
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">7</span> Sep <span class="token number">19</span> 09:10 lib -<span class="token operator">></span> usr/lib
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">9</span> Sep <span class="token number">19</span> 09:10 lib64 -<span class="token operator">></span> usr/lib64
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 proc
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 root
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 run
lrwxrwxrwx.  <span class="token number">1</span> root root    <span class="token number">8</span> Sep <span class="token number">19</span> 09:10 sbin -<span class="token operator">></span> usr/sbin
-rwxr-xr-x.  <span class="token number">1</span> root root <span class="token number">3117</span> Sep <span class="token number">19</span> 09:10 <span class="token function">shutdown</span>
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 sys
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 sysroot
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep <span class="token number">19</span> 09:10 tmp
drwxr-xr-x.  <span class="token number">7</span> root root   <span class="token number">66</span> Sep <span class="token number">19</span> 09:10 usr
drwxr-xr-x.  <span class="token number">2</span> root root   <span class="token number">29</span> Sep <span class="token number">19</span> 09:10 var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解压后查询下这个文件系统中 systemd 调用的运行模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ ll usr/lib/systemd/system/default.target
lrwxrwxrwx. <span class="token number">1</span> root root <span class="token number">13</span> Sep <span class="token number">19</span> 09:10 usr/lib/systemd/system/default.target -<span class="token operator">></span> initrd.target
<span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ systemctl list-dependencies initrd.target
initrd.target
● ├─dracut-cmdline.service
● ├─dracut-initqueue.service
● ├─dracut-mount.service
● ├─dracut-pre-mount.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过查询 initrd.target 可以知道内核先是用载入虚拟文件系统中的 basic.target、sysinit.target 等功能启用的流程，让系统顺利运行，再卸载虚拟文件系统，挂载实际系统根目录。</p>
<p>如果想要创建一个自定义的 initramfs 镜像，可以使用 <code>dracut</code> 或 <code>mkinitrd</code> 来处理。例如，新建一个添加了 x200 网卡驱动和 nfs 文件系统驱动的 initramfs 镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ dracut <span class="token parameter variable">-v</span> -add-drivers <span class="token string">"x200"</span> <span class="token parameter variable">--filesystems</span> <span class="token string">"nfs"</span> <span class="token operator">></span> initramfs-new.img <span class="token operator">&amp;</span> <span class="token punctuation">(</span>uname -r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="systemd-启动流程"><a class="markdownIt-Anchor" href="#systemd-启动流程"></a> Systemd 启动流程</h1>
<p>Systemd 是一种系统和服务管理器，是 Linux 系统中的一项关键技术。它可以用于启动、停止和管理系统进程、网络、文件系统和其他系统资源。Systemd 最初是为 Red Hat Linux 发行版设计的，但现在已被广泛采用，并被大多数 Linux 发行版所使用。</p>
<p>Systemd 的主要优势是速度和可靠性。它的启动速度远远快于传统的 init 系统，因为它能够并行启动多个服务。此外，Systemd 还提供了强大的日志功能和灵活的单元文件格式，可用于管理各种类型的服务和资源。</p>
<p>Systemd 还引入了一些新的概念，例如单元和片段。单元是 Systemd 中的基本单位，用于描述系统资源，如服务、套接字、挂载点等。片段是单元文件的组成部分，可供其他单元文件重用。这种灵活性使得 Systemd 能够更容易地管理和组织系统资源，使其更加模块化和可重用。</p>
<h2 id="启动流程"><a class="markdownIt-Anchor" href="#启动流程"></a> 启动流程</h2>
<p>在内核载入完毕硬件驱动后，采用 Systemd 管理服务的启动流程如下：</p>
<ol>
<li>内核会主动调用第一个程序 <code>systemd</code> 执行 sysinit.target，初始化系统及准备基本系统；</li>
<li>接下来进入 <code>/usr/lib/systemd/system/</code> 目录，调用 multi-user.target（default.target）；</li>
<li>然后系统会去 <code>/etc/systemd/system/multi-user.target.wants/</code> 目录查找用户设置的开机启动服务（unit）；</li>
<li>最后到 <code>/usr/lib/systemd/system/multi-user.target.wants/</code> 目录查找系统默认的开机启动服务（unit）；</li>
<li>（非必需）执行图形化界面所需的服务。</li>
</ol>
<p>关于最终启动的服务有哪些，可以使用 <code>systemctl list-dependencies</code> 命令查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ systemctl list-dependencies multi-user.target <span class="token operator">|</span> <span class="token function">grep</span> target
multi-user.target
● ├─basic.target
● │ ├─selinux-policy-migrate-local-changes@targeted.service
● │ ├─paths.target
● │ ├─slices.target
● │ ├─sockets.target
● │ ├─sysinit.target
● │ │ ├─cryptsetup.target
● │ │ ├─local-fs.target
● │ │ └─swap.target
● │ └─timers.target
● ├─getty.target
● └─remote-fs.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，为了与之前通过 <code>/etc/rc.d/rc.local</code> 配置自启动脚本的方式保持兼容，CentOS 7 引入了一个名为 rc-local.service 的服务来执行这些脚本。</p>
<h2 id="启动相关目录"><a class="markdownIt-Anchor" href="#启动相关目录"></a> 启动相关目录</h2>
<p>开机会读取的文件目录如下：</p>
<ul>
<li><code>/etc/modules-load.d/*.conf</code>：配置内核需要加载的模块。</li>
<li><code>/etc/modprobe.d/*.conf</code>：可以设置模块参数的配置。</li>
<li><code>/etc/sysconfig/</code>：系统配置目录下有许多环境配置文件，其中一些重要的文件包括：
<ul>
<li><code>authconfig</code>：用于规范用户身份认证机制，包括是否使用本地的 <code>/etc/passwd</code>、<code>/etc/shadow</code> 等文件以及密码记录使用的加密算法，是否使用外部密码服务器提供的账号验证（如 NIS、LDAP）等。</li>
<li><code>cpupower</code>：如果启动了 <code>cpupower.service</code> 服务，会读取此配置文件。</li>
<li><code>firewalld</code>、<code>iptables-config</code>、<code>iptables-config</code>、<code>ebtables-config</code>：与防火墙服务相关的配置。</li>
<li><code>network-scripts</code>：网卡设置。</li>
</ul>
</li>
</ul>
<h1 id="system-v-启动流程"><a class="markdownIt-Anchor" href="#system-v-启动流程"></a> System V 启动流程</h1>
<p>System V (System 5) 是 Unix 操作系统中的一个初始化系统。它是早期 Unix 系统的标准初始化系统，常见于许多 Linux 发行版中。System V 通过运行一个脚本，逐个启动和停止系统服务来初始化系统。这些脚本通常存储在 <code>/etc/rc.d/init.d/</code> 目录下，每个脚本对应着一个系统服务。在系统启动或关闭时，System V 会根据 <code>/etc/inittab</code> 文件的配置来执行这些脚本。</p>
<p>System V 的缺点在于启动过程比较慢，因为它需要逐个启动和停止每个系统服务，这使得启动时间较长。此外，System V 在处理系统服务时需要手动编写脚本，并且难以处理服务之间的依赖关系，这可能导致系统启动失败或服务无法正常运行。由于这些缺点，现代 Linux 发行版逐渐转向使用 Systemd 作为默认初始化系统。</p>
<h2 id="启动流程-2"><a class="markdownIt-Anchor" href="#启动流程-2"></a> 启动流程</h2>
<p>在内核加载完硬件驱动后，内核会主动调用第一个进程 <code>/sbin/init</code>。它最主要的功能是准备软件执行环境。启动流程如下：</p>
<ol>
<li>init 取得默认执行等级，执行 <code>/etc/rc.d/rc.sysinit</code> 文件来准备软件执行的操作环境，例如网络和时区等。</li>
<li>init 执行 run level 的各个服务的启动（脚本方式）。例如执行等级是 5，则只执行 <code>5:5:wait:/etc/rc.d/rc5</code> 这行：
<ul>
<li>和 rc5 相关的脚本存放在 <code>/etc/rc5.d/</code> 下面，以 Kxx 开头的文件代表执行 stop，以 Sxx 开头代表执行 start 操作。</li>
<li>这些脚本全部是连接文件，连接到 stand alone 服务启动的目录 <code>/etc/init.d/</code>内。</li>
<li>S 或 K 后面两位数字代表执行顺序，数字越小执行越早。</li>
</ul>
</li>
<li>设置好组合键功能和不断电系统 pf、pr 机制。</li>
<li>执行用户自定义脚本 <code>/etc/rc.d/rc.local</code> 中的程序。</li>
<li>启动终端模拟程序 <code>mingetty</code>，以启动登录进程。</li>
<li>（非必须）启动图形界面，通过执行 <code>/etc/X11/perfdm -nodaemon</code> 来启动。</li>
</ol>
<h2 id="启动相关目录-2"><a class="markdownIt-Anchor" href="#启动相关目录-2"></a> 启动相关目录</h2>
<p>在系统启动过程中，有一些与配置相关的目录和文件：</p>
<ul>
<li>
<p><code>/etc/modprobe.conf</code></p>
<p>这个文件定义了系统启动时需要加载的模块。模块文件存放在 <code>/etc/sysconfig/modules/</code> 目录下。</p>
</li>
<li>
<p><code>/etc/sysconfig/*</code></p>
<p>这个目录下的文件与系统服务的配置相关。其中一些重要的文件包括：</p>
<ul>
<li><code>authconfig</code>：用于设置用户身份认证机制。</li>
<li><code>clock</code>：用于设置 Linux 主机的时区。</li>
<li><code>i18n</code>：用于设置语言环境。</li>
<li><code>keyboard</code> 和 <code>mouse</code>：用于设置键盘和鼠标的样式。</li>
<li><code>network</code>：用于设置网络启用、主机名和网关。</li>
<li><code>network-scripts</code>：用于设置网卡配置。</li>
</ul>
</li>
</ul>
<h2 id="init-配置文件"><a class="markdownIt-Anchor" href="#init-配置文件"></a> init 配置文件</h2>
<p>系统的初始化过程通过配置文件 <code>/etc/inittab</code> 进行规划。每一行配置由冒号<code>:</code>分隔的四个字段组成：</p>
<ul>
<li>
<p><strong>设置选项</strong></p>
<p>这是一个最多四个字符的字段，用于说明 init 的主要工作选项。</p>
</li>
<li>
<p><strong>执行等级</strong></p>
<p>这个字段表示在哪些执行等级下运行该选项。例如，35 表示在执行等级 3 和 5 下都会运行。</p>
</li>
<li>
<p><strong>init 的操作行为</strong></p>
<p>可以设置的值包括：</p>
<ul>
<li><code>initdefault</code>：设置默认的执行等级。</li>
<li><code>sysinit</code>：用于系统初始化的操作选项。</li>
<li><code>ctrlaltdel</code>：表示组合快捷键 Ctrl+Alt+Del 是否可以重新启动系统。</li>
<li><code>wait</code>：表示后面设置的命令必须要执行完毕才能继续下面的操作。</li>
<li><code>respawn</code>：表示后面的命令可以无限重启，例如 tty1。</li>
</ul>
</li>
<li>
<p><strong>命令选项</strong></p>
<p>这个字段用于指定要执行的命令，通常是一些脚本文件。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>NIS 服务</title>
    <url>/26249757/</url>
    <content><![CDATA[<h1 id="nis-服务器"><a class="markdownIt-Anchor" href="#nis-服务器"></a> NIS 服务器</h1>
<p>NIS 是 Network Information Services 的缩写，也称为 Sun Yellow Pages。NIS 服务器主要提供用户的账号，密码，主目录，UID 等信息给客户端主机用来查询之用。</p>
<p>NIS 服务器使用 RPC 协议传输数据，并且可以使用 Master/Slave 构架。整个运行流程如下：</p>
<ul>
<li>NIS Master 先将账号密码相关文件制作成数据库格式。</li>
<li>NIS Slave 连接 Master 同步数据。</li>
<li>如果账号密码有变动会重新制作数据库并同步。</li>
<li>当 NIS Client 有登录需求时会先查询本机 passwd, shadow 等文件。</li>
<li>若找不到相关账号数据，则向整个 NIS 网络的主机广播查询。</li>
<li>由 NIS Server 响应 Client 的请求。</li>
</ul>
<h1 id="服务端配置"><a class="markdownIt-Anchor" href="#服务端配置"></a> 服务端配置</h1>
<p>NIS 服务器同时也可以被当作客户端，它依赖的软件有下面一些：</p>
<ul>
<li>yp-tools：提供 NIS 相关查询命令。</li>
<li>ypbind：提供 NIS Client 端设置。</li>
<li>ypserv：提供 NIS Server 端设置。</li>
<li>rpcbind：RPC 服务主程序。</li>
</ul>
<p>默认情况下需要手动安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yp-tools
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> ypserv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>和 NIS 服务器配置有关的文件：</p>
<ul>
<li><code>/etc/ypserv.conf</code>：NIS 服务器主要配置文件，可以定义 NIS 客户端是否有可登录权限。</li>
<li><code>/etc/hosts</code>：由于 NIS Server/Client 会用到网络主机名，因此要在 hosts 中有记录。</li>
<li><code>/etc/sysconfig/network</code>：可以在这个文件内指定 NIS 的网络。</li>
<li><code>/var/yp/Makefile</code>：与建立数据库有关的操作控制文件。</li>
</ul>
<p>首先需要设置 NIS 的域名，NIS 通过域名来分辨不同的账号密码数据，因此在服务端与客户端都要指定相同的 NIS 域名。</p>
<p>例如设置域名为 vserver，启动端口固定在 1011：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"NISDOMAIN=vserver"</span> <span class="token operator">>></span> /etc/sysconfig/network
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">'YPSERV_ARGS="-p 1011"'</span> <span class="token operator">>></span> /etc/sysconfig/network
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/sysconfig/network
<span class="token comment"># Created by anaconda</span>
<span class="token assign-left variable">NISDOMAIN</span><span class="token operator">=</span>vserver
<span class="token assign-left variable">YPSERV_ARGS</span><span class="token operator">=</span><span class="token string">"-p 1011"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后 NIS 的服务端配置文件保持默认值即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/ypserv.conf 
files: <span class="token number">30</span>
xfr_check_port: <span class="token function">yes</span>

<span class="token comment"># Host                     : Domain  : Map              : Security </span>
<span class="token number">192.168</span>.2.0/255.255.255.0  <span class="token builtin class-name">:</span> vserver <span class="token builtin class-name">:</span> *   				<span class="token builtin class-name">:</span> none<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中主要参数设置如下：</p>
<ul>
<li>files：设置多少个数据库被读入内存当中。</li>
<li>xfr_check_port：和主从构架有关，将同步更新的数据库对比所使用的端口设置成小于 1024。</li>
<li>Host：主机名或 IP，例如 192.168.2.0/255.255.255.0。</li>
<li>Domain：NIS 域名，例如 vserver。</li>
<li>Map：可用数据库名称。</li>
<li>Security：安全限制，包括 none（无限制），port（仅用 &lt;1024 号端口），deny（拒绝）。</li>
</ul>
<p>在设置客户端查询的权限部分，可以使用星号 * 来代表接受所有数据。</p>
<p>最后修改本地 hosts，将服务端和客户端的主机名与 IP 对应记录写入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.254  server2"</span> <span class="token operator">>></span> /etc/hosts
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"192.168.2.234  server1"</span> <span class="token operator">>></span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为了将 yppasswdd 启动在固定端口 1012 还需要修改下配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/YPPASSWDD_ARGS=/YPPASSWDD_ARGS="--port 1012"/g'</span> /etc/sysconfig/yppasswdd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="服务端管理"><a class="markdownIt-Anchor" href="#服务端管理"></a> 服务端管理</h1>
<p>依次启动 ypserv 和 yppasswdd：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> ypserv
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> yppasswdd
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ rpcinfo <span class="token parameter variable">-p</span>
   program vers proto   port  <span class="token function">service</span>
    <span class="token number">100004</span>    <span class="token number">2</span>   udp   <span class="token number">1011</span>  ypserv
    <span class="token number">100004</span>    <span class="token number">1</span>   udp   <span class="token number">1011</span>  ypserv
    <span class="token number">100004</span>    <span class="token number">2</span>   tcp   <span class="token number">1011</span>  ypserv
    <span class="token number">100004</span>    <span class="token number">1</span>   tcp   <span class="token number">1011</span>  ypserv
    <span class="token number">100009</span>    <span class="token number">1</span>   udp   <span class="token number">1012</span>  yppasswdd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在服务端建立一个测试用户并转成数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">useradd</span> <span class="token parameter variable">-p</span> password nisuser
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ /usr/lib64/yp/ypinit <span class="token parameter variable">-m</span>

At this point, we have to construct a list of the hosts <span class="token function">which</span> will run NIS
servers.  server2 is <span class="token keyword">in</span> the list of NIS server hosts.  Please <span class="token builtin class-name">continue</span> to <span class="token function">add</span>
the names <span class="token keyword">for</span> the other hosts, one per line.  When you are <span class="token keyword">done</span> with the
list, <span class="token builtin class-name">type</span> a <span class="token operator">&lt;</span>control D<span class="token operator">></span>.
        next <span class="token function">host</span> to add:  server2
        next <span class="token function">host</span> to add:  
The current list of NIS servers looks like this:

server2

Is this correct?  <span class="token punctuation">[</span>y/n: y<span class="token punctuation">]</span>  y
We need a few minutes to build the databases<span class="token punctuation">..</span>.
Building /var/yp/vserver/ypservers<span class="token punctuation">..</span>.
Running /var/yp/Makefile<span class="token punctuation">..</span>.
gmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token variable"><span class="token variable">`</span>/var/yp/vserver'
Updating passwd.byname<span class="token punctuation">..</span>.
Updating passwd.byuid<span class="token punctuation">..</span>.
Updating group.byname<span class="token punctuation">..</span>.
Updating group.bygid<span class="token punctuation">..</span>.
Updating hosts.byname<span class="token punctuation">..</span>.
Updating hosts.byaddr<span class="token punctuation">..</span>.
Updating rpc.byname<span class="token punctuation">..</span>.
Updating rpc.bynumber<span class="token punctuation">..</span>.
Updating services.byname<span class="token punctuation">..</span>.
Updating services.byservicename<span class="token punctuation">..</span>.
Updating netid.byname<span class="token punctuation">..</span>.
Updating protocols.bynumber<span class="token punctuation">..</span>.
Updating protocols.byname<span class="token punctuation">..</span>.
Updating mail.aliases<span class="token punctuation">..</span>.
gmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token variable">`</span></span>/var/yp/vserver'

server2 has been <span class="token builtin class-name">set</span> up as a NIS master server.

Now you can run ypinit <span class="token parameter variable">-s</span> server2 on all slave server.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果用户密码发生过变化，需要运行上面命令重新制作数据库。</p>
<h1 id="客户端设置"><a class="markdownIt-Anchor" href="#客户端设置"></a> 客户端设置</h1>
<p>客户端也需要安装 <code>ypbind</code> 和 <code>yp-tools</code> 软件，<code>yp-tools</code> 中已经包含了 <code>ypbind</code> 软件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yp-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>客户端同服务器端一样先修改 <code>/etc/sysconfig/network</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"NISDOMAIN=vserver"</span> <span class="token operator">>></span> /etc/sysconfig/network<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改客户端主要配置文件 <code>/etc/yp.conf</code> 文件，将服务端地址写进去：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"domain vserver server 192.168.2.254"</span> <span class="token operator">>></span> /etc/yp.conf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改 <code>/etc/nsswitch.conf</code> 和 <code>/etc/sysconfig/authconfig</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/nsswitch.conf
passwd:     files nis
shadow:     files nis
group:      files nis
hosts:      files nis dns
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/sysconfig/authconfig
<span class="token assign-left variable">USENIS</span><span class="token operator">=</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="客户端管理"><a class="markdownIt-Anchor" href="#客户端管理"></a> 客户端管理</h1>
<p>启动服务，并用 <code>id</code> 查询存在服务端的账号 nisuser：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl start ypbind
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">id</span> nisuser
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span>,1000<span class="token punctuation">(</span>usergroup<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>利用 <code>yptest</code> 验证数据库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ yptest
Test <span class="token number">1</span>: domainname
Configured domainname is <span class="token string">"vserver"</span>

Test <span class="token number">2</span>: ypbind
Used NIS server: server2

Test <span class="token number">3</span>: yp_match
WARNING: No such key <span class="token keyword">in</span> map <span class="token punctuation">(</span>Map passwd.byname, key nobody<span class="token punctuation">)</span>

Test <span class="token number">9</span>: yp_all
nisuser nisuser:password:1000:1000::/home/nisuser:/bin/bash
<span class="token number">1</span> tests failed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Test 3 报错说没有该数据库，可以忽略。</p>
<p>使用 <code>ypwhich</code> 检查数据库数量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ypwhich <span class="token parameter variable">-x</span>
Use <span class="token string">"ethers"</span>    <span class="token keyword">for</span> map <span class="token string">"ethers.byname"</span>
Use <span class="token string">"aliases"</span>   <span class="token keyword">for</span> map <span class="token string">"mail.aliases"</span>
Use <span class="token string">"services"</span>  <span class="token keyword">for</span> map <span class="token string">"services.byname"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以很清楚看到相关文件，这些数据库文件放置在服务端 <code>/var/yp/vserver/*</code> 中</p>
<p>使用 <code>ypcat</code> 能直接读取数据库内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ypcat <span class="token parameter variable">-h</span> <span class="token number">192.168</span>.2.254 passwd.byname
nisuser:password:1000:1000::/home/nisuser:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="客户端操作"><a class="markdownIt-Anchor" href="#客户端操作"></a> 客户端操作</h1>
<p>启动好 <code>ypbind</code> 服务后，服务端和客户端的账号已经同步了。可以在客户端直接切换到 nisuser 用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">su</span> - nisuser
Last login: Sat Oct  <span class="token number">2</span> 01:18:14 CST <span class="token number">2021</span> on pts/0
su: warning: cannot change directory to /home/nisuser: No such <span class="token function">file</span> or directory
-bash-4.2$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>usergroup<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>usergroup<span class="token punctuation">)</span> <span class="token assign-left variable">context</span><span class="token operator">=</span>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示说没有用户主目录，可以使用 <code>yppasswd</code> 来修改这个账号的密码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-bash-4.2$ yppasswd
Changing NIS account information <span class="token keyword">for</span> nisuser on server2.
Please enter old password:
Sorry.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外还有 <code>ypchfn</code> 修改个人信息和 <code>ypchsh</code> 修改使用 shell 命令可用。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>NFS服务</title>
    <url>/165304807/</url>
    <content><![CDATA[<h1 id="nfs-服务器"><a class="markdownIt-Anchor" href="#nfs-服务器"></a> NFS 服务器</h1>
<p>NFS 为 Network File System 的简称，目的是想让不同机器、不同操作系统可以彼此共享数据文件。NFS 服务器可以让主机将网络中 NFS 服务器共享的目录挂载到本地端的文件系统中，用起来就像本地分区一样。</p>
<p>NFS 服务端口是 2049，此外用来传输的端口是小于 1024 号的随机端口，由 RPC 协议来调用。</p>
<p>远程过程调用（RPC，Remote Procedure Call）服务主要功能是指定每个 NFS 功能所对应的端口号，并通知给客户端。端口号由 NFS 启动时随机选取并向 RPC 注册，因此 RPC 服务需要先于 NFS 启动。</p>
<p>RPC 服务使用固定的 111 端口来监听客户端需求。使用 NFS 时，客户端和服务端都需要启动 RPC 服务，实际上称 NFS 为 RPC 服务的一种。</p>
<p>NFS 所依赖的 RPC 服务如下：</p>
<ul>
<li><code>rpc.nfsd</code>：最主要的 NFS 服务提供程序，管理客户端是否能够使用服务器文件系统挂载信息等。</li>
<li><code>rpc.mountd</code>：用于管理 NFS 文件系统的权限，它会去读 NFS 配置文件 <code>/etc/exports</code> 来对比客户端权限。</li>
<li><code>rpc.lockd</code>：用于管理文件锁定功能。需要服务端和客户端同时开启，与 <code>rpc.statd</code> 有依赖关系，非必须启动。</li>
<li><code>rpc.statd</code>：用来检查文件的一致性，如果文件被多客户端同时使用造成损坏时，它可以检测并尝试恢复文件。</li>
</ul>
<h1 id="nfs-服务配置"><a class="markdownIt-Anchor" href="#nfs-服务配置"></a> NFS 服务配置</h1>
<p>要想启动 NFS 服务器，需要具备下面两个程序：</p>
<ul>
<li><code>rpcbind</code>：RPC 的主程序，用来做好端口对应的工作。</li>
<li><code>nfs-utils</code>：提供 <code>rpc.nfsd</code> 及 <code>rpc.mountd</code> 服务的程序</li>
</ul>
<p>默认情况下没有安装，使用 yum 来安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> rpcbind
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> nfs-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>NFS 的配置文件存在 <code>/etc/exports</code>，日志文件放在 <code>/var/lib/nfs/</code> 路径下。</p>
<p>例如将 <code>/tmp</code> 目录共享给主机 192.168.2.234 和 10.1.1.0/24，将 <code>/root/nf</code> 目录分享给所有人：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/exports
/tmp <span class="token number">192.168</span>.2.234<span class="token punctuation">(</span>ro<span class="token punctuation">)</span> <span class="token number">10.1</span>.1.0/24<span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
/root/nf *<span class="token punctuation">(</span>rw,no_root_squash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>括号内的权限设置有下面几种组合，可以用逗号，分隔指定多个权限：</p>
<ul>
<li>rw, ro：目录共享权限为可读写（read-write）或只读（read-only）。还需要参考文件系统权限和身份。</li>
<li>sync, async：数据同步或异步写入到硬盘。</li>
<li>no_root_squash, root_squash：root_squash 表示将 root 身份替换成 nfsnobody。否则开放 root 身份权限。</li>
<li>all_squash：将所有用户都压缩成匿名用户（nfsnobody）。</li>
<li>anonuid=, anongid=：设置匿名用户 UID 或 GID 值。</li>
</ul>
<p>一般 NFS 服务不会对互联网开放，如果遇到特殊要求，可以调整配置 <code>/etc/sysconfig/nfs</code> 让除了 111 和 2049 号外的端口固定，以方便防火墙设置规则。</p>
<h1 id="nfs-服务管理"><a class="markdownIt-Anchor" href="#nfs-服务管理"></a> NFS 服务管理</h1>
<p>改好配置文件后就可以启动 NFS 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl start rpcbind
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl start nfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用 <code>rpcinfo</code> 来查询本机 RPC 状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ rpcinfo <span class="token parameter variable">-p</span>
   program vers proto   port  <span class="token function">service</span>
    <span class="token number">100000</span>    <span class="token number">4</span>   tcp    <span class="token number">111</span>  portmapper
    <span class="token number">100000</span>    <span class="token number">3</span>   tcp    <span class="token number">111</span>  portmapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改配置文件后，可以使用 <code>exportfs</code> 命令重新挂载 NFS 文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-arv</span>
exporting <span class="token number">192.168</span>.2.234:/tmp
exporting <span class="token number">10.1</span>.1.0/24:/tmp
exporting *:/root/nf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>卸载已经共享的 NFS 目录也使用 <code>exportfs</code> 命令操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ exportfs <span class="token parameter variable">-auv</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="nfs-目录挂载"><a class="markdownIt-Anchor" href="#nfs-目录挂载"></a> NFS 目录挂载</h1>
<p>可以使用 <code>showmount</code> 来查询 NFS 服务器共享目录情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ showmount <span class="token parameter variable">-e</span> <span class="token number">10.1</span>.1.1
Export list <span class="token keyword">for</span> <span class="token number">127.0</span>.0.1:
/root/nf *
/tmp     <span class="token number">10.1</span>.1.0/24,192.168.2.234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端可以使用 <code>mount</code> 命令直接挂载使用共享目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token number">192.168</span>.2.254:/tmp <span class="token number">111</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ll
total <span class="token number">8992</span>
drwxrwxrwt. <span class="token number">8</span> root root     <span class="token number">172</span> Oct <span class="token number">10</span> <span class="token number">14</span>:52 <span class="token number">111</span>
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">df</span>
Filesystem              1K-blocks    Used Available Use% Mounted on
<span class="token number">192.168</span>.2.254:/tmp        <span class="token number">1020928</span>   <span class="token number">33280</span>    <span class="token number">987648</span>   <span class="token number">4</span>% /root/111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>卸载 NFS 目录使用 <code>umount</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">umount</span> <span class="token number">111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外客户端在挂载 NFS 文件系统时，可以使用一些特殊的挂载参数：</p>
<ul>
<li>fg, bg：执行挂载时，挂载行为在前台或后台执行。默认是前台，在后台执行挂载不会影响到前台工作。</li>
<li>soft, hard：默认 hard 参数，在主机脱机时 RPC 会持续尝试连接，使用 soft 参数则会等待超时时间后再尝试。</li>
<li>intr：如果采用 hard 方式挂载，使用 intr 参数可以中断尝试连接。</li>
<li>rsize, wsize：读写区块大小，默认 1024 bytes。调大可以加速网络传输速度。</li>
</ul>
<p>例如采用后台软挂载，调整读写区块大小为 32K：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> nfs <span class="token parameter variable">-o</span> bg,soft,rsize<span class="token operator">=</span><span class="token number">32768</span>,wsize<span class="token operator">=</span><span class="token number">32768</span> <span class="token number">10.1</span>.1.1:/root/nf <span class="token number">111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>想要开机挂载可以将上面的命令写入到 <code>/etc/rc.d/rc.local</code> 文件中，并加入运行权限。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>DHCP 服务</title>
    <url>/4189308113/</url>
    <content><![CDATA[<h1 id="dhcp-服务器"><a class="markdownIt-Anchor" href="#dhcp-服务器"></a> DHCP 服务器</h1>
<p>DHCP（Dynamic Host Configuration Protocol）服务器的主要工作是自动地将网络参数分配给网络中的计算机，这些网络参数包括 IP，网关，DNS 地址等。</p>
<p>一般 DHCP 服务器用在计算机（或移动设备）数量众多的局域网内。如果局域网内计算机数量较少，使用手动配置 IP 能节省开机后从 DHCP 服务器获取 IP 的时间。</p>
<h1 id="dhcp-协议"><a class="markdownIt-Anchor" href="#dhcp-协议"></a> DHCP 协议</h1>
<p>DHCP 通常是用于局域网内的一个通信协议，它主要通过客户端发送广播数据包给整个物理网段内的所有主机，如果有 DHCP 服务器则会响应客户端的 IP 参数要求。</p>
<p>整个请求过程如下：</p>
<ol>
<li>
<p>若客户端网卡设置为自动获得 IP， 则当客户端开机或重启网卡时，网卡会发送搜索 DHCP 服务器的 UDP 数据包给整个物理网段。广播数据包发送目标为 255.255.255.255，因此一般主机会直接忽略此包，只有 DHCP 服务器会响应。</p>
</li>
<li>
<p>DHCP 服务器端在接收到客户端请求后，会针对客户端的 MAC 地址与本身的设置数据来进行下面工作：</p>
<ul>
<li>到服务器日志查询该用户是否曾租用过某个 IP，若有记录且该 IP 当前闲置，则提供此 IP 给客户端。</li>
<li>若配置文件针对此 MAC 地址设置了固定 IP，则将此 IP 分配给客户端。</li>
<li>如果不符合上面两个条件，则随机选取当前没有被使用的 IP 参数给客户端，并记录下来。</li>
</ul>
<p>由于客户端此时没有 IP 地址，因此针对客户端 MAC 来给与回应，此时服务端会保留这个租约然后等待客户端回应。</p>
</li>
<li>
<p>有可能局域网内不止一台 DHCP 服务器，客户端需要选择确认 DHCP 服务器提供的相关网络参数租约。当决定好要使用的参数后，客户端开始使用这组网络参数来配置自己的网络环境。此外，客户端也会发送一个广播数据包告知已接受该服务器的租约。没有被接受的 DHCP 服务器会回收对应 IP 租约。</p>
</li>
<li>
<p>DHCP 服务器端收到客户端确认选择后，会回送确认的响应数据包，并告知客户端这个租约的期限，并开始倒计时。当租约到期且没重新收到申请（renew）时，IP 将会被收回，用户可以向 DHCP 服务器再次要求分配 IP。此外，客户端如果脱机，DHCP 服务器也会将 IP 收回。</p>
</li>
</ol>
<p>一般来说，DHCP 客户端程序大多会主动依据租约时间去重新申请 IP，时间点为租约时间过半和过掉九成。服务端使用 67 端口监听客户请求，而客户端使用 68 端口向 DHCP 服务器请求。</p>
<h1 id="dhcp-服务器配置"><a class="markdownIt-Anchor" href="#dhcp-服务器配置"></a> DHCP 服务器配置</h1>
<p>使用 Linux 架设 DHCP 服务器需要安装 dhcp 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> dhcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装完毕后需要修改配置文件 <code>/etc/dhcp/dhcpd.conf</code> 后才能启动。作为参考可以查看示例文件 <code>/usr/share/doc/dhcp-4.2.5/dhcpd.conf.example</code>。</p>
<p>服务器配置文件分为两大块，全局配置和 IP 分配设置。</p>
<h2 id="全局配置"><a class="markdownIt-Anchor" href="#全局配置"></a> 全局配置</h2>
<p>假设整个局域网只有一个子网，那除了 IP 分配之外的配置参数可以放在全局设置区域中。主要参数如下：</p>
<ul>
<li><code>default-lease-time</code>：默认租约时间，单位是秒。如果用户没有特别要求租约时间，那么使用此默认值。</li>
<li><code>max-lease-time</code>：最大租约时间，设置用户能请求的最大租约时间限制。</li>
<li><code>option domain-name</code>：在用户查找的主机名后自动加上此域名后缀。</li>
<li><code>option domain-name-servers</code>：设置客户端的 DNS 服务器。</li>
<li><code>ddns-update-style</code>：通过 ddns 来更新主机名与 IP 的对应关系。</li>
<li><code>option routers</code>：设定网关的 IP 地址。</li>
</ul>
<h2 id="ip-分配设置"><a class="markdownIt-Anchor" href="#ip-分配设置"></a> IP 分配设置</h2>
<p>根据分配类型动态 IP 使用 <code>range</code> 参数指定。例如分配范围 10.1.1.101~10.1.1.200：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>
  range <span class="token number">10.1</span>.1.101 <span class="token number">10.1</span>.1.200<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>静态 IP 分配指定 MAC 地址与对应的固定 IP。例如设置主机名 server1，绑定 MAC 地址 10.1.1.103：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">host</span> server1 <span class="token punctuation">&#123;</span>
  hardware ethernet 00:0c:29:ab:18:72<span class="token punctuation">;</span>
  fixed-address <span class="token number">10.1</span>.1.103<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2>
<p>整个配置文件内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/dhcp/dhcpd.conf
default-lease-time <span class="token number">600</span><span class="token punctuation">;</span>
max-lease-time <span class="token number">7200</span><span class="token punctuation">;</span>
log-facility local7<span class="token punctuation">;</span>
option domain-name-servers <span class="token number">8.8</span>.8.8, <span class="token number">114.114</span>.114.114<span class="token punctuation">;</span>
option routers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>

subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>
  range <span class="token number">10.1</span>.1.101 <span class="token number">10.1</span>.1.200<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">host</span> server1 <span class="token punctuation">&#123;</span>
  hardware ethernet 00:0c:29:ab:18:72<span class="token punctuation">;</span>
  fixed-address <span class="token number">10.1</span>.1.103<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后就可以启动 dhcp 服务器了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl start dhcpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在客户端中获取到的 IP 参数信息保存在 <code>/var/lib/dhclient/dhclient.leases</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /var/lib/dhclient/dhclient.leases 
lease <span class="token punctuation">&#123;</span>
  interface <span class="token string">"ens37"</span><span class="token punctuation">;</span>
  fixed-address <span class="token number">10.1</span>.1.129<span class="token punctuation">;</span>
  option subnet-mask <span class="token number">255.255</span>.255.0<span class="token punctuation">;</span>
  option dhcp-lease-time <span class="token number">1800</span><span class="token punctuation">;</span>
  option dhcp-message-type <span class="token number">5</span><span class="token punctuation">;</span>
  option domain-name-servers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>
  option dhcp-server-identifier <span class="token number">10.1</span>.1.254<span class="token punctuation">;</span>
  option broadcast-address <span class="token number">10.1</span>.1.255<span class="token punctuation">;</span>
  option domain-name <span class="token string">"localdomain"</span><span class="token punctuation">;</span>
  renew <span class="token number">5</span> <span class="token number">2021</span>/09/24 03:02:47<span class="token punctuation">;</span>
  rebind <span class="token number">5</span> <span class="token number">2021</span>/09/24 03:17:31<span class="token punctuation">;</span>
  expire <span class="token number">5</span> <span class="token number">2021</span>/09/24 03:21:16<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务端的记录保存在 <code>/var/lib/dhcpd/dhcpd.leases</code> 文件中。</p>
<h1 id="通过网络唤醒"><a class="markdownIt-Anchor" href="#通过网络唤醒"></a> 通过网络唤醒</h1>
<p>在局域网内的计算机只要支持且开启了网络唤醒功能，就可以使用 <code>ether-wake</code> 命令来让目标从关机状态开机。</p>
<p>例如唤醒 MAC 地址为 AA:BB:CC:DD:EE:FF 的主机开机：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ ether-wake <span class="token parameter variable">-i</span> ens33 AA:BB:CC:DD:EE:FF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 服务</title>
    <url>/3422512598/</url>
    <content><![CDATA[<h1 id="ssh-服务器"><a class="markdownIt-Anchor" href="#ssh-服务器"></a> SSH 服务器</h1>
<p>SSH 是安全的壳程序协议（Secure Shell Protocol），它可以通过数据包加密技术将等待传输的数据包加密后在网上传输。默认状态下，SSH 协议提供服务端和客户端，还带有一个类似 FTP 服务的 Sftp-Server，它们都使用 22 端口。</p>
<p>目前常见网络数据包加密技术通过非对称密钥系统来处理，它通过两把不一样的公钥和私钥来进行数据加密与解密：</p>
<ul>
<li>公钥（Public Key）：提供给远程主机进行数据加密的行为。</li>
<li>私钥（Private Key）：在本地端使用私钥来解密通过公钥加密的数据。</li>
</ul>
<p>SSH 服务端与客户端的连接步骤如下：</p>
<ol>
<li>服务端第一次启动 sshd 时自动产生公钥和私钥，存放于 <code>/etc/ssh/ssh_host_*</code>；</li>
<li>客户端向服务端请求连接；</li>
<li>服务端给客户端发送服务端的公钥；</li>
<li>客户端将公钥记录在 <code>~/.ssh/known_hosts</code> 中，并发送自己的公钥给服务端；</li>
<li>服务端和客户端建立连接，并各自通过对方公钥加密数据后传输。</li>
</ol>
<p>在第 4 步客户端生成的公钥和私钥是一次性的，每次建立连接会重新生成。而服务器的公钥不变，因此客户端也会比较每次连接收到的公钥是否和 known_hosts 中的记录一致。</p>
<p>可以直接使用 <code>systemctl</code> 来控制 ssh 服务器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl status sshd
● sshd.service - OpenSSH server daemon
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/sshd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Sat <span class="token number">2021</span>-10-09 03:22:48 CST<span class="token punctuation">;</span> 19h ago
     Docs: man:sshd<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
           man:sshd_config<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
 Main PID: <span class="token number">1242</span> <span class="token punctuation">(</span>sshd<span class="token punctuation">)</span>
   CGroup: /system.slice/sshd.service
           └─1242 /usr/sbin/sshd <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ssh-客户端"><a class="markdownIt-Anchor" href="#ssh-客户端"></a> SSH 客户端</h1>
<p>默认 SSH 客户端使用 <code>ssh</code> 命令来运行，命令格式：<code>ssh [-f] [-o 参数项目] [-p 端口号] [账号@]IP [命令]</code></p>
<p>选项说明：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>配合后面的命令，不登录主机直接发送命令过去执行。</td>
</tr>
<tr>
<td>-o</td>
<td>参数项目，常用的有：<br />ConnectTimeout=秒数：控制超时时间<br />StrictHostKeyChecking=yes|no|ask：加入新公钥时的操作，默认 ask 询问</td>
</tr>
<tr>
<td>-p</td>
<td>指定非标准 SSH 连接端口。</td>
</tr>
</tbody>
</table>
<p>如果连接时不指定账号，使用的是本地端账号尝试登录。例如以 user1 账号登录远程 10.1.1.2:10022 服务器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token parameter variable">-p</span> <span class="token number">10022</span> user1@10.1.1.2
ssh: connect to <span class="token function">host</span> <span class="token number">10.1</span>.1.2 port <span class="token number">10022</span>: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>例如通过 <code>ssh</code> 运行指定命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token parameter variable">-f</span> <span class="token number">127.0</span>.0.1 <span class="token function">find</span> / <span class="token operator">&amp;></span> find.log
The authenticity of <span class="token function">host</span> <span class="token string">'127.0.0.1 (127.0.0.1)'</span> can't be established.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假设服务器重新安装过系统，密钥更新后会造成客户端认证失败。客户端清空掉 <code>known_hosts</code> 文件内容即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> /etc/ssh/ssh_host*
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl restart sshd
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token number">127.0</span>.0.1
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED<span class="token operator">!</span>     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY<span class="token operator">!</span>
Someone could be eavesdropping on you right now <span class="token punctuation">(</span>man-in-the-middle attack<span class="token punctuation">)</span><span class="token operator">!</span>
It is also possible that a <span class="token function">host</span> key has just been changed.
The fingerprint <span class="token keyword">for</span> the ECDSA key sent by the remote <span class="token function">host</span> is
SHA256:jNdAaJuldv+NT40ULeK7lEre4ro8OE/teafAM/bBibg.
Please contact your system administrator.
Add correct <span class="token function">host</span> key <span class="token keyword">in</span> /root/.ssh/known_hosts to get rid of this message.
Offending ECDSA key <span class="token keyword">in</span> /root/.ssh/known_hosts:2
ECDSA <span class="token function">host</span> key <span class="token keyword">for</span> <span class="token number">127.0</span>.0.1 has changed and you have requested strict checking.
Host key verification failed.
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">""</span> <span class="token operator">></span> /root/.ssh/known_hosts 
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token number">127.0</span>.0.1
The authenticity of <span class="token function">host</span> <span class="token string">'127.0.0.1 (127.0.0.1)'</span> can't be established.
ECDSA key fingerprint is SHA256:jNdAaJuldv+NT40ULeK7lEre4ro8OE/teafAM/bBibg.
ECDSA key fingerprint is MD5:8f:86:05:da:66:c3:d8:fd:cf:09:d4:21:bc:84:80:be.
Are you sure you want to <span class="token builtin class-name">continue</span> connecting <span class="token punctuation">(</span>yes/no<span class="token punctuation">)</span>? <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="sftp-文件传输"><a class="markdownIt-Anchor" href="#sftp-文件传输"></a> SFTP 文件传输</h1>
<p>可以通过 <code>sftp</code> 或 <code>scp</code> 命令向服务器上传或下载文件。</p>
<p>用 <code>sftp</code> 命令连接和 <code>ssh</code> 类似，连接以后可以使用一些如 <code>cd</code>、<code>ls</code>、<code>pwd</code>、<code>mkdir</code> 之类的命令来在远程服务器操作。而针对本机的命令在针对服务器的命令前加上 <code>l</code>，比如 <code>lcd</code>、<code>lls</code>、<code>lpwd</code> 等。</p>
<p>上传文件使用 <code>put</code> 命令。例如将本地 <code>find.log</code> 文件传输到服务器端：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">sftp</span> <span class="token number">10.1</span>.1.2
root@10.1.1.2's password: 
Connected to <span class="token number">10.1</span>.1.2.
sftp<span class="token operator">></span> put find.log /tmp
Uploading find.log to /tmp/find.log
find.log                                                   <span class="token number">100</span>% 8958KB  <span class="token number">56</span>.2MB/s   00:00 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下载文件或目录使用 <code>get</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">sftp</span> <span class="token number">10.1</span>.1.2
root@10.1.1.2's password: 
Connected to <span class="token number">10.1</span>.1.2.
sftp<span class="token operator">></span> get html/
Fetching /root/html/ to html
Cannot download non-regular file: /root/html/
sftp<span class="token operator">></span> get html/*
Fetching /root/html/index.html to index.html
/root/html/index.html                                      <span class="token number">100</span>%   <span class="token number">81</span>    <span class="token number">46</span>.8KB/s   00:00 
Fetching /root/html/index.html.1 to index.html.1
/root/html/index.html.1                                    <span class="token number">100</span>%   <span class="token number">81</span>    <span class="token number">48</span>.0KB/s   00:00 
Fetching /root/html/index.html.2 to index.html.2
/root/html/index.html.2                                    <span class="token number">100</span>%   <span class="token number">81</span>    <span class="token number">42</span>.1KB/s   00:00 
sftp<span class="token operator">></span> <span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，上传或下载目录时，要想保持文件夹结构，需要使用 <code>-r</code> 参数。</p>
<p>如果要让新建用户 <code>user01</code> 能够使用 <code>sftp</code>，需要修改配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/ssh/sshd_config 
Match User user01
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以配置匹配的用户组，并强制用户只能停留在自己的主目录。要定义多个用户组，使用逗号分隔：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/ssh/sshd_config 
<span class="token comment">#Subsystem       sftp    /usr/libexec/openssh/sftp-server</span>
Subsystem       <span class="token function">sftp</span>    internal-sftp
Match Group sftpgroup
ChrootDirectory %h
ForceCommand internal-sftp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="scp-文件传输"><a class="markdownIt-Anchor" href="#scp-文件传输"></a> SCP 文件传输</h1>
<p>如果已知服务器上存在的文件信息，可以使用 <code>scp</code> 命令来上传和下载。</p>
<p>上传命令：<code>scp [-pr] [-l 速率] 本地文件路径 [账号@]主机:远程目录名</code></p>
<p>下载命令：<code>scp [-pr] [-l 速率] [账号@]主机:远程文件路径 本地目录名</code></p>
<p>选项说明：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>保留文件权限信息</td>
</tr>
<tr>
<td>-r</td>
<td>递归目录</td>
</tr>
<tr>
<td>-l</td>
<td>限制传输速率，单位为 Kbits/s。例如 <code>-l 800</code> 代表 100 KB/s</td>
</tr>
</tbody>
</table>
<p>例如，将本地 <code>/etc/hosts*</code> 上传到 10.1.1.2 的 <code>/root/html</code> 目录中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">scp</span> /etc/hosts* root@10.1.1.2:/root/html/
root@10.1.1.2's password: 
hosts                                                      <span class="token number">100</span>%  <span class="token number">801</span>   <span class="token number">533</span>.0KB/s   00:00 
hosts.allow                                                <span class="token number">100</span>%  <span class="token number">370</span>   <span class="token number">281</span>.4KB/s   00:00 
hosts.deny                                                 <span class="token number">100</span>%  <span class="token number">460</span>   <span class="token number">391</span>.2KB/s   00:00 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将远程主机 10.1.1.2 中的 <code>/boot/</code> 目录下载到本地 <code>/tmp</code> 目录下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">scp</span> <span class="token parameter variable">-r</span> root@10.1.1.2:/boot /tmp
root@10.1.1.2's password: 
device.map                                                 <span class="token number">100</span>%   <span class="token number">84</span>    <span class="token number">16</span>.4KB/s   00:00 
gcry_rmd160.mod                                            <span class="token number">100</span>% <span class="token number">8068</span>     <span class="token number">2</span>.4MB/s   00:00 
acpi.mod                                                   <span class="token number">100</span>% <span class="token number">9932</span>     <span class="token number">5</span>.0MB/s   00:00 
gcry_rsa.mod                                               <span class="token number">100</span>% <span class="token number">2068</span>     <span class="token number">1</span>.3MB/s   00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ssh-服务器配置文件"><a class="markdownIt-Anchor" href="#ssh-服务器配置文件"></a> SSH 服务器配置文件</h1>
<p>sshd 服务器配置文件存放在 <code>/etc/ssh/sshd_config</code>。一些重要的配置选项如下：</p>
<ul>
<li><strong>Port</strong> 22：默认端口为 22，也可以使用多个端口，在配置中多定义一个 Port 选项即可。</li>
<li>Protocol 2：SSH 协议版本。可以指定为 Protocol 2, 1 来同时支持 v1 和 v2 版本。</li>
<li><strong>ListenAddress</strong> 0.0.0.0：默认监听所有端口。</li>
<li>PidFile /var/run/sshd.pid：放置 PID 文件的路径。</li>
<li>LoginGraceTime 2m：连接超时时间，包括密码输入等待时间。</li>
<li>HostKey /etc/ssh/ssh_host_key：SSH v1 使用的私钥。</li>
<li>HostKey /etc/ssh/ssh_host_rsa_key：SSH v2 使用的 RSA 私钥。</li>
<li>HostKey /etc/ssh/ssh_host_dsa_key：SSH v2 使用的 DSA 私钥。</li>
<li>LogLevel INFO：日志的等级。</li>
<li><strong>PermitRootLogin</strong> yes：是否允许 root 登录。</li>
<li>StrictModes yes：是否让 sshd 检查用户主目录或相关文件的权限。</li>
<li><strong>PubkeyAuthentication</strong> yes：是否允许通过密钥登录。</li>
<li><strong>AuthorizedKeysFile</strong> .ssh/authorized_keys：自定义公钥数据存放位置。</li>
<li><strong>PasswordAuthentication</strong> yes：是否允许通过密码登录。</li>
<li>PermitEmptyPasswords no：是否允许以空密码登录。</li>
<li>IgnoreUserKnowHosts no：是否忽略 known_hosts 文件。</li>
<li>UsePAM yes：利用 PAM 管理用户认证。</li>
<li>X11Forwarding yes：让窗口数据通过 SSH 连接来传送。</li>
<li>PrintLastLog yes：是否显示上次登录信息。</li>
<li>TCPKeepAlive yes：是否一直发送 TCP 数据包给客户端，来检测连接状态。</li>
<li>UseDNS yes：是否使用 DNS 去反查客户端的主机名。在内网可以设为 no 加速连接。</li>
</ul>
<h1 id="通过密钥登录"><a class="markdownIt-Anchor" href="#通过密钥登录"></a> 通过密钥登录</h1>
<p>可以将客户端用户的公钥复制到服务器端用户目录内的 SSH 认证文件中，这样就可以实现免密码使用 SSH 和 SFTP。</p>
<p>首先，客户端需要生成密钥对（id_rsa 私钥和 id_rsa.pub 公钥），可以使用 <code>-t</code> 参数指定 RSA 或 DSA 算法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ssh-keygen <span class="token parameter variable">-t</span> rsa
Generating public/private rsa key pair.
Enter <span class="token function">file</span> <span class="token keyword">in</span> <span class="token function">which</span> to save the key <span class="token punctuation">(</span>/root/.ssh/id_rsa<span class="token punctuation">)</span>: 
Enter passphrase <span class="token punctuation">(</span>empty <span class="token keyword">for</span> no passphrase<span class="token punctuation">)</span>: 
Enter same passphrase again: 
Your identification has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.
Your public key has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.pub.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，使用 <code>ssh-copy-id</code> 命令将公钥 <code>id_rsa.pub</code> 的内容传送到 <code>root@192.168.2.254</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ssh-copy-id root@192.168.2.254
/usr/bin/ssh-copy-id: INFO: Source of key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to be installed: <span class="token string">"/root/.ssh/id_rsa.pub"</span>
/usr/bin/ssh-copy-id: INFO: attempting to log <span class="token keyword">in</span> with the new key<span class="token punctuation">(</span>s<span class="token punctuation">)</span>, to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: <span class="token number">1</span> key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> remain to be installed -- <span class="token keyword">if</span> you are prompted now it is to <span class="token function">install</span> the new keys
root@192.168.2.254<span class="token string">'s password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '</span>root@192.168.2.254'"
and check to <span class="token function">make</span> sure that only the key<span class="token punctuation">(</span>s<span class="token punctuation">)</span> you wanted were added.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在就可以通过 SSH 免密码登录到 <code>192.168.2.254</code> 了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> root@192.168.2.254
Last login: Sat Oct  <span class="token number">9</span> <span class="token number">20</span>:00:00 <span class="token number">2021</span> from <span class="token number">192.168</span>.2.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过使用密钥登录，可以提高安全性并简化 SSH 连接过程。</p>
<h1 id="修改-ssh-端口"><a class="markdownIt-Anchor" href="#修改-ssh-端口"></a> 修改 SSH 端口</h1>
<p>在启用 SELinux 的情况下，修改 SSH 配置文件中的端口配置可能导致 SSH 无法启动。</p>
<p>当出现类似以下错误信息时，表示在绑定端口时遇到了权限拒绝的问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ journalctl <span class="token parameter variable">-xe</span>
Oct <span class="token number">10</span> 01:22:37 server1 sshd<span class="token punctuation">[</span><span class="token number">10905</span><span class="token punctuation">]</span>: error: Bind to port <span class="token number">20000</span> on :: failed: Permission denie
Oct <span class="token number">10</span> 01:22:37 server1 sshd<span class="token punctuation">[</span><span class="token number">10905</span><span class="token punctuation">]</span>: fatal: Cannot <span class="token builtin class-name">bind</span> any address.
Oct <span class="token number">10</span> 01:22:37 server1 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: sshd.service: main process exited, <span class="token assign-left variable">code</span><span class="token operator">=</span>exited, <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">25</span>
Oct <span class="token number">10</span> 01:22:37 server1 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Failed to start OpenSSH server daemon.
-- Subject: Unit sshd.service has failed
-- Defined-By: systemd
-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel
-- 
-- Unit sshd.service has failed.
-- 
-- The result is failed.
Oct <span class="token number">10</span> 01:22:37 server1 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Unit sshd.service entered failed state.
Oct <span class="token number">10</span> 01:22:37 server1 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: sshd.service failed.
Oct <span class="token number">10</span> 01:22:37 server1 polkitd<span class="token punctuation">[</span><span class="token number">963</span><span class="token punctuation">]</span>: Unregistered Authentication Agent <span class="token keyword">for</span> unix-process:1088
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /var/log/audit/audit.log <span class="token operator">|</span> <span class="token function">grep</span> AVC <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">ssh</span>
<span class="token assign-left variable">type</span><span class="token operator">=</span>AVC <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1633800192.050</span>:404<span class="token punctuation">)</span>: avc:  denied  <span class="token punctuation">&#123;</span> name_bind <span class="token punctuation">&#125;</span> <span class="token keyword">for</span>  <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">10954</span> <span class="token assign-left variable">comm</span><span class="token operator">=</span><span class="token string">"sshd"</span> <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token number">20000</span> <span class="token assign-left variable">scontext</span><span class="token operator">=</span>system_u:system_r:sshd_t:s0-s0:c0.c1023 <span class="token assign-left variable">tcontext</span><span class="token operator">=</span>system_u:object_r:unreserved_port_t:s0 <span class="token assign-left variable">tclass</span><span class="token operator">=</span>tcp_socket <span class="token assign-left variable">permissive</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过安装 <code>setroubleshoot</code> 诊断套件后，可以查询 SELinux 日志信息以了解详细情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ yum <span class="token parameter variable">-y</span> <span class="token function">install</span> setroubleshoot
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> /var/log/messages
Oct <span class="token number">10</span> 01:48:40 server1 setroubleshoot: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port <span class="token number">20000</span>. For complete SELinux messages run: sealert <span class="token parameter variable">-l</span> 04603a0d-6723-417a-839a-d0974457f614
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ sealert <span class="token parameter variable">-l</span> 04603a0d-6723-417a-839a-d0974457f614
SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port <span class="token number">20000</span>.

*****  Plugin bind_ports <span class="token punctuation">(</span><span class="token number">92.2</span> confidence<span class="token punctuation">)</span> suggests   ************************

If you want to allow /usr/sbin/sshd to <span class="token builtin class-name">bind</span> to network port <span class="token number">20000</span>
Then you need to modify the port type.
Do
<span class="token comment"># semanage port -a -t PORT_TYPE -p tcp 20000</span>
    where PORT_TYPE is one of the following: ssh_port_t, vnc_port_t, xserver_port_t.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据提示，有三种解决方法：</p>
<ul>
<li>修改默认绑定端口的设置：<code>semanage port -a -t ssh_port_t -p tcp 20000</code></li>
<li>修改 NIS 的设置：<code>setsebool -P nis_enabled 1</code></li>
<li>强制允许动作：<code>ausearch -c 'sshd' --raw | audit2allow -M my-sshd; semodule -i my-sshd.pp</code></li>
</ul>
<p>通过以上任意一种方法，都可以解决端口绑定的问题。</p>
<h1 id="使用-ssh-通道"><a class="markdownIt-Anchor" href="#使用-ssh-通道"></a> 使用 SSH 通道</h1>
<p>您可以使用 SSH 来开启一个加密的通道，以供其他不支持加密的应用程序使用。</p>
<p>例如，要在本地开启一个端口为 8888 的通道，连接到远程服务器 192.168.2.234 的 22 端口，可以执行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token parameter variable">-L</span> <span class="token number">8888</span>:127.0.0.1:22 <span class="token parameter variable">-N</span> <span class="token number">192.168</span>.2.234
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">8888</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:8888          <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">78842</span>/ssh 
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> <span class="token parameter variable">-p</span> <span class="token number">8888</span> <span class="token number">127.0</span>.0.1
Last login: Sun Oct <span class="token number">10</span> 02:20:31 <span class="token number">2021</span> from localhost<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在本地，端口 8888 将保持监听状态，而本地的 SSH 端口将直接连接到远程服务器 192.168.2.234 的 22 端口。要中断通道，只需关闭相应的 SSH 进程即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>DNS 服务</title>
    <url>/1926461212/</url>
    <content><![CDATA[<h1 id="域名系统"><a class="markdownIt-Anchor" href="#域名系统"></a> 域名系统</h1>
<p>域名系统（DNS，Domain Name System）的主要作用是将计算机主机名转换为 IP 地址。</p>
<p>完整主机名（FQDN，Fully Qualified Domain Name）由主机名与域名（Hostname and Domain Name）组成。例如，FQDN 为 <code>www.hxz.ass</code> 的域名为 hxz.ass。</p>
<p>在 DNS 数据库中，针对每个要解析的域（domain）称为一个区域（zone）。每个 DNS 服务器必备称为 hint 的区域，记录根服务器地址。</p>
<p>域名系统利用类似树状目录结构，将主机名的管理分配在不同层级的 DNS 服务器中，并进行分层管理。最顶层的 DNS 服务器叫根服务器（root），最早管理的只有 com、edu、gov、mil、org、net 这种特殊区域以及以国家为分类的第二层的主机名，这两者称为顶级域名（TLDs，Top Level Domains）。</p>
<p>DNS 采用分层查询流程的好处是：</p>
<ul>
<li>当主机名有修改时，只需要改动上一层 DNS 服务器记录，维护简单。</li>
<li>DNS 服务器可以将主机名解析结果缓存起来，下次查询能快速响应。</li>
<li>可持续向下授权（子域名授权），也就是可以设置任意多级域名。</li>
</ul>
<p>DNS 服务器使用的监听端口为 53，DNS 查询同时使用 UDP 和 TCP 数据包。</p>
<h1 id="域名注册"><a class="markdownIt-Anchor" href="#域名注册"></a> 域名注册</h1>
<p>申请合法的主机名需要进行注册，注册后可以获得两种类型的数据：</p>
<ul>
<li>一种是域名托管。设置 FQDN 对应的 A 记录，由上层 DNS 服务器来解析主机名。</li>
<li>一种是申请区域查询权。在自己搭建的 DNS 服务器中编写 NS 记录，通过自己的 DNS 服务器来解析主机名。</li>
</ul>
<h1 id="域名查询流程"><a class="markdownIt-Anchor" href="#域名查询流程"></a> 域名查询流程</h1>
<p>以向 DNS 服务器 8.8.8.8 查询域名 <code>www.abc.edu.cn</code> 为例，整个流程如下：</p>
<ol>
<li>首先查询本地 <code>/etc/hosts</code> 文件中是否有记录，如果没有，则向 <code>/etc/resolv.conf</code> 中配置的 DNS 服务器 8.8.8.8 发起查询（查询顺序由 <code>/etc/nsswitch.conf</code> 文件配置）；</li>
<li>DNS 服务器 8.8.8.8 收到查询请求后发现没有相应的记录，会向最顶层服务器（即根服务器）查询域名；</li>
<li>根服务器中记录了顶级域名 <code>.cn</code> 服务器的地址，并将其返回给 8.8.8.8；</li>
<li>顶级域名 <code>.cn</code> 服务器回复二级域名 <code>.edu.cn</code> 服务器的地址给 8.8.8.8；</li>
<li>二级域名 <code>.edu.cn</code> 服务器发送 <code>.abc.edu.cn</code> 对应的 IP 地址给 8.8.8.8；</li>
<li>最后通过访问 <code>.abc.edu.cn</code> 服务器的 IP 地址，获得其对应的 www 服务的 IP 地址；</li>
<li>DNS 服务器 8.8.8.8 将查询结果返回给客户端，并在自己的缓存中记录下来（一般有效时间为 24 小时）。</li>
</ol>
<p>可以使用 <code>dig</code> 和 <code>trace</code> 命令观察这个过程:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> +trace mail.dlut.edu.cn

<span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> DiG <span class="token number">9.11</span>.4-P2-RedHat-9.11.4-26.P2.el7_9.7 <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> +trace mail.dlut.edu.cn
<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd
<span class="token builtin class-name">.</span>                       <span class="token number">25330</span>   IN      NS      m.root-servers.net.
<span class="token builtin class-name">.</span>                       <span class="token number">25330</span>   IN      NS      c.root-servers.net.
<span class="token builtin class-name">.</span>                       <span class="token number">25330</span>   IN      NS      a.root-servers.net.
<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">267</span> bytes from <span class="token number">222.246</span>.129.80<span class="token comment">#53(222.246.129.80) in 4 ms</span>

cn.                     <span class="token number">172800</span>  IN      NS      e.dns.cn.
cn.                     <span class="token number">172800</span>  IN      NS      f.dns.cn.
cn.                     <span class="token number">172800</span>  IN      NS      ns.cernet.net.
cn.                     <span class="token number">86400</span>   IN      DS      <span class="token number">57724</span> <span class="token number">8</span> <span class="token number">2</span> 5D0423633EB24A499BE78AA22D1C0C9BA36218FF49FD95A4CDF1A4AD 97C67044
cn.                     <span class="token number">86400</span>   IN      RRSIG   DS <span class="token number">8</span> <span class="token number">1</span> <span class="token number">86400</span> <span class="token number">20211025050000</span> <span class="token number">20211012040000</span> <span class="token number">14748</span> <span class="token builtin class-name">.</span> H7PWSfaMnU5bqTVD4anI0Gkagqbpu3jXuVX6wiGfaBpMYAU06BlzVDSk TcGqHd5qSfztQrT0ztQnWno12NhCfFzOyf64hv54quKOYWss8ilQnmgX AftgAZYD8V/v/cAbo2EKoCwLD8KAWoiUN9VGQpcLeVpb/O4mQ1xMbRbr ENxir09m6iYn+F9Y3MCTekj79c1RWKJ8Qqn+nJlj+bES2OvDNuEmSHlZ 4D/NSqz4WMI3IaaCk/WaKf6NzZHvazs8NsDVXDnqgND3opj6g0B3fQMC NVbtLO/M+FyuYNXmuk/VOettllpYUAOYaSdPZLxmqWXyTgiVbNXTH74S <span class="token assign-left variable">1cRveA</span><span class="token operator">==</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">707</span> bytes from <span class="token number">2001</span>:500:2f::f<span class="token comment">#53(f.root-servers.net) in 23 ms</span>

mail.dlut.edu.cn.       <span class="token number">59602</span>   IN      A       <span class="token number">202.118</span>.66.82
<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">106</span> bytes from <span class="token number">203.119</span>.26.1<span class="token comment">#53(b.dns.cn) in 4 ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="域名查询命令"><a class="markdownIt-Anchor" href="#域名查询命令"></a> 域名查询命令</h1>
<p>域名查询命令由 <code>bind-utils</code> 包提供，需要使用 <code>yum</code> 安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> bind-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="host"><a class="markdownIt-Anchor" href="#host"></a> host</h2>
<p>使用 <code>host</code> 命令进行正向查询。例如，查询 <code>163.com</code> 的 IP 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">host</span> <span class="token number">163</span>.com
<span class="token number">163</span>.com has address <span class="token number">123.58</span>.180.7
<span class="token number">163</span>.com has address <span class="token number">123.58</span>.180.8
<span class="token number">163</span>.com mail is handled by <span class="token number">10</span> 163mx02.mxmail.netease.com.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-a</code> 参数可以获取更详细的查询信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">host</span> <span class="token parameter variable">-a</span> douban.com
Trying <span class="token string">"douban.com"</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> -<span class="token operator">>></span>HEADER<span class="token operator">&lt;&lt;-</span> opcode: QUERY, status: NOERROR, id: <span class="token number">61546</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> flags: qr rd ra<span class="token punctuation">;</span> QUERY: <span class="token number">1</span>, ANSWER: <span class="token number">3</span>, AUTHORITY: <span class="token number">0</span>, ADDITIONAL: <span class="token number">0</span>

<span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:
<span class="token punctuation">;</span>douban.com.                    IN      ANY

<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
douban.com.             <span class="token number">180</span>     IN      A       <span class="token number">81.70</span>.124.99
douban.com.             <span class="token number">180</span>     IN      A       <span class="token number">140.143</span>.177.206
douban.com.             <span class="token number">180</span>     IN      A       <span class="token number">49.233</span>.242.15

Received <span class="token number">76</span> bytes from 240e:50:5000::80<span class="token comment">#53 in 8 ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="nslookup"><a class="markdownIt-Anchor" href="#nslookup"></a> nslookup</h2>
<p><code>nslookup</code> 命令可用于正向和反向查询，正向查询结果与 <code>host</code> 命令基本一致：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">^C<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">nslookup</span> <span class="token number">163</span>.com
Server:         <span class="token number">222.246</span>.129.80
Address:        <span class="token number">222.246</span>.129.80<span class="token comment">#53</span>

Non-authoritative answer:
Name:   <span class="token number">163</span>.com
Address: <span class="token number">123.58</span>.180.7
Name:   <span class="token number">163</span>.com
Address: <span class="token number">123.58</span>.180.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dig"><a class="markdownIt-Anchor" href="#dig"></a> dig</h2>
<p><code>dig</code> 命令综合了上述两个命令的功能，主要参数包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+trace</td>
<td>从根服务器开始追踪。</td>
</tr>
<tr>
<td>-t type</td>
<td>查询的数据类型，如 MX、NS、SOA 等。</td>
</tr>
<tr>
<td>-x</td>
<td>进行反向解析。</td>
</tr>
</tbody>
</table>
<p>例如，使用默认参数查询 <code>linux.org</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> linux.org

<span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> DiG <span class="token number">9.11</span>.4-P2-RedHat-9.11.4-26.P2.el7_9.7 <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> linux.org
<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd
<span class="token punctuation">;</span><span class="token punctuation">;</span> Got answer:
<span class="token punctuation">;</span><span class="token punctuation">;</span> -<span class="token operator">>></span>HEADER<span class="token operator">&lt;&lt;-</span> opcode: QUERY, status: NOERROR, id: <span class="token number">30344</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> flags: qr rd ra<span class="token punctuation">;</span> QUERY: <span class="token number">1</span>, ANSWER: <span class="token number">2</span>, AUTHORITY: <span class="token number">0</span>, ADDITIONAL: <span class="token number">1</span>

<span class="token punctuation">;</span><span class="token punctuation">;</span> OPT PSEUDOSECTION:
<span class="token punctuation">;</span> EDNS: version: <span class="token number">0</span>, flags:<span class="token punctuation">;</span> udp: <span class="token number">4096</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:
<span class="token punctuation">;</span>linux.org.                     IN      A

<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
linux.org.              <span class="token number">300</span>     IN      A       <span class="token number">104.21</span>.48.239
linux.org.              <span class="token number">300</span>     IN      A       <span class="token number">172.67</span>.157.1

<span class="token punctuation">;</span><span class="token punctuation">;</span> Query time: <span class="token number">338</span> msec
<span class="token punctuation">;</span><span class="token punctuation">;</span> SERVER: <span class="token number">222.246</span>.129.80<span class="token comment">#53(222.246.129.80)</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> WHEN: Wed Oct <span class="token number">13</span> 03:21:51 CST <span class="token number">2021</span>
<span class="token punctuation">;</span><span class="token punctuation">;</span> MSG SIZE  rcvd: <span class="token number">70</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询结果中的重要部分如下：</p>
<ul>
<li>QUESTION：显示所查询的内容。</li>
<li>ANSWER：显示查询结果，数字 300 表示查询结果的缓存时间。</li>
<li>AUTHORITY：显示查询结果来源的 DNS 服务器。</li>
</ul>
<h2 id="whois"><a class="markdownIt-Anchor" href="#whois"></a> whois</h2>
<p><code>whois</code> 用于查询域名所有者的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ whois <span class="token number">163</span>.com
   Domain Name: <span class="token number">163</span>.COM
   Registry Domain ID: 473619_DOMAIN_COM-VRSN
   Registrar WHOIS Server: whois.markmonitor.com
   Registrar URL: http://www.markmonitor.com
   Updated Date: <span class="token number">2019</span>-01-25T07:56:57Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="正解文件记录"><a class="markdownIt-Anchor" href="#正解文件记录"></a> 正解文件记录</h1>
<p>从主机名查询到 IP 的流程称为正向解析，正解文件资源记录（RR，Resource Record）格式如下：</p>
<p><code>[domain]  [ttl]  IN  [[RR type]  [RR data]]</code></p>
<p>字段说明：</p>
<ul>
<li>domain：域名记录使用 FQDN，也就是在主机名末尾加上小数点。例如 <code>www.abc.com.</code></li>
<li>ttl：暂存时间（time to live），单位为秒。指其他 DNS 服务器缓存此笔记录的时间。</li>
<li>IN：固定关键词。</li>
<li>RR type：资源类型，如 A 或 NS。</li>
<li>RR data：资源内容，如 IP 地址或 NS 域名。</li>
</ul>
<p>资源类型有下面几种:</p>
<ul>
<li>
<p>A（Address）记录：记录对应 IPv4 地址。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-t</span> a douban.com
douban.com.             <span class="token number">300</span>     IN      A       <span class="token number">81.70</span>.124.99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p>AAAA 记录：记录对应 IPv6 地址。</p>
</li>
<li>
<p>NS（NameServer）记录：查询管理区域名（Zone）的服务器主机名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-t</span> ns douban.com
douban.com.             <span class="token number">59880</span>   IN      NS      ns3.dnsv4.com.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p>SOA（Start Of Authority）：开始验证的标志。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-t</span> soa douban.com
douban.com.             <span class="token number">180</span>     IN      SOA     ns3.dnsv4.com. enterprise2dnsadmin.dnspod.com. <span class="token number">1629873707</span> <span class="token number">3600</span> <span class="token number">180</span> <span class="token number">1209600</span> <span class="token number">180</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>SOA 后面会接七个参数，按顺序分别表示：</p>
<ul>
<li>主 DNS 服务器主机名。</li>
<li>管理员的 Email 地址。第一个点需要替换成 @ 才是实际地址。</li>
<li>序号（Serial），代表数据库文件的版本，序号越大表示越新。</li>
<li>更新频率（Refresh），单位为秒，需大于 2 * Retry 时间。指从服务器向主服务器检查更新的频率。</li>
<li>失败重试时间（Retry），单位为秒。指从服务器连不上主服务器时，重试等待时间。</li>
<li>失效时间（Expire），单位为秒，需大于 Refresh+Retry 或七天以上时间。指失败尝试总时长到这一值后停止重试。</li>
<li>缓存时间（Minimum TTL），单位为秒。当没有设置 TTL 时，用此值代替。</li>
</ul>
</li>
<li>
<p>MX（Mail eXchanger）记录：邮件服务器主机名字。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-t</span> mx dlut.edu.cn 
dlut.edu.cn.            <span class="token number">74898</span>   IN      MX      <span class="token number">20</span> mx2.dlut.edu.cn.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>邮件服务器前面的数字代表优先级，有多台邮件服务器情况下数字越小优先级越高。</p>
</li>
<li>
<p>CNAME（Alias）记录：主机名的别名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> www.douban.com
www.douban.com.         <span class="token number">2</span>       IN      CNAME   forward.douban.com.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>常用于单 IP 地址对应多个域名情况下，可以将域名指向别名，而别名指向目标 IP。这样当更换服务器 IP 地址时，只需要更新别名与 IP 地址对应的记录，这样可以简化管理过程并提高效率。</p>
</li>
</ul>
<h1 id="反解文件记录"><a class="markdownIt-Anchor" href="#反解文件记录"></a> 反解文件记录</h1>
<p>从 IP 反解析到主机名的流程称为反解，需要直属上层 ISP 授权。使用 <code>nslookup</code> 进行反解查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">nslookup</span> <span class="token number">123.58</span>.180.7
<span class="token number">7.180</span>.58.123.in-addr.arpa.       name <span class="token operator">=</span> <span class="token number">163</span>.com.

Authoritative answers can be found from:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 IP 从左到右解析与域名相反，因此反解的 Zone 必须将 IP 反过来写，并在结尾加上 <code>.in-addr.arpa.</code> 字样。</p>
<p>反解区最主要的类型是 PTR（PoinTeR）记录，即查询 IP 对应的主机名。</p>
<h1 id="客户端设置"><a class="markdownIt-Anchor" href="#客户端设置"></a> 客户端设置</h1>
<p>客户端和 DNS 相关的配置文件主要有三个：</p>
<ul>
<li><code>/etc/hosts</code>：本地文件，用于设置主机名与 IP 对应关系。</li>
<li><code>/etc/resolv.conf</code>：记录 DNS 服务器 IP 地址。会被 DHCP 服务器更新，可以在网卡配置文件中加入 <code>PEERDNS=no</code> 来禁止更新。</li>
<li><code>/etc/nsswitch.conf</code>：决定 DNS 查询顺序，优先进行本地解析还是 DNS 服务器解析。</li>
</ul>
<p><code>/etc/hosts</code> 的设置格式如下，每行一个主机名和 IP 对应关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/hosts
<span class="token number">207.97</span>.227.243 www.github.com 
<span class="token number">192.168</span>.2.234  server1 smblinux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>/etc/resolv.conf</code> 的设置格式如下，可以设置多个 DNS 地址，一般不超过 3 个：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/resolv.conf
<span class="token comment"># Generated by NetworkManager</span>
nameserver <span class="token number">222.246</span>.129.80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>/etc/nsswitch.conf</code> 的设置选项如下，<code>files</code> 代表本地解析，<code>dns</code> 代表网络 DNS 服务器解析：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/nsswitch.conf
hosts:      files dns myhostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="主从构架"><a class="markdownIt-Anchor" href="#主从构架"></a> 主从构架</h1>
<p>为了确保 DNS 服务的持续可用性，通常会采用主从架构（Master/Slave）来搭建 DNS 服务器。</p>
<p>在主服务器（Master）中，所有与主机名相关的信息都需要手动进行配置，而从服务器（Slave）则直接从主服务器中拉取配置进行同步。</p>
<p>主从服务器之间的数据同步是基于数据库版本号进行的。每当主服务器更新数据时，数据库版本号会增加，主服务器会主动通知从服务器进行数据库更新。从服务器会定期检查主服务器的数据库版本，并根据需要进行更新。</p>
<h1 id="dns-服务器安装"><a class="markdownIt-Anchor" href="#dns-服务器安装"></a> DNS 服务器安装</h1>
<p>搭建 DNS 服务器所需的软件名为 BIND（Berkeley Internet Name Domain）。可以使用 <code>yum</code> 安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token builtin class-name">bind</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>与服务器设置相关的文件和目录有：</p>
<ul>
<li><code>/etc/named.conf</code>：主配置文件。</li>
<li><code>/etc/sysconfig/named</code>：用于控制 chroot 和其他额外参数的启动文件。</li>
<li><code>/var/named/</code>：默认的数据库存放目录。</li>
<li><code>/var/run/named/</code>：named 程序存放 pid 文件的目录。</li>
</ul>
<h1 id="缓存-dns-服务器"><a class="markdownIt-Anchor" href="#缓存-dns-服务器"></a> 缓存 DNS 服务器</h1>
<p>最简单的高速缓存（Cache-Only）DNS 服务器只需要一个根目录的区域文件，它只具备缓存搜索结果的功能。甚至连根目录的指向也可以不需要，在上层 DNS 服务器进行转发。</p>
<p>配置文件 <code>/etc/named.conf</code> 的内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/named.conf
options <span class="token punctuation">&#123;</span>
        listen-on port <span class="token number">53</span> <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        listen-on-v6 port <span class="token number">53</span> <span class="token punctuation">&#123;</span> ::1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        directory       <span class="token string">"/var/named"</span><span class="token punctuation">;</span>
        dump-file       <span class="token string">"/var/named/data/cache_dump.db"</span><span class="token punctuation">;</span>
        statistics-file <span class="token string">"/var/named/data/named_stats.txt"</span><span class="token punctuation">;</span>
        memstatistics-file <span class="token string">"/var/named/data/named_mem_stats.txt"</span><span class="token punctuation">;</span>
        recursing-file  <span class="token string">"/var/named/data/named.recursing"</span><span class="token punctuation">;</span>
        secroots-file   <span class="token string">"/var/named/data/named.secroots"</span><span class="token punctuation">;</span>
        allow-query     <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        recursion <span class="token function">yes</span><span class="token punctuation">;</span>
        forward only<span class="token punctuation">;</span>
        forwarders <span class="token punctuation">&#123;</span>
                <span class="token number">222.246</span>.129.80<span class="token punctuation">;</span>
                <span class="token number">8.8</span>.8.8<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件选项说明如下：</p>
<ul>
<li>
<p><strong>listen-on port 53 { any; };</strong> 设置本机监听使用的网口，可以设置多个端口。</p>
</li>
<li>
<p><strong>directory “/var/named”;</strong> 设置正解和反解的区域文件存放目录。</p>
</li>
<li>
<p><strong>dump-file, statistics-file, memstatistics-file</strong> 与 named 服务有关的统计信息文件路径。</p>
</li>
<li>
<p><strong>allow-query { any; };</strong> 设置可以使用 DNS 查询的客户端列表。</p>
</li>
<li>
<p><strong>forward only;</strong> 设置 DNS 服务器仅进行转发，忽略区域文件设置。</p>
</li>
<li>
<p><strong>forwarders {222.246.129.80; 8.8.8.8;};</strong> 设置转发到的上层 DNS 服务器地址。</p>
</li>
</ul>
<p>启动 named 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> named
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span><span class="token function">grep</span> named
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">10.1</span>.1.1:53             <span class="token number">0.0</span>.0.0:*           LISTEN      <span class="token number">43486</span>/named   
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.2.254:53        <span class="token number">0.0</span>.0.0:*           LISTEN      <span class="token number">43486</span>/named   
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:53            <span class="token number">0.0</span>.0.0:*           LISTEN      <span class="token number">43486</span>/named   
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:953           <span class="token number">0.0</span>.0.0:*           LISTEN      <span class="token number">43486</span>/named <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，953 端口是 named 的远程控制功能，称为远程名称解析服务控制功能（RNDC，Remote Name Daemon Control）。</p>
<p>查看 named 相关日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> <span class="token parameter variable">-30</span> /var/log/messages <span class="token operator">|</span> <span class="token function">grep</span> named
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: configuring <span class="token builtin class-name">command</span> channel from <span class="token string">'/etc/rndc.key'</span>
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: <span class="token builtin class-name">command</span> channel listening on <span class="token number">127.0</span>.0.1<span class="token comment">#953</span>
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: configuring <span class="token builtin class-name">command</span> channel from <span class="token string">'/etc/rndc.key'</span>
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: <span class="token builtin class-name">command</span> channel listening on ::1<span class="token comment">#953</span>
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: managed-keys-zone: loaded serial <span class="token number">0</span>
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: all zones loaded
Oct <span class="token number">13</span> 05:20:42 server2 named<span class="token punctuation">[</span><span class="token number">43486</span><span class="token punctuation">]</span>: running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用客户端进行测试，使用 <code>dig</code> 指定 DNS 服务器为 192.168.2.254：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token number">163</span>.com @192.168.2.254
<span class="token punctuation">;</span><span class="token punctuation">;</span> SERVER: <span class="token number">192.168</span>.2.254<span class="token comment">#53(192.168.2.254)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果显示通过 192.168.2.254 服务器解析成功，表示已经成功配置。</p>
<h1 id="配置-dns-主服务器"><a class="markdownIt-Anchor" href="#配置-dns-主服务器"></a> 配置 DNS 主服务器</h1>
<p>假设要搭建 DNS 服务器，域名规划为 hxz.ass，搭配 IP 网段为 192.168.2.0/24，需要设置的配置文件有以下几个：</p>
<ul>
<li>/etc/named.conf: 主要配置文件.</li>
<li>/var/named/named.hxz.ass: 主要的区域正解文件.</li>
<li>/var/named/named.192.168.2: 主要的区域反解文件.</li>
<li>/var/named/named.ca: 由 bind 软件提供的.正解文件.</li>
</ul>
<p>整个 DNS 测试环境规划如下:</p>
<table>
<thead>
<tr>
<th>系统与 IP</th>
<th>主机名与 RR 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux (192.168.2.254)</td>
<td>master.hxz.ass (NS, A)<br />www.hxz.ass (A)<br />ftp.hxz.ass (CNAME)<br />www.hxz.ass (MX)</td>
<td>DNS 设置使用 master.hxz.ass<br />主要名称为 www.hxz.ass<br />其他都是 CNAME</td>
</tr>
<tr>
<td>Linux (192.168.2.234)</td>
<td>slave.hxz.ass (NS, A)<br />client.hxz.ass (A)</td>
<td>作为 DNS 从服务器</td>
</tr>
<tr>
<td>Win10 (192.168.2.101)</td>
<td>win.hxz.ass (A)</td>
<td>工作站主机</td>
</tr>
<tr>
<td>Linux (10.1.1.2)</td>
<td></td>
<td>测试使用的客户端</td>
</tr>
</tbody>
</table>
<h2 id="主要配置文件"><a class="markdownIt-Anchor" href="#主要配置文件"></a> 主要配置文件</h2>
<p>主要配置文件 <code>/etc/named.conf</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/named.conf
options <span class="token punctuation">&#123;</span>
        listen-on port <span class="token number">53</span> <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        listen-on-v6 port <span class="token number">53</span> <span class="token punctuation">&#123;</span> ::1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        directory       <span class="token string">"/var/named"</span><span class="token punctuation">;</span>
        dump-file       <span class="token string">"/var/named/data/cache_dump.db"</span><span class="token punctuation">;</span>
        statistics-file <span class="token string">"/var/named/data/named_stats.txt"</span><span class="token punctuation">;</span>
        memstatistics-file <span class="token string">"/var/named/data/named_mem_stats.txt"</span><span class="token punctuation">;</span>
        recursing-file  <span class="token string">"/var/named/data/named.recursing"</span><span class="token punctuation">;</span>
        secroots-file   <span class="token string">"/var/named/data/named.secroots"</span><span class="token punctuation">;</span>
        allow-query     <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        recursion <span class="token function">yes</span><span class="token punctuation">;</span>
        allow-transfer  <span class="token punctuation">&#123;</span> none<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

zone <span class="token string">"."</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
zone <span class="token string">"hxz.ass"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.hxz.ass"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
zone <span class="token string">"2.168.192.in-addr.arpa"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.192.168.2"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>allow-transfer</code> 设置是否允许来自从 DNS 服务器对整个领域数据进行传送。</p>
<h2 id="正解文件配置"><a class="markdownIt-Anchor" href="#正解文件配置"></a> 正解文件配置</h2>
<p>正解文件设置数据行首前不可有空格符，正解配置文件 <code>/var/named/named.hxz.ass</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/named/named.hxz.ass
<span class="token variable">$TTL</span>    <span class="token number">600</span>
@               IN      SOA     master.hxz.ass. ad.www.hxz.ass<span class="token punctuation">(</span><span class="token number">2020010101</span> 3H 15M 1W 1D<span class="token punctuation">)</span>
@               IN      NS      master.hxz.ass.
master.hxz.ass. IN      A       <span class="token number">192.168</span>.2.254
@               IN      MX  <span class="token number">10</span>  www.hxz.ass.
 
www.hxz.ass.    IN      A       <span class="token number">192.168</span>.2.254
ftp.hxz.ass.    IN      CNAME   www.hxz.ass.
 
slave.hxz.ass.  IN      A       <span class="token number">192.168</span>.2.234
client.hxz.ass. IN      A       <span class="token number">192.168</span>.2.234
win.hxz.ass.    IN      A       <span class="token number">192.168</span>.2.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>@</code> 符号代表主配置文件中 <code>zone</code> 的意思。例如，正解中的 <code>@</code> 代表 <code>hxz.ass</code>。反解中的 <code>@</code> 代表 <code>2.168.192.in-addr.arpa</code>。</p>
<p>开头的 <code>$TTL</code> 是将 TTL 设置应用到每笔 RR 记录中。</p>
<h2 id="反解文件配置"><a class="markdownIt-Anchor" href="#反解文件配置"></a> 反解文件配置</h2>
<p>反解文件仅需设置 PTR 记录，反解配置文件 <code>/var/named/named.192.168.2</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/named/named.192.168.2
<span class="token variable">$TTL</span>    <span class="token number">600</span>
@       IN      SOA     master.hxz.ass. ad.www.hxz.ass.<span class="token punctuation">(</span><span class="token number">2020010101</span> 3H 15M 1W 1D<span class="token punctuation">)</span>
@       IN      NS      master.hxz.ass.
<span class="token number">254</span>     IN      PTR     master.hxz.ass.

<span class="token number">254</span>     IN      PTR     www.hxz.ass.
<span class="token number">234</span>     IN      PTR     slave.hxz.ass.
<span class="token number">101</span>     IN      PTR     win.hxz.ass.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于主配置文件中已经设置了反解区域（zone），因此 IP 全名部分已经包含了 <code>192.168.2</code>，所以最左边的数值只需填入最后一个 IP 位，例如 <code>234</code> 代表 <code>192.168.2.234</code>。</p>
<h2 id="服务启动"><a class="markdownIt-Anchor" href="#服务启动"></a> 服务启动</h2>
<p>直接启动 <code>named</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> named<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要放行防火墙，设置以下规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">53</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> udp <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">--dport</span> <span class="token number">53</span> <span class="token parameter variable">--sport</span> <span class="token number">1024</span>:65534 <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="客户端测试"><a class="markdownIt-Anchor" href="#客户端测试"></a> 客户端测试</h2>
<p>在客户端修改 <code>/etc/resolv.conf</code> 文件，将 DNS 地址设为 <code>192.168.2.254</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/resolv.conf
<span class="token comment"># Generated by NetworkManager</span>
nameserver <span class="token number">192.168</span>.2.254
nameserver <span class="token number">222.246</span>.129.80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>dig</code> 命令进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> master.hxz.ass
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
master.hxz.ass.         <span class="token number">600</span>     IN      A       <span class="token number">192.168</span>.2.254
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> www.hxz.ass
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
www.hxz.ass.            <span class="token number">600</span>     IN      A       <span class="token number">192.168</span>.2.254
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> ftp.hxz.ass
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
ftp.hxz.ass.            <span class="token number">600</span>     IN      CNAME   www.hxz.ass.
www.hxz.ass.            <span class="token number">600</span>     IN      A       <span class="token number">192.168</span>.2.254
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> win.hxz.ass
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
win.hxz.ass.            <span class="token number">600</span>     IN      A       <span class="token number">192.168</span>.2.101
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-t</span> mx hxz.ass
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
hxz.ass.                <span class="token number">600</span>     IN      MX      <span class="token number">10</span> www.hxz.ass.
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-x</span> <span class="token number">192.168</span>.2.254
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
<span class="token number">254.2</span>.168.192.in-addr.arpa. <span class="token number">600</span> IN      PTR     master.hxz.ass.
<span class="token number">254.2</span>.168.192.in-addr.arpa. <span class="token number">600</span> IN      PTR     www.hxz.ass.
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-x</span> <span class="token number">192.168</span>.2.101
<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:
<span class="token number">101.2</span>.168.192.in-addr.arpa. <span class="token number">600</span> IN      PTR     win.hxz.ass.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有从服务器，每次更新区域文件后，记得修改序列号（Serial），也就是 SOA 参数括号内的第一个数字，这样从服务器才会自动从主服务器更新数据库。</p>
<h1 id="配置-dns-从服务器"><a class="markdownIt-Anchor" href="#配置-dns-从服务器"></a> 配置 DNS 从服务器</h1>
<p>由于前面已经架设了一台主服务器 192.168.2.254，现在在 192.168.2.234 上搭建一台从服务器。</p>
<p>首先需要在主服务器的主要配置文件中添加 <code>allow-transfer</code> 选项，以允许从服务器进行同步：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/named.conf
zone <span class="token string">"hxz.ass"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.hxz.ass"</span><span class="token punctuation">;</span>
        allow-transfer <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.234<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
zone <span class="token string">"2.168.192.in-addr.arpa"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.192.168.2"</span><span class="token punctuation">;</span>
        allow-transfer <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.234<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后修改主服务器中的正解和反解文件配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/named/named.hxz.ass
@               IN      NS      slave.hxz.ass.
slave.hxz.ass.  IN      A       <span class="token number">192.168</span>.2.234
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/named/named.192.168.2
@       In      NS      slave.hxz.ass.
<span class="token number">234</span>     IN      PTR     slave.hxz.ass.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从服务器安装 <code>bind</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 sss<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token builtin class-name">bind</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>从服务器主配置文件 <code>/etc/named.conf</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/named.conf
options <span class="token punctuation">&#123;</span>
        listen-on port <span class="token number">53</span> <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        listen-on-v6 port <span class="token number">53</span> <span class="token punctuation">&#123;</span> ::1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        directory       <span class="token string">"/var/named"</span><span class="token punctuation">;</span>
        dump-file       <span class="token string">"/var/named/data/cache_dump.db"</span><span class="token punctuation">;</span>
        statistics-file <span class="token string">"/var/named/data/named_stats.txt"</span><span class="token punctuation">;</span>
        memstatistics-file <span class="token string">"/var/named/data/named_mem_stats.txt"</span><span class="token punctuation">;</span>
        recursing-file  <span class="token string">"/var/named/data/named.recursing"</span><span class="token punctuation">;</span>
        secroots-file   <span class="token string">"/var/named/data/named.secroots"</span><span class="token punctuation">;</span>
        allow-query     <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        recursion <span class="token function">yes</span><span class="token punctuation">;</span>
        allow-transfer  <span class="token punctuation">&#123;</span> none<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

zone <span class="token string">"."</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
zone <span class="token string">"hxz.ass"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> slave<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"slaves/named.hxz.ass"</span><span class="token punctuation">;</span>
        masters <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.254<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
zone <span class="token string">"2.168.192.in-addr.arpa"</span> IN <span class="token punctuation">&#123;</span>
        <span class="token builtin class-name">type</span> slave<span class="token punctuation">;</span>
        <span class="token function">file</span> <span class="token string">"slaves/named.192.168.2"</span><span class="token punctuation">;</span>
        masters <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.254<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后启动从服务器上的 DNS 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl start named
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> named<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用 <code>dig</code> 命令进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> master.hxz.ass @127.0.0.1
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> <span class="token parameter variable">-x</span> <span class="token number">192.168</span>.2.254 @127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="view-功能"><a class="markdownIt-Anchor" href="#view-功能"></a> View 功能</h1>
<p>DNS 的 View 功能能够让不同来源（内外网）的用户获取对应 Zone 的响应。因此，在同一个 Zone 中需要进行两种不同的设置。</p>
<p>修改主配置文件 <code>/etc/named.conf</code> 内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/named.conf
options <span class="token punctuation">&#123;</span>
        listen-on port <span class="token number">53</span> <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        listen-on-v6 port <span class="token number">53</span> <span class="token punctuation">&#123;</span> ::1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        directory       <span class="token string">"/var/named"</span><span class="token punctuation">;</span>
        dump-file       <span class="token string">"/var/named/data/cache_dump.db"</span><span class="token punctuation">;</span>
        statistics-file <span class="token string">"/var/named/data/named_stats.txt"</span><span class="token punctuation">;</span>
        memstatistics-file <span class="token string">"/var/named/data/named_mem_stats.txt"</span><span class="token punctuation">;</span>
        recursing-file  <span class="token string">"/var/named/data/named.recursing"</span><span class="token punctuation">;</span>
        secroots-file   <span class="token string">"/var/named/data/named.secroots"</span><span class="token punctuation">;</span>
        allow-query     <span class="token punctuation">&#123;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        recursion <span class="token function">yes</span><span class="token punctuation">;</span>
        allow-transfer  <span class="token punctuation">&#123;</span> none<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

acl lan <span class="token punctuation">&#123;</span> <span class="token number">10.1</span>.1.0/24<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
acl wan <span class="token punctuation">&#123;</span> <span class="token operator">!</span> <span class="token number">10.1</span>.1.0/24<span class="token punctuation">;</span> any<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

view <span class="token string">"lan"</span> <span class="token punctuation">&#123;</span>
        match-clients <span class="token punctuation">&#123;</span> <span class="token string">"lan"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        zone <span class="token string">"."</span> IN <span class="token punctuation">&#123;</span>
                <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>
                <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        zone <span class="token string">"hxz.ass"</span> IN <span class="token punctuation">&#123;</span>
                <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
                <span class="token function">file</span> <span class="token string">"named.hxz.ass-lan"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

view <span class="token string">"wan"</span> <span class="token punctuation">&#123;</span>
        match-clients <span class="token punctuation">&#123;</span> <span class="token string">"wan"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        zone <span class="token string">"."</span> IN <span class="token punctuation">&#123;</span>
                <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>
                <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      
        zone <span class="token string">"hxz.ass"</span> IN <span class="token punctuation">&#123;</span>
                <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
                <span class="token function">file</span> <span class="token string">"named.hxz.ass"</span><span class="token punctuation">;</span>
                allow-transfer <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.234<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        zone <span class="token string">"2.168.192.in-addr.arpa"</span> IN <span class="token punctuation">&#123;</span>
                <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>
                <span class="token function">file</span> <span class="token string">"named.192.168.2"</span><span class="token punctuation">;</span>
                allow-transfer <span class="token punctuation">&#123;</span> <span class="token number">192.168</span>.2.234<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改内网正解区域（zone）配置文件 <code>/var/named/master/named.hxz.ass-lan</code>，将来自内网 10.1.1.0 地址的客户端查询 <code>hxz.ass</code> 的结果指向内网地址 10.1.1.1:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /var/named/named.hxz.ass-lan
<span class="token variable">$TTL</span>    <span class="token number">600</span>
@               IN      SOA     master.hxz.ass. ad.www.hxz.ass<span class="token punctuation">(</span><span class="token number">2020010101</span> 3H 15M 1W 1D<span class="token punctuation">)</span>
@               IN      NS      master.hxz.ass.
@               IN      NS      slave.hxz.ass.
master.hxz.ass. IN      A       <span class="token number">10.1</span>.1.1
slave.hxz.ass.  IN      A       <span class="token number">192.168</span>.2.234
@               IN      MX  <span class="token number">10</span>  www.hxz.ass.

www.hxz.ass.    IN      A       <span class="token number">10.1</span>.1.1
ftp.hxz.ass.    IN      CNAME   www.hxz.ass.

slave.hxz.ass.  IN      A       <span class="token number">192.168</span>.2.234
client.hxz.ass. IN      A       <span class="token number">192.168</span>.2.234
win.hxz.ass.    IN      A       <span class="token number">192.168</span>.2.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重启服务后，分别使用内网和外网进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ systemctl restart named
<span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> www.hxz.ass
www.hxz.ass.            <span class="token number">600</span>     IN      A       <span class="token number">10.1</span>.1.1
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">dig</span> www.hxz.ass @192.168.2.254
www.hxz.ass.            <span class="token number">600</span>     IN      A       <span class="token number">192.168</span>.2.254<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 网络安全</title>
    <url>/3333155646/</url>
    <content><![CDATA[<h1 id="网络传输流程"><a class="markdownIt-Anchor" href="#网络传输流程"></a> 网络传输流程</h1>
<p>当一个安全配置的服务器要接收外来数据时，可以分为以下阶段：</p>
<ul>
<li>
<p><strong>防火墙的分析</strong></p>
<p>Linux 系统内建防火墙机制，因此首先连接要通过防火墙。</p>
</li>
<li>
<p><strong>服务的基本功能</strong></p>
<p>在应用层面来看，某些软件带有控制访问功能。例如 <code>httpd.conf</code> 配置文件内可以规定某些 IP 来源不能使用 <code>httpd</code> 这个服务来取得主机的数据。</p>
</li>
<li>
<p><strong>SELinux 对网络服务的权限控制</strong></p>
<p>为了避免前一个步骤的权限误用，或者是程序有问题所造成的安全问题，SELinux 可以针对网络服务的权限设置一些规则，让程序能够拥有的功能有限。这样即使 <code>httpd</code> 真的被攻击取得 root 的使用权，所能操作的范围也被控制在 <code>/var/www/html</code> 里面，无法对系统造成进一步威胁。</p>
</li>
<li>
<p><strong>使用主机的文件系统资源</strong></p>
<p>主要是文件系统的权限设置，如果文件权限错误，用户依然可能无法获得网页数据。</p>
</li>
</ul>
<h1 id="常见攻击手段"><a class="markdownIt-Anchor" href="#常见攻击手段"></a> 常见攻击手段</h1>
<p>下面介绍一些常见的网络攻击手法。完善防火墙规则、定期自动更新软件和定时检查日志是应对网络攻击的基本工作。同时要时刻保持警惕，及时采取措施来保护系统和数据的安全。</p>
<h2 id="暴力破解密码"><a class="markdownIt-Anchor" href="#暴力破解密码"></a> 暴力破解密码</h2>
<p>假如有人知道了你的主机地址，可以利用端口扫描工具（如 <code>NMAP</code>）来扫描主机，得出主机上运行的服务，例如邮箱服务。接下来使用脚本来尝试常用管理员账号（如 admin）的密码，通过密码字典就能破解一些简单密码，获取管理权限。</p>
<p>不过现在很多软件都有密码输入次数限制，连续输入错误到一定次数会限制攻击者的访问。此时攻击者可以使用代理池来更换 IP 地址继续破解，不过这样会耗时耗力，因此现在比较少见了。</p>
<p>对于这种攻击，设置一个不易破解的密码是最重要的。其次可以制定密码修改策略，提高密码破解的难度。</p>
<h2 id="本地提权"><a class="markdownIt-Anchor" href="#本地提权"></a> 本地提权</h2>
<p>如果已经拥有本机账号，在登录以后可以设法提升权限。例如利用下面这些具有 SUID 的二进制文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ <span class="token function">find</span> / <span class="token parameter variable">-perm</span> <span class="token number">4775</span> <span class="token parameter variable">-uid</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>目前系统已经很少有能如此利用二进制文件了。</p>
<h2 id="缓冲区溢出攻击"><a class="markdownIt-Anchor" href="#缓冲区溢出攻击"></a> 缓冲区溢出攻击</h2>
<p>入侵程序的目的是取得 root 执行权，或是通过 root 所执行的程序指向自己。缓冲区溢出攻击的目的在于干扰具有某些特权运行的程序功能，使得攻击者取得程序控制权。如果程序由 root 所执行，那么整个主机就有可能被控制。</p>
<p>从程序角度看，是在寻求改变程序的执行流程，使之跳转到攻击代码，例如溢出一个没有边界检查的缓冲区。</p>
<p>主要防范方法是编写程序时注意安全检查。</p>
<h2 id="利用程序漏洞主动攻击"><a class="markdownIt-Anchor" href="#利用程序漏洞主动攻击"></a> 利用程序漏洞主动攻击</h2>
<p>程序 Bug 可能造成安全问题，导致系统权限被攻击者掌握。由于程序问题被公开后，网上会出现针对漏洞的攻击程序代码，很容易被别有用心的人拿来使用，因此这类攻击比较常见。</p>
<p>针对解决方法也很简单：保持系统更新，关闭掉不需要的软件和服务即可。</p>
<h2 id="利用社会工程学欺骗"><a class="markdownIt-Anchor" href="#利用社会工程学欺骗"></a> 利用社会工程学欺骗</h2>
<p>社会工程学欺骗方式很多，有些甚至完全不需要懂电脑技术，例如通过邮件和仿制网站钓鱼，来骗取用户账号密码。</p>
<p>只要记住不要随便透露账号密码信息，多留意下网站网址或交流对象身份即可。</p>
<h2 id="利用程序功能的被动攻击"><a class="markdownIt-Anchor" href="#利用程序功能的被动攻击"></a> 利用程序功能的被动攻击</h2>
<p>在一些利用浏览器漏洞的网站上，只是打开页面就能运行网站上插入的恶意代码，进而使主机遭受攻击。</p>
<p>作为应对，记得更新浏览器和设置好不要自动下载运行文件。</p>
<h2 id="蠕虫和木马的-rootkit"><a class="markdownIt-Anchor" href="#蠕虫和木马的-rootkit"></a> 蠕虫和木马的 Rootkit</h2>
<p>蠕虫会让主机一直发送数据包向外攻击。木马则是在主机中开启一个后门（端口），来进一步控制主机。</p>
<p>Rootkit 是指可以获取 root 权限的一组工具，主要也是通过主机的程序漏洞进行攻击。很多 Rootkit 本身就是蠕虫或木马，主要通过下载安装带有 Rootkit 的软件来传播，一旦被绑架非常难以追踪与清除。</p>
<p>作为防范最重要的一点是不要下载安装来路不明的程序，另外可以安装防范扫描 Rootkit 的软件，确保安全。</p>
<h2 id="ddos-攻击"><a class="markdownIt-Anchor" href="#ddos-攻击"></a> DDoS 攻击</h2>
<p>DDoS（Distributed Denial of Service）叫分布式拒绝服务，是通过分散在世界各地的僵尸计算机进行高频率的请求，从而使正常请求无法处理的攻击方式。</p>
<p>最常见的是 SYN Flood 攻击，发送带有 SYN 的 TCP 数据包请求连接，但将服务器的回复确认数据包丢弃，造成服务器一直处于等待状态。一旦此类数据包过多，服务器的端口被占满，就无法继续提供服务。</p>
<p>现在的云服务提供商和 CDN 服务提供商都具有一定的抵御 DDoS 攻击能力，会自动阻断异常请求和流量，因此可以根据需要进行购买。</p>
<h1 id="ipv4-内核管理功能"><a class="markdownIt-Anchor" href="#ipv4-内核管理功能"></a> IPv4 内核管理功能</h1>
<p>在 <code>/proc/sys/net/ipv4/</code> 目录中还有许多内核网络功能的设置，可以通过将其值设置为 1 来启用。如果希望在开机时自动启用这些设置，可以将其写入 <code>/etc/sysctl.conf</code> 文件，并运行 <code>sysctl -p</code> 命令。</p>
<h2 id="tcp_syncookies"><a class="markdownIt-Anchor" href="#tcp_syncookies"></a> tcp_syncookies</h2>
<p>SYN Cookie 模块用于抵御 DoS 攻击，在系统使用的端口（1024~65535）即将耗尽时会自动启用。</p>
<p>启用 SYN Cookie 后，在主机发送 SYN/ACK 确认数据包之前，会要求客户端在短时间内回复一个序列号。这个序列号包含了原始 SYN 数据包中的许多信息，包括 IP 和端口等。如果客户端能够正确回复序列号，主机会确认该数据包是可信的，并发送 SYN/ACK 数据包。否则，数据包将被丢弃。</p>
<p>由于 SYN Cookie 的设置违反了 TCP 的三次握手规定，所以可能会导致某些服务的延迟问题，例如 SMTP。因此，它不适用于负载已经很高的服务器，因为在负载过高的主机上，内核有时会错误地判断遭受 SYN Flood 攻击。</p>
<h2 id="icmp_echo_ignore"><a class="markdownIt-Anchor" href="#icmp_echo_ignore"></a> icmp_echo_ignore</h2>
<p>使用大量的大尺寸 Ping 包发送到服务器可能会导致服务器带宽满载或无响应，这种攻击方式被称为 Ping Flooding 和 Ping of Death。</p>
<p>可以通过防火墙取消对 ICMP 类型 8 的 ICMP 数据包的回应，也可以调整内核参数来取消 ICMP 回应。有两个设置文件可供使用：<code>icmp_echo_ignore_all</code>（拒绝所有 Ping 回应）和 <code>icmp_echo_ignore_broadcasts</code>（仅在收到 Ping 广播地址时取消 Ping 回应）。</p>
<h2 id="conf"><a class="markdownIt-Anchor" href="#conf"></a> conf/*/</h2>
<p>在网口配置目录下有一些参数设置：</p>
<ul>
<li>rp_filter：称为逆向路径过滤（Reverse Path Filtering），可以通过分析网口的路由信息，结合数据包的源地址来分析数据包是否合理。</li>
<li>log_martians：启用记录不合法的 IP 来源功能，例如来自 127.0.0.0 或 192.168.0.0 的 IP 不应应用于互联网。记录将写入 <code>/var/log/messages</code> 日志文件中。</li>
<li>accept_source_route：允许源路由。一般不设置。</li>
<li>accept_redirects：允许实体网络内不同 IP 网段之间的信息不通过路由器传递。不建议开启。</li>
<li>send_redirects：类似于上一个设置，该值用于发送 ICMP redirect 数据包。不建议开启。</li>
</ul>
<h1 id="访问控制列表"><a class="markdownIt-Anchor" href="#访问控制列表"></a> 访问控制列表</h1>
<p>访问控制列表（TCP Wrappers）通过服务器程序的外挂（tcpd）进行处理。该机制主要用于管理服务器程序。系统会检查 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 的配置，以过滤特定的 IP 和端口。</p>
<p>并非所有软件都可以通过配置文件进行管理，只有由 Super Daemon（Xinetd）管理的服务和支持 <code>Libwrap.so</code> 模块的服务才能使用访问控制列表。</p>
<p>对于 <code>allow</code> 和 <code>deny</code> 文件的优先规则如下：</p>
<ul>
<li>首先与 <code>/etc/hosts.allow</code> 进行匹配，符合规则的允许访问。</li>
<li>其次与 <code>/etc/hosts.deny</code> 进行匹配，符合规则的阻止访问。</li>
<li>如果不匹配这两个文件，则允许访问。</li>
</ul>
<p>例如，如果要定义允许局域网 192.168.1.0/24 和 10.1.1.2 使用 rsync，而不允许其他来源使用 rsync。修改配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/hosts.allow
ALL: <span class="token number">127.0</span>.0.1
rsync: <span class="token number">192.168</span>.1.0/255.255.255.0 <span class="token number">10.1</span>.1.2
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/hosts.deny 
rsync: ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h1>
<p>防火墙是一种通过定义一系列有序规则，并管理进入网络内的主机数据包的机制。只要能够分析与过滤进出管理的网络数据包的数据，就可以称为防火墙。防火墙最大的功能是限制某些服务的访问来源。</p>
<p>网络数据包一般包含四个基本信息，即源 IP、目标 IP、源端口和目标端口。防火墙即对数据包报头进行分析，根据设定的规则来对数据包进行放行或丢弃。防火墙在 OSI 七层协议中具体作用如下：</p>
<ul>
<li>第二层：可以针对来源与目标的 MAC 进行阻挡。</li>
<li>第三层：主要针对来源与目标的 IP，以及 ICMP 的类别进行阻挡。</li>
<li>第四层：针对 TCP/UDP 的端口进行阻挡，也可以针对 TCP 的状态来处理。</li>
</ul>
<p>防火墙可以分为硬件防火墙和软件防火墙两种。硬件防火墙是由厂商设计的主机硬件，其操作系统主要以提供数据包数据的过滤机制为主，并将其他不必要的功能剔除。而软件防火墙本身就是一套保护系统网络安全的软件。</p>
<h1 id="数据包过滤防火墙"><a class="markdownIt-Anchor" href="#数据包过滤防火墙"></a> 数据包过滤防火墙</h1>
<p>所谓数据包过滤（IP Filtering 或 Net Filter），就是分析进入主机的网络数据包，将包头数据提取出来进行分析，以决定该连接是放行还是阻止的机制。数据包过滤防火墙简单地说就是 iptables 或 firewall 提供的防火墙功能，它主要分析 OSI 的第 2 到 4 层，控制 MAC、IP、ICMP、TCP 和 UDP 的端口与状态（SYN、ACK 等）。</p>
<p>防火墙由 Linux 内核处理，因此性能非常好。根据内核版本的不同，所用的防火墙软件也不同：</p>
<ul>
<li>版本 2.0：使用 ipfwadm 防火墙</li>
<li>版本 2.2：使用 ipchains 防火墙</li>
<li>版本 2.4 或 2.6：使用 iptables 防火墙</li>
</ul>
<p>在这里主要以 iptables 为主。</p>
<h2 id="规则顺序"><a class="markdownIt-Anchor" href="#规则顺序"></a> 规则顺序</h2>
<p>防火墙规则有顺序关系，数据包会按照规则定义的顺序一条条进行对比。如果匹配到一条规则，就会执行后面定义的动作，并忽略之后的规则。如果没有匹配的规则，则使用默认策略来决定数据包的去向。</p>
<h2 id="表与链"><a class="markdownIt-Anchor" href="#表与链"></a> 表与链</h2>
<p>防火墙中可以定义多个表格（Table），每个表格都定义了自己的默认策略和规则链（Chain），以用于不同的目的。默认情况下，有三个功能的表格：管理本机进出的 Filter、管理后端主机（防火墙内部机器）的 NAT、管理特殊标志使用的 Mangle。</p>
<ul>
<li>
<p><strong>Filter</strong>（过滤器）</p>
<p>主要与进入 Linux 本机的数据包有关，是默认的 table。</p>
<ul>
<li>INPUT：与本机接收的数据包有关。</li>
<li>OUTPUT：与本机发送的数据包有关。</li>
<li>FORWARD：与本机无关，可以转发数据包到后端主机，与 NAT 的 table 相关性较高。</li>
</ul>
</li>
<li>
<p><strong>NAT</strong>（地址转换）</p>
<p>NAT 是 Network Address Translation 的缩写，主要用于进行源地址和目标地址以及端口的转换。</p>
<ul>
<li>PREROUTING：在进行路由判断之前要执行的规则（DNAT/REDIRECT）。</li>
<li>POSTROUTING：在进行路由判断之后要执行的规则（SNAT/MASQUERADE）。</li>
<li>INPUT：与接收的数据包有关。</li>
<li>OUTPUT：与发送的数据包有关。</li>
</ul>
</li>
<li>
<p><strong>Mangle</strong>（破坏者）</p>
<p>与特殊数据包的路由标志有关，用于重组数据包，使用较少。</p>
</li>
</ul>
<p>各表格之间的关系如下图所示：</p>
<p><img data-src="../../../images/%E9%93%BE%E4%B8%8E%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7.png" alt="链与表的相关性" /></p>
<p>从上图可以看出，iptables 可以控制三种数据包流向：</p>
<ul>
<li>路径 A：数据包进入 Linux 主机并使用资源。在路由判断后确定是向 Linux 主机请求的数据包，主机通过 Filter 的 INPUT 链来进行控制。</li>
<li>路径 B：数据包通过 Linux 主机进行转发，不使用主机资源，目标是后端主机。在路由判断之前对数据包报头进行修订后，发现数据包目标地址是防火墙后端主机，数据包通过路径 B 移动。主要经过的链是 Filter 的 FORWARD 和 NAT 的 POSTROUTING、PREROUTING。</li>
<li>路径 C：数据包由 Linux 本机发出，可能是响应客户端请求或主动发送的数据包。在路由判断后确定输出路径，然后通过 Filter 的 OUTPUT 链传送，最后经过 NAT 的 POSTROUTING 链。</li>
</ul>
<h2 id="规则查询"><a class="markdownIt-Anchor" href="#规则查询"></a> 规则查询</h2>
<p>防火墙查询和设置都使用 <code>iptables</code> 命令，命令格式为：<code>iptables [-t tables] [-L] [-nv]</code>。与规则查询相关的选项如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t</td>
<td>后面接 tables，例如 nat 或 filter。不带此参数默认查询 filter。</td>
</tr>
<tr>
<td>-L</td>
<td>列出当前表格的规则。</td>
</tr>
<tr>
<td>-n</td>
<td>不解析 IP 对应的主机名。</td>
</tr>
<tr>
<td>-v</td>
<td>列出详细信息，包括数据包传输状态和相关网口等。</td>
</tr>
</tbody>
</table>
<p>例如，查询 nat table 中的 4 条链的规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-L</span> <span class="token parameter variable">-n</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination         

Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination         

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination         

Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，policy 表示默认策略，其他项目的解释如下：</p>
<ul>
<li>target：代表执行的操作，ACCEPT 允许，REJECT 拒绝，DROP 丢弃。</li>
<li>prot：代表使用的数据包协议，TCP、UDP、ICMP。</li>
<li>opt：额外的选项说明。</li>
<li>source：规则匹配的来源 IP。</li>
<li>destination：规则匹配的目标 IP。</li>
</ul>
<p>可以使用 <code>iptables-save</code> 命令来查询完整的规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables-save <span class="token parameter variable">-t</span> filter
<span class="token comment"># Generated by iptables-save v1.4.21 on Fri Oct  8 23:48:44 2021</span>
*filter
:INPUT ACCEPT <span class="token punctuation">[</span><span class="token number">2470</span>:186319<span class="token punctuation">]</span>
:FORWARD ACCEPT <span class="token punctuation">[</span><span class="token number">0</span>:0<span class="token punctuation">]</span>
:OUTPUT ACCEPT <span class="token punctuation">[</span><span class="token number">1687</span>:123767<span class="token punctuation">]</span>
COMMIT
<span class="token comment"># Completed on Fri Oct  8 23:48:44 2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，以星号 * 开头的是表格，以冒号 : 开头的是链。</p>
<h2 id="清空规则"><a class="markdownIt-Anchor" href="#清空规则"></a> 清空规则</h2>
<p>清除规则使用的命令格式：<code>iptables [-t table] [-FXZ]</code></p>
<p>选项说明：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>清除所有已定义的规则。</td>
</tr>
<tr>
<td>-X</td>
<td>清除所有用户自定义的表格。</td>
</tr>
<tr>
<td>-Z</td>
<td>将所有链的计数和流量统计归零。</td>
</tr>
</tbody>
</table>
<p>例如，清除所有 filter 表格的规则，但不改变默认策略：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables -F<span class="token punctuation">;</span>iptables -X<span class="token punctuation">;</span>iptables <span class="token parameter variable">-Z</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="定义默认策略"><a class="markdownIt-Anchor" href="#定义默认策略"></a> 定义默认策略</h2>
<p>定义默认策略（Policy）使用命令：<code>iptables [-t table] -P [INPUT, OUTPUT, FORWARD] [ACCEPT, DROP]</code>。</p>
<p>例如，将本机的 INPUT 设置为 DROP，其他设置为 ACCEPT：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-P</span> INPUT DROP
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-P</span> OUTPUT ACCEPT
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-P</span> FORWARD ACCEPT
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables-save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="自定义规则"><a class="markdownIt-Anchor" href="#自定义规则"></a> 自定义规则</h2>
<p>使用 <code>iptables</code> 自定义规则的语法如下：</p>
<p><code>iptables [-AI 链名] [-io 网口] [-p 协议] [-s 源地址] [--sport 端口范围] [-d 目标地址] [--dport 端口范围] -j [ACCEPT|DROP|REJECT|LOG]</code></p>
<p>选项说明：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>在链的最后新增一条规则。</td>
</tr>
<tr>
<td>-I</td>
<td>插入一条规则，默认在链最前面插入。</td>
</tr>
<tr>
<td>-i</td>
<td>数据包接收的网口，例如 <code>eth0</code>。需要与 INPUT 链配合。</td>
</tr>
<tr>
<td>-o</td>
<td>数据包发送的网口，需要与 OUTPUT 链配合。</td>
</tr>
<tr>
<td>-p</td>
<td>设置规则适用的数据包格式，例如 tcp、udp、icmp、all。</td>
</tr>
<tr>
<td>-s</td>
<td>来源 IP/网络，可以指定具体 IP 或网段。</td>
</tr>
<tr>
<td>-d</td>
<td>目标 IP/网络，例如 192.168.1.104 或 192.168.1.0/24。</td>
</tr>
<tr>
<td>–sport</td>
<td>限制来源端口号码，可以设置连续端口，例如 1055:1100。</td>
</tr>
<tr>
<td>–dport</td>
<td>限制目标端口号码，针对端口操作需要与 <code>-p</code> 参数配合才能成功。</td>
</tr>
<tr>
<td>-j</td>
<td>后面接针对数据包的操作。</td>
</tr>
</tbody>
</table>
<p>例如，将 lo 口设置为受信任设备，不管数据包来源与目标，只要来自 lo 口都予以接受：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> lo <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-L</span> <span class="token parameter variable">-nv</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">86</span> packets, <span class="token number">7740</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
   <span class="token number">12</span>   <span class="token number">702</span> ACCEPT     all  --  lo     *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面命令没有指定 <code>-s</code> 和 <code>-d</code> 参数，则默认代表该项目完全接受。</p>
<p>设置接受来源 192.168.2.234 的包，拒绝 192.168.2.230 的包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.234 <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.230 <span class="token parameter variable">-j</span> DROP
<span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables-save 
<span class="token comment"># Generated by iptables-save v1.4.21 on Sat Oct  9 00:58:26 2021</span>
*filter
:INPUT ACCEPT <span class="token punctuation">[</span><span class="token number">74</span>:6754<span class="token punctuation">]</span>
:FORWARD ACCEPT <span class="token punctuation">[</span><span class="token number">0</span>:0<span class="token punctuation">]</span>
:OUTPUT ACCEPT <span class="token punctuation">[</span><span class="token number">33</span>:3160<span class="token punctuation">]</span>
<span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.234/32 <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-j</span> ACCEPT
<span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.230/32 <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-j</span> DROP
COMMIT
<span class="token comment"># Completed on Sat Oct  9 00:58:26 2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置屏蔽本机端口 2021：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">2021</span> <span class="token parameter variable">-j</span> DROP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>屏蔽 10000~20000 端口带 SYN 标记的 TCP 数据包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--sport</span> <span class="token number">10000</span>:20000 <span class="token parameter variable">--dport</span> <span class="token number">10000</span>:20000 <span class="token parameter variable">--syn</span> <span class="token parameter variable">-j</span> DROP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除规则"><a class="markdownIt-Anchor" href="#删除规则"></a> 删除规则</h2>
<p>删除规则使用命令：<code>iptables [-t table] -D [chain] line-numbers</code></p>
<p>首先需要获取规则在表链中的序号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-L</span> <span class="token parameter variable">-t</span> nat --line-numbers
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
num  target     prot opt <span class="token builtin class-name">source</span>            destination         
<span class="token number">1</span>    REDIRECT   tcp  --  <span class="token number">10.1</span>.1.0/24       anywhere     tcp dpt:http redir ports <span class="token number">3128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后用行号删除指定规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-D</span> PREROUTING <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="外挂模块"><a class="markdownIt-Anchor" href="#外挂模块"></a> 外挂模块</h2>
<p>在早期版本的防火墙中，需要分别在 INPUT 和 OUTPUT 链中添加规则才能实现双向通信，这样规则会变得相当冗长。现在的 <code>iptables</code> 可以通过一个状态模块来分析数据包是否为响应包，如果是，则直接放行。这样就不用考虑向 INPUT 链添加对应规则了。</p>
<p>加载模块使用 <code>-m</code> 参数，常用的有 <code>mac</code> 和 <code>state</code> 模块。指定 <code>-m state</code> 模块后可以使用 <code>--state</code> 接收数据包状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INVALID</td>
<td>无效数据包，例如数据破损的数据包状态。</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>已经连接成功的连接状态。</td>
</tr>
<tr>
<td>NEW</td>
<td>想要新建立连接的数据包状态。</td>
</tr>
<tr>
<td>RELATED</td>
<td>表示数据包与发送出去的数据包有关。</td>
</tr>
</tbody>
</table>
<p>例如设置只要已建立连接或已发出请求相关的数据包就予以通过：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-m</span> state <span class="token parameter variable">--state</span> RELATED,ESTABLISHED <span class="token parameter variable">-j</span> ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>针对局域网内网卡 MAC 地址进行限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-m</span> mac --mac-source aa:bb:cc:dd:ee:ff <span class="token parameter variable">-j</span> ACCEPT <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="nat-服务器"><a class="markdownIt-Anchor" href="#nat-服务器"></a> NAT 服务器</h1>
<p>网络地址转换是通过 iptables 修改 IP 数据包报头数据中来源或目标 IP 地址和端口。在 NAT 表中，POSTROUTING 链用于修改源 IP，PREROUTING 链用于修改目标 IP。</p>
<p>NAT 有两种，来源 NAT（SNAT，Source NAT）针对局域网访问互联网，目标 NAT（DNAT，Destination NAT）针对局域网内服务器服务互联网。</p>
<h2 id="snat"><a class="markdownIt-Anchor" href="#snat"></a> SNAT</h2>
<p>当内网主机通过 NAT 服务器发送互联网请求包时，POSTROUTING 链将数据包报头来源的内网 IP 替换成 NAT 服务器的外网 IP，记录数据包序号和转换的 IP 地址信息后，将数据包发送出去。</p>
<p>当数据包返回通过 NAT 服务器时，iptables 会分析数据包的序号。如发现序号有记录，PREROUTING 链会将目标 IP 替换成对应的内网 IP，并转发给对应主机。</p>
<p>例如将内部 10.1.1.0/24 网段的 IP 伪装成外网口 <code>ens37</code> 的 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-s</span> <span class="token number">10.1</span>.1.0/24 <span class="token parameter variable">-o</span> ens37 <span class="token parameter variable">-j</span> MASQUERADE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以指定多个对外 IP 轮流使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-o</span> ens37 <span class="token parameter variable">-j</span> SNAT --to-source <span class="token number">192.168</span>.2.230-192.168.2.240<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="dnat"><a class="markdownIt-Anchor" href="#dnat"></a> DNAT</h2>
<p>当内网中有提供 HTTP 服务的服务器时，必须通过 NAT 服务器映射端口，也就是将自身 80 端口与 NAT 服务器 80 端口绑定。NAT 服务器接收到客户端发送的 HTTP 请求数据包后，PREROUTING 链会将目标 IP 替换成内网 HTTP 服务器 IP 并发送给它。</p>
<p>当内网 HTTP 服务器回应数据包通过 NAT 服务器时，通过 POSTROUTING 链将源 IP 替换成 NAT 服务器外网 IP，并发送出去。</p>
<p>例如将内网 HTTP 服务器 10.1.1.2 的端口指向外网端口 <code>ens33</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> DNAT --to-destination <span class="token number">10.1</span>.1.2:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以将本机的 8080 端口转发到 80 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">8080</span> <span class="token parameter variable">-j</span> REDIRECT --to-ports <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="防火墙配置"><a class="markdownIt-Anchor" href="#防火墙配置"></a> 防火墙配置</h1>
<p>常见的防火墙与网络布线配置有下面几种：</p>
<h2 id="客户端防火墙"><a class="markdownIt-Anchor" href="#客户端防火墙"></a> 客户端防火墙</h2>
<p>当 Linux 主机作为客户端且不提供网络服务时，基本防火墙设置如下：</p>
<ul>
<li>规则归零：清除所有已存在的规则。</li>
<li>默认策略：除了将 INPUT 设为 DROP 外，其他默认为 ACCEPT。</li>
<li>信任本机：由于 lo 对本机来说很重要，因此必须设置为信任设备。</li>
<li>回应数据包：让本机通过主动向外发出请求而响应的数据包可以进入本机。</li>
<li>信任用户：可在想要让本地网络的来源使用主机资源时设置。</li>
</ul>
<p>可以将防火墙规则写入脚本中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># 1.清除规则</span>
iptables <span class="token parameter variable">-F</span>
iptables <span class="token parameter variable">-X</span>
iptables <span class="token parameter variable">-Z</span>

<span class="token comment"># 2.设置默认策略</span>
iptables <span class="token parameter variable">-P</span> INPUT DROP
iptables <span class="token parameter variable">-P</span> OUTPUT ACCEPT
iptables <span class="token parameter variable">-P</span> FORWARD ACCEPT

<span class="token comment"># 3.定制各项规则</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens37 <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.101 <span class="token parameter variable">-j</span> ACCEPT
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> lo <span class="token parameter variable">-j</span> ACCEPT
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> ens37 <span class="token parameter variable">-m</span> state <span class="token parameter variable">--state</span> RELATED,ESTABLISHED <span class="token parameter variable">-j</span> ACCEPT

<span class="token comment"># 4.保存配置</span>
iptables-save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单一网络防火墙"><a class="markdownIt-Anchor" href="#单一网络防火墙"></a> 单一网络防火墙</h2>
<p>防火墙至少有两个接口，将可信任的内部局域网与不可信任的外部因特网分开，由防火墙全权掌控到局域网内的所有数据包。</p>
<p>网络示例图：</p>
<p><img data-src="../../../images/%E5%8D%95%E4%B8%80%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="单一网络防火墙" /></p>
<p>假设上面的 Linux 服务器作为防火墙和内部 LAN 的路由器使用，配置如下：</p>
<ul>
<li>对外网口 ens33，IP 配置 192.168.2.254/24，网关 192.168.2.1。</li>
<li>对内网口 ens37，IP 配置 10.1.1.1/24。</li>
<li>默认开放 HTTP、HTTPS、SSH 端口。</li>
</ul>
<p>针对防火墙的脚本内容如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ <span class="token function">vi</span> iptables.rules
<span class="token comment">#!/bin/bash</span>

<span class="token comment"># 定义参数</span>
<span class="token assign-left variable">OUTIF</span><span class="token operator">=</span><span class="token string">'ens33'</span>
<span class="token assign-left variable">INIF</span><span class="token operator">=</span><span class="token string">'ens37'</span>
<span class="token assign-left variable">INNET</span><span class="token operator">=</span><span class="token string">'10.1.1.0/24'</span>
<span class="token builtin class-name">export</span> OUTIF INIF INNET

<span class="token comment"># 针对互联网卡设置###################</span>
<span class="token comment"># 1.设置内核参数</span>
<span class="token builtin class-name">echo</span> <span class="token string">"1"</span> <span class="token operator">></span>/proc/sys/net/ipv4/tcp_syncookies
<span class="token builtin class-name">echo</span> <span class="token string">"1"</span> <span class="token operator">></span>/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> /proc/sys/net/ipv4/conf/*/<span class="token punctuation">&#123;</span>rp_filter,log_martians<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"1"</span> <span class="token operator">></span><span class="token variable">$i</span>
<span class="token keyword">done</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> /proc/sys/net/ipv4/conf/*/<span class="token punctuation">&#123;</span>accept_source_route,accept_redirects,send_redirects<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"0"</span> <span class="token operator">></span><span class="token variable">$i</span>
<span class="token keyword">done</span>

<span class="token comment"># 2.清除规则,设置默认策略及开放lo与相关设置值</span>
iptables <span class="token parameter variable">-F</span>
iptables <span class="token parameter variable">-X</span>
iptables <span class="token parameter variable">-Z</span>
iptables <span class="token parameter variable">-P</span> INPUT DROP
iptables <span class="token parameter variable">-P</span> OUTPUT ACCEPT
iptables <span class="token parameter variable">-P</span> FORWARD ACCEPT
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> lo <span class="token parameter variable">-j</span> ACCEPT
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-m</span> state <span class="token parameter variable">--state</span> RELATED,ESTABLISHED <span class="token parameter variable">-j</span> ACCEPT

<span class="token comment"># 3.启动额外的防火墙script模块</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /root/iptables/iptables.deny <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">sh</span> /root/iptables/iptables.deny
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /root/iptables/iptables.allow <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">sh</span> /root/iptables/iptables.allow
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /root/iptables/iptables.http <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">sh</span> /root/iptables/iptables.http
<span class="token keyword">fi</span>

<span class="token comment"># 4.允许某些类型的ICMP数据包进入</span>
<span class="token assign-left variable">AICMP</span><span class="token operator">=</span><span class="token string">"0 3 3/4 4 11 12 14 16 18"</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">x</span> <span class="token keyword">in</span> <span class="token variable">$AICMP</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">-p</span> icmp --icmp-type <span class="token variable">$x</span> <span class="token parameter variable">-j</span> ACCEPT
<span class="token keyword">done</span>

<span class="token comment"># 5.允许某些服务的进入</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">21</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># FTP</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">22</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># SSH</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">25</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># SMTP</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">53</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># DNS</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> UDP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">53</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># DNS</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT  <span class="token comment"># HTTP</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">110</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT <span class="token comment"># POP3</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> TCP <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">443</span> <span class="token parameter variable">--sport</span> <span class="token number">1</span>:65534 <span class="token parameter variable">-j</span> ACCEPT <span class="token comment"># HTTPS</span>

<span class="token comment"># 针对局域网网卡设置####################</span>
<span class="token comment"># 1.先加载一些有用的模块</span>
<span class="token assign-left variable">modules</span><span class="token operator">=</span><span class="token string">"ip_tables iptable_nat ip_nat_ftp ip_nat_irc ip_conntrack ip_conntrack_ftp ip_conntrack_irc"</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">mod</span> <span class="token keyword">in</span> <span class="token variable">$modules</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token assign-left variable">testmod</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>lsmod <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^<span class="token variable">$&#123;mod&#125;</span> "</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $1&#125;'</span><span class="token variable">)</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$testmod</span>"</span> <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        modprobe <span class="token variable">$mod</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span>

<span class="token comment"># 2.清除NAT table的规则</span>
iptables <span class="token parameter variable">-F</span> <span class="token parameter variable">-t</span> nat
iptables <span class="token parameter variable">-X</span> <span class="token parameter variable">-t</span> nat
iptables <span class="token parameter variable">-Z</span> <span class="token parameter variable">-t</span> nat
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-P</span> PREROUTING ACCEPT
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-P</span> POSTROUTING ACCEPT
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-P</span> OUTPUT ACCEPT

<span class="token comment"># 3.开启内网SNAT</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INIF</span>"</span> <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> <span class="token variable">$INIF</span> <span class="token parameter variable">-j</span> ACCEPT
    <span class="token builtin class-name">echo</span> <span class="token string">"1"</span> <span class="token operator">></span>/proc/sys/net/ipv4/ip_forward
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INNET</span>"</span> <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-s</span> <span class="token variable">$INNET</span> <span class="token parameter variable">-o</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">-j</span> MASQUERADE
    <span class="token keyword">fi</span>
<span class="token keyword">fi</span>

<span class="token comment"># 4. NAT服务器内局域网中服务器端口转发</span>
iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> PREROUTING <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> DNAT --to-destination <span class="token number">192.168</span>.2.234:80

<span class="token comment"># 5. 保存规则</span>
iptables-save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>/root/iptables</code> 目录下可以填写额外规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ <span class="token function">vi</span> iptables.allow
<span class="token comment">#!/bin/bash</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.0/24 <span class="token parameter variable">-j</span> ACCEPT
<span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ <span class="token function">vi</span> iptables.deny
<span class="token comment">#!/bin/bash</span>
iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-i</span> <span class="token variable">$OUTIF</span> <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.2.230 <span class="token parameter variable">-j</span> DROP
<span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">700</span> iptables.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以将脚本写入 <code>/etc/rc.d/rc.local</code> 文件中来开机执行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server2 iptables<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/rc.d/rc.local
/root/iptables/iptables.rules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="内网防火墙"><a class="markdownIt-Anchor" href="#内网防火墙"></a> 内网防火墙</h2>
<p>一般情况下，局域网内部的防火墙并不需要过于严格的防备措施。但是，如果局域网内部存在高度机密的子网，可以考虑增设防火墙进行保护。</p>
<p>网络示例图：</p>
<p><img data-src="../../../images/%E5%86%85%E7%BD%91%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="内网防火墙" /></p>
<h2 id="网络服务器防火墙"><a class="markdownIt-Anchor" href="#网络服务器防火墙"></a> 网络服务器防火墙</h2>
<p>如果存在提供对外网络服务的服务器，可以将该服务器放置在两台防火墙之间，这样可以使服务器免受来自内部和外部网络的攻击。该服务器所处的区域也被称为非军事化隔离区（DMZ）。</p>
<p>网络示例图：</p>
<p><img data-src="../../../images/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="网络服务器防火墙" /></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 网络命令</title>
    <url>/2991697559/</url>
    <content><![CDATA[<h1 id="网络设置"><a class="markdownIt-Anchor" href="#网络设置"></a> 网络设置</h1>
<p>虽然现在网络设置可以通过 <code>nmcli</code> 来完成，但旧的命令仍然可用。</p>
<h2 id="ifconfig"><a class="markdownIt-Anchor" href="#ifconfig"></a> ifconfig</h2>
<p><code>ifconfig</code> 命令可以手动启动、查看和修改网络接口的参数，语法如下：<code>ifconfig interface [选项]</code></p>
<p>其中，<code>interface</code> 为网卡接口名称，例如 <code>eth0</code>、<code>ens34</code> 等。选项可以使用以下参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>up, down</td>
<td>启用或禁用接口</td>
</tr>
<tr>
<td>mtu</td>
<td>设置 MTU 数值，单位为字节</td>
</tr>
<tr>
<td>netmask</td>
<td>设置子网掩码</td>
</tr>
<tr>
<td>broadcast</td>
<td>设置广播地址</td>
</tr>
</tbody>
</table>
<p>例如，要查询 <code>ens33</code> 网卡的信息，可以运行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> ens33
ens33: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>
        inet <span class="token number">192.168</span>.2.201  netmask <span class="token number">255.255</span>.0.0  broadcast <span class="token number">192.168</span>.255.255
        inet6 fe80::df56:57bc:63b:6ccd  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>
        inet6 240e:383:406:ac00:3d71:87ed:5f5:fde  prefixlen <span class="token number">64</span>  scopeid 0x<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>global<span class="token operator">></span>
        inet6 fe80::6216:718c:bab2:a10d  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>
        ether 00:0c:29:da:7d:5c  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets <span class="token number">444049</span>  bytes <span class="token number">506386469</span> <span class="token punctuation">(</span><span class="token number">482.9</span> MiB<span class="token punctuation">)</span>
        RX errors <span class="token number">0</span>  dropped <span class="token number">64242</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>
        TX packets <span class="token number">42962</span>  bytes <span class="token number">7774934</span> <span class="token punctuation">(</span><span class="token number">7.4</span> MiB<span class="token punctuation">)</span>
        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在输出中，RX 表示接收的数据包情况，TX 表示发送的数据包情况。注意，其中的 collisions 数值表示冲突次数。</p>
<p>还可以设置虚拟接口。例如，将 <code>ens33</code> 设置为 192.168.3.201，可以运行以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> ens33:0 <span class="token number">192.168</span>.3.201
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ifconfig</span> ens33:0
ens33:0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>
        inet <span class="token number">192.168</span>.3.201  netmask <span class="token number">255.255</span>.255.0  broadcast <span class="token number">192.168</span>.3.255
        ether 00:0c:29:da:7d:5c  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，使用 <code>ifconfig</code> 设置的临时网络参数在重新启动网络服务后会重置并消失。为了永久保留设置，可以修改网络配置文件。</p>
<h2 id="route"><a class="markdownIt-Anchor" href="#route"></a> route</h2>
<p><code>route</code> 命令用来修改本机的路由表，命令用法如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">route <span class="token punctuation">[</span>-nee<span class="token punctuation">]</span>
route <span class="token function">add</span> <span class="token punctuation">[</span>-net<span class="token operator">|</span>-host<span class="token punctuation">]</span> <span class="token punctuation">[</span>网络或主机<span class="token punctuation">]</span> netmask <span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token punctuation">[</span>gw<span class="token operator">|</span>dev<span class="token punctuation">]</span>
route del <span class="token punctuation">[</span>-net<span class="token operator">|</span>-host<span class="token punctuation">]</span> <span class="token punctuation">[</span>网络或主机<span class="token punctuation">]</span> netmask <span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token punctuation">[</span>gw<span class="token operator">|</span>dev<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-n</code></td>
<td>直接显示 IP 和端口，而不是通信协议或主机名。</td>
</tr>
<tr>
<td><code>-ee</code></td>
<td>显示更详细的信息。</td>
</tr>
<tr>
<td><code>-net</code></td>
<td>表示后面接的路由指向一个网络。</td>
</tr>
<tr>
<td><code>-host</code></td>
<td>表示后面接的路由指向单个主机。</td>
</tr>
<tr>
<td><code>netmask</code></td>
<td>可以设置 netmask 决定网络的大小。</td>
</tr>
<tr>
<td><code>gw</code></td>
<td>gateway 的缩写，后面接网关 IP。</td>
</tr>
<tr>
<td><code>dev</code></td>
<td>指定工作网卡，后面接 ens33 等。</td>
</tr>
</tbody>
</table>
<p>查询下本机路由表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         <span class="token number">0.0</span>.0.0         UG    <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token number">192.168</span>.0.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route <span class="token parameter variable">-nee</span>
Kernel IP routing table
Destination   Gateway       Genmask     Flags Metric Ref    Use Iface   MSS   Window irtt
<span class="token number">0.0</span>.0.0       <span class="token number">192.168</span>.2.1   <span class="token number">0.0</span>.0.0     UG    <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33   <span class="token number">0</span>     <span class="token number">0</span>      <span class="token number">0</span>
<span class="token number">192.168</span>.0.0   <span class="token number">0.0</span>.0.0       <span class="token number">255.255</span>.0.0 U     <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33   <span class="token number">0</span>     <span class="token number">0</span>      <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一行表达去往任何地址（0.0.0.0）都要通过网口 <code>ens33</code> 转向网关 192.168.2.1。</p>
<p>第二行表示去往 192.168.0.0/16 网段地址不需要经过网关（0.0.0.0），直接通过网口 <code>ens33</code> 出去。</p>
<p>其中 Flags 标志有多种值：</p>
<ul>
<li>U（route is up）：表示该路由已启用。</li>
<li>H（target is a host）：表示该路由的目标是一个主机。</li>
<li>G（use gateway）：表示数据包需要经过网关进行处理和传递。</li>
<li>R（reinstate route for dynamic routing）：表示在使用动态路由时，恢复路由信息的标志。</li>
<li>D（dynamically installed by daemon or redirect）：表示动态路由。</li>
<li>M（modified from routing daemon or redirect）：表示路由已被修改。</li>
<li>!（reject route）：表示此路由被阻止。</li>
</ul>
<p>路由按照路由表的顺序进行匹配和执行。例如，在上述路由表中，原本发送到 192.168.2.100 的局域网数据包也会通过 192.168.2.1 进行处理，因为后面的路由设置不起作用。</p>
<p>因此，可以尝试调整顺序，首先删除默认路由，然后重新添加默认路由：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route del <span class="token parameter variable">-net</span> <span class="token number">0.0</span>.0.0 netmask <span class="token number">0.0</span>.0.0 gw <span class="token number">192.168</span>.2.1
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
<span class="token number">192.168</span>.0.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route <span class="token function">add</span> <span class="token parameter variable">-net</span> <span class="token number">0.0</span>.0.0 netmask <span class="token number">0.0</span>.0.0 gw <span class="token number">192.168</span>.2.1
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ route <span class="token parameter variable">-n</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.2.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> ens33
<span class="token number">192.168</span>.0.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">102</span>    <span class="token number">0</span>        <span class="token number">0</span> ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果并没有变化，因为路由的优先级是由 Metric 定义的。</p>
<p>一般情况下，修改路由用于指定不同的端口以访问不同的网络段。在重新启动网络服务后，路由表将被还原。</p>
<h2 id="ip"><a class="markdownIt-Anchor" href="#ip"></a> ip</h2>
<p><code>ip</code> 命令综合了 <code>ifconfig</code> 与 <code>route</code> 命令的功能，命令语法：<code>ip [选项] [动作] [命令]</code>。</p>
<p>例如，查看网卡 <code>ens33</code> 的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> <span class="token parameter variable">-s</span> <span class="token function">link</span> show ens33
<span class="token number">2</span>: ens33: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UP mode DEFAULT group default qlen <span class="token number">1000</span>
    link/ether 00:0c:29:da:7d:5c brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    <span class="token number">506917745</span>  <span class="token number">449906</span>   <span class="token number">0</span>       <span class="token number">66383</span>   <span class="token number">0</span>       <span class="token number">0</span>       
    TX: bytes  packets  errors  dropped carrier collsns 
    <span class="token number">7955626</span>    <span class="token number">44475</span>    <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">0</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不加 <code>-s</code> 参数，可以得到简略的结果。如果要修改网卡信息，可以使用 <code>set</code> 命令。例如，修改 <code>ens33</code> 的 MAC 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> ens33 address 00:0c:29:da:7d:5c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要修改与网卡 IP 地址相关的参数，可以使用 <code>address</code> 动作。例如，给 <code>ens33</code> 增加一个虚拟接口，并配置 IP：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> address <span class="token function">add</span> <span class="token number">192.168</span>.3.101/24 broadcast <span class="token number">192.168</span>.3.255 dev ens33 label ens33:new3
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> address show ens33
<span class="token number">2</span>: ens33: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc pfifo_fast state UP group default qlen <span class="token number">1000</span>
    link/ether 00:0c:29:da:7d:5c brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">192.168</span>.2.201/16 brd <span class="token number">192.168</span>.255.255 scope global noprefixroute ens33
       valid_lft forever preferred_lft forever
    inet <span class="token number">192.168</span>.3.101/24 brd <span class="token number">192.168</span>.3.255 scope global ens33:new3
       valid_lft forever preferred_lft forever
    inet6 240e:383:406:ac00:3d71:87ed:5f5:fde/64 scope global noprefixroute dynamic 
       valid_lft 3600sec preferred_lft 3600sec
    inet6 fe80::df56:57bc:63b:6ccd/64 scope <span class="token function">link</span> noprefixroute 
       valid_lft forever preferred_lft forever
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> address del <span class="token number">192.168</span>.3.101/24 dev ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要修改路由相关的设定，可以使用 <code>route</code> 动作，用法和 <code>route</code> 命令类似。首先使用 <code>ip route show</code> 查看当前的路由表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> route show
default via <span class="token number">192.168</span>.2.1 dev ens33 
<span class="token number">192.168</span>.0.0/16 dev ens33 proto kernel scope <span class="token function">link</span> src <span class="token number">192.168</span>.2.201 metric <span class="token number">102</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>结果中多了两个字段：<code>proto</code> 指示路由的路由协议，<code>scope</code> 指示路由的范围。</p>
<p>下面是添加一条路由到 <code>192.168.3.0/24</code> 网段，通过 <code>ens37</code> 端口进出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> route <span class="token function">add</span> <span class="token number">192.168</span>.3.0/24 dev ens37
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> route show
default via <span class="token number">192.168</span>.2.1 dev ens33 
<span class="token number">192.168</span>.0.0/16 dev ens33 proto kernel scope <span class="token function">link</span> src <span class="token number">192.168</span>.2.201 metric <span class="token number">102</span> 
<span class="token number">192.168</span>.3.0/24 dev ens37 scope <span class="token function">link</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加默认路由和删除路由的示例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> route <span class="token function">add</span> default via <span class="token number">192.168</span>.2.1 dev ens33
RTNETLINK answers: File exists
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ip</span> route del <span class="token number">192.168</span>.3.0/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="网络诊断"><a class="markdownIt-Anchor" href="#网络诊断"></a> 网络诊断</h1>
<p>用于在网络出现故障时跟踪可能的错误原因。</p>
<h2 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h2>
<p><code>ping</code> 命令通过 ICMP 数据包来进行整个网络的状态报告。常用参数有：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c 数值</td>
<td>可以定义 <code>ping</code> 的次数。</td>
</tr>
<tr>
<td>-n</td>
<td>不进行 IP 与主机名的解析，只用 IP 显示。</td>
</tr>
<tr>
<td>-s 数值</td>
<td>发送出去的 ICMP 数据包大小，默认为 56 Bytes。</td>
</tr>
<tr>
<td>-t 数值</td>
<td>TTL 的数值，默认是 255。如果在同一网络内，TTL 默认 64。</td>
</tr>
<tr>
<td>-W 数值</td>
<td>等待相应超时秒数。</td>
</tr>
<tr>
<td>-M [do|dont]</td>
<td>主要用来检测网络 MTU 数值大小，do 表示不拆分数据包，dont 表示可以拆分。</td>
</tr>
</tbody>
</table>
<p>直接 <code>ping baidu.com</code> 看看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ping</span> baidu.com <span class="token parameter variable">-c</span> <span class="token number">3</span>
PING baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">52</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">39.0</span> ms
<span class="token number">64</span> bytes from baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">51</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">39.1</span> ms <span class="token punctuation">(</span>DUP<span class="token operator">!</span><span class="token punctuation">)</span>
<span class="token number">64</span> bytes from baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">52</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">39.6</span> ms <span class="token punctuation">(</span>DUP<span class="token operator">!</span><span class="token punctuation">)</span>
<span class="token number">64</span> bytes from baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">51</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">39.6</span> ms <span class="token punctuation">(</span>DUP<span class="token operator">!</span><span class="token punctuation">)</span>
From <span class="token number">192.168</span>.2.102 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.102<span class="token punctuation">)</span> <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> Redirect Network<span class="token punctuation">(</span>New nexthop: gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.2.1<span class="token punctuation">))</span>
From <span class="token number">192.168</span>.2.102 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.102<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> Redirect Network<span class="token punctuation">(</span>New nexthop: gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.2.1<span class="token punctuation">))</span>
<span class="token number">64</span> bytes from baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.251<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">52</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">39.5</span> ms

--- baidu.com <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, +3 duplicates, +1 errors, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 1002ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">39.099</span>/39.392/39.611/0.257 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果可得下面这些信息：</p>
<ul>
<li>64 bytes：表示发送 ICMP 数据包大小，最大可以设置 <code>-s 65507</code>。</li>
<li>icmp_seq=1：ICMP 的检测次数，第一次为 1。</li>
<li>ttl=52：TTL 与 IP 数据包内的 TTL 相同，每经过一个带有 MAC 的节点时 TTL 减 1，默认 TTL 为 255。</li>
<li>time=39.1ms：响应时间，越短越好。</li>
</ul>
<p>下面这样可以检测 MTU：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ping</span> <span class="token parameter variable">-s</span> <span class="token number">9000</span> <span class="token parameter variable">-M</span> <span class="token keyword">do</span> <span class="token number">192.168</span>.2.101 
PING <span class="token number">192.168</span>.2.101 <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span> <span class="token number">9000</span><span class="token punctuation">(</span><span class="token number">9028</span><span class="token punctuation">)</span> bytes of data.
ping: <span class="token builtin class-name">local</span> error: Message too long, <span class="token assign-left variable">mtu</span><span class="token operator">=</span><span class="token number">1500</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意，本地网卡和设备的 MTU 值也会影响到检测。</p>
<h2 id="traceroute"><a class="markdownIt-Anchor" href="#traceroute"></a> traceroute</h2>
<p><code>traceroute</code> 命令用于跟踪两台主机之间通过的各个节点的通信状态。常用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>不解析域名，只使用 IP。</td>
</tr>
<tr>
<td>-U</td>
<td>使用 UDP 的端口 33434 来检测，默认选项。</td>
</tr>
<tr>
<td>-I</td>
<td>使用 ICMP 的方式来检测。</td>
</tr>
<tr>
<td>-T</td>
<td>使用 TCP 来检测，一般测试 80 端口。</td>
</tr>
<tr>
<td>-w</td>
<td>设置超时时间。</td>
</tr>
<tr>
<td>-p 端口号</td>
<td>可以自定义检测端口号。</td>
</tr>
<tr>
<td>-i 设备</td>
<td>指定检测时使用的网卡。</td>
</tr>
<tr>
<td>-g 路由</td>
<td>与 -i 作用相似，指定网关 IP。</td>
</tr>
</tbody>
</table>
<p>查看连接到 <code>baidu.com</code> 的各个节点状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">traceroute</span> <span class="token parameter variable">-n</span> baidu.com
<span class="token function">traceroute</span> to baidu.com <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets
 <span class="token number">1</span>  <span class="token number">192.168</span>.2.1  <span class="token number">0.739</span> ms  <span class="token number">0.547</span> ms  <span class="token number">0.519</span> ms
 <span class="token number">2</span>  <span class="token number">192.168</span>.2.1  <span class="token number">0.536</span> ms  <span class="token number">1.052</span> ms  <span class="token number">1.181</span> ms
 <span class="token number">3</span>  <span class="token number">100.84</span>.64.1  <span class="token number">8.648</span> ms  <span class="token number">8.486</span> ms  <span class="token number">8.444</span> ms
 <span class="token number">4</span>  <span class="token number">61.137</span>.11.165  <span class="token number">8.412</span> ms  <span class="token number">8.325</span> ms  <span class="token number">8.214</span> ms
 <span class="token number">5</span>  <span class="token number">61.137</span>.11.165  <span class="token number">8.128</span> ms  <span class="token number">8.016</span> ms  <span class="token number">7.998</span> ms
 <span class="token number">6</span>  <span class="token number">202.97</span>.18.73  <span class="token number">18.533</span> ms <span class="token number">202.97</span>.18.105  <span class="token number">18.318</span> ms <span class="token number">202.97</span>.18.101  <span class="token number">18.384</span> ms
 <span class="token number">7</span>  <span class="token number">202.97</span>.122.237  <span class="token number">35.134</span> ms <span class="token number">202.97</span>.79.225  <span class="token number">49.466</span> ms <span class="token number">202.97</span>.40.49  <span class="token number">30.696</span> ms
 <span class="token number">8</span>  <span class="token number">36.110</span>.245.174  <span class="token number">49.776</span> ms <span class="token number">36.110</span>.247.54  <span class="token number">27.887</span> ms <span class="token number">36.110</span>.246.134  <span class="token number">27.632</span> ms
 <span class="token number">9</span>  <span class="token number">218.30</span>.104.177  <span class="token number">27.365</span> ms <span class="token number">106.38</span>.244.130  <span class="token number">41.744</span> ms *
<span class="token number">10</span>  <span class="token number">106.38</span>.244.130  <span class="token number">41.509</span> ms <span class="token number">106.38</span>.244.150  <span class="token number">41.990</span> ms <span class="token number">220.181</span>.17.146  <span class="token number">41.979</span> ms
<span class="token number">11</span>  <span class="token number">106.38</span>.244.166  <span class="token number">41.818</span> ms * *
<span class="token number">12</span>  * * *
<span class="token number">13</span>  * * *
<span class="token number">14</span>  * * *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面显示的三个时间是每个节点检测的三次数据，而显示 <code>* * *</code> 的行表示该节点可能有某些防护措施，导致发送的 UDP 数据包被丢弃。可以尝试使用 <code>-I</code> 或 <code>-T</code> 参数来更换检测方式。</p>
<h2 id="netstat"><a class="markdownIt-Anchor" href="#netstat"></a> netstat</h2>
<p><code>netstat</code> 命令一般用于检测网络端口的状态。固定用法 <code>netstat -nutlp</code> 表示列出监听中的 TCP 和 UDP 数据包连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-nutlp</span>
Active Internet connections <span class="token punctuation">(</span>only servers<span class="token punctuation">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address  State       PID/Program name 
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:22              <span class="token number">0.0</span>.0.0:*        LISTEN      <span class="token number">8173</span>/sshd     
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:25            <span class="token number">0.0</span>.0.0:*        LISTEN      <span class="token number">8359</span>/master   
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::22                   :::*             LISTEN      <span class="token number">8173</span>/sshd     
tcp6       <span class="token number">0</span>      <span class="token number">0</span> ::1:25                  :::*             LISTEN      <span class="token number">8359</span>/master   
udp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:323           <span class="token number">0.0</span>.0.0:*                    <span class="token number">15767</span>/chronyd 
udp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:68              <span class="token number">0.0</span>.0.0:*                    <span class="token number">58762</span>/dhclient 
udp6       <span class="token number">0</span>      <span class="token number">0</span> ::1:323                 :::*                         <span class="token number">15767</span>/chronyd 
udp6       <span class="token number">0</span>      <span class="token number">0</span> fe80::df56:57bc:63b:546 :::*                         <span class="token number">59548</span>/dhclient <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示表头部分说明如下：</p>
<ul>
<li>Proto：该连接的数据包协议，主要是 TCP 和 UDP。</li>
<li>Recv-Q：由非用户程序连接所复制而来的总字节数。</li>
<li>Send-Q：由远程主机发送而来，但没有 ACK 标志的总字节数。</li>
<li>Local Address：本地端的地址和端口。其中，端口 25 固定为 lo 口。</li>
<li>Foreign Address：远程主机的 IP 和端口。</li>
<li>State：状态栏，主要包含以下状态：
<ul>
<li>ESTABLISHED：已建立连接状态。</li>
<li>SYN_SENT：发出主动连接（带有 SYN 标志）的连接数据包。</li>
<li>SYN_RECV：接收到一个请求连接的主动连接数据包。</li>
<li>FIN_WAIT1：该套接字服务已中断，连接正在断开。</li>
<li>FIN_WAIT2：该连接已挂断，但等待对方主机响应断线确认的数据包。</li>
<li>TIME_WAIT：该连接已挂断，但 socket 还在网络上等待结束。</li>
<li>LISTEN：通常用于服务的监听端口。</li>
</ul>
</li>
<li>PID/Program name：由 <code>-p</code> 参数指定显示的端口对应程序。</li>
</ul>
<p>如果要查询已经建立的连接端口，使用 <code>-nutp</code> 参数即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-nutp</span>
Active Internet connections <span class="token punctuation">(</span>w/o servers<span class="token punctuation">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.2.201:22        <span class="token number">192.168</span>.2.101:64456     ESTABLISHED <span class="token number">61123</span>/sshd: root@pt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="nmap"><a class="markdownIt-Anchor" href="#nmap"></a> nmap</h2>
<p>nmap 软件全称为 Network exploration tool and security/port scanner，顾名思义是用于管理系统安全性检查的工具。基本用法：<code>nmap [扫描类型] [扫描参数] [hosts 地址与范围]</code>。</p>
<p>其中，扫描类型有下面几种：</p>
<ul>
<li>-sT：扫描已建立的 TCP 连接的数据包（connect）。</li>
<li>-sS：扫描带有 SYN 标志的 TCP 数据包。</li>
<li>-sP：以 ping 的方式进行扫描。</li>
<li>-sU：以 UDP 数据包格式进行扫描。</li>
<li>-sO：以 IP 协议进行主机扫描。</li>
</ul>
<p>扫描参数有下面几种：</p>
<ul>
<li>-PT：使用 TCP 的 ping 方式进行扫描，可以获知当前存在的计算机数目。</li>
<li>-PI：使用实际的 ping（带有 ICMP 数据包）进行扫描。</li>
<li>-P：端口范围，例如 1024-、3000-40000 等方式。</li>
</ul>
<p>hosts 地址与范围的指定方式有：</p>
<ul>
<li>192.168.1.101：直接指定主机的 IP，只检查一台主机。</li>
<li>192.168.1.0/24：扫描整个网段。</li>
<li>192.168.<em>.</em>：扫描更大范围。</li>
<li>192.168.1.0-50,60-100,103,204：指定间隔的范围。</li>
</ul>
<p>首先进行本机扫描的测试结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ nmap localhost

Starting Nmap <span class="token number">6.40</span> <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at <span class="token number">2021</span>-09-23 <span class="token number">22</span>:49 CST
Nmap scan report <span class="token keyword">for</span> localhost <span class="token punctuation">(</span><span class="token number">127.0</span>.0.1<span class="token punctuation">)</span>
Host is up <span class="token punctuation">(</span><span class="token number">0</span>.000017s latency<span class="token punctuation">)</span>.
Other addresses <span class="token keyword">for</span> localhost <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: <span class="token number">127.0</span>.0.1
Not shown: <span class="token number">998</span> closed ports
PORT   STATE SERVICE
<span class="token number">22</span>/tcp <span class="token function">open</span>  <span class="token function">ssh</span>
<span class="token number">25</span>/tcp <span class="token function">open</span>  smtp

Nmap done: <span class="token number">1</span> IP address <span class="token punctuation">(</span><span class="token number">1</span> <span class="token function">host</span> up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> <span class="token number">1.64</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到扫描速度非常快。默认情况下，只会扫描 TCP 协议。如果想同时扫描 UDP 协议，可以使用 <code>-sTU</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ nmap <span class="token parameter variable">-sTU</span> localhost

Starting Nmap <span class="token number">6.40</span> <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at <span class="token number">2021</span>-09-23 <span class="token number">22</span>:51 CST
Nmap scan report <span class="token keyword">for</span> localhost <span class="token punctuation">(</span><span class="token number">127.0</span>.0.1<span class="token punctuation">)</span>
Host is up <span class="token punctuation">(</span><span class="token number">0</span>.0021s latency<span class="token punctuation">)</span>.
Other addresses <span class="token keyword">for</span> localhost <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: <span class="token number">127.0</span>.0.1
Not shown: <span class="token number">1997</span> closed ports
PORT   STATE         SERVICE
<span class="token number">22</span>/tcp <span class="token function">open</span>          <span class="token function">ssh</span>
<span class="token number">25</span>/tcp <span class="token function">open</span>          smtp
<span class="token number">68</span>/udp <span class="token function">open</span><span class="token operator">|</span>filtered dhcpc

Nmap done: <span class="token number">1</span> IP address <span class="token punctuation">(</span><span class="token number">1</span> <span class="token function">host</span> up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> <span class="token number">2.84</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 ICMP 扫描局域网中有多少台主机：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ nmap <span class="token parameter variable">-sP</span> <span class="token number">192.168</span>.2.0/24

Starting Nmap <span class="token number">6.40</span> <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at <span class="token number">2021</span>-09-23 <span class="token number">22</span>:53 CST
Nmap scan report <span class="token keyword">for</span> <span class="token number">192.168</span>.2.101
Host is up <span class="token punctuation">(</span>-0.10s latency<span class="token punctuation">)</span>.
MAC Address: 0C:9D:92:83:DB:35 <span class="token punctuation">(</span>Unknown
Nmap scan report <span class="token keyword">for</span> <span class="token number">192.168</span>.2.201
Host is up.
Nmap done: <span class="token number">256</span> IP addresses <span class="token punctuation">(</span><span class="token number">2</span> hosts up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> <span class="token number">2.08</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果会列出目标 IP 地址和 MAC 地址。</p>
<h1 id="远程连接"><a class="markdownIt-Anchor" href="#远程连接"></a> 远程连接</h1>
<p>远程连接主要指的是远程工具与即时通信软件。</p>
<h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> telnet</h2>
<p>telnet 是早期用得很广泛的远程连接工具，但使用 telnet 传输的数据是明文的，因此现在已被支持加密的 ssh 取代。命令格式：<code>telnet [主机|IP [端口]]</code>。</p>
<p>例如，使用 telnet 连接 192.168.2.101 的 2201 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ telnet <span class="token number">192.168</span>.2.101 <span class="token number">2201</span>
Trying <span class="token number">192.168</span>.2.101<span class="token punctuation">..</span>.
telnet: connect to address <span class="token number">192.168</span>.2.101: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在经常被用来检测目标 IP 地址特定端口是否打开。</p>
<h2 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h2>
<p>文字接口的 ftp 软件主要有 ftp、lftp、gftp。</p>
<p>例如，使用 ftp 连接 <code>ftp.vim.org</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">ftp</span> ftp.vim.org
Trying <span class="token number">2001</span>:67c:6ec:221:145:220:21:40<span class="token punctuation">..</span>.
Connected to ftp.vim.org <span class="token punctuation">(</span><span class="token number">2001</span>:67c:6ec:221:145:220:21:40<span class="token punctuation">)</span>.
<span class="token number">220</span>-Welcome to the FTP archive of 
<span class="token number">220</span>-The Netherlands Unix Users Group <span class="token punctuation">(</span>NLUUG<span class="token punctuation">)</span>.
<span class="token number">220</span>-You may login as <span class="token string">"ftp"</span> or <span class="token string">"anonymous"</span><span class="token builtin class-name">.</span>
Name <span class="token punctuation">(</span>ftp.vim.org:root<span class="token punctuation">)</span>: <span class="token function">ftp</span>
<span class="token number">331</span> Please specify the password.
Password:
<span class="token number">230</span> Login successful.
Remote system <span class="token builtin class-name">type</span> is UNIX.
Using binary mode to transfer files.
ftp<span class="token operator">></span> <span class="token builtin class-name">help</span>
ftp<span class="token operator">></span> ? recv
recv            receive <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入 <code>help</code> 可以查看说明，输入 <code>bye</code> 退出 ftp。</p>
<h2 id="lftp"><a class="markdownIt-Anchor" href="#lftp"></a> lftp</h2>
<p>lftp 默认使用匿名登录 FTP 服务器，也可以在命令行输入账号密码，可以在脚本中使用。</p>
<p>例如，使用 ftp 用户登录 <code>ftp.vim.org</code>，用法和功能与 ftp 类似，可以使用 <code>help</code> 查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ lftp <span class="token parameter variable">-u</span> ftp,  ftp.vim.org
lftp ftp@ftp.vim.org:~<span class="token operator">></span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用 <code>-f</code> 参数来载入脚本，脚本内容为在 ftp 中实际操作的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> ftp.sh
<span class="token function">open</span> ftp.vim.org
<span class="token builtin class-name">cd</span> pub
get WhereToFindWhat.txt
bye
<span class="token string">"ftp.sh"</span> 4L, 52C written  
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ lftp <span class="token parameter variable">-f</span> ftp.sh 
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ ll WhereToFindWhat.txt                 
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">2023</span> May  <span class="token number">4</span>  <span class="token number">2005</span> WhereToFindWhat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="网络抓包"><a class="markdownIt-Anchor" href="#网络抓包"></a> 网络抓包</h1>
<p>命令模式下可用的抓包工具为 <code>tcpdump</code>，图形界面可以使用 <code>Wireshark</code>。</p>
<h2 id="tcpdump"><a class="markdownIt-Anchor" href="#tcpdump"></a> tcpdump</h2>
<p><code>tcpdump</code> 命令用法：</p>
<p><code>tcpdump [-AennqX] [-i 接口] [-w 储存文件名] [-c 次数] [-r 文件] [要抓取的数据包数据格式]</code></p>
<p>参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>数据包的内容以 ASCII 显示，通常用来抓取 WWW 的网页数据包数据</td>
</tr>
<tr>
<td>-e</td>
<td>使用数据链路层的 MAC 数据包数据来显示</td>
</tr>
<tr>
<td>-nn</td>
<td>直接以 IP 和端口显示</td>
</tr>
<tr>
<td>-q</td>
<td>仅列出较为简短的数据包信息，每一行的内容比较精简</td>
</tr>
<tr>
<td>-X</td>
<td>可以列出十六进制（hex）以及 ASCII 的数据包内容，对于监听数据包内容很有用</td>
</tr>
<tr>
<td>-i</td>
<td>后面接要监听的网络接口，例如 eth0、lo、ppp0 等的界面</td>
</tr>
<tr>
<td>-w</td>
<td>将监听的数据包数据保存到文件</td>
</tr>
<tr>
<td>-r</td>
<td>从已存在的文件中读取数据</td>
</tr>
<tr>
<td>-c</td>
<td>监听的数据包数，如果不指定，<code>tcpdump</code> 会一直监听下去</td>
</tr>
</tbody>
</table>
<p>其中最后一个要抓取的数据包数据格式可以用以下方法表示：</p>
<ul>
<li>‘host server201’，‘host 192.168.2.101’：针对单台主机进行数据包抓取；</li>
<li>‘net 192.168’：针对某个网络来进行数据包捕获；</li>
<li>‘src host 127.0.0.1’，‘dst net 192.168’：同时加上来源与目标地址限制；</li>
<li>‘tcp port 21’：针对通信协议检测，如 TCP、UDP、ARP 等；</li>
<li>还可以利用 and 与 or 来进行数据包整合显示。</li>
</ul>
<p>例如抓取 <code>ens33</code> 网口上的数据包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ tcpdump <span class="token parameter variable">-i</span> ens33 <span class="token parameter variable">-nn</span>
<span class="token number">19</span>:45:37.349993 IP <span class="token number">192.168</span>.2.101.64456 <span class="token operator">></span> <span class="token number">192.168</span>.2.201.22: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">682480</span>, win <span class="token number">8212</span>, options <span class="token punctuation">[</span>nop,nop,sack <span class="token number">1</span> <span class="token punctuation">&#123;</span><span class="token number">681424</span>:682480<span class="token punctuation">&#125;</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">19</span>:45:37.350036 IP <span class="token number">192.168</span>.2.101.64456 <span class="token operator">></span> <span class="token number">192.168</span>.2.201.22: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">682480</span>, win <span class="token number">8212</span>, options <span class="token punctuation">[</span>nop,nop,sack <span class="token number">1</span> <span class="token punctuation">&#123;</span><span class="token number">681424</span>:682480<span class="token punctuation">&#125;</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">4472</span> packets captured
<span class="token number">4480</span> packets received by filter
<span class="token number">0</span> packets dropped by kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>短短 1 秒钟就抓取到了 4472 个数据包。以第一条数据来说明：</p>
<ul>
<li>19:45:37.349993：数据包被捕获的时间。</li>
<li>IP：通过的通信协议是 IP。</li>
<li>192.168.2.101.64456 &gt;：传送端的 IP 和端口。</li>
<li>192.168.2.201.22：接收端的 IP 和端口。</li>
<li>Flags [.], ack 682480…：传输内容。</li>
</ul>
<h2 id="nc"><a class="markdownIt-Anchor" href="#nc"></a> nc</h2>
<p><code>nc</code> 命令可以用于作为某些服务的检测，因为它可以连接到某个端口进行通信。此外，还可以自行启动一个端口来监听其他用户的连接。</p>
<p>例如，检测本机的 22 号端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">nc</span> localhost <span class="token number">22</span>
SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>测试 192.168.2.113 上的 10002 端口的联通性，超时时间为 2 秒：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">nc</span> <span class="token parameter variable">-vz</span> <span class="token parameter variable">-w</span> <span class="token number">2</span> <span class="token number">192.168</span>.2.113 <span class="token number">10002</span>
Ncat: Version <span class="token number">7.70</span> <span class="token punctuation">(</span> https://nmap.org/ncat <span class="token punctuation">)</span>
Ncat: Connected to <span class="token number">192.168</span>.2.113:10002.
Ncat: <span class="token number">0</span> bytes sent, <span class="token number">0</span> bytes received <span class="token keyword">in</span> <span class="token number">0.01</span> seconds.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以使用 <code>nc</code> 来启动监听端口号，例如启动 19999 号作为监听端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">nc</span> <span class="token parameter variable">-l</span> localhost <span class="token number">19999</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，在另一个终端中查询端口和连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">netstat</span> <span class="token parameter variable">-ntulp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">19999</span>
tcp6       <span class="token number">0</span>      <span class="token number">0</span> ::1:19999               :::*                    LISTEN      <span class="token number">61792</span>/nc
<span class="token punctuation">[</span>root@server201 ~<span class="token punctuation">]</span>$ <span class="token function">nc</span> localhost <span class="token number">19999</span>
a
f <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>4.网络服务</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 内核编译</title>
    <url>/3262096821/</url>
    <content><![CDATA[<h1 id="内核编译介绍"><a class="markdownIt-Anchor" href="#内核编译介绍"></a> 内核编译介绍</h1>
<p>通常只有在以下情况下才需要重新编译内核：</p>
<ul>
<li>新功能需求：需要的新功能只有在新内核中才能使用，为了获得这些功能，必须重新编译内核；</li>
<li>内核过于臃肿：如果内核中包含很多不需要的功能，可以重新编译内核并去除这些功能；</li>
<li>更换硬件驱动：如果当前内核编译的驱动导致系统不稳定，可以替换为稳定版的驱动；</li>
<li>其他需求：对于特殊硬件系统，可能需要自行设计内核。</li>
</ul>
<p>内核及内核模块的路径如下：</p>
<ul>
<li>内核：/boot/vmlinuz</li>
<li>虚拟文件系统（RAM Disk）：/boot/initramfs</li>
<li>内核模块：/lib/modules/version/kernel</li>
<li>内核源代码：/usr/src/linux</li>
</ul>
<p>在 CentOS 上，可以在以下网站下载原始 SRPM：<a href="http://vault.centos.org/">http://vault.centos.org/</a></p>
<p>Linux 官方内核源码可以在以下网站下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<h1 id="保持源码干净"><a class="markdownIt-Anchor" href="#保持源码干净"></a> 保持源码干净</h1>
<p>下载内核并解压：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">wget</span> ftp://ftp.twaren.net/pub/Unix/Kernel/linux/kernel/v3.x/linux-3.10.89.tar.xz
<span class="token punctuation">[</span>root@234c8 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-Jxvf</span> linux-3.10.89.tar.xz <span class="token parameter variable">-C</span> /usr/src/kernels/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为了确保内核源代码干净，没有保留目标文件(<code>*.o</code>)及相关配置，可以使用<code>make mrproper</code>来处理：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> mrproper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一般只有第一次执行内核编译前采用这一命令，其他时候用<code>make clean</code>就可以。</p>
<h1 id="挑选内核功能"><a class="markdownIt-Anchor" href="#挑选内核功能"></a> 挑选内核功能</h1>
<p>在<code>/boot</code>目录下存在<code>config-*</code>的内核功能列表文件，可以通过多个方法创建：</p>
<ul>
<li><code>make menuconfig</code>：最常用的方法，在命令行模式下进行配置。</li>
<li><code>make oldconfig</code>：通过已存在的<code>./.config</code>文件内容设置默认值，只将新版内核内功能列出来供选择。</li>
<li><code>make xconfig</code>：通过 KDE 图形界面来设置。</li>
<li><code>make gconfig</code>：通过 GNOME 图形界面来设置。</li>
<li><code>make config</code>：过去的设置方式。</li>
</ul>
<p>下面以<code>make menuconfig</code>为例进行操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">cp</span> /boot/config-3.10.0-1160.41.1.el7.x86_64 .config
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> menuconfig
 .config - Linux/x86 <span class="token number">3.10</span>.89 Kernel Configuration
 ----------------------------------------------------------------------------------------
  +--------------------- Linux/x86 <span class="token number">3.10</span>.89 Kernel Configuration -----------------------+
  <span class="token operator">|</span>  Arrow keys navigate the menu.  <span class="token operator">&lt;</span>Enter<span class="token operator">></span> selects submenus -- letters are hotkeys.   <span class="token operator">|</span>
  <span class="token operator">|</span>  Pressing <span class="token operator">&lt;</span>Y<span class="token operator">></span> includes, <span class="token operator">&lt;</span>N<span class="token operator">></span> excludes, <span class="token operator">&lt;</span>M<span class="token operator">></span> modu.  Press <span class="token operator">&lt;</span>Esc<span class="token operator">></span><span class="token operator">&lt;</span>Esc<span class="token operator">></span> to exit, <span class="token operator">&lt;</span>?<span class="token operator">></span> <span class="token keyword">for</span> <span class="token operator">|</span>
  <span class="token operator">|</span>  Help, <span class="token operator">&lt;</span>/<span class="token operator">></span> <span class="token keyword">for</span> Search.  Legend: <span class="token punctuation">[</span>*<span class="token punctuation">]</span> built-in  <span class="token punctuation">[</span> <span class="token punctuation">]</span> excluded  <span class="token operator">&lt;</span>M<span class="token operator">></span> module  <span class="token operator">&lt;</span> <span class="token operator">></span> mod    <span class="token operator">|</span>
  <span class="token operator">|</span>                                                                                    <span class="token operator">|</span>
  <span class="token operator">|</span> +--------------------------------------------------------------------------------+ <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>             <span class="token punctuation">[</span>*<span class="token punctuation">]</span> <span class="token number">64</span>-bit kernel                                                  <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 General setup  ---<span class="token operator">></span>                                            <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>             <span class="token punctuation">[</span>*<span class="token punctuation">]</span> Enable loadable module support  ---<span class="token operator">></span>                           <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>             -*- Enable the block layer  ---<span class="token operator">></span>                                   <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Processor <span class="token builtin class-name">type</span> and features  ---<span class="token operator">></span>                              <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Power management and ACPI options  ---<span class="token operator">></span>                        <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Bus options <span class="token punctuation">(</span>PCI etc.<span class="token punctuation">)</span>  ---<span class="token operator">></span>                                   <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Executable <span class="token function">file</span> formats / Emulations  ---<span class="token operator">></span>                     <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>             -*- Networking support  ---<span class="token operator">></span>                                       <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Device Drivers  ---<span class="token operator">></span>                                           <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Firmware Drivers  ---<span class="token operator">></span>                                         <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 File systems  ---<span class="token operator">></span>                                             <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> <span class="token operator">|</span>                 Kernel hacking  ---<span class="token operator">></span>                                           <span class="token operator">|</span> <span class="token operator">|</span>
  <span class="token operator">|</span> +-------------↓<span class="token punctuation">(</span>+<span class="token punctuation">)</span>---------------------------------------------------------------+ <span class="token operator">|</span>
  +------------------------------------------------------------------------------------+
  <span class="token operator">|</span>               <span class="token operator">&lt;</span>Select<span class="token operator">></span>    <span class="token operator">&lt;</span> Exit <span class="token operator">></span>    <span class="token operator">&lt;</span> Help <span class="token operator">></span>    <span class="token operator">&lt;</span> Save <span class="token operator">></span>    <span class="token operator">&lt;</span> Load <span class="token operator">></span>             <span class="token operator">|</span>
  +------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于整个内核功能选择，一般来说，要选择必需的功能编译进内核，可能需要的功能编译成模块，不清楚的功能则保持默认。功能选择好后，选择<code>Save</code>退出。</p>
<h1 id="内核编译"><a class="markdownIt-Anchor" href="#内核编译"></a> 内核编译</h1>
<p>在编译内核之前，需要清除无用文件，然后分别编译内核和模块。使用 <code>-j</code> 参数指定编译时使用的线程数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> clean
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">16</span> bzImage
  BUILD   arch/x86/boot/bzImage
Setup is <span class="token number">16704</span> bytes <span class="token punctuation">(</span>padded to <span class="token number">16896</span> bytes<span class="token punctuation">)</span>.
System is <span class="token number">4674</span> kB
CRC e48489cb
Kernel: arch/x86/boot/bzImage is ready  <span class="token punctuation">(</span><span class="token comment">#1)</span>
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">16</span> modules
  IHEX2FW firmware/whiteheat_loader.fw
  IHEX2FW firmware/keyspan_pda/keyspan_pda.fw
  IHEX2FW firmware/keyspan_pda/xircom_pgs.fw
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">16</span> clean bzImage modules
  LD      drivers/scsi/scsi_mod.o
  LD <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  drivers/scsi/scsi_tgt.o
  LD      drivers/scsi/built-in.o
  LD      drivers/built-in.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译完成后，文件应该存放在当前目录下。</p>
<h1 id="安装模块"><a class="markdownIt-Anchor" href="#安装模块"></a> 安装模块</h1>
<p>如果模块有修改，可以在内核功能选择的 General setup 中的 Local version 中修改成新的名称。安装模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">make</span> modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="安装内核"><a class="markdownIt-Anchor" href="#安装内核"></a> 安装内核</h1>
<p>在无法确认新内核是否工作情况下，保留旧内核:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">cp</span> arch/x86/boot/bzImage /boot/vmliunz-3.10.89m
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">cp</span> .config /boot/config-3.10.89m
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">chmod</span> a+x /boot/vmlinuz-3.10.89m
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">cp</span> System.map /boot/System.map-3.10.89m
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ <span class="token function">gzip</span> <span class="token parameter variable">-c</span> Module.symvers <span class="token operator">></span> /boot/symvers-3.10.89m.gz
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ restorecon <span class="token parameter variable">-Rv</span> /boot
<span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ dracut <span class="token parameter variable">-v</span> /oot/initramfs-3.10.89m.img <span class="token number">3.10</span>.89m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着使用<code>grub2-mkconfig</code>来处理<code>grub2</code>开机菜单:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@234c8 linux-3.10.89<span class="token punctuation">]</span>$ grub2-mkconfig <span class="token parameter variable">-o</span> /boot/grub2/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后就可以重启测试新内核了。</p>
<h1 id="内核模块依赖"><a class="markdownIt-Anchor" href="#内核模块依赖"></a> 内核模块依赖</h1>
<p>在内核模块目录中通常分为以下几个子目录：</p>
<ul>
<li>arch：与硬件平台有关的项目，如 CPU 的等级。</li>
<li>crypto：内核所支持的加密技术，例如 MD5、DES 等。</li>
<li>drivers：一些硬件的驱动程序，如网卡、显卡驱动等。</li>
<li>fs：内核支持的文件系统，如 VFAT、NFS 等。</li>
<li>lib：一些函数库。</li>
<li>net：与网络有关的各项协定数据，包括防火墙。</li>
<li>sound：与声音有关的模块。</li>
</ul>
<p>内核模块之间的依赖性检查通过 <code>/lib/modules/version/modules.dep</code> 来记录，可以使用 <code>depmod</code> 命令来加入已编译好的模块。例如要加入名为 <code>tp-413.ko</code> 网卡驱动到内核模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cp</span> tp-413.ko /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/net/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ depmod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>执行 <code>depmod</code> 命令后，程序会跑到内核模块目录，将全部模块分析一遍，将结果写入到 <code>modules.dep</code> 文件中。</p>
<h1 id="内核模块查询"><a class="markdownIt-Anchor" href="#内核模块查询"></a> 内核模块查询</h1>
<p>要查询内核以及加载的模块列表，可以使用 <code>lsmod</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lsmod
Module                  Size  Used by
nf_conntrack_ftp       <span class="token number">18478</span>  <span class="token number">0</span> 
nf_conntrack          <span class="token number">139264</span>  <span class="token number">1</span> nf_conntrack_ftp
snd_seq_midi           <span class="token number">13565</span>  <span class="token number">0</span> 
snd_seq_midi_event     <span class="token number">14597</span>  <span class="token number">1</span> snd_seq_midi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果会分别显示出模块名称，模块大小和模块被其他模块使用（Used by）的信息。</p>
<p>如果想要查询模块具体信息，可以使用 <code>modinfo</code> 命令。例如查询 <code>nf_conntrack_ftp</code> 模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ modinfo nf_conntrack_ftp
filename:       /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/net/netfilter/nf_conntrack_ftp.ko.xz
alias:          nfct-helper-ftp
alias:          ip_conntrack_ftp
description:    <span class="token function">ftp</span> connection tracking helper
author:         Rusty Russell <span class="token operator">&lt;</span>rusty@rustcorp.com.au<span class="token operator">></span>
license:        GPL
retpoline:      Y
rhelversion:    <span class="token number">7.9</span>
srcversion:     F21861D5AD43080B93CC4DD
depends:        nf_conntrack
intree:         Y
vermagic:       <span class="token number">3.10</span>.0-1160.41.1.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        4B:E3:B8:E9:52:F4:81:B2:62:51:AC:E4:66:9B:A7:99:71:D1:F1:AF
sig_hashalgo:   sha256
parm:           ports:array of ushort
parm:           loose:bool<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面查询可以得到模块的文件位置、依赖的模块，还有模块的参数（<code>parm</code>）。</p>
<h1 id="内核模块加载与删除"><a class="markdownIt-Anchor" href="#内核模块加载与删除"></a> 内核模块加载与删除</h1>
<p>除了上面使用到的<code>modprobe</code>命令，还可以使用<code>insmod</code>来安装模块。例如载入<code>fat</code>模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/fat.ko.xz 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lsmod <span class="token operator">|</span> <span class="token function">grep</span> fat
fat                    <span class="token number">65950</span>  <span class="token number">0</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用<code>insmod</code>命令必须接模块完整路径来安装，并且不会去分析模块的依赖性。</p>
<p>想要移除模块使用<code>rmmod</code>命令，例如移除<code>fat</code>模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ rmmod fat
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz 
insmod: ERROR: could not insert module /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz: Unknown symbol <span class="token keyword">in</span> module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>不过这样有个坏处就是需要手动处理依赖问题，比如上面<code>fat</code>模块被移除后，无法用<code>insmod</code>命令来载入<code>vfat</code>模块。</p>
<p>最稳妥的方式还是使用<code>modprobe</code>来处理。<code>-f</code>参数可以强制载入模块，<code>-r</code>参数用来移除模块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ modprobe vfat
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lsmod <span class="token operator">|</span> <span class="token function">grep</span> vfat
vfat                   <span class="token number">17461</span>  <span class="token number">0</span> 
fat                    <span class="token number">65950</span>  <span class="token number">1</span> vfat
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ modprobe <span class="token parameter variable">-r</span> vfat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想让模块开机自动载入，例如要加入启动一个<code>nf_conntrack_frp</code>模块，可以在目录下新建一个 conf 文件：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/modules-load.d/ftp.conf
nf_conntrack_ftp
<span class="token string">"/etc/modules-load.d/ftp.conf"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 1L, 17C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>一个模块（驱动）写一行，上面模块是针对默认 FTP 端口设置。如果要调整到 558 端口，可以在<code>modprobe.d</code>目录下面新建配置：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/modprobe.d/ftp.conf
options nf_conntrack_ftp <span class="token assign-left variable">ports</span><span class="token operator">=</span><span class="token number">558</span>
<span class="token string">"/etc/modprobe.d/ftp.conf"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 1L, 35C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>系统重启后就能顺利载入模块了。也可以通过重启<code>systemd-modules-load</code>服务来即刻生效：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ systemctl restart systemd-modules-load
<span class="token punctuation">[</span>root@101c7 initrams<span class="token punctuation">]</span>$ lsmod <span class="token operator">|</span> <span class="token function">grep</span> nf_conntrack_ftp
nf_conntrack_ftp       <span class="token number">18478</span>  <span class="token number">0</span> 
nf_conntrack          <span class="token number">139264</span>  <span class="token number">1</span> nf_conntrack_ftp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 基本系统设置</title>
    <url>/3511703514/</url>
    <content><![CDATA[<h1 id="网络设置"><a class="markdownIt-Anchor" href="#网络设置"></a> 网络设置</h1>
<p>可以通过 <code>nmcli connection show</code> 命令来查询网卡信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ nmcli connection show
NAME   UUID                                  TYPE      DEVICE 
ens33  ebab2aaf-84f5-45b6-a431-7ec3c63891b0  ethernet  ens33
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ nmcli connection show ens33
connection.id:                          ens33
connection.uuid:                        ebab2aaf-84f5-45b6-a431-7ec3c63891b0
connection.stable-id:                   --
connection.type:                        <span class="token number">802</span>-3-ethernet
connection.interface-name:              ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上，网卡信息列得非常详细，也可以通过 <code>nmcli connection modify</code> 来修改网卡参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ nmcli connection modify ens33 <span class="token punctuation">\</span>
<span class="token operator">></span> connection.autoconnect <span class="token function">yes</span> <span class="token punctuation">\</span>
<span class="token operator">></span> ipv4.method manual <span class="token punctuation">\</span>
<span class="token operator">></span> ipv4.addresses <span class="token number">192.168</span>.2.234/16 <span class="token punctuation">\</span>
<span class="token operator">></span> ipv4.gateway <span class="token number">192.168</span>.2.1 <span class="token punctuation">\</span>
<span class="token operator">></span> ipv4.dns <span class="token number">222.246</span>.129.80
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ nmcli connection up ens33
Connection successfully activated <span class="token punctuation">(</span>D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果设置成 DHCP 获取 IP，只用把 <code>ipv4.method</code> 设置为 <code>auto</code> 即可，或者使用 <code>dhclient</code> 命令来发送 DHCP 请求获取 IP 地址参数。</p>
<p>和网络参数有关的配置文件有下面一些：</p>
<ul>
<li>
<p><code>/etc/sysconfig/network-scripts/ifcfg-*</code></p>
<p>配置网卡 IP 地址、子网掩码、网关等参数。</p>
</li>
<li>
<p><code>/etc/sysconfig/network</code></p>
<p>配置网络主机名。</p>
</li>
<li>
<p><code>/etc/resolv.conf</code></p>
<p>配置 DNS 服务器地址。</p>
</li>
<li>
<p><code>/etc/hosts</code></p>
<p>自定义域名解析列表。</p>
</li>
<li>
<p><code>/etc/services</code></p>
<p>记录协议和对应端口号。</p>
</li>
<li>
<p><code>/etc/protocols</code></p>
<p>定义 IP 数据包协议的相关数据，包括 ICMP/TCP/UDP 的数据包协议。</p>
</li>
</ul>
<h1 id="修改主机名"><a class="markdownIt-Anchor" href="#修改主机名"></a> 修改主机名</h1>
<p>修改主机名使用 <code>hostnamectl</code> 命令。例如修改主机名为 234c8：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ hostnamectl set-hostname 234c8
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ hostnamectl
   Static hostname: 234c8
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 77a36143eb014dd5a0d6e738b1d84778
           Boot ID: d9ef90ff0bbe4cc184d4b0599cbcb747
    Virtualization: vmware
  Operating System: CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux <span class="token number">3.10</span>.0-1160.41.1.el7.x86_64
      Architecture: x86-64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="修改系统时区"><a class="markdownIt-Anchor" href="#修改系统时区"></a> 修改系统时区</h1>
<p>修改系统时区使用 <code>timedatectl</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ timedatectl
      Local time: Tue <span class="token number">2021</span>-09-21 04:42:53 EDT
  Universal time: Tue <span class="token number">2021</span>-09-21 08:42:53 UTC
        RTC time: Tue <span class="token number">2021</span>-09-21 08:42:52
       Time zone: America/New_York <span class="token punctuation">(</span>EDT, -0400<span class="token punctuation">)</span>
     NTP enabled: <span class="token function">yes</span>
NTP synchronized: <span class="token function">yes</span>
 RTC <span class="token keyword">in</span> <span class="token builtin class-name">local</span> TZ: no
      DST active: <span class="token function">yes</span>
 Last DST change: DST began at
                  Sun <span class="token number">2021</span>-03-14 01:59:59 EST
                  Sun <span class="token number">2021</span>-03-14 03:00:00 EDT
 Next DST change: DST ends <span class="token punctuation">(</span>the clock jumps one hour backwards<span class="token punctuation">)</span> at
                  Sun <span class="token number">2021</span>-11-07 01:59:59 EDT
                  Sun <span class="token number">2021</span>-11-07 01:00:00 EST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目前使用的是纽约时间，改成东八区上海：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ timedatectl list-timezones <span class="token operator">|</span> <span class="token function">grep</span> Shang
Asia/Shanghai
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ timedatectl set-timezone <span class="token string">"Asia/Shanghai"</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">date</span>
Tue Sep <span class="token number">21</span> <span class="token number">16</span>:46:20 CST <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>timedatectl</code> 命令手动调整时间或使用网络校时：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ timedatectl set-time <span class="token string">"2021-09-21 16:50"</span>
Failed to <span class="token builtin class-name">set</span> time: Automatic <span class="token function">time</span> synchronization is enabled
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ntpdate cn.pool.ntp.org
<span class="token number">21</span> Sep <span class="token number">16</span>:49:08 ntpdate<span class="token punctuation">[</span><span class="token number">13077</span><span class="token punctuation">]</span>: adjust <span class="token function">time</span> server <span class="token number">84.16</span>.67.12 offset <span class="token parameter variable">-0.002613</span> sec
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ hwclock <span class="token parameter variable">-w</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="系统编码设置"><a class="markdownIt-Anchor" href="#系统编码设置"></a> 系统编码设置</h1>
<p>有时候，系统语言和软件使用的语言不一致。使用 <code>localectl</code> 命令可以查询系统语言设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ localectl
   System Locale: <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8
       VC Keymap: us
      X11 Layout: us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>locale</code> 命令可以查询系统的语言设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ locale
<span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8
<span class="token assign-left variable">LC_CTYPE</span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>
<span class="token assign-left variable"><span class="token environment constant">LC_NUMERIC</span></span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>
<span class="token assign-left variable"><span class="token environment constant">LC_TIME</span></span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>localectl set-locale</code> 命令来修改系统语言设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ localectl set-locale <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.utf8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 日志分析与管理</title>
    <url>/808925609/</url>
    <content><![CDATA[<h1 id="日志系统"><a class="markdownIt-Anchor" href="#日志系统"></a> 日志系统</h1>
<p>日志记录简单来说就是记录系统何时由哪个程序做了什么行为，发生了什么事件等等。</p>
<p>常见日志文件有下面一些：</p>
<ul>
<li><code>/var/log/boot.log</code>：开机硬件检测产生的记录信息，在 CentOS 合并到了 <code>dmesg</code> 中。</li>
<li><code>/var/log/cron</code>：记录 <code>crontab</code> 调度工作运行情况。</li>
<li><code>/var/log/dmesg</code>：记录开机检测信息。</li>
<li><code>/var/log/lastlog</code>：记录系统上所有账号最近一次登录的信息。</li>
<li><code>/var/log/maillog</code>：记录邮件的往来信息。</li>
<li><code>/var/log/messages</code>：记录所有错误与重要信息。</li>
<li><code>/var/log/secure</code>：记录账号登录验证信息。</li>
<li><code>/var/log/wtmp</code>，<code>/var/log/faillog</code>：记录正确登录与错误登录时的账号信息。</li>
<li><code>/var/log/服务名</code>：不同服务会使用各自的目录记录日志。</li>
</ul>
<p>系统提供日志记录相关的服务有：</p>
<ul>
<li><code>systemd-journald.service</code>：由 <code>systemd</code> 提供的日志系统；</li>
<li><code>rsyslog.service</code>：主要登录系统与网络等服务的信息；</li>
<li><code>logrotate</code>：对日志文件进行轮替处理。</li>
</ul>
<p>日志文件记录内容由四段组成：</p>
<ul>
<li>事件发生的时间与日期；</li>
<li>发生此事件的主机名称；</li>
<li>启动此事件的服务名称或命令与函数名；</li>
<li>信息的实际内容。</li>
</ul>
<h1 id="日志规范"><a class="markdownIt-Anchor" href="#日志规范"></a> 日志规范</h1>
<p>rsyslog 的配置文件位于 <code>/etc/rsyslog.conf</code>，可以配置服务、日志等级和日志存放位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/rsyslog.conf 
<span class="token variable">$ModLoad</span> imuxsock <span class="token comment"># provides support for local system logging (e.g. via logger command)</span>
<span class="token variable">$ModLoad</span> imjournal <span class="token comment"># provides access to the systemd journal</span>
<span class="token variable">$WorkDirectory</span> /var/lib/rsyslog
<span class="token variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf
mail.*                                                  -/var/log/maillog
uucp,news.crit                                          /var/log/spooler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Linux 的 syslog 有规范服务类型如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>kernel</td>
<td>内核产生日志，比如硬件检测和内核功能启用</td>
</tr>
<tr>
<td>1</td>
<td>user</td>
<td>使用者层级产生的日志</td>
</tr>
<tr>
<td>2</td>
<td>mail</td>
<td>与邮件收发者有关的日志</td>
</tr>
<tr>
<td>3</td>
<td>daemon</td>
<td>系统服务产生的日志</td>
</tr>
<tr>
<td>4</td>
<td>auth</td>
<td>与认证/授权有关的日志</td>
</tr>
<tr>
<td>5</td>
<td>syslog</td>
<td>rsyslogd 程序产生的日志</td>
</tr>
<tr>
<td>6</td>
<td>lpr</td>
<td>与打印相关的日志</td>
</tr>
<tr>
<td>7</td>
<td>news</td>
<td>与新闻组服务有关日志</td>
</tr>
<tr>
<td>8</td>
<td>uucp</td>
<td>Unix to Unix Copy Protocol，早期 Unix 系统间程序数据交换日志</td>
</tr>
<tr>
<td>9</td>
<td>cron</td>
<td>与工作调度有关日志</td>
</tr>
<tr>
<td>10</td>
<td>authpriv</td>
<td>与 auth 类似，但记录较多私人信息，包括 pam 模块的运行等</td>
</tr>
<tr>
<td>11</td>
<td>ftp</td>
<td>与 FTP 通讯协议有关的日志</td>
</tr>
<tr>
<td>16~23</td>
<td>local0~7</td>
<td>保留给本机用户使用的一些日志文件信息，较常与终端机互动</td>
</tr>
</tbody>
</table>
<p>日志等级有八级，根据 syslog.h 的定义如下：</p>
<table>
<thead>
<tr>
<th>等级数值</th>
<th>等级名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>debug</td>
<td>Debug 时产生的日志</td>
</tr>
<tr>
<td>6</td>
<td>info</td>
<td>一些基本运行记录</td>
</tr>
<tr>
<td>5</td>
<td>notice</td>
<td>正常提示信息</td>
</tr>
<tr>
<td>4</td>
<td>warning (warn)</td>
<td>警示信息，可能有问题，但还不至于影响服务运行</td>
</tr>
<tr>
<td>3</td>
<td>err (error)</td>
<td>重大错误信息，例如配置文件错误导致的服务不能启动</td>
</tr>
<tr>
<td>2</td>
<td>crit</td>
<td>致命错误信息</td>
</tr>
<tr>
<td>1</td>
<td>alert</td>
<td>告警信息</td>
</tr>
<tr>
<td>0</td>
<td>emerg (panic)</td>
<td>紧急级别，意味着出现了硬件问题导致系统无法运行</td>
</tr>
</tbody>
</table>
<p>在服务名和日志等级之间使用符号进行设置：</p>
<ul>
<li>. ：代表比后面等级更严重的日志都会被记录下来；</li>
<li>.= ：代表只记录后面等级的日志；</li>
<li>.! ：代表除该等级以外的其他等级日志都被记录。</li>
</ul>
<p>如果是 <code>*.emerg</code> 的写法，则代表所有程序的 <code>emerg</code> 等级的日志。</p>
<p>在日志文件记录位置前的减号 <code>-</code> 代表日志会先放到内存中缓存，直到达到一定大小才会写入到硬盘。</p>
<p>例如，要在 <code>/var/log/messages</code> 中排除掉 <code>news</code> 和 <code>mail</code> 的日志，可以设置为：</p>
<p><code>*,*;news,mail.none   /var/log/messages</code></p>
<p>或者：</p>
<p><code>*.*;news.none;mail.none  /var/log/messages</code></p>
<p>设置好记录规则后，需要重启 rsyslog 服务才能生效。</p>
<p>注意，如果在记录中的日志文件被其他程序打开并修改，rsyslog 将不会再向这个日志文件中写入新内容，此时也需要重启 rsyslog 服务才能恢复。</p>
<p>如果实在要向日志文件中插入数据，可以使用 <code>logger</code> 命令，用法为：<code>logger [-p 服务名称.日志等级] &quot;内容&quot;</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ logger <span class="token parameter variable">-p</span> user.info <span class="token string">"msg from logger"</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ journalctl <span class="token parameter variable">-f</span>
Sep <span class="token number">19</span> 06:34:57 101c7 root<span class="token punctuation">[</span><span class="token number">10003</span><span class="token punctuation">]</span>: msg from logger<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这通常写在脚本中用来记录时间戳。</p>
<h1 id="日志收集"><a class="markdownIt-Anchor" href="#日志收集"></a> 日志收集</h1>
<p>rsyslogd 具有日志收集功能，也就是用一台主机做服务端，收集客户端发送的日志。</p>
<p>日志收集功能需要手动启用，可以在 <code>/etc/rsyslog.conf</code> 中修改相关配置。例如，在服务端：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/rsyslog.conf
<span class="token comment"># Provides UDP syslog reception</span>
<span class="token comment">#$ModLoad imudp</span>
<span class="token comment">#$UDPServerRun 514</span>

<span class="token comment"># Provides TCP syslog reception</span>
<span class="token variable">$ModLoad</span> imtcp
<span class="token variable">$InputTCPServerRun</span> <span class="token number">514</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上所示，开启了通过 TCP 传输日志，监听端口 514。重启服务以使设置生效。</p>
<p>对于客户端，只需在 <code>/etc/rsyslog.conf</code> 文件中设置一条记录，将日志文件发送到服务端。例如，如果服务端 IP 地址为 192.168.2.234，则可以这样设置：<code>*.* @@192.168.2.234</code>。</p>
<p>重启后生效，服务端接收的日志内容中的第二段会标明日志发送的来源主机。</p>
<h1 id="日志轮替"><a class="markdownIt-Anchor" href="#日志轮替"></a> 日志轮替</h1>
<p>执行日志轮替操作的程序 <code>logrotate</code> 会定期将旧有日志文件重命名，再建立一个空的新文件来写入新日志。</p>
<p>由于是定期执行，所以可以到 <code>/etc/cron.daily</code> 中查看定时任务内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/cron.daily/logrotate 
<span class="token comment">#!/bin/sh</span>

/usr/sbin/logrotate <span class="token parameter variable">-s</span> /var/lib/logrotate/logrotate.status /etc/logrotate.conf
<span class="token assign-left variable">EXITVALUE</span><span class="token operator">=</span><span class="token variable">$?</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$EXITVALUE</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    /usr/bin/logger <span class="token parameter variable">-t</span> <span class="token function">logrotate</span> <span class="token string">"ALERT exited abnormally with [<span class="token variable">$EXITVALUE</span>]"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在执行脚本中调用了配置文件 <code>/etc/logrotate.conf</code>，它用来在没有指定参数的情况下作为默认值使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/logrotate.conf 
<span class="token comment"># see "man logrotate" for details</span>
<span class="token comment"># rotate log files weekly</span>
weekly

<span class="token comment"># keep 4 weeks worth of backlogs</span>
rotate <span class="token number">4</span>

<span class="token comment"># create new (empty) log files after rotating old ones</span>
create

<span class="token comment"># use date as a suffix of the rotated file</span>
dateext

<span class="token comment"># uncomment this if you want your log files compressed</span>
<span class="token comment">#compress</span>

<span class="token comment"># RPM packages drop log rotation information into this directory</span>
include /etc/logrotate.d

<span class="token comment"># no packages own wtmp and btmp -- we'll rotate them here</span>
/var/log/wtmp <span class="token punctuation">&#123;</span>
    monthly
    create 0664 root utmp
        minsize 1M
    rotate <span class="token number">1</span>
<span class="token punctuation">&#125;</span>

/var/log/btmp <span class="token punctuation">&#123;</span>
    missingok
    monthly
    create 0600 root utmp
    rotate <span class="token number">1</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由配置文件注释可以得知目前的设置为：每周进行一次轮替工作，保留最多四个记录，轮替后创建新的空文件作日志记录，被轮替文件名上加日期，不压缩日志，读取 <code>/etc/logrotate.d</code> 目录内的配置文件。</p>
<p>下面以 <code>&#123;&#125;</code> 括起来的段落是针对不同文件的单独配置，例如针对 <code>wtmp</code>，轮替周期为月而不是周，指定新建文件的权限与所属，文件大小超过 1M 才进行轮替（比时间条件优先），最后是只保留一个记录。</p>
<p>再看看保存在 <code>/etc/logrotate.d</code> 中针对个别程序的独立设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/logrotate.d/syslog 
/var/log/cron
/var/log/maillog
/var/log/messages
/var/log/secure
/var/log/spooler
<span class="token punctuation">&#123;</span>
    missingok
    sharedscripts
    postrotate
        /bin/kill <span class="token parameter variable">-HUP</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /var/run/syslogd.pid <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null<span class="token variable">`</span></span> <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null <span class="token operator">||</span> <span class="token boolean">true</span>
    endscript
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>logrotate 配置文件基本写法如下：</p>
<ul>
<li>文件名：以绝对路径写在最前面，可以每行一个表示处理多个日志文件。</li>
<li>参数：用 <code>&#123;&#125;</code> 括起来。</li>
<li>执行脚本：可调用外部命令，需要写入 <code>sharedscripts...endscript</code> 里面。可以用 <code>prerotate/postrotate</code> 表示执行命令的时机在启动 logrotate 之前/之后。这个特性可以用于处理加上特殊属性的文件。例如处理 messages 文件上的追加属性。</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/logrotate.d/syslog 
/var/log/cron
/var/log/maillog
/var/log/messages
/var/log/secure
/var/log/spooler
<span class="token punctuation">&#123;</span>
    missingok
    sharedscripts
    prerotate
        /usr/bin/chattr <span class="token parameter variable">-a</span> /var/log/messages
    endscript
    sharedscripts
    postrotate
        /bin/kill <span class="token parameter variable">-HUP</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /var/run/syslogd.pid <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null<span class="token variable">`</span></span> <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null <span class="token operator">||</span> <span class="token boolean">true</span>
        /usr/bin/chattr +a /var/log/messages
    endscript
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置修改完毕后可以使用 <code>systemctl reload</code> 来让配置生效，或者手动强制执行一次：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">logrotate</span> <span class="token parameter variable">-vf</span> /etc/logrotate.conf
reading config <span class="token function">file</span> /etc/logrotate.conf
including /etc/logrotate.d
reading config <span class="token function">file</span> bootlog
reading config <span class="token function">file</span> chrony<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="日志查询"><a class="markdownIt-Anchor" href="#日志查询"></a> 日志查询</h1>
<p>systemd 使用 <code>systemd-journald.service</code> 服务来记录日志，会记录所有经由 systemd 所管理服务产生的日志。</p>
<p>由于 <code>systemd-journald</code> 把日志存在内存中，因此重启后上次登录时产生的日志文件都不存在了。可以搭配 <code>rsyslogd</code> 来记录需要的日志。</p>
<p><code>journalctl</code> 命令使用语法为：<code>journalctl [-nrpf] [--since TIME] [--until TIME] 选项</code></p>
<p>主要参数和选项为：</p>
<table>
<thead>
<tr>
<th>参数或选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-n</code></td>
<td>打印最近的 <code>n</code> 条日志</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>反向输出，最新的记录在前</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>只查询指定等级日志</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>类似 <code>tail -f</code> 来持续输出</td>
</tr>
<tr>
<td><code>--since</code> <code>--until</code></td>
<td>设置开始与结束时间来筛选日志</td>
</tr>
<tr>
<td><code>_SYSTEMD_UNIT=unit.service</code></td>
<td>只输出 <code>unit.service</code> 的日志</td>
</tr>
<tr>
<td><code>_COMM=bash</code></td>
<td>只输出与 <code>bash</code> 有关的日志</td>
</tr>
<tr>
<td><code>_PID=pid</code></td>
<td>只输出指定 <code>pid</code> 进程的日志</td>
</tr>
<tr>
<td><code>_UID=uid</code></td>
<td>只输出指定 <code>uid</code> 用户的日志</td>
</tr>
<tr>
<td><code>SYSLOG_FACILITY=[0-23]</code></td>
<td>使用 <code>syslog.h</code> 规范的服务类型编号来调用数据</td>
</tr>
</tbody>
</table>
<p>如只查看 9.1 到 9.3 号之间的日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ journalctl <span class="token parameter variable">--since</span> <span class="token string">"2020-09-01 00:00:00"</span> <span class="token parameter variable">--until</span> <span class="token string">"2020-09-04 00:00:00"</span>
-- Logs begin at Sat <span class="token number">2021</span>-09-18 <span class="token number">23</span>:12:47 EDT, end at Sun <span class="token number">2021</span>-09-19 06:01:01 EDT. --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查询搜索错误 <code>err</code> 等级日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ journalctl <span class="token parameter variable">-p</span> err
-- Logs begin at Sat <span class="token number">2021</span>-09-18 <span class="token number">23</span>:12:47 EDT, end at Sun <span class="token number">2021</span>-09-19 06:01:01 EDT. --
Sep <span class="token number">18</span> <span class="token number">23</span>:12:47 101c7 kernel: Detected CPU family 17h model <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只查询和 <code>sshd</code> 服务有关的最近 3 条普通日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ journalctl <span class="token assign-left variable">_SYSTEMD_UNIT</span><span class="token operator">=</span>sshd.service <span class="token parameter variable">-n</span> <span class="token number">3</span> <span class="token parameter variable">-p</span> info
-- Logs begin at Sat <span class="token number">2021</span>-09-18 <span class="token number">23</span>:12:47 EDT, end at Sun <span class="token number">2021</span>-09-19 06:01:01 EDT. --
Sep <span class="token number">18</span> <span class="token number">23</span>:12:54 101c7 sshd<span class="token punctuation">[</span><span class="token number">2610</span><span class="token punctuation">]</span>: Accepted password <span class="token keyword">for</span> root from <span class="token number">192.168</span>.2.101 port <span class="token number">62528</span> ssh2
Sep <span class="token number">18</span> <span class="token number">23</span>:12:55 101c7 sshd<span class="token punctuation">[</span><span class="token number">2923</span><span class="token punctuation">]</span>: Accepted password <span class="token keyword">for</span> root from <span class="token number">192.168</span>.2.101 port <span class="token number">59039</span> ssh2
Sep <span class="token number">18</span> <span class="token number">23</span>:12:55 101c7 sshd<span class="token punctuation">[</span><span class="token number">2956</span><span class="token punctuation">]</span>: Accepted password <span class="token keyword">for</span> root from <span class="token number">192.168</span>.2.101 port <span class="token number">59040</span> ssh2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要保存 <code>journalctl</code> 的日志文件，不需要修改 <code>/etc/systemd/journald.conf</code> 文件，只需要在 <code>/var/log/</code> 下面新建一个 <code>journal</code> 的目录并处理一下权限就可以了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /var/log/journal
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> root:systemd-journal /var/log/journal
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">2775</span> /var/log/journal
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl restart systemd-journald
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll /var/log/journal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样设置以后在 <code>/run/log</code> 下面就不会有相关 <code>journal</code> 日志存在了。</p>
<h1 id="日志分析"><a class="markdownIt-Anchor" href="#日志分析"></a> 日志分析</h1>
<p><code>logwatch</code>是 CentOS 7 默认提供的日志文件分析工具，功能为每天定时发送一份邮件给 root 报告昨天系统状态。</p>
<p>安装完毕后可以直接运行一下计划任务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ /etc/cron.daily/0logwatch 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mail
Heirloom Mail version <span class="token number">12.5</span> <span class="token number">7</span>/5/10.  Type ? <span class="token keyword">for</span> help.
<span class="token string">"/var/spool/mail/root"</span><span class="token builtin class-name">:</span> <span class="token number">24</span> messages <span class="token number">15</span> unread
 U <span class="token number">24</span> logwatch@101c7.local  Sun Sep <span class="token number">19</span> 06:46 <span class="token number">183</span>/10954 <span class="token string">"Logwatch for 101c7 (Linux)"</span>
 <span class="token operator">&amp;</span> <span class="token number">24</span>
Message <span class="token number">24</span>:
From root@101c7.localdomain  Sun Sep <span class="token number">19</span> 06:46:51 <span class="token number">2021</span>
Return-Path: <span class="token operator">&lt;</span>root@101c7.localdomain<span class="token operator">></span>
X-Original-To: root
Delivered-To: root@101c7.localdomain
To: root@101c7.localdomain
From: logwatch@101c7.localdomain
Subject: Logwatch <span class="token keyword">for</span> 101c7 <span class="token punctuation">(</span>Linux<span class="token punctuation">)</span>
Auto-Submitted: auto-generated
Precedence: bulk
Content-Type: text/plain<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">"iso-8859-1"</span>
Date: Sun, <span class="token number">19</span> Sep <span class="token number">2021</span> 06:46:50 <span class="token parameter variable">-0400</span> <span class="token punctuation">(</span>EDT<span class="token punctuation">)</span>
Status: RO

 
 <span class="token comment">################### Logwatch 7.4.0 (03/01/11) #################### </span>
        Processing Initiated: Sun Sep <span class="token number">19</span> 06:46:50 <span class="token number">2021</span>
        Date Range Processed: yesterday
                              <span class="token punctuation">(</span> <span class="token number">2021</span>-Sep-18 <span class="token punctuation">)</span>
                              Period is day.
        Detail Level of Output: <span class="token number">0</span>
        Type of Output/Format: mail / text
        Logfiles <span class="token keyword">for</span> Host: 101c7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到非常详细的系统报告。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 服务管理</title>
    <url>/1224880312/</url>
    <content><![CDATA[<h1 id="服务定义"><a class="markdownIt-Anchor" href="#服务定义"></a> 服务定义</h1>
<p>可以将守护进程（Daemon）和服务（Service）视为同一个东西的不同称呼。</p>
<p>服务是常驻内存中的进程，通常负责提供系统功能以服务用户的各项任务。</p>
<p>一般来说，守护进程类型的程序会在文件名末尾加上 <code>d</code>。</p>
<h1 id="init-脚本管理"><a class="markdownIt-Anchor" href="#init-脚本管理"></a> Init 脚本管理</h1>
<p>SysV（System V）的 init 脚本程序处理方式为：将第一个启动的程序称为 init，然后由 init 去启动其他系统所需服务。</p>
<h2 id="init-的管理机制特性"><a class="markdownIt-Anchor" href="#init-的管理机制特性"></a> init 的管理机制特性</h2>
<ul>
<li>
<p><strong>服务管理方式</strong></p>
<p>所有服务启动的 bash 脚本均放在 <code>/etc/init.d/</code> 下面，用统一方式进行处理：</p>
<ul>
<li><strong>启动</strong>：<code>/etc/init.d/daemon start</code></li>
<li><strong>关闭</strong>：<code>/etc/init.d/daemon stop</code></li>
<li><strong>重新启动</strong>：<code>/etc/init.d/daemon restart</code></li>
<li><strong>状态查询</strong>：<code>/etc/init.d/daemon status</code></li>
</ul>
</li>
<li>
<p><strong>服务启动分类</strong></p>
<p>依据服务是独立启动还是被总管程序管理，可分为两大类：</p>
<ul>
<li><strong>独立启动模式</strong>（Stand Alone）：服务独立启动，常驻于内存中，反应速度快。</li>
<li><strong>总管程序管理</strong>（Super Daemon）：由常驻于内存的 xinetd 或 inetd 程序来管理。当用户请求某些功能时，xinetd 才会去唤醒对应服务。当请求完毕服务也跟随停止。好处是统一管理，但启动服务有延时。</li>
</ul>
</li>
<li>
<p><strong>工作形态分类</strong></p>
<p>以 daemon 提供服务的工作状态来分又可以分为两大类：</p>
<ul>
<li><strong>signal-control</strong>：通过信号来管理，只要有请求进来就会立即处理</li>
<li><strong>interval-control</strong>：每隔一段时间主动去执行某项任务</li>
</ul>
</li>
<li>
<p><strong>服务依赖问题</strong></p>
<p>如果服务之间启动互相依赖，则 init 无法解决依赖问题。</p>
</li>
<li>
<p><strong>执行等级分类</strong></p>
<p>init 可以根据设定的运行等级（run level）来启动不同的服务。总共有 7 个执行等级，各执行等级启动脚本通过 <code>/etc/rc.d/rc[0-6]/SXXdaemon</code> 链接到 <code>/etc/init.d/daemon</code>。</p>
<p>链接文件名（SXXdaemon）的作用是指定启动顺序。通过 SXX 的设置，开机时可以按顺序启动服务，同时也解决了服务依赖问题。</p>
</li>
<li>
<p><strong>设定执行等级</strong></p>
<p>可以使用以下命令进行设置：</p>
<ul>
<li><strong>开机启动</strong>：<code>chkconfig daemon on</code></li>
<li><strong>取消开机启动</strong>：<code>chkconfig daemon off</code></li>
<li><strong>查询是否开机启动</strong>：<code>chkconfig --list daemon</code></li>
</ul>
</li>
<li>
<p><strong>执行等级切换</strong></p>
<p>例如，要从命令行（run level 3）切换到图形界面（run level 5），只需使用 <code>init 5</code> 命令即可切换。init 会自动分析 <code>/etc/rc.d/rc[3|5].d/</code> 这两个目录内的脚本，并启动相应的服务。</p>
</li>
</ul>
<h2 id="启动脚本目录配置"><a class="markdownIt-Anchor" href="#启动脚本目录配置"></a> 启动脚本目录配置</h2>
<p>启动脚本基本上固定放在以下位置：</p>
<ul>
<li><code>/etc/init.d/*</code>：所有脚本存放处，因此有大量连接文件。</li>
<li><code>/etc/sysconfig/*</code>：服务初始化环境配置文件，记录一些初始化的参数设置。</li>
<li><code>/etc/xinetd.conf</code>，<code>/etc/xinetd.d/*</code>：super daemon 配置文件及其管理的服务配置文件存放处。</li>
</ul>
<h2 id="stand-alone-启动方式"><a class="markdownIt-Anchor" href="#stand-alone-启动方式"></a> Stand Alone 启动方式</h2>
<p>可以查看一下 <code>netconsole</code> 这个命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ /etc/init.d/netconsole 
Usage: /etc/init.d/netconsole <span class="token punctuation">&#123;</span>start<span class="token operator">|</span>stop<span class="token operator">|</span>status<span class="token operator">|</span>restart<span class="token operator">|</span>condrestart<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ /etc/init.d/netconsole status
netconsole module not loaded
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ /etc/init.d/netconsole start
Starting netconsole <span class="token punctuation">(</span>via systemctl<span class="token punctuation">)</span>:  Job <span class="token keyword">for</span> netconsole.service failed because the control process exited with error code. See <span class="token string">"systemctl status netconsole.service"</span> and <span class="token string">"journalctl -xe"</span> <span class="token keyword">for</span> details.
                                                           <span class="token punctuation">[</span>FAILED<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以直接使用 <code>service</code> 命令来执行查询和操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">service</span> --status-all
netconsole module not loaded
Configured devices:
lo ens33
Currently active devices:
lo ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如查看 <code>crond</code> 服务的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">service</span> crond status
Redirecting to /bin/systemctl status crond.service
● crond.service - Command Scheduler
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/crond.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Sun <span class="token number">2021</span>-09-19 02:32:00 EDT<span class="token punctuation">;</span> 7s ago<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="super-daemon-启动方式"><a class="markdownIt-Anchor" href="#super-daemon-启动方式"></a> Super Daemon 启动方式</h2>
<p>编辑 <code>/etc/xinetd.d/</code> 下面的配置文件，如果 <code>disable=yes</code> 表示未启用，<code>disable=no</code> 才是开机启动。</p>
<p>修改了配置文件后，重启 <code>xinetd</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">service</span> xinetd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用 <code>xinetd</code> 启动的服务，显示名称统一是 <code>xinetd</code>。</p>
<p>位于 <code>/etc/xinetd.d</code> 下面的配置文件可设置的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable</td>
<td>设置是否启动，可设为 <code>yes</code> 或 <code>no</code>。</td>
</tr>
<tr>
<td>id</td>
<td>服务的名称。</td>
</tr>
<tr>
<td>Server</td>
<td>程序完整路径，例如 <code>server=/usr/bin/rsync</code>。</td>
</tr>
<tr>
<td>server_args</td>
<td>程序参数，例如 <code>server_args=--daemon</code>。</td>
</tr>
<tr>
<td>User</td>
<td>服务所属 UID。</td>
</tr>
<tr>
<td>group</td>
<td>服务所属 GID。</td>
</tr>
<tr>
<td>socket_type</td>
<td>数据包类型，<code>stream</code> 代表 TCP，<code>dgram</code> 代表 UDP，<code>raw</code> 代表直接交互。</td>
</tr>
<tr>
<td>protocol</td>
<td>数据包类型，与 <code>socket_type</code> 重复。</td>
</tr>
<tr>
<td>Wait</td>
<td>连接机制，可设为 <code>wait=no</code> 代表多线程。</td>
</tr>
<tr>
<td>instances</td>
<td>最大连接数，如果不限制，可设为 <code>instances=unlimited</code>。</td>
</tr>
<tr>
<td>per_source</td>
<td>单用户最大同时连接数。</td>
</tr>
<tr>
<td>Cps</td>
<td>建立新连接限制，如 <code>[两个数字]</code>。</td>
</tr>
<tr>
<td>log_type</td>
<td>日志文件等级，默认为 <code>info</code>。</td>
</tr>
<tr>
<td>log_on_failure</td>
<td>登录失败后记录的信息，可设置为 <code>PID</code>、<code>HOST</code>、<code>USERID</code>、<code>EXIT</code>、<code>DURATION</code>。</td>
</tr>
<tr>
<td>env</td>
<td>额外变量设置，如 <code>[变量名称=变量内容]</code>。</td>
</tr>
<tr>
<td>Port</td>
<td>非正规端口号，如 <code>[小于 65535 的数字]</code>。</td>
</tr>
<tr>
<td>redirect</td>
<td>服务跳转，如 <code>[IP 端口]</code>。</td>
</tr>
<tr>
<td>includedir</td>
<td>调用外部设置，可导入某个目录内的配置文件，如 <code>[目录名称]</code>。</td>
</tr>
<tr>
<td>bind</td>
<td>服务 IP 绑定，如 <code>[IP]</code>。</td>
</tr>
<tr>
<td>interface</td>
<td>与 <code>bind</code> 相同。</td>
</tr>
<tr>
<td>only_from</td>
<td>防火墙机制，规定可以登录的 IP 地址。</td>
</tr>
<tr>
<td>no_access</td>
<td>与 <code>only_from</code> 差不多，规定不可登录的 IP 地址。</td>
</tr>
<tr>
<td>access_times</td>
<td>时间控制，设置服务启动的时间。</td>
</tr>
<tr>
<td>umask</td>
<td>设置 umask，如 <code>[000，777，022]</code>。</td>
</tr>
</tbody>
</table>
<h2 id="设置开机启动"><a class="markdownIt-Anchor" href="#设置开机启动"></a> 设置开机启动</h2>
<p>使用 <code>chkconfig</code> 命令设置服务的启动等级。例如查看目前被 <code>chkconfig</code> 管理的服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chkconfig</span> <span class="token parameter variable">--list</span>

netconsole      <span class="token number">0</span>:off   <span class="token number">1</span>:off   <span class="token number">2</span>:off   <span class="token number">3</span>:off   <span class="token number">4</span>:off   <span class="token number">5</span>:off   <span class="token number">6</span>:off
network         <span class="token number">0</span>:off   <span class="token number">1</span>:off   <span class="token number">2</span>:on    <span class="token number">3</span>:on    <span class="token number">4</span>:on    <span class="token number">5</span>:on    <span class="token number">6</span>:off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有 super daemon 管理的服务会分别显示在不同的运行级别下：0~6 代表不同运行级别下的启动状态。其中，3 代表命令行界面，5 代表图形界面。</p>
<p>例如要开启 <code>httpd</code> 在运行级别 3 下自动启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chkconfig</span> httpd on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要加入自定义的启动脚本（已经存在于 <code>/etc/init.d/</code> 目录下），可以使用 <code>--add</code> 参数。同样，使用 <code>--del</code> 参数可以删除服务的启动脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chkconfig</span> <span class="token parameter variable">--add</span> myservice<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此外，也可以使用 <code>ntsysv</code> 命令来设置管理服务的开机启动。</p>
<h1 id="systemd-服务管理"><a class="markdownIt-Anchor" href="#systemd-服务管理"></a> Systemd 服务管理</h1>
<p>自从 CentOS 7 之后，服务管理机制由 init 脚本管理改为 systemd 启动服务管理。</p>
<h2 id="systemd-的特性"><a class="markdownIt-Anchor" href="#systemd-的特性"></a> Systemd 的特性</h2>
<ul>
<li>
<p><strong>平行处理模式</strong></p>
<p>旧的 init 启动脚本是线性模式，只能单任务处理。systemd 可以让所有服务同时启动，更好利用多核心架构。</p>
</li>
<li>
<p><strong>单命令控制</strong></p>
<p>只需要一个 <code>systemctl</code> 命令来处理事务。此外，由于 systemd 常驻内存，因此任何要求（On-Demand）都会立刻处理。</p>
</li>
<li>
<p><strong>自动处理服务依赖</strong></p>
<p>由于 systemd 可以设置服务依赖检查，因此启动服务时，能自动启用相依赖服务。</p>
</li>
<li>
<p><strong>依服务功能分类</strong></p>
<p>systemd 把服务定义为服务单元（Unit），并归类到不同的服务类型（Type）中。旧的 init 仅能分为 stand alone 和 super daemon 两种，而 systemd 可以分为 service、socket、target 等多种不同类型，方便记忆和管理。</p>
</li>
<li>
<p><strong>可设置群组</strong></p>
<p>systemd 可将许多功能合为一个 Target 项目，也就是集合有相同目标的服务到一个群组，通过群组统一执行。</p>
</li>
<li>
<p><strong>向下兼容 init 服务脚本</strong></p>
<p>systemd 可以兼容旧的 init 启动脚本，并通过 systemd 来管理。</p>
</li>
</ul>
<h2 id="systemd-与-init-的区别"><a class="markdownIt-Anchor" href="#systemd-与-init-的区别"></a> Systemd 与 Init 的区别</h2>
<p>Systemd 与 Init 的区别主要有下面这些：</p>
<ul>
<li>在 run level 对应上，只有 1、3、5 对应到 systemd 的某些 target 类型，没有全部对应；</li>
<li><code>systemctl</code> 支持的语法有限，没有 init 纯脚本自由；</li>
<li>没通过 <code>systemctl</code> 来启动的服务，systemd 管理不了；</li>
<li>systemd 启动过程中不接受 stdin 传参。也就是不能与用户互动。</li>
</ul>
<h2 id="systemd-的-unit-类型"><a class="markdownIt-Anchor" href="#systemd-的-unit-类型"></a> Systemd 的 Unit 类型</h2>
<p><code>/usr/lib/systemd/system/</code> 下的数据可根据扩展名来区分不同的 Unit 类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ ll /usr/lib/systemd/system/ <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'(vsftpd|multi|cron)'</span>
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">318</span> Aug  <span class="token number">8</span>  <span class="token number">2019</span> crond.service
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">492</span> Feb  <span class="token number">2</span>  <span class="token number">2021</span> multi-user.target
drwxr-xr-x. <span class="token number">2</span> root root  <span class="token number">258</span> Sep  <span class="token number">7</span> 05:54 multi-user.target.wants
lrwxrwxrwx. <span class="token number">1</span> root root   <span class="token number">17</span> Sep  <span class="token number">7</span> 05:53 runlevel2.target -<span class="token operator">></span> multi-user.target
lrwxrwxrwx. <span class="token number">1</span> root root   <span class="token number">17</span> Sep  <span class="token number">7</span> 05:53 runlevel3.target -<span class="token operator">></span> multi-user.target
lrwxrwxrwx. <span class="token number">1</span> root root   <span class="token number">17</span> Sep  <span class="token number">7</span> 05:53 runlevel4.target -<span class="token operator">></span> multi-user.target
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">171</span> Jun  <span class="token number">9</span> <span class="token number">12</span>:15 vsftpd.service
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">184</span> Jun  <span class="token number">9</span> <span class="token number">12</span>:15 vsftpd@.service
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">89</span> Jun  <span class="token number">9</span> <span class="token number">12</span>:15 vsftpd.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上例，其中 vsftpd 和 crond 是服务（service），而 multi-user 是 target 类型。</p>
<p>常见的类型有下面这些：</p>
<ul>
<li>
<p><strong>一般服务类型</strong>（.service）</p>
<p>主要是系统服务及网络服务，最常见的类型。</p>
</li>
<li>
<p><strong>套接字服务</strong>（.socket）</p>
<p>主要是 IPC（Inter-process communication）的传输信息插槽档（socket file）功能。这种类型的服务通常用在监控信息传递，当有通过此 socket 请求时，将请求发送给对应服务。若服务未启动，则先启动后再传送请求。使用 socket 类型的服务一般不常用，因此开机时通常会稍微延迟启动。一般用于本机服务较多，例如图形界面很多软件都是通过 socket 来通信。</p>
</li>
<li>
<p><strong>执行环境类型</strong>（.target）</p>
<p>其实是一群 unit 的集合。例如图形模式、救援模式等。</p>
</li>
<li>
<p><strong>文件系统挂载服务</strong>（.mount/.automount）</p>
<p>例如网络 NFS 文件系统挂载等。</p>
</li>
<li>
<p><strong>文件监控类型或目录类型</strong>（.path）</p>
<p>某些服务需要监控特定目录来提供队列服务，例如最常见的打印服务。</p>
</li>
<li>
<p><strong>循环执行的服务</strong>（.timer）</p>
<p>有点类似 anacrontab，不过由 systemd 管理更具弹性。</p>
</li>
</ul>
<h1 id="systemctl-命令"><a class="markdownIt-Anchor" href="#systemctl-命令"></a> Systemctl 命令</h1>
<p>依据 Unit 类型的不同，systemctl 管理方式有点不同。</p>
<h2 id="查询-unit"><a class="markdownIt-Anchor" href="#查询-unit"></a> 查询 Unit</h2>
<p>可以使用 <code>systemctl list-units</code> 命令来查询 unit 或文件。</p>
<p>查询运行中的 unit，默认使用 <code>list-units</code>。如果要查询所有 unit，可以使用 <code>--all</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl <span class="token parameter variable">--all</span>
  UNIT                                     LOAD   ACTIVE SUB       DESCRIPTION
  ext333.mount                             loaded active mounted   /ext333
  NetworkManager.service                   loaded active running   Network Manager
  network.target                           loaded active active    Network
LOAD   <span class="token operator">=</span> Reflects whether the unit definition was properly loaded.
ACTIVE <span class="token operator">=</span> The high-level unit activation state, i.e. generalization of SUB.
SUB    <span class="token operator">=</span> The low-level unit activation state, values depend on unit type.

<span class="token number">135</span> loaded <span class="token function">units</span> listed. Pass <span class="token parameter variable">--all</span> to see loaded but inactive units, too.
To show all installed unit files use <span class="token string">'systemctl list-unit-files'</span><span class="token builtin class-name">.</span>
lines <span class="token number">118</span>-143/143 <span class="token punctuation">(</span>END<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，UNIT 是项目名，LOAD 表示开机时是否会被载入，ACTIVE 和 SUB 是运行状态。</p>
<p>例如，查询所有 socket 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl list-sockets
LISTEN                      UNIT                         ACTIVATES
/dev/log                    systemd-journald.socket      systemd-journald.service
/run/dbus/system_bus_socket dbus.socket                  dbus.service

<span class="token number">13</span> sockets listed.
Pass <span class="token parameter variable">--all</span> to see loaded but inactive sockets, too.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出所有已安装的 unit，使用 <code>list-unit-files</code> 查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl list-unit-files
UNIT FILE                                     STATE   
proc-sys-fs-binfmt_misc.automount             static  
dev-hugepages.mount                           static  
dev-mqueue.mount                              static <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要仅查询与 httpd 相关的启动服务，可以使用 <code>--type</code> 指定类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl <span class="token parameter variable">--type</span><span class="token operator">=</span>service <span class="token parameter variable">--all</span> <span class="token operator">|</span> <span class="token function">grep</span> httpd
  httpd.service                       loaded    active   running The Apache HTTP Server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="管理-service-unit"><a class="markdownIt-Anchor" href="#管理-service-unit"></a> 管理 Service Unit</h2>
<p>systemctl 管理 service 时主要命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>立即启动服务</td>
</tr>
<tr>
<td>stop</td>
<td>立即关闭服务</td>
</tr>
<tr>
<td>restart</td>
<td>立即重启服务</td>
</tr>
<tr>
<td>reload</td>
<td>不关闭服务情况下，重新载入配置文件，让配置生效</td>
</tr>
<tr>
<td>enable</td>
<td>设置开机启动</td>
</tr>
<tr>
<td>disable</td>
<td>取消开机启动</td>
</tr>
<tr>
<td>status</td>
<td>查看服务运行状态</td>
</tr>
<tr>
<td>is-active</td>
<td>服务有没有处于活动状态</td>
</tr>
<tr>
<td>is-enable</td>
<td>服务有没有开机启动</td>
</tr>
<tr>
<td>mask</td>
<td>注销服务</td>
</tr>
<tr>
<td>unmask</td>
<td>取消注销</td>
</tr>
</tbody>
</table>
<p>例如查看 atd 服务的状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span><span class="token comment"># systemctl status atd.service</span>
● atd.service - Job spooling tools
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/atd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Tue <span class="token number">2023</span>-05-02 02:06:10 UTC<span class="token punctuation">;</span> 21min ago
     Docs: man:atd<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
 Main PID: <span class="token number">1913</span> <span class="token punctuation">(</span>atd<span class="token punctuation">)</span>
    Tasks: <span class="token number">1</span> <span class="token punctuation">(</span>limit: <span class="token number">32768</span><span class="token punctuation">)</span>
   Memory: <span class="token number">824</span>.0K
   CGroup: /system.slice/atd.service
           └─1913 /usr/sbin/atd <span class="token parameter variable">-f</span>

May 02 02:06:10 101c7 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Started Job spooling tools.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键信息有：</p>
<ul>
<li><strong>Loaded</strong>：<code>enabled</code> 代表开机启动，<code>disabled</code> 为不启动，<code>static</code> 为需要别的服务唤醒，<code>masked</code> 代表无法设置启动。</li>
<li><strong>Active</strong>：unit 的状态，正在运行（<code>running</code>）或是没有运行（<code>dead</code>）。</li>
<li><strong>日志</strong>：最下面是日志信息，格式为：<code>时间 信息发出的主机 信息发出的服务 信息内容</code>。</li>
</ul>
<p>使用 stop 正常关闭 atd 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl stop atd.service
<span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl status atd.service
â— atd.service - Job spooling tools
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/atd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: inactive <span class="token punctuation">(</span>dead<span class="token punctuation">)</span> since Sat <span class="token number">2021</span>-09-18 <span class="token number">13</span>:06:56 EDT<span class="token punctuation">;</span> 1s ago
  Process: <span class="token number">27679</span> <span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/sbin/atd <span class="token parameter variable">-f</span> <span class="token variable">$OPTS</span> <span class="token punctuation">(</span>code<span class="token operator">=</span>exited, <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">0</span>/SUCCESS<span class="token punctuation">)</span>
 Main PID: <span class="token number">27679</span> <span class="token punctuation">(</span>code<span class="token operator">=</span>exited, <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token number">0</span>/SUCCESS<span class="token punctuation">)</span>

Sep <span class="token number">18</span> <span class="token number">13</span>:06:56 101c7 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Stopping Job spooling tools<span class="token punctuation">..</span>.
Sep <span class="token number">18</span> <span class="token number">13</span>:06:56 101c7 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Stopped Job spooling tools.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用 kill 来关闭服务，systemd 会无法继续监控服务。</p>
<p>常见运行状态：</p>
<ul>
<li><strong>active (running)</strong>：此时服务有一或多个进程正在运行。</li>
<li><strong>active (exited)</strong>：单次执行的服务，目前没有在运行。</li>
<li><strong>active (waiting)</strong>：等待队列执行中。</li>
<li><strong>inactive</strong>：服务没有运行。</li>
</ul>
<p>给 chronyd 设置开机启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> chronyd
Created symlink from /etc/systemd/system/multi-user.target.wants/chronyd.service to /usr/lib/systemd/system/chronyd.service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从返回信息看，其实就是在 <code>/etc/systemd/system/multi-user.target.wants/</code> 下面新建了一个链接。</p>
<h2 id="管理-target-unit"><a class="markdownIt-Anchor" href="#管理-target-unit"></a> 管理 Target Unit</h2>
<p>systemctl 管理 target 时主要命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>get-default</td>
<td>取得目前的 target</td>
</tr>
<tr>
<td>set-default</td>
<td>设置默认 target</td>
</tr>
<tr>
<td>isolate</td>
<td>切换模式</td>
</tr>
<tr>
<td>poweroff/reboot</td>
<td>关机/重启</td>
</tr>
<tr>
<td>suspend/hibernate</td>
<td>进入暂停/休眠模式</td>
</tr>
<tr>
<td>rescue/emergency</td>
<td>进入救援/紧急模式</td>
</tr>
</tbody>
</table>
<p>首先查询系统中的所有 target：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl <span class="token parameter variable">--type</span><span class="token operator">=</span>target <span class="token parameter variable">--all</span>
  UNIT                      LOAD      ACTIVE   SUB    DESCRIPTION
  basic.target              loaded    active   active Basic System
  bluetooth.target          loaded    active   active Bluetooth

LOAD   <span class="token operator">=</span> Reflects whether the unit definition was properly loaded.
ACTIVE <span class="token operator">=</span> The high-level unit activation state, i.e. generalization of SUB.
SUB    <span class="token operator">=</span> The low-level unit activation state, values depend on unit type.

<span class="token number">35</span> loaded <span class="token function">units</span> listed.
To show all installed unit files use <span class="token string">'systemctl list-unit-files'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示有 35 个 target，常见的 target 有以下几个：</p>
<ul>
<li>graphical.target：文本加图形界面，包含了 multi-user.target。</li>
<li>multi-user.target：纯文本模式。</li>
<li>rescue.target：救援模式。</li>
<li>emergency.target：无法使用救援模式时，可以进入紧急处理模式。</li>
<li>shutdown.target：关机流程。</li>
<li>getty.target：和 tty 有关。</li>
</ul>
<p>例如要切换到图形界面模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl get-default
multi-user.target
<span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ systemctl isolate graphical.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="查询服务依赖"><a class="markdownIt-Anchor" href="#查询服务依赖"></a> 查询服务依赖</h2>
<p>可以使用命令 <code>list-dependencies</code> 来查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl list-dependencies
default.target
● ├─atd.service
● ├─auditd.service
● ├─chronyd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反向查询服务被依赖情况可以用 <code>--reverse</code> 参数。例如查询 <code>sshd</code> 服务被依赖目标：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl list-dependencies sshd.service <span class="token parameter variable">--reverse</span>
sshd.service
● └─multi-user.target
●   └─graphical.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="systemctl-配置"><a class="markdownIt-Anchor" href="#systemctl-配置"></a> Systemctl 配置</h1>
<p>系统服务的开机启动配置位于<code>/etc/systemd/system</code>目录下。如果要修改服务的实际脚本，则应该将其放置在<code>/usr/lib/systemd/system/</code>目录下。</p>
<h2 id="systemd-配置目录"><a class="markdownIt-Anchor" href="#systemd-配置目录"></a> Systemd 配置目录</h2>
<p>systemd 将每种服务依据功能放置在不同目录:</p>
<ul>
<li>
<p><strong>/usr/lib/systemd/system/</strong>：包含每个服务的主要启动脚本设置，类似于<code>/etc/init.d</code>。</p>
</li>
<li>
<p><strong>/run/systemd/system/</strong>：包含系统在运行过程中所生成的服务脚本，优先级高于<code>/usr/lib/systemd/system</code>。</p>
</li>
<li>
<p><strong>/etc/systemd/system/</strong>：包含用户创建的服务执行脚本，类似于<code>/etc/rc.d/rc5.d/Sxx</code>，执行优先级最高。</p>
</li>
<li>
<p><strong>/etc/sysconfig/</strong>：包含服务初始化时的一些参数配置。</p>
</li>
<li>
<p><strong>/var/lib/</strong>：包含服务产生的数据默认存储目录。</p>
</li>
<li>
<p><strong>/run/</strong>：用于放置临时文件，包括锁文件、PID 文件等。</p>
</li>
</ul>
<h2 id="systemctl-配置文件"><a class="markdownIt-Anchor" href="#systemctl-配置文件"></a> Systemctl 配置文件</h2>
<p>以下是以 sshd 服务的配置文件为例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /usr/lib/systemd/system/sshd.service 
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>OpenSSH server daemon
<span class="token assign-left variable">Documentation</span><span class="token operator">=</span>man:sshd<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> man:sshd_config<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token assign-left variable">After</span><span class="token operator">=</span>network.target sshd-keygen.service
<span class="token assign-left variable">Wants</span><span class="token operator">=</span>sshd-keygen.service

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>notify
<span class="token assign-left variable">EnvironmentFile</span><span class="token operator">=</span>/etc/sysconfig/sshd
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/sbin/sshd <span class="token parameter variable">-D</span> <span class="token variable">$OPTIONS</span>
<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill <span class="token parameter variable">-HUP</span> <span class="token variable">$MAINPID</span>
<span class="token assign-left variable">KillMode</span><span class="token operator">=</span>process
<span class="token assign-left variable">Restart</span><span class="token operator">=</span>on-failure
<span class="token assign-left variable">RestartSec</span><span class="token operator">=</span>42s

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件分为三段:</p>
<ul>
<li>
<p><strong>[Unit]</strong>：Unit 定义描述文字，文档位置，服务依赖关系等设置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>使用 <code>systemctl status</code> 查询时显示在第一行的描述</td>
</tr>
<tr>
<td>Documentation</td>
<td>提供的服务配套文档配置</td>
</tr>
<tr>
<td>After</td>
<td>说明此 Unit 的前导启动服务，没有强制约束</td>
</tr>
<tr>
<td>Before</td>
<td>说明此 Unit 的被依赖服务，同样没有强制约束力</td>
</tr>
<tr>
<td>Requires</td>
<td>定义此 Unit 的依赖服务，如果依赖服务没启动，此 Unit 也无法启动</td>
</tr>
<tr>
<td>Wants</td>
<td>定义在此 Unit 后启动的服务，没有明确规范</td>
</tr>
<tr>
<td>Conflicts</td>
<td>冲突性检查，代表和此 Unit 有冲突的服务</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>[Service]</strong>：这段也有可能是 [Socket]、[Path]、[Timer] 等，根据 Unit 类型决定。规范了配置文件路径、启动参数等。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>说明服务启动方式，有下面几种类型<br />simple：默认值，服务由 ExecStart 启动，启动后常驻内存<br />forking：通过 spawns 衍生出其他子程序作为主要服务，父程序随后终止<br />oneshot：只用跑一次的程序，不会常驻内存<br />dbus：服务必须取一个 D-Bus 名称<br />idle：在系统空闲时才运行</td>
</tr>
<tr>
<td>EnvironmentFile</td>
<td>指定启动脚本的环境配置文件</td>
</tr>
<tr>
<td>ExecStart</td>
<td>启动服务运行的命令或脚本</td>
</tr>
<tr>
<td>ExecStop</td>
<td>关闭服务运行的命令</td>
</tr>
<tr>
<td>ExecReload</td>
<td>重载服务运行的命令</td>
</tr>
<tr>
<td>Restart</td>
<td>设置服务自动重启参数，假如设为 1 则表示总会重启，只能用 <code>systemctl</code> 来停止</td>
</tr>
<tr>
<td>RemainAfterExit</td>
<td>设为 1 时，当服务所属的所有程序都停止后再次尝试启动</td>
</tr>
<tr>
<td>TimeoutSec</td>
<td>服务启动或关闭时等待的超时时间，时间一到会强制结束进程</td>
</tr>
<tr>
<td>KillMode</td>
<td>process 表示终止服务时只结束主程序，control-group 则是一同结束关联进程</td>
</tr>
<tr>
<td>RestartSec</td>
<td>重启服务前等待的时间</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>[Install]</strong>：指定此 unit 安装的 target</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WantedBy</td>
<td>后面大多接 target unit，就是说此 unit 属于哪个 target 环境</td>
</tr>
<tr>
<td>Also</td>
<td>此 Unit 被设为开机启动时，其他一同要设为开机启动的 Unit</td>
</tr>
<tr>
<td>Alias</td>
<td>设置一个链接别名</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>如果要将备份脚本 <code>backup.sh</code> 设置为 service 用 <code>systemctl</code> 来管理，可以新建一个简单的配置文件，例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/systemd/system/backup.service
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>backup my <span class="token function">dir</span>
<span class="token assign-left variable">Requires</span><span class="token operator">=</span>atd.service

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>simple
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/bin/bash <span class="token parameter variable">-c</span> <span class="token string">"echo /root/backup.sh | at now"</span>

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
<span class="token string">"/etc/systemd/system/backup.service"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 10L, 170C written
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl start backup
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl status backup
● backup.service - backup my <span class="token function">dir</span>
   Loaded: loaded <span class="token punctuation">(</span>/etc/systemd/system/backup.service<span class="token punctuation">;</span> disabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>
   Active: inactive <span class="token punctuation">(</span>dead<span class="token punctuation">)</span>

Sep <span class="token number">19</span> 01:00:34 101c7 systemd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Started backup my dir.
Sep <span class="token number">19</span> 01:00:34 101c7 bash<span class="token punctuation">[</span><span class="token number">9147</span><span class="token punctuation">]</span>: job <span class="token number">10</span> at Sun Sep <span class="token number">19</span> 01:00:00 <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="重复配置方式"><a class="markdownIt-Anchor" href="#重复配置方式"></a> 重复配置方式</h2>
<p>有一些服务名带有@符号代表启动多重的重复设置，目的是简化多个执行的启动设置。例如 <code>getty@.service</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /usr/lib/systemd/system/getty@.service
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>Getty on %I
<span class="token assign-left variable">Documentation</span><span class="token operator">=</span>man:agetty<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> man:systemd-getty-generator<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token assign-left variable">Documentation</span><span class="token operator">=</span>http://0pointer.de/blog/projects/serial-console.html
<span class="token assign-left variable">After</span><span class="token operator">=</span>systemd-user-sessions.service plymouth-quit-wait.service getty-pre.target
<span class="token assign-left variable">After</span><span class="token operator">=</span>rc-local.service
<span class="token assign-left variable">Before</span><span class="token operator">=</span>getty.target
<span class="token assign-left variable">IgnoreOnIsolate</span><span class="token operator">=</span>yes
<span class="token assign-left variable">ConditionPathExists</span><span class="token operator">=</span>/dev/tty0

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>-/sbin/agetty <span class="token parameter variable">--noclear</span> %I <span class="token environment constant">$TERM</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>idle
<span class="token assign-left variable">Restart</span><span class="token operator">=</span>always
<span class="token assign-left variable">RestartSec</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">UtmpIdentifier</span><span class="token operator">=</span>%I
<span class="token assign-left variable">TTYPath</span><span class="token operator">=</span>/dev/%I
<span class="token assign-left variable">TTYReset</span><span class="token operator">=</span>yes
<span class="token assign-left variable">TTYVHangup</span><span class="token operator">=</span>yes
<span class="token assign-left variable">TTYVTDisallocate</span><span class="token operator">=</span>yes
<span class="token assign-left variable">KillMode</span><span class="token operator">=</span>process
<span class="token assign-left variable">IgnoreSIGPIPE</span><span class="token operator">=</span>no
<span class="token assign-left variable">SendSIGHUP</span><span class="token operator">=</span>yes
<span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token environment constant">LANG</span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LANGUAGE</span></span><span class="token operator">=</span> <span class="token assign-left variable">LC_CTYPE</span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_NUMERIC</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_TIME</span></span><span class="token operator">=</span> <span class="token assign-left variable">LC_COLLATE</span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_MONETARY</span></span><span class="token operator">=</span> <span class="token assign-left variable">LC_MESSAGES</span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_PAPER</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_NAME</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_ADDRESS</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_TELEPHONE</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_MEASUREMENT</span></span><span class="token operator">=</span> <span class="token assign-left variable"><span class="token environment constant">LC_IDENTIFICATION</span></span><span class="token operator">=</span>

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>getty.target
<span class="token assign-left variable">DefaultInstance</span><span class="token operator">=</span>tty1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ExecStart</code> 指定的启动命令 <code>agetty --noclear %I</code> 中 <code>%I</code> 指代范例名称，这里等于 <code>tty1</code>。具体在 <code>getty.target</code> 里有定义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl show getty.target
<span class="token assign-left variable">Id</span><span class="token operator">=</span>getty.target
<span class="token assign-left variable">Names</span><span class="token operator">=</span>getty.target
<span class="token assign-left variable">Wants</span><span class="token operator">=</span>getty@tty1.service
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
<span class="token assign-left variable">Conflicts</span><span class="token operator">=</span>shutdown.target
<span class="token assign-left variable">Before</span><span class="token operator">=</span>multi-user.target
<span class="token assign-left variable">After</span><span class="token operator">=</span>getty@tty1.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当执行完 <code>getty.target</code> 后，会持续要求 <code>getty@tty1.service</code> 服务启动，由于 <code>/usr/lib/systemd/system</code> 和 <code>/etc/systemd/system</code> 中没有 <code>getty@tty1.service</code> 存在，systemd 则找到 <code>getty@.service</code> 设置，将 @ 后面的数据带入成 <code>%I</code> 的变量。</p>
<p>当然也可以手动指定 @ 后面的参数来启动服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl start getty@tty9.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="timer-类型配置文件"><a class="markdownIt-Anchor" href="#timer-类型配置文件"></a> timer 类型配置文件</h2>
<p>我们可以利用 <code>systemd</code> 来设置定时任务，比起用 <code>crond</code> 设置来说，多了日志记录功能，并且可以和其他服务相结合。</p>
<p>想要使用 <code>timer</code> 的功能必须：</p>
<ul>
<li>系统的 <code>timer.target</code> 一定要启动；</li>
<li>要有个自定义 <code>.service</code> 服务存在；</li>
<li>要有个自定义 <code>.timer</code> 的时间启动服务存在。</li>
</ul>
<p>一个 <code>timer</code> 类配置主要用到 <code>[Timer]</code> 段，可用的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OnActiveSec</code></td>
<td>当 <code>timers.target</code> 启动多久后执行此 <code>Unit</code></td>
</tr>
<tr>
<td><code>OnBootSec</code></td>
<td>当开机后多久执行</td>
</tr>
<tr>
<td><code>OnStartupSec</code></td>
<td>当 <code>systemd</code> 第一次启动后多久执行</td>
</tr>
<tr>
<td><code>OnUnitActiveSec</code></td>
<td><code>Unit</code> 服务最后一次启动后，隔多久再执行一次</td>
</tr>
<tr>
<td><code>OnUnitInactiveSec</code></td>
<td><code>Unit</code> 服务最后一次停止后，隔多久再执行一次</td>
</tr>
<tr>
<td><code>OnCalendar</code></td>
<td>使用实际时间的方式启动服务</td>
</tr>
<tr>
<td><code>Unit</code></td>
<td>一般不需要设置，只有在 <code>.timer</code> 文件和 <code>.service</code> 文件名不一致时用到</td>
</tr>
<tr>
<td><code>Persistent</code></td>
<td>当使用 <code>OnCalendar</code> 设置时，指定该功能要不要持续进行。通常为 <code>yes</code></td>
</tr>
</tbody>
</table>
<p>时间设置可以使用间隔时间，例如隔 3 小时（<code>3h</code>），隔 5 天又 300 分钟（<code>300m 5day</code>）。也可以使用实际时间格式：</p>
<table>
<thead>
<tr>
<th>英语口语</th>
<th>实际时间格式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>now</code></td>
<td><code>Wed 2020-09-09 15:43:05</code></td>
</tr>
<tr>
<td><code>today</code></td>
<td><code>Wed 2020-09-09 00:00:00</code></td>
</tr>
<tr>
<td><code>tomorrow</code></td>
<td><code>Thu 2020-09-10 00:00:00</code></td>
</tr>
<tr>
<td><code>hourly</code></td>
<td><code>--:00:00</code></td>
</tr>
<tr>
<td><code>daily</code></td>
<td><code>--* 00:00:00</code></td>
</tr>
<tr>
<td><code>weekly</code></td>
<td><code>Mon --* 00:00:00</code></td>
</tr>
<tr>
<td><code>monthly</code></td>
<td><code>--01 00:00:00</code></td>
</tr>
<tr>
<td><code>+1h16m55s</code></td>
<td><code>Thu 2020-09-09 17:00:00</code></td>
</tr>
<tr>
<td><code>2020-09-11</code></td>
<td><code>Fri 2020-09-11 17:00:00</code></td>
</tr>
</tbody>
</table>
<p>例如设置一个<code>backup.timer</code>作用为开机后 1 小时执行，每 2 天执行一次：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/systemd/system/backup.timer
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>backup my <span class="token function">dir</span> timer

<span class="token punctuation">[</span>Timer<span class="token punctuation">]</span>
<span class="token assign-left variable">OnBootSec</span><span class="token operator">=</span>1h
<span class="token assign-left variable">OnUnitActivesec</span><span class="token operator">=</span>2d

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target

<span class="token string">"/etc/systemd/system/backup.timer"</span> <span class="token punctuation">[</span>New<span class="token punctuation">]</span> 9L, 118C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将<code>.timer</code>设置为开机启动，对应的<code>.service</code>可以不需要开机启动：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> backup.timer
Created symlink from /etc/systemd/system/multi-user.target.wants/backup.timer to /etc/systemd/system/backup.timer.
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl restart backup.timer
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl list-unit-files <span class="token operator">|</span> <span class="token function">grep</span> backup
backup.service                                disabled
backup.timer                                  enabled <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看一下这个 timer unit 的启动时间、<code>backup.service</code>上次执行时间和下次执行间隔时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl show timers.target <span class="token operator">|</span> <span class="token function">grep</span> ConditionTimestamp
<span class="token assign-left variable">ConditionTimestamp</span><span class="token operator">=</span>Sat <span class="token number">2021</span>-09-18 <span class="token number">23</span>:12:52 EDT
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl show backup.service <span class="token operator">|</span> <span class="token function">grep</span> ExecMainExitTimestamp
<span class="token assign-left variable">ExecMainExitTimestamp</span><span class="token operator">=</span>Sun <span class="token number">2021</span>-09-19 01:34:00 EDT
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl show backup.timer <span class="token operator">|</span> <span class="token function">grep</span> Next
<span class="token assign-left variable">NextElapseUSecRealtime</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">NextElapseUSecMonotonic</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>OnCalendar</code>实际时间设置为每周日 14:00 执行一次可以这样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/systemd/system/backup.timer
<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>backup my <span class="token function">dir</span> timer

<span class="token punctuation">[</span>Timer<span class="token punctuation">]</span>
<span class="token assign-left variable">OnCalendar</span><span class="token operator">=</span>Sun *-*-* <span class="token number">14</span>:00:00
<span class="token assign-left variable">Persistent</span><span class="token operator">=</span>true
<span class="token assign-left variable">Unit</span><span class="token operator">=</span>backup.service

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
~
<span class="token string">"/etc/systemd/system/backup.timer"</span> 10L, 152C written
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl restart backup.timer
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl show backup.timer <span class="token operator">|</span> <span class="token function">grep</span> Next
<span class="token assign-left variable">NextElapseUSecRealtime</span><span class="token operator">=</span>51y 8month 2w 4d 12h
<span class="token assign-left variable">NextElapseUSecMonotonic</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，<code>NextElapseUSecRealtime</code>时间是以 Unix 标准时间显示。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>SELinux 安全访问控制</title>
    <url>/1359563972/</url>
    <content><![CDATA[<hr />
<h1 id="selinux-介绍"><a class="markdownIt-Anchor" href="#selinux-介绍"></a> SELinux 介绍</h1>
<p><code>SELinux</code>（Security Enhanced Linux）是在进行程序、文件等权限设置依据的一个内核模块。</p>
<p>传统的权限管理方式称为自主访问控制，<code>SELinux</code>使用的是委托访问控制：</p>
<ul>
<li>
<p><strong>自主访问控制:</strong></p>
<p>自主访问控制（<code>DAC</code>，Discretionary Access Control）是依据进程的所有者与文件资源的<code>rwx</code>权限来决定文件的访问能力。</p>
<p><code>DAC</code>访问控制的缺陷：</p>
<ul>
<li><code>root</code>具有最高权限；</li>
<li>用户可以取得进程来更改文件资源的访问权限。</li>
</ul>
</li>
<li>
<p><strong>强制访问控制:</strong></p>
<p><code>SELinux</code>导入了强制访问控制（<code>MAC</code>，Mandatory Access Control）的方法。<code>MAC</code>可以针对特定的进程与特定的文件资源来进行权限控制，控制的主体变成了进程而不是用户。</p>
<p>此外这个主体进程也不能任意使用系统文件资源，因为每个文件资源也有针对该主体进程设置可取用的权限。</p>
<p>这样，可以控制的项目和策略组合非常多，因此 <code>SELinux</code> 也提供一些默认的策略，并在该策略内提供多个规则，以便用户可以选择是否启用该控制规则。</p>
</li>
</ul>
<h1 id="selinux-名词"><a class="markdownIt-Anchor" href="#selinux-名词"></a> SELinux 名词</h1>
<ul>
<li>
<p><strong>主体（Subject）</strong></p>
<p>SELinux 主要管理的就是进程。</p>
</li>
<li>
<p><strong>目标（Object）</strong></p>
<p>主体进程能否访问的目标资源一般就是文件系统。</p>
</li>
<li>
<p><strong>策略（Policy）</strong></p>
<p>由于进程与文件数量庞大，因此 SELinux 会依据某些服务来制订基本的访问安全性策略。目前提供三个主要的策略，分别是：</p>
<ul>
<li>targeted：针对网络服务限制较多，针对本机限制较少，是默认的策略。</li>
<li>minimum：由 targeted 修订而来，仅针对选择的程序来保护。</li>
<li>mls(strict)：完整的 SELinux 限制，限制方面较为严格。</li>
</ul>
</li>
<li>
<p><strong>安全上下文（Security Context）</strong></p>
<p>主体能不能访问目标除了策略指定之外，主体与目标的安全上下文必须一致才能够顺利访问。安全上下文有点类似文件系统的 rwx。安全上下文的内容与设置非常重要，如果设置错误某些服务就无法访问文件系统，出现权限不符的错误信息。</p>
<p>文件的安全上下文记录放置到文件的 inode 内。</p>
<p>使用 <code>ls -Z</code> 命令可以查看安全上下文：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span>
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 error.log
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 nomarl.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>安全上下文主要用冒号分为四个字段：身份识别，角色，类型，灵敏度。</p>
</li>
<li>
<p><strong>身份标识（Identify）</strong></p>
<p>相当于账号方面的身份标识，常见的有：</p>
<ul>
<li>unconfined_u：表示不受 SELinux 限制的用户，也就是说该文件来自不受限的程序产生。</li>
<li>system_u：表示系统程序方面的标识，通常是系统自己产生的文件。</li>
</ul>
<p>系统或网络服务产生的大部分数据是 system_u，用户通过 bash 创建的文件，大多是不受限的 unconfined_u 身份。</p>
</li>
<li>
<p><strong>角色（Role）</strong></p>
<p>通过角色字段，我们可以知道这个数据是属于程序，文件资源还是代表用户，常见的有：</p>
<ul>
<li>object_r：代表文件或目录；</li>
<li>system_r：代表进程，一般用户也会被指定为 system_r。</li>
</ul>
<p>角色字段最后面使用 _r 来结尾。</p>
</li>
<li>
<p><strong>类型（Type）</strong></p>
<p>在默认 targeted 策略中最重要的是类型字段，一个主体进程能不能读取到这个文件资源与类型字段有关。类型字段与文件与进程的定义不太相同，分别是：</p>
<ul>
<li>
<p>type：在文件资源（Object）上面称为类型（Type）；</p>
</li>
<li>
<p>domain：在主体程序（Subject）中则称为域（domain）；</p>
</li>
</ul>
<p>domain 需要与 type 搭配，程序才能够顺利读取文件资源。</p>
</li>
</ul>
<h1 id="类型-domain-与-type"><a class="markdownIt-Anchor" href="#类型-domain-与-type"></a> 类型 domain 与 type</h1>
<p>以 cron 程序举例看程序的域和文件的类型之间的关系.</p>
<p>先查询 cron 进程的安全上下文内容:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-eZ</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">cron</span>
system_u:system_r:crond_t:s0-s0:c0.c1023 <span class="token number">885</span> ?  00:00:02 crond
system_u:system_r:crond_t:s0-s0:c0.c1023 <span class="token number">27679</span> ? 00:00:00 atd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>cron 关联进程有两个,但它们的安全上下文一样:</p>
<ul>
<li>
<p>身份标识:角色为 system_u:system_r,说明 crond 和 atd 为系统进程.</p>
</li>
<li>
<p>最重要的安全上下文类型为 crond_t 域.</p>
</li>
</ul>
<p>再查询可执行文件 crond,crontab 和配置文件目录/etc/cron.d 的安全上下文:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Zd</span> /usr/sbin/crond /etc/crontab /etc/cron.d
-rwxr-xr-x. root root system_u:object_r:crond_exec_t:s0 /usr/sbin/crond
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 /etc/crontab
drwxr-xr-x. root root system_u:object_r:system_cron_spool_t:s0 /etc/cron.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>安全上下文详情如下:</p>
<ul>
<li>
<p>身份标识都是系统进程</p>
</li>
<li>
<p>配置目录/etc/cron.d 的类型为 system_cron_spool_t,</p>
</li>
<li>
<p>可执行文件 crond 的类型为 crond_exec_t,</p>
</li>
<li>
<p>可执行文件 crontab 的类型为 system_cron_spool_t.</p>
</li>
</ul>
<p>分析可得以下结论:</p>
<ul>
<li>
<p>当执行类型为 crond_exec_t 的二进制文件/usr/sbin/crond 后,这个程序产生类型为 crond_t 域的进程 crond.</p>
</li>
<li>
<p>而 crond_t 域类型进程能读取 system_cron_spool_t 类型的资源文件.</p>
</li>
<li>
<p>域与类型对应关系已经被定义好,所以如果类型设置错误,即使文件 rwx 权限全开程序也读不了目标资源.</p>
</li>
<li>
<p>最终能不能读取到正确数据,还要看 rwx 是否符合 Linux 权限的规范.</p>
</li>
</ul>
<h1 id="selinux-启动管理"><a class="markdownIt-Anchor" href="#selinux-启动管理"></a> SELinux 启动管理</h1>
<p>目前 SELinux 支持三种模式，分别是：</p>
<ul>
<li>enforcing：强制模式，代表 SELinux 正在运行中，且已经正确开始限制 domain/type 了。</li>
<li>permissive：宽容模式，代表 SELinux 正在运行中，不过仅有警告日志记录，并没有实际限制。这种模式可作调试用。</li>
<li>disabled：关闭。</li>
</ul>
<p>查询 SELinux 模式通过命令 <code>getenforce</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ getenforce
Enforcing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查询 SELinux 的策略使用 <code>sestatus</code> 来查看，支持参数为：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>检查列于 <code>/etc/sestatus.conf</code> 内的文件与程序的安全上下文内容</td>
</tr>
<tr>
<td>-b</td>
<td>将目前策略的规则布尔值列出，即某些规则是否启动</td>
</tr>
</tbody>
</table>
<p>列出目前的 SELinux 使用策略：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      <span class="token number">31</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SELinux 的配置文件是 <code>/etc/selinux/config</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/selinux/config 
<span class="token comment"># This file controls the state of SELinux on the system.</span>
<span class="token comment"># SELINUX= can take one of these three values:</span>
<span class="token comment">#     enforcing - SELinux security policy is enforced.</span>
<span class="token comment">#     permissive - SELinux prints warnings instead of enforcing.</span>
<span class="token comment">#     disabled - No SELinux policy is loaded.</span>
<span class="token assign-left variable">SELINUX</span><span class="token operator">=</span>enforcing
<span class="token comment"># SELINUXTYPE= can take one of three two values:</span>
<span class="token comment">#     targeted - Targeted processes are protected,</span>
<span class="token comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span>
<span class="token comment">#     mls - Multi Level Security protection.</span>
<span class="token assign-left variable">SELINUXTYPE</span><span class="token operator">=</span>targeted <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>里面设置了 SELinux 的模式与策略。如果改变策略或模式开关需要重启系统。</p>
<p>由 enforcing 变为 permissive 模式可以在系统运行时切换。</p>
<p>切换 SELinux 模式使用 <code>setenforce</code> 命令，0 为宽容模式，1 为强制模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ setenforce <span class="token number">0</span>
<span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ getenforce
Permissive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>有时从 disabled 切换成 enforcing 模式后，系统必须针对文件写入安全标签（SELinux Label），会有一堆服务无法启动，提示权限错误。可以在 Permissive 状态下使用 <code>restorecon -Rv /</code> 来重新还原 SELinux 的类型。</p>
<h1 id="selinux-规则统计"><a class="markdownIt-Anchor" href="#selinux-规则统计"></a> SELinux 规则统计</h1>
<p>查询规则启动状态可以使用 <code>sestatus -b</code> 或 <code>getsebool -a</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ sestatus <span class="token parameter variable">-b</span>
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      <span class="token number">31</span>

Policy booleans:
abrt_anon_write                             off
abrt_handle_event                           off
abrt_upload_watch_anon_write                on
antivirus_can_scan_system                   off
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ getsebool <span class="token parameter variable">-a</span>
abrt_anon_write --<span class="token operator">></span> off
abrt_handle_event --<span class="token operator">></span> off
abrt_upload_watch_anon_write --<span class="token operator">></span> on
antivirus_can_scan_system --<span class="token operator">></span> off
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要查询规则具体内容，需要安装 <code>setools</code> 工具套件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ yum <span class="token function">install</span> <span class="token parameter variable">-y</span> setools-console-*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>seinfo</code> 工具查询规则统计信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ seinfo

Statistics <span class="token keyword">for</span> policy file: /sys/fs/selinux/policy
Policy Version <span class="token operator">&amp;</span> Type: v.31 <span class="token punctuation">(</span>binary, mls<span class="token punctuation">)</span>

   Classes:           <span class="token number">130</span>    Permissions:       <span class="token number">272</span>
   Sensitivities:       <span class="token number">1</span>    Categories:       <span class="token number">1024</span>
   Types:            <span class="token number">4793</span>    Attributes:        <span class="token number">253</span>
   Users:               <span class="token number">8</span>    Roles:              <span class="token number">14</span>
   Booleans:          <span class="token number">316</span>    Cond. Expr.:       <span class="token number">362</span>
   Allow:          <span class="token number">107834</span>    Neverallow:          <span class="token number">0</span>
   Auditallow:        <span class="token number">158</span>    Dontaudit:       <span class="token number">10022</span>
   Type_trans:      <span class="token number">18153</span>    Type_change:        <span class="token number">74</span>
   Type_member:        <span class="token number">35</span>    Role allow:         <span class="token number">37</span>
   Role_trans:        <span class="token number">414</span>    Range_trans:      <span class="token number">5899</span>
   Constraints:       <span class="token number">143</span>    Validatetrans:       <span class="token number">0</span>
   Initial SIDs:       <span class="token number">27</span>    Fs_use:             <span class="token number">32</span>
   Genfscon:          <span class="token number">103</span>    Portcon:           <span class="token number">614</span>
   Netifcon:            <span class="token number">0</span>    Nodecon:             <span class="token number">0</span>
   Permissives:         <span class="token number">0</span>    Polcap:              <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到当前 v31 版本的规则（Booleans）总共有 316 条。此外 <code>seinfo</code> 加参数还可以查询其他种类信息：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–all</td>
<td>列出所有信息</td>
</tr>
<tr>
<td>-u</td>
<td>列出所有身份标识种类</td>
</tr>
<tr>
<td>-r</td>
<td>列出所有角色种类</td>
</tr>
<tr>
<td>-t</td>
<td>列出所有类别种类</td>
</tr>
<tr>
<td>-b</td>
<td>列出所有规则种类</td>
</tr>
</tbody>
</table>
<h1 id="selinux-规则查询"><a class="markdownIt-Anchor" href="#selinux-规则查询"></a> SELinux 规则查询</h1>
<p>使用 <code>sesearch</code> 命令可以用来搜索规则。命令语法：<code>sesearch [-A] [-s 主体程序类型] [-t 目标类别] [-b 规则]</code></p>
<p>主要参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>列出后面的数据中，允许&quot;读取或放行&quot;的相关数据</td>
</tr>
<tr>
<td>-s</td>
<td>后面接域类型，例如 -s httpd_t</td>
</tr>
<tr>
<td>-t</td>
<td>后面接类别，例如 -t user_home_dir_t</td>
</tr>
<tr>
<td>-b</td>
<td>后面接 SELinux 规则，如 -b httpd_enable_ftp_server</td>
</tr>
</tbody>
</table>
<p>例如找出 <code>crond_t</code> 这个域类型的进程能够读取的文件类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ sesearch <span class="token parameter variable">-A</span> <span class="token parameter variable">-s</span> crond_t <span class="token operator">|</span> <span class="token function">grep</span> spool
   allow crond_t system_cron_spool_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> getattr lock search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow crond_t var_spool_t <span class="token builtin class-name">:</span> <span class="token function">file</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> getattr lock <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow daemon user_cron_spool_t <span class="token builtin class-name">:</span> <span class="token function">file</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> <span class="token function">write</span> getattr lock append <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>allow</code> 后面接进程域类型和文件类型，冒号后表明资源类型，大括号 {} 内为允许的动作。</p>
<p>例如第一条表示允许 <code>crond_t</code> 域类型进程对 <code>system_cron_spool_t</code> 类型的文件夹读取，打开，查看属性等操作。</p>
<p>再使用 <code>semanage</code> 查一下 <code>httpd_enable_homedirs</code> 这条规则的含义：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ semanage boolean <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> httpd_enable_homedirs
SELinux boolean                State  Default Description
httpd_enable_homedirs          <span class="token punctuation">(</span>off  ,  off<span class="token punctuation">)</span>  Allow httpd to <span class="token builtin class-name">enable</span> homedirs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 description 一列介绍了规则内容是允许 httpd 程序去读取使用者主文件夹。</p>
<p>再使用 <code>sesearch</code> 来搜索 <code>httpd_enable_homedirs</code> 规则里面具体规定：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ sesearch <span class="token parameter variable">-A</span> <span class="token parameter variable">-b</span> httpd_enable_homedirs
Found <span class="token number">77</span> semantic av rules:
   allow httpd_t user_home_dir_t <span class="token builtin class-name">:</span> lnk_file <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_suexec_t user_home_dir_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> getattr search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_t nfs_t <span class="token builtin class-name">:</span> lnk_file <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_sys_script_t nfs_t <span class="token builtin class-name">:</span> <span class="token function">file</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> geta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>共有 77 条相关规定，如果规则没有启用，<code>httpd_t</code> 域类型进程就无法读取使用者主文件夹。这是由 <code>sestatus</code> 查到的 Policy deny_unknown status 设置规定默认抵挡未知的主题程序。</p>
<h1 id="selinux-规则开闭"><a class="markdownIt-Anchor" href="#selinux-规则开闭"></a> SELinux 规则开闭</h1>
<p>当确认要关闭或开启某条规则可以使用 <code>setsebool</code> 来管理。例如启动 <code>httpd_enable_homedirs</code> 规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ getsebool httpd_enable_homedirs
httpd_enable_homedirs --<span class="token operator">></span> off
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ setsebool <span class="token parameter variable">-P</span> httpd_enable_homedirs <span class="token number">1</span>
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ getsebool httpd_enable_homedirs
httpd_enable_homedirs --<span class="token operator">></span> on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="安全上下文修改"><a class="markdownIt-Anchor" href="#安全上下文修改"></a> 安全上下文修改</h1>
<p>修改文件的安全上下文可以使用 <code>chcon</code> 命令。命令格式：<code>chcon [-R] [-t type] [-u user] [-r role] 文件</code></p>
<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-R</td>
<td>递归修改目录</td>
</tr>
<tr>
<td>-t</td>
<td>接安全上下文的类型字段，如 <code>thhpd_sys_content_t</code></td>
</tr>
<tr>
<td>-u</td>
<td>接身份识别</td>
</tr>
<tr>
<td>-r</td>
<td>接角色</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细结果</td>
</tr>
<tr>
<td>–reference=参考文件</td>
<td>用参考文件作为范例修改目标文件的安全上下文</td>
</tr>
</tbody>
</table>
<p>例如修改 <code>1.txt</code> 文件的安全上下文类型为 <code>net_conf_t</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">-v</span> <span class="token parameter variable">-t</span> net_conf_t <span class="token number">1</span>.txt
changing security context of â€˜1.txtâ€™
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span> <span class="token number">1</span>.txt 
-rw-r--r--. root root unconfined_u:object_r:net_conf_t:s0 <span class="token number">1</span>.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一种修改方式，例如将 <code>/etc/shadow</code> 的安全上下文套用到 <code>1.txt</code> 文件上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ chcon <span class="token parameter variable">-v</span> <span class="token parameter variable">--reference</span><span class="token operator">=</span>/etc/shadow <span class="token number">1</span>.txt
changing security context of â€˜1.txtâ€™
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span> /etc/shadow <span class="token number">1</span>.txt 
-rw-r--r--. root root system_u:object_r:shadow_t:s0    <span class="token number">1</span>.txt
----------. root root system_u:object_r:shadow_t:s0    /etc/shadow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="安全上下文恢复"><a class="markdownIt-Anchor" href="#安全上下文恢复"></a> 安全上下文恢复</h1>
<p>如果想要将目录的安全上下文类型错误恢复到默认值，可以使用 <code>restorecon</code> 命令。</p>
<p><code>restorecon</code> 命令可用 <code>-R</code> 来递归修改目录，例如恢复 <code>/etc/cron.d/</code> 下面的文件安全上下文类型为默认值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ <span class="token function">mv</span> <span class="token number">1</span>.txt /etc/cron.d/ <span class="token punctuation">;</span> ll <span class="token parameter variable">-Z</span> /etc/cron.d/
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 0hourly
-rw-r--r--. root root system_u:object_r:shadow_t:s0    <span class="token number">1</span>.txt
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 raid-check
<span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ restorecon <span class="token parameter variable">-Rv</span> /etc/cron.d <span class="token punctuation">;</span> ll <span class="token parameter variable">-Z</span> /etc/cron.d/
restorecon reset /etc/cron.d/1.txt context system_u:object_r:shadow_t:s0-<span class="token operator">></span>system_u:object_r:system_cron_spool_t:s0
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 0hourly
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 <span class="token number">1</span>.txt
-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 raid-check<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到移动到<code>/etc/cron.d/</code> 的文件 <code>1.txt</code> 安全上下文类型从 <code>shadow_t</code> 恢复成了 <code>system_cron_spool_t</code>。</p>
<h1 id="安全上下文默认值修改"><a class="markdownIt-Anchor" href="#安全上下文默认值修改"></a> 安全上下文默认值修改</h1>
<p>之所以用 <code>restorecon</code> 命令可以恢复目录内的文件安全上下文类型，是因为目录和文件有个安全上下文默认值设定。</p>
<p>可以通过 <code>semanage</code> 命令来查询与修改安全上下文类型默认值。</p>
<p>常用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fcontext</td>
<td>用在安全性上下文标签（默认值）方面的用途，-l 查询</td>
</tr>
<tr>
<td>-a</td>
<td>增加，可以增加一些目录的默认安全上下文类型设置</td>
</tr>
<tr>
<td>-m</td>
<td>修改</td>
</tr>
<tr>
<td>-d</td>
<td>删除</td>
</tr>
</tbody>
</table>
<p>例如查询 <code>/etc/cron.d</code> 目录的默认值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ semanage fcontext <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">"/etc/cron<span class="token entity" title="\\">\\</span>\.d\("</span>
/etc/cron<span class="token punctuation">\</span>.d<span class="token punctuation">(</span>/.*<span class="token punctuation">)</span>?                                 all files          system_u:object_r:system_cron_spool_t:s0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改 <code>ftp_port_t</code> 端口策略，增加一个端口 <code>955</code> 作为 FTP 端口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ semanage port <span class="token parameter variable">-a</span> <span class="token parameter variable">-t</span> ftp_port_t <span class="token parameter variable">-p</span> tcp <span class="token number">955</span><span class="token punctuation">;</span> semanage port <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">955</span>
ftp_port_t                     tcp      <span class="token number">955</span>, <span class="token number">21</span>, <span class="token number">989</span>, <span class="token number">990</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改目录 <code>/root/myps</code> 的安全上下文类型为 <code>system_cron_spool_t</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-dZ</span> /root/myps/* /root/myps /root 
dr-xr-x---. root root system_u:object_r:admin_home_t:s0 /root
drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 /root/myps
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /root/myps/ip.txt
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ semanage fcontext <span class="token parameter variable">-a</span> <span class="token parameter variable">-t</span> system_cron_spool_t <span class="token string">"/root/myps(/.*)?"</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-dZ</span> /root/myps/* /root/myps /root 
dr-xr-x---. root root system_u:object_r:admin_home_t:s0 /root
drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 /root/myps
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /root/myps/ip.txt
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ semanage fcontext <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">"/root/myps\("</span>
/root/myps<span class="token punctuation">(</span>/.*<span class="token punctuation">)</span>?                                   all files          system_u:object_r:system_cron_spool_t:s0 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ restorecon <span class="token parameter variable">-Rv</span> /root/myps
restorecon reset /root/myps context unconfined_u:object_r:admin_home_t:s0-<span class="token operator">></span>unconfined_u:object_r:system_cron_spool_t:s0
restorecon reset /root/myps/ip.txt context unconfined_u:object_r:admin_home_t:s0-<span class="token operator">></span>unconfined_u:object_r:system_cron_spool_t:s0
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-dZ</span> /root/myps/* /root/myps
drwxr-xr-x. root root unconfined_u:object_r:system_cron_spool_t:s0 /root/myps
-rw-r--r--. root root unconfined_u:object_r:system_cron_spool_t:s0 /root/myps/ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改了以后再用 <code>restorecon</code> 命令还原默认值，所有其目录和文件的安全上下文类型变成了新设置的值。</p>
<h1 id="selinux-日志查询"><a class="markdownIt-Anchor" href="#selinux-日志查询"></a> SELinux 日志查询</h1>
<p>首先检查用于 SE 日志记录的服务 <code>auditd</code>（setroubleshoot）是否启动中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl status auditd
â— auditd.service - Security Auditing Service
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/auditd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Thu <span class="token number">2021</span>-09-09 <span class="token number">15</span>:08:51 EDT<span class="token punctuation">;</span> <span class="token number">1</span> weeks <span class="token number">1</span> days ago<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认情况下系统会自动启动。这里使用 <code>httpd</code> 服务来测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">ps</span> aux <span class="token parameter variable">-Z</span> <span class="token operator">|</span> <span class="token function">grep</span> http
system_u:system_r:httpd_t:s0    root      <span class="token number">60730</span>  <span class="token number">0.0</span>  <span class="token number">0.1</span> <span class="token number">230444</span>  <span class="token number">5204</span> ?        Ss   <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span>
system_u:system_r:httpd_t:s0    apache    <span class="token number">60731</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">230576</span>  <span class="token number">3732</span> ?        S    <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span>
system_u:system_r:httpd_t:s0    apache    <span class="token number">60732</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">230576</span>  <span class="token number">3736</span> ?        S    <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span>
system_u:system_r:httpd_t:s0    apache    <span class="token number">60733</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">230576</span>  <span class="token number">3736</span> ?        S    <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span>
system_u:system_r:httpd_t:s0    apache    <span class="token number">60734</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">230576</span>  <span class="token number">3720</span> ?        S    <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span>
system_u:system_r:httpd_t:s0    apache    <span class="token number">60735</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">230576</span>  <span class="token number">3732</span> ?        S    <span class="token number">10</span>:30   <span class="token number">0</span>:00 /usr/sbin/httpd <span class="token parameter variable">-DFOREGROUND</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询得知 <code>httpd</code> 的进程安全上下文类型为 <code>httpd_t</code> 域。增加首页内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"Today is 9.14"</span> <span class="token operator">></span> /var/www/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过浏览器访问服务器的 IP 地址可看到刚建页面。此时浏览器会通过 <code>httpd</code> 这个进程去读取 <code>/var/www/html/index.html</code> 文件。</p>
<p>查询一下 <code>index.html</code> 文件的安全上下文：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span> /var/www/html/index.html
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>看到文件安全上下文类型为 <code>httpd_sys_content_t</code>，查询一下 <code>httpd_t</code> 域类型与它的关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ sesearch <span class="token parameter variable">-A</span> <span class="token parameter variable">-s</span> httpd_t <span class="token operator">|</span> <span class="token function">grep</span> httpd_sys_content_t
   allow httpd_t httpd_sys_content_t <span class="token builtin class-name">:</span> lnk_file <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_t httpd_sys_content_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> getattr lock search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_t httpd_sys_content_t <span class="token builtin class-name">:</span> <span class="token function">file</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> getattr lock map <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow daemon httpd_sys_content_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> getattr search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_t httpd_sys_content_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> ioctl <span class="token builtin class-name">read</span> <span class="token function">write</span> getattr lock add_name remove_name search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着测试一下错误的安全上下文类型，可以将网页数据在 <code>/root</code> 文件夹下面生成，再移动到 <code>/var/www/html/</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"Now is 22:41"</span> <span class="token operator">></span> index.html
<span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">mv</span> index.html /var/www/html/
mv: overwrite a€?/var/www/html/index.htmla€?? y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>再次访问 <code>index.html</code>，结果变成了 <code>Forbidden</code> 拒绝访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1/index.html
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC <span class="token string">"-//IETF//DTD HTML 2.0//EN"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token number">403</span> Forbidden<span class="token operator">&lt;</span>/title<span class="token operator">></span>
<span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>></span>Forbidden<span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>></span>
<span class="token operator">&lt;</span>p<span class="token operator">></span>You don't have permission to access /index.html
on this server.<span class="token operator">&lt;</span>/p<span class="token operator">></span>
<span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把 Selinux 转换工作模式再访问试试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ setenforce <span class="token number">0</span>
<span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1/index.html
Now is <span class="token number">23</span>:41
<span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ setenforce <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>切换 SELinux 到警告模式后访问 <code>index.html</code> 正常，可以确定是 SELinux 的问题。看下 <code>index.html</code> 的安全上下文：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-Z</span> /var/www/html/index.html
-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /var/www/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安全上下文类型为 <code>admin_home_t</code>，查询一下与 <code>httpd_t</code> 的关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ sesearch <span class="token parameter variable">-A</span> <span class="token parameter variable">-s</span> httpd_t <span class="token operator">|</span> <span class="token function">grep</span> admin_home_t
   allow domain admin_home_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> getattr search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow domain admin_home_t <span class="token builtin class-name">:</span> lnk_file <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>结果显示没有结果，也就默认会被拒绝掉。到 <code>/var/log/messages</code> 下面查看下日志，果然有记录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> /var/log/messages
Sep <span class="token number">18</span> 08:40:32 101c7 setroubleshoot: failed to retrieve <span class="token function">rpm</span> info <span class="token keyword">for</span> /var/www/html/index.html
Sep <span class="token number">18</span> 08:40:32 101c7 setroubleshoot: SELinux is preventing httpd from getattr access on the <span class="token function">file</span> /var/www/html/index.html. For complete SELinux messages run: sealert <span class="token parameter variable">-l</span> c7d023db-6ae4-4397-9a6b-5b1061f5a9fa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>来自 <code>setroubleshoot</code> 的报告指出 SELinux 拒绝了 <code>httpd</code> 读取 <code>/var/www/html/index.html</code> 的请求，运行 <code>sealert -l</code> 命令来查看报告。看看 <code>sealert</code> 给出的报告：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ sealert <span class="token parameter variable">-l</span> c7d023db-6ae4-4397-9a6b-5b1061f5a9fa
SELinux is preventing httpd from getattr access on the <span class="token function">file</span> /var/www/html/index.html.

*****  Plugin restorecon <span class="token punctuation">(</span><span class="token number">99.5</span> confidence<span class="token punctuation">)</span> suggests   ************************

If you want to fix the label. 
/var/www/html/index.html default label should be httpd_sys_content_t.
Then you can run restorecon. The access attempt may have been stopped due to insufficient permissions to access a parent directory <span class="token keyword">in</span> <span class="token function">which</span> <span class="token keyword">case</span> try to change the following <span class="token builtin class-name">command</span> accordingly.
Do
<span class="token comment"># /sbin/restorecon -v /var/www/html/index.html</span>

*****  Plugin catchall <span class="token punctuation">(</span><span class="token number">1.49</span> confidence<span class="token punctuation">)</span> suggests   **************************

If you believe that httpd should be allowed getattr access on the index.html <span class="token function">file</span> by default.
Then you should report this as a bug.
You can generate a <span class="token builtin class-name">local</span> policy module to allow this access.
Do
allow this access <span class="token keyword">for</span> now by executing:
<span class="token comment"># ausearch -c 'httpd' --raw | audit2allow -M my-httpd</span>
<span class="token comment"># semodule -i my-httpd.pp</span>


Additional Information:
Source Context                system_u:system_r:httpd_t:s0
Target Context                unconfined_u:object_r:admin_home_t:s0
Target Objects                /var/www/html/index.html <span class="token punctuation">[</span> <span class="token function">file</span> <span class="token punctuation">]</span>
Source                        httpd
Source Path                   httpd
Port                          <span class="token operator">&lt;</span>Unknown<span class="token operator">></span>
Host                          101c7
Source RPM Packages           
Target RPM Packages           
Policy RPM                    selinux-policy-3.13.1-268.el7_9.2.noarch
Selinux Enabled               True
Policy Type                   targeted
Enforcing Mode                Enforcing
Host Name                     101c7
Platform                      Linux 101c7 <span class="token number">3.10</span>.0-1160.41.1.el7.x86_64 <span class="token comment">#1 SMP Tue</span>
                              Aug <span class="token number">31</span> <span class="token number">14</span>:52:47 UTC <span class="token number">2021</span> x86_64 x86_64
Alert Count                   <span class="token number">6</span>
First Seen                    <span class="token number">2021</span>-09-18 08:39:24 EDT
Last Seen                     <span class="token number">2021</span>-09-18 08:52:01 EDT
Local ID                      c7d023db-6ae4-4397-9a6b-5b1061f5a9fa

Raw Audit Messages
<span class="token assign-left variable">type</span><span class="token operator">=</span>AVC <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631969521.111</span>:5038<span class="token punctuation">)</span>: avc:  denied  <span class="token punctuation">&#123;</span> getattr <span class="token punctuation">&#125;</span> <span class="token keyword">for</span>  <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">60731</span> <span class="token assign-left variable">comm</span><span class="token operator">=</span><span class="token string">"httpd"</span> <span class="token assign-left variable">path</span><span class="token operator">=</span><span class="token string">"/var/www/html/index.html"</span> <span class="token assign-left variable">dev</span><span class="token operator">=</span><span class="token string">"dm-0"</span> <span class="token assign-left variable">ino</span><span class="token operator">=</span><span class="token number">33829126</span> <span class="token assign-left variable">scontext</span><span class="token operator">=</span>system_u:system_r:httpd_t:s0 <span class="token assign-left variable">tcontext</span><span class="token operator">=</span>unconfined_u:object_r:admin_home_t:s0 <span class="token assign-left variable">tclass</span><span class="token operator">=</span>file <span class="token assign-left variable">permissive</span><span class="token operator">=</span><span class="token number">0</span>


Hash: httpd,httpd_t,admin_home_t,file,getattr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>报告指出报错原因 99.5% 是因为：<code>index.html</code> 文件的默认 label 应该为 <code>httpd_sys_content_t</code>，这是我们已经知道的错误原因，并且下面给出了解决办法，运行命令 <code>/sbin/restorecon -v /var/www/html/index.html</code> 来修复这一错误。</p>
<p>接着报告提示 1.49% 的可能原因是遇到了 bug，可以运行命令 <code>ausearch -c 'httpd' --raw | audit2allow -M my-httpd</code> 和 <code>semodule -i my-httpd.pp</code> 来报告错误。</p>
<p>先试下后面这条命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ausearch <span class="token parameter variable">-c</span> <span class="token string">'httpd'</span> <span class="token parameter variable">--raw</span> <span class="token operator">|</span> audit2allow <span class="token parameter variable">-M</span> my-httpd
******************** IMPORTANT ***********************
To <span class="token function">make</span> this policy package active, execute:

semodule <span class="token parameter variable">-i</span> my-httpd.pp

<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ semodule <span class="token parameter variable">-i</span> my-httpd.pp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在浏览器访问 http 服务器，惊讶地发现可以访问了，日志 <code>/var/log/messages</code> 里面没有报错，显然最后一条命令起了作用。现在通过在 <code>/root</code> 下面新建 <code>index.html</code> 再转移到 <code>/var/www/html/</code> 的方式也不会拒绝访问了。</p>
<p>查询一下 <code>httpd_t</code> 与 <code>admin_home_t</code> 的关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ sesearch <span class="token parameter variable">-A</span> <span class="token parameter variable">-s</span> httpd_t <span class="token operator">|</span> <span class="token function">grep</span> admin_home_t
   allow domain admin_home_t <span class="token builtin class-name">:</span> <span class="token function">dir</span> <span class="token punctuation">&#123;</span> getattr search <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow domain admin_home_t <span class="token builtin class-name">:</span> lnk_file <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> 
   allow httpd_t admin_home_t <span class="token builtin class-name">:</span> <span class="token function">file</span> <span class="token punctuation">&#123;</span> <span class="token builtin class-name">read</span> getattr <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>果然系统给我们新建了一条策略来解决这一问题。由此可见，只要知道分析错误日志，SELinux 的 targeted 模式还是很灵活的，不必急着装好系统后就把 SELinux 关掉。</p>
<p>另外 <code>/var/log/audit</code> 下面也有日志，不过有用的信息并不多：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 home<span class="token punctuation">]</span>$ audit2why <span class="token operator">&lt;</span> /var/log/audit/audit.log 
<span class="token assign-left variable">type</span><span class="token operator">=</span>AVC <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631972305.031</span>:5057<span class="token punctuation">)</span>: avc:  denied  <span class="token punctuation">&#123;</span> <span class="token function">open</span> <span class="token punctuation">&#125;</span> <span class="token keyword">for</span>  <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">60735</span> <span class="token assign-left variable">comm</span><span class="token operator">=</span><span class="token string">"httpd"</span> <span class="token assign-left variable">path</span><span class="token operator">=</span><span class="token string">"/var/www/html/index.html"</span> <span class="token assign-left variable">dev</span><span class="token operator">=</span><span class="token string">"dm-0"</span> <span class="token assign-left variable">ino</span><span class="token operator">=</span><span class="token number">50435189</span> <span class="token assign-left variable">scontext</span><span class="token operator">=</span>system_u:system_r:httpd_t:s0 <span class="token assign-left variable">tcontext</span><span class="token operator">=</span>unconfined_u:object_r:home_root_t:s0 <span class="token assign-left variable">tclass</span><span class="token operator">=</span>file <span class="token assign-left variable">permissive</span><span class="token operator">=</span><span class="token number">1</span>

        Was caused by:
                Missing <span class="token builtin class-name">type</span> enforcement <span class="token punctuation">(</span>TE<span class="token punctuation">)</span> allow rule.

                You can use audit2allow to generate a loadable module to allow this access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 查询硬件与系统信息</title>
    <url>/741506456/</url>
    <content><![CDATA[<h1 id="查看内核版本"><a class="markdownIt-Anchor" href="#查看内核版本"></a> 查看内核版本</h1>
<p>使用命令<code>uname -r</code>可以查看当前内核版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">uname</span> <span class="token parameter variable">-r</span>
<span class="token number">3.10</span>.0-862.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果想要查看更详细的内核信息，可以使用<code>uname -a</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">uname</span> <span class="token parameter variable">-a</span>
Linux 101c7 <span class="token number">3.10</span>.0-862.el7.x86_64 <span class="token comment">#1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="查看操作系统位数"><a class="markdownIt-Anchor" href="#查看操作系统位数"></a> 查看操作系统位数</h1>
<p>使用<code>getconf</code>命令查看<code>LONG_BIT</code>变量可以得到操作系统位数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ getconf LONG_BIT
<span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="查看发行版本"><a class="markdownIt-Anchor" href="#查看发行版本"></a> 查看发行版本</h1>
<p>在 CentOS 5 中，可以使用命令<code>lsb_release -a</code>查看发行版本。</p>
<p>在 CentOS 7 中，可以查看文件<code>/etc/centos-release</code>的内容来查看版本号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/centos-release
CentOS Linux release <span class="token number">7.9</span>.2009 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="查看当前时间"><a class="markdownIt-Anchor" href="#查看当前时间"></a> 查看当前时间</h1>
<p>使用<code>date</code>命令可以查看系统中当前的时间和日期：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">date</span>
Sat Sep <span class="token number">11</span> 00:16:31 EDT <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用<code>systemd-analyze</code>命令查看系统启动时间：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-m1-pro ~<span class="token punctuation">]</span><span class="token comment"># systemd-analyze</span>
Startup finished <span class="token keyword">in</span> 614ms <span class="token punctuation">(</span>kernel<span class="token punctuation">)</span> + <span class="token number">1</span>.192s <span class="token punctuation">(</span>initrd<span class="token punctuation">)</span> + <span class="token number">27</span>.889s <span class="token punctuation">(</span>userspace<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">29</span>.695s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中，kernel 表示内核启动时间，initrd 表示 initramfs 加载时间，userspace 表示用户空间启动时间。</p>
<h1 id="查看内存使用情况"><a class="markdownIt-Anchor" href="#查看内存使用情况"></a> 查看内存使用情况</h1>
<p>使用<code>free</code>命令查看内存使用情况，单位默认为 KB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">free</span>
              total        used        <span class="token function">free</span>      shared  buff/cache   available
Mem:        <span class="token number">3861280</span>      <span class="token number">283612</span>     <span class="token number">2429740</span>       <span class="token number">11956</span>     <span class="token number">1147928</span>     <span class="token number">3272400</span>
Swap:       <span class="token number">2097148</span>           <span class="token number">0</span>     <span class="token number">2097148</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般来说，内存被大量<code>buff/cache</code>了是正常现象，但<code>swap</code>用量超过 20%说明物理内存不足。</p>
<h1 id="系统资源占用信息"><a class="markdownIt-Anchor" href="#系统资源占用信息"></a> 系统资源占用信息</h1>
<p>如果想要了解系统资源的运行情况，可以使用<code>vmstat</code>命令检测 CPU/内存/磁盘 IO 等。该命令常用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>使用 inactive/active 替代 buffer/.cache 的内存输出信息</td>
</tr>
<tr>
<td>-f</td>
<td>开机到目前为止系统复制（fork）的进程数</td>
</tr>
<tr>
<td>-s</td>
<td>将一些事件导致的内存变化情况列表说明</td>
</tr>
<tr>
<td>-S</td>
<td>接单位，让显示的数据有单位</td>
</tr>
<tr>
<td>-d</td>
<td>列出磁盘的读写总量统计</td>
</tr>
<tr>
<td>-p</td>
<td>列出分区，可显示该分区的读写总量统计</td>
</tr>
</tbody>
</table>
<p>例如统计目前主机 CPU 状态，每秒一次，共三次:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">vmstat</span> <span class="token number">1</span> <span class="token number">3</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st
<span class="token number">1</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">2434408</span>  <span class="token number">15508</span> <span class="token number">1132464</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">4</span>    <span class="token number">6</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span>
<span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">2434416</span>  <span class="token number">15508</span> <span class="token number">1132464</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>  <span class="token number">143</span>  <span class="token number">191</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span>
<span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">2434416</span>  <span class="token number">15508</span> <span class="token number">1132464</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">87</span>  <span class="token number">113</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是各字段的说明。</p>
<p>进程（procs）字段统计的数量越多，代表系统越繁忙：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>就绪或正在运行的进程数</td>
</tr>
<tr>
<td>b</td>
<td>不可中断的睡眠进程数</td>
</tr>
</tbody>
</table>
<p>内存字段（memory）：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>swpd</td>
<td>使用的虚拟内存大小（单位 KB）</td>
</tr>
<tr>
<td>free</td>
<td>空闲内存大小（单位 KB）</td>
</tr>
<tr>
<td>buff</td>
<td>用于缓存的内存大小（单位 KB）</td>
</tr>
<tr>
<td>cache</td>
<td>用于高速缓存的内存大小（单位 KB）</td>
</tr>
</tbody>
</table>
<p>内存交换空间（swap）数值越大代表内存不太够用：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>si</td>
<td>从磁盘中交换到内存的块数量</td>
</tr>
<tr>
<td>so</td>
<td>从内存中交换到磁盘的块数量</td>
</tr>
</tbody>
</table>
<p>磁盘读写（io）数值越高代表磁盘越忙碌：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bi</td>
<td>从块设备（磁盘）读取的块数</td>
</tr>
<tr>
<td>bo</td>
<td>写入到块设备（磁盘）的块数</td>
</tr>
</tbody>
</table>
<p>系统（system）项目计数越大，代表系统与接口设备的通信越频繁：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>每秒中断次数（包括时钟中断）</td>
</tr>
<tr>
<td>cs</td>
<td>每秒上下文切换次数</td>
</tr>
</tbody>
</table>
<p>CPU 的选项：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>us</td>
<td>用户空间占用 CPU 时间的百分比</td>
</tr>
<tr>
<td>sy</td>
<td>内核空间占用 CPU 时间的百分比</td>
</tr>
<tr>
<td>id</td>
<td>空闲 CPU 时间的百分比</td>
</tr>
<tr>
<td>wa</td>
<td>等待 I/O 操作占用 CPU 时间的百分比</td>
</tr>
<tr>
<td>st</td>
<td>用于运行虚拟机的 CPU 时间的百分比</td>
</tr>
</tbody>
</table>
<p>例如查看磁盘读写状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">vmstat</span> <span class="token parameter variable">-d</span>
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
sdb    <span class="token number">11640</span>  <span class="token number">23419</span> <span class="token number">1679403</span>    <span class="token number">3097</span>   <span class="token number">3013</span> <span class="token number">143194</span>  <span class="token number">714969</span>    <span class="token number">2367</span>      <span class="token number">0</span>      <span class="token number">2</span>
sda    <span class="token number">13672</span>     <span class="token number">28</span> <span class="token number">1219051</span>    <span class="token number">6501</span>  <span class="token number">22246</span>   <span class="token number">3488</span> <span class="token number">1921401</span>   <span class="token number">17945</span>      <span class="token number">0</span>     <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查询内存中内容"><a class="markdownIt-Anchor" href="#查询内存中内容"></a> 查询内存中内容</h1>
<p>内存中的数据都写入到目录<code>/proc/*</code>中（不占用实际硬盘空间）。查看目录<code>/proc</code>中的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ ll /proc <span class="token operator">|</span> <span class="token function">head</span> 
total <span class="token number">0</span>
dr-xr-xr-x.  <span class="token number">9</span> root    root                  <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 <span class="token number">1</span>
dr-xr-xr-x.  <span class="token number">9</span> root    root                  <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 <span class="token number">10</span>
dr-xr-xr-x.  <span class="token number">9</span> root    root                  <span class="token number">0</span> Sep <span class="token number">14</span> 00:31 <span class="token number">10025</span>
dr-xr-xr-x.  <span class="token number">9</span> root    root                  <span class="token number">0</span> Sep <span class="token number">14</span> 00:31 <span class="token number">10026</span>
dr-xr-xr-x.  <span class="token number">9</span> root    root                  <span class="token number">0</span> Sep <span class="token number">14</span> 00:31 <span class="token number">10139</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，各个进程的 PID 都是以目录的形式存在于 <code>/proc</code> 中。</p>
<p>进一步查看进程在内存中写入的内容，以 PID=1 的 init 程序为例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ ll /proc/1
total <span class="token number">0</span>
dr-xr-xr-x. <span class="token number">2</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 attr
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 autogroup
-r--------. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 auxv
-r--r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 cgroup
--w-------. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 clear_refs
-r--r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 cmdline
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 <span class="token function">comm</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 coredump_filter
-r--r--r--. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 cpuset
lrwxrwxrwx. <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">10</span> 01:44 cwd -<span class="token operator">></span> /
-r--------. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 environ
lrwxrwxrwx. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:08 exe -<span class="token operator">></span> /usr/lib/systemd/systemd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>cmdline</code> 定义了 init 被启动的命令串，<code>environ</code> 定义了这个进程的环境变量。</p>
<p>以下是在 <code>/proc</code> 目录下常见文件的内容：</p>
<table>
<thead>
<tr>
<th><strong>文件名</strong></th>
<th><strong>文件内容</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>cmdline</td>
<td>加载 kernel 时所执行的相关参数</td>
</tr>
<tr>
<td>cpuinfo</td>
<td>本机 CPU 的相关信息，包括频率、类型和运算功能等</td>
</tr>
<tr>
<td>devices</td>
<td>记录各个主要设备的主要设备代号，与 mknod 有关</td>
</tr>
<tr>
<td>filesystems</td>
<td>目前系统已经加载的文件系统</td>
</tr>
<tr>
<td>interrupts</td>
<td>目前系统上的 IRQ 分配状态</td>
</tr>
<tr>
<td>ioports</td>
<td>目前系统上各个设备所配置的 I/O 地址</td>
</tr>
<tr>
<td>kcore</td>
<td>内存的大小</td>
</tr>
<tr>
<td>loadavg</td>
<td>系统负载情况</td>
</tr>
<tr>
<td>meminfo</td>
<td>内存信息</td>
</tr>
<tr>
<td>modules</td>
<td>已经加载的模块列表，主要是驱动程序</td>
</tr>
<tr>
<td>mounts</td>
<td>系统已挂载的数据</td>
</tr>
<tr>
<td>swaps</td>
<td>系统加载的内存使用的分区记录</td>
</tr>
<tr>
<td>partitions</td>
<td>记录系统分区信息</td>
</tr>
<tr>
<td>pci</td>
<td>在 PCI 总线上每个设备的详细情况，可用 lspci 查询</td>
</tr>
<tr>
<td>uptime</td>
<td>系统运行时长记录</td>
</tr>
<tr>
<td>version</td>
<td>内核版本</td>
</tr>
<tr>
<td>bus/*</td>
<td>一些总线设备，包括 USB 记录设备</td>
</tr>
</tbody>
</table>
<p>对 <code>/proc</code> 下的文件进行修改后，修改将立即生效。</p>
<h1 id="查询使用中的文件"><a class="markdownIt-Anchor" href="#查询使用中的文件"></a> 查询使用中的文件</h1>
<p>查询文件正在被什么程序使用可以使用 <code>fuser</code>命令查询（使用 yum install psmisc 安装）。可用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u</td>
<td>列出进程所有者</td>
</tr>
<tr>
<td>-m</td>
<td>列出占用文件系统的进程</td>
</tr>
<tr>
<td>-v</td>
<td>列出文件与程序还有命令的完整相关性</td>
</tr>
<tr>
<td>-k</td>
<td>找出使用文件的 PID，并试图强制结束程序</td>
</tr>
<tr>
<td>-i</td>
<td>结束程序前询问用户</td>
</tr>
</tbody>
</table>
<p>例如找到当前目录正在使用它的 PID/所属账户/权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">fuser</span> <span class="token parameter variable">-uv</span> <span class="token builtin class-name">.</span>
            <span class="token environment constant">USER</span>      PID   ACCESS COMMAND
/root/bin:  root      <span class="token number">40090</span> <span class="token punctuation">..</span>c<span class="token punctuation">..</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span>bash
            root      <span class="token number">40855</span> <span class="token punctuation">..</span>c<span class="token punctuation">..</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span>tail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示有两个 PID 为 40090 和 40855 的程序在使用该目录，程序所属为 root，命令是 <code>bash</code> 和 <code>tail</code>。可以直接使用<code>fuser -k</code>命令来终止使用该目录的进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">fuser</span> <span class="token parameter variable">-k</span> /root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ACCESS 选项代表的意义为：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>此进程在当前目录下（非子目录）</td>
</tr>
<tr>
<td>e</td>
<td>可被触发为执行状态</td>
</tr>
<tr>
<td>f</td>
<td>是一个被打开的文件</td>
</tr>
<tr>
<td>r</td>
<td>代表顶层目录</td>
</tr>
<tr>
<td>F</td>
<td>该文件被打开了，不过在等待回应中</td>
</tr>
<tr>
<td>m</td>
<td>可能为分享的动态函数库</td>
</tr>
</tbody>
</table>
<h1 id="查询程序打开的文件"><a class="markdownIt-Anchor" href="#查询程序打开的文件"></a> 查询程序打开的文件</h1>
<p>要查询某个程序正在使用的文件，可以使用 <code>lsof</code> 命令。命令参数如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>多项数据需要同时成立才显示出结果时</td>
</tr>
<tr>
<td>-p</td>
<td>指定进程 PID</td>
</tr>
<tr>
<td>-U</td>
<td>仅列出 Unix like 系统的 socket 文件类型</td>
</tr>
<tr>
<td>-u</td>
<td>接 username，列出该用户相关进程所打开的文件</td>
</tr>
<tr>
<td>+d</td>
<td>接目录，找出某个目录下面已经被打开的文件</td>
</tr>
</tbody>
</table>
<p>例如，列出关于 root 的所有进程打开的 socket 文件（-a 表示逻辑与，限定了必须为 root 用户和 socket 文件）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">lsof</span> <span class="token parameter variable">-u</span> root <span class="token parameter variable">-a</span> <span class="token parameter variable">-U</span>
COMMAND     PID <span class="token environment constant">USER</span>   FD   TYPE             DEVICE SIZE/OFF   NODE NAME
systemd       <span class="token number">1</span> root   12u  unix 0xffff9ac438950000      0t0  <span class="token number">20565</span> /run/systemd/private
systemd       <span class="token number">1</span> root   13u  unix 0xffff9ac438b14400      0t0 <span class="token number">605204</span> socket
systemd       <span class="token number">1</span> root   18u  unix 0xffff9ac4b5ec8440      0t0     <span class="token number">29</span> /run/systemd/notify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如，查询属于 root 的 <code>tail</code> 命令所打开的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">lsof</span> <span class="token parameter variable">-u</span> root <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">tail</span>
<span class="token function">tail</span>       <span class="token number">40855</span> root  cwd       DIR      <span class="token number">253,0</span>       <span class="token number">246</span>   <span class="token number">33607964</span> /root/bin
<span class="token function">tail</span>       <span class="token number">40855</span> root  rtd       DIR      <span class="token number">253,0</span>       <span class="token number">253</span>         <span class="token number">64</span> /
<span class="token function">tail</span>       <span class="token number">40855</span> root  txt       REG      <span class="token number">253,0</span>     <span class="token number">66816</span>   <span class="token number">50333754</span> /usr/bin/tail
<span class="token function">tail</span>       <span class="token number">40855</span> root    0w      CHR        <span class="token number">1,3</span>       0t0       <span class="token number">1028</span> /dev/null
<span class="token function">tail</span>       <span class="token number">40855</span> root    1w      REG      <span class="token number">253,0</span>       <span class="token number">236</span>   <span class="token number">33607951</span> /root/bin/nomarl.log
<span class="token function">tail</span>       <span class="token number">40855</span> root    2w      REG      <span class="token number">253,0</span>        <span class="token number">54</span>   <span class="token number">33607959</span> /root/bin/error.log
<span class="token function">tail</span>       <span class="token number">40855</span> root    3r      REG      <span class="token number">253,0</span>       <span class="token number">236</span>   <span class="token number">33607979</span> /root/bin/sh01.sh
<span class="token function">tail</span>       <span class="token number">40855</span> root    4r  a_inode      <span class="token number">0,10</span>         <span class="token number">0</span>       <span class="token number">8534</span> inotify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示结果字段含义如下：</p>
<ul>
<li>COMMAND：正在运行的命令名前 9 个字符。</li>
<li>PID：进程的 PID。</li>
<li>USER：进程属主的登录名。</li>
<li>FD：文件描述符号以及访问类型。r 读，w 写，u 代表读写。</li>
<li>TYPE：文件的类型。CHR 字符型，BLK 块型，DIR 目录，REG 代表常规文件。</li>
<li>DEVICE：设备的设备号。</li>
<li>SIZE：文件的大小。</li>
<li>NODE：本地文件的 inode 号。</li>
<li>NAME：文件名。</li>
</ul>
<h1 id="查询硬件信息"><a class="markdownIt-Anchor" href="#查询硬件信息"></a> 查询硬件信息</h1>
<p>使用 <code>dmidecode</code> 命令可以查询当前计算机的硬件配置。使用 <code>-t</code> 参数来选择查看的硬件设备类型。对应类型如下表：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>BIOS 信息</td>
</tr>
<tr>
<td>2</td>
<td>主板信息</td>
</tr>
<tr>
<td>4</td>
<td>CPU 信息</td>
</tr>
<tr>
<td>9</td>
<td>插槽信息</td>
</tr>
<tr>
<td>10</td>
<td>板载设备</td>
</tr>
<tr>
<td>17</td>
<td>内存信息</td>
</tr>
<tr>
<td>41</td>
<td>板载设备</td>
</tr>
</tbody>
</table>
<p>例如查看 CPU 信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ dmidecode <span class="token parameter variable">-t</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">50</span>
<span class="token comment"># dmidecode 3.2</span>
Getting SMBIOS data from sysfs.
SMBIOS <span class="token number">2.7</span> present.

Handle 0x0004, DMI <span class="token builtin class-name">type</span> <span class="token number">4</span>, <span class="token number">42</span> bytes
Processor Information
        Socket Designation: CPU <span class="token comment">#000</span>
        Type: Central Processor
        Family: Unknown
        Manufacturer: AuthenticAMD
        ID: <span class="token number">82</span> 0F <span class="token number">80</span> 00 FF FB 8B <span class="token number">17</span>
        Version: AMD Ryzen Threadripper 2990WX <span class="token number">32</span>-Core Processor
        Voltage: <span class="token number">3.3</span> V
        External Clock: Unknown
        Max Speed: <span class="token number">30000</span> MHz
        Current Speed: <span class="token number">3200</span> MHz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用<code>dmesg</code>来输出所有的内核运行时的记录日志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">less</span>
<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Initializing cgroup subsys cpuset
<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Initializing cgroup subsys cpu
<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> Initializing cgroup subsys cpuacct<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>配合 <code>grep ATA</code>过滤掉无关的信息，查询 SATA 接口硬盘信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@s55 ~<span class="token punctuation">]</span>$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> ATA
<span class="token punctuation">[</span>    <span class="token number">3.367870</span><span class="token punctuation">]</span> ata6.00: ATA-10: HGST HUS722T1TALA604, RAGNWA09, max UDMA/133
<span class="token punctuation">[</span>    <span class="token number">3.369145</span><span class="token punctuation">]</span> ata5.00: ATA-10: HGST HUS722T1TALA604, RAGNWA09, max UDMA/133<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以下是一些常用的 Linux 系统硬件信息查询命令：</p>
<ul>
<li><code>gdisk</code>/<code>fdisk</code>：查询分区信息。</li>
<li><code>vmstat</code>：分析系统状态。</li>
<li><code>lscpu</code>：查询 CPU 相关信息。</li>
<li><code>lspci</code>：查询 PCI 接口设备。</li>
<li><code>lsusb</code>：查询 USB 接口状态。</li>
<li><code>iostat</code>：查询系统 I/O 状态。</li>
<li><code>smartctl</code>：查询硬盘 S.M.A.R.T 信息。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程查询与管理</title>
    <url>/1804980384/</url>
    <content><![CDATA[<h1 id="进程查看命令"><a class="markdownIt-Anchor" href="#进程查看命令"></a> 进程查看命令</h1>
<p>查询系统上正在运行的进程，可以使用 <code>ps</code> 命令。常用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>-a</td>
<td>不与终端有关的所有进程</td>
</tr>
<tr>
<td>-u</td>
<td>与有效用户相关的进程</td>
</tr>
<tr>
<td>x</td>
<td>通常与 a 参数一起使用，可列出较完整信息</td>
</tr>
<tr>
<td>l</td>
<td>将 PID 信息较详细列出来</td>
</tr>
<tr>
<td>j</td>
<td>工作的格式（jobs format）</td>
</tr>
<tr>
<td>-f</td>
<td>生成更为完整的输出</td>
</tr>
</tbody>
</table>
<p>要查询与当前登录会话相关的 PID 和相关信息，可以使用 <code>ps -l</code> 命令，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-l</span>
F S   <span class="token environment constant">UID</span>    PID   <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
<span class="token number">4</span> S     <span class="token number">0</span>  <span class="token number">40090</span>  <span class="token number">40085</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">28919</span> do_wai pts/0    00:00:00 <span class="token function">bash</span>
<span class="token number">0</span> S     <span class="token number">0</span>  <span class="token number">40855</span>  <span class="token number">40090</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">27024</span> wait_w pts/0    00:00:00 <span class="token function">tail</span>
<span class="token number">0</span> R     <span class="token number">0</span>  <span class="token number">42025</span>  <span class="token number">40090</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">38332</span> -      pts/0    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果仅显示与当前操作环境（bash）相关的进程。表格中各选项的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>表头</strong></th>
<th><strong>例值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>4</td>
<td>4：表示此进程权限为 root；<br />1：表示此子进程仅可进行复制（fork）而不能执行（exec）。</td>
</tr>
<tr>
<td>S</td>
<td>S</td>
<td>R（Runing）：程序正在运行；<br />I（Idle）：空闲，超过 20 秒的睡眠；<br />S（Sleep）：进程目前正在睡眠状态（idle），但可被唤醒（signal）；<br />D：不可被唤醒的睡眠状态，可能在等到 I/O 的情况；<br />T：停止状态，可能在工作控制（后台暂停）或除错（traced）；<br />Z（Zombie）：僵尸进程，进程已经被终止但无法被移出内存。</td>
</tr>
<tr>
<td>UID/PID/PPID</td>
<td>0/40090/40085</td>
<td>代表进程被该 UID 所拥有/进程 PID/父进程 PID。</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>代表 CPU 使用率，单位是百分比。</td>
</tr>
<tr>
<td>PRI/NI</td>
<td>80/0</td>
<td>Priority/Nice 的缩写，代表进程执行优先级，越小优先级越高。</td>
</tr>
<tr>
<td>ADDR</td>
<td>-</td>
<td>指出该进程在内存的虚拟地址，running 中的进程显示-。</td>
</tr>
<tr>
<td>SZ</td>
<td>28919</td>
<td>代表此进程占用多少物理内存。</td>
</tr>
<tr>
<td>WCHAN</td>
<td>do_wai</td>
<td>表示目前进程是否运行在，运行中显示-。</td>
</tr>
<tr>
<td>TTY</td>
<td>pts/0</td>
<td>用户终端位置，远程登录使用动态终端接口(pts/n)，守护进程显示?。</td>
</tr>
<tr>
<td>TIME</td>
<td>00:00:00</td>
<td>使用掉的 CPU 时间，指进程实际花费 CPU 运行的时间。</td>
</tr>
<tr>
<td>CMD</td>
<td>bash</td>
<td>command 的缩写，正在执行的命令名称。</td>
</tr>
</tbody>
</table>
<p>另外，如果看到的 <code>bash</code> 状态为 S，则是因为它触发了 <code>ps</code>，此时 <code>ps</code> 状态为 R。</p>
<p>查看系统所有进程可以使用 <code>ps aux</code> 命令组合:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'1~17p'</span>
<span class="token environment constant">USER</span>        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">21</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Sep09   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kworker/2:0H<span class="token punctuation">]</span>
root        <span class="token number">788</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Sep09   <span class="token number">0</span>:00 <span class="token punctuation">[</span>xfs-log/sda1<span class="token punctuation">]</span>
root       <span class="token number">1131</span>  <span class="token number">0.0</span>  <span class="token number">0.1</span> <span class="token number">222740</span>  <span class="token number">5640</span> ?        Ssl  Sep09   <span class="token number">0</span>:19 /usr/sbin/rsyslogd <span class="token parameter variable">-n</span>
root      <span class="token number">11078</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Sep13   <span class="token number">0</span>:00 <span class="token punctuation">[</span>bioset<span class="token punctuation">]</span>
root      <span class="token number">40855</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">108096</span>   <span class="token number">616</span> pts/0    S    04:07   <span class="token number">0</span>:00 <span class="token function">tail</span> <span class="token parameter variable">-f</span> sh01.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 BSD 选项显示结果表头说明如下:</p>
<table>
<thead>
<tr>
<th><strong>表头</strong></th>
<th><strong>例值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>root</td>
<td>该进程所属账号。</td>
</tr>
<tr>
<td>PID</td>
<td>40855</td>
<td>进程标识符。</td>
</tr>
<tr>
<td>%CPU</td>
<td>0.0</td>
<td>进程使用掉的 CPU 资源百分比。</td>
</tr>
<tr>
<td>%MEM</td>
<td>0.1</td>
<td>进程所占用的物理内存百分比。</td>
</tr>
<tr>
<td>VSZ</td>
<td>108096</td>
<td>进程使用掉的虚拟内存量（KB）。</td>
</tr>
<tr>
<td>RSS</td>
<td>616</td>
<td>该进程占用的固定内存量（KB）。</td>
</tr>
<tr>
<td>TTY</td>
<td>pts/0</td>
<td>该进程运行的终端，和终端无关显示？</td>
</tr>
<tr>
<td>STAT</td>
<td>Ssl</td>
<td><strong>进程主状态</strong>：<br />O（正在运行）R（可运行）/S（休眠）/D（挂起）/T（停止）/Z（僵尸进程）<br /><strong>进程副状态</strong>：<br />&lt;（运行在高优先级上）/N（运行在低优先级上）/L（该进程所有页面锁定在内存中）/s（该进程是控制进程）/l（该进程是多线程）/+（该进程运行在前台）。</td>
</tr>
<tr>
<td>START</td>
<td>04:07</td>
<td>该进程被触发的启动时间。</td>
</tr>
<tr>
<td>TIME</td>
<td>0:19</td>
<td>该进程被触发启动的时间。</td>
</tr>
<tr>
<td>COMMAND</td>
<td>tail -f</td>
<td>该进程的实际命令。</td>
</tr>
</tbody>
</table>
<p>想要更直观展示进程间的关系，可以使用命令组合<code>ps axjf</code>将结果用进程树显示:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">ps</span> axjf
  <span class="token environment constant">PPID</span>    PID   PGID    SID TTY       TPGID STAT   <span class="token environment constant">UID</span>   TIME COMMAND
     <span class="token number">0</span>      <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">0</span> ?            <span class="token parameter variable">-1</span> S        <span class="token number">0</span>   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
     <span class="token number">1</span>    <span class="token number">897</span>    <span class="token number">897</span>    <span class="token number">897</span> ?            <span class="token parameter variable">-1</span> Ss       <span class="token number">0</span>   <span class="token number">0</span>:00 login -- root
   <span class="token number">897</span> <span class="token number">104660</span> <span class="token number">104660</span> <span class="token number">104660</span> tty1     <span class="token number">104660</span> Ss+      <span class="token number">0</span>   <span class="token number">0</span>:00  <span class="token punctuation">\</span>_ <span class="token parameter variable">-bash</span>
     <span class="token number">1</span>   <span class="token number">1130</span>   <span class="token number">1130</span>   <span class="token number">1130</span> ?            <span class="token parameter variable">-1</span> Ss       <span class="token number">0</span>   <span class="token number">0</span>:00 /usr/sbin/sshd <span class="token parameter variable">-D</span>
  <span class="token number">1130</span>  <span class="token number">40085</span>  <span class="token number">40085</span>  <span class="token number">40085</span> ?            <span class="token parameter variable">-1</span> Ss       <span class="token number">0</span>   <span class="token number">0</span>:00  <span class="token punctuation">\</span>_ sshd: root@pts/0
<span class="token number">40085</span>  <span class="token number">40090</span>  <span class="token number">40090</span>  <span class="token number">40090</span> pts/0     <span class="token number">43864</span> Ss       <span class="token number">0</span>   <span class="token number">0</span>:00      <span class="token punctuation">\</span>_ <span class="token parameter variable">-bash</span>
<span class="token number">40090</span>  <span class="token number">40855</span>  <span class="token number">40855</span>  <span class="token number">40090</span> pts/0     <span class="token number">43864</span> S        <span class="token number">0</span>   <span class="token number">0</span>:00          <span class="token punctuation">\</span>_ <span class="token function">tail</span> <span class="token parameter variable">-f</span> sh01.sh
<span class="token number">40090</span>  <span class="token number">43864</span>  <span class="token number">43864</span>  <span class="token number">40090</span> pts/0     <span class="token number">43864</span> R+       <span class="token number">0</span>   <span class="token number">0</span>:00          <span class="token punctuation">\</span>_ <span class="token function">ps</span> axjf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更方便展示进程树用<code>pstree</code>命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ pstree <span class="token parameter variable">-Apu</span>
systemd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>-+-NetworkManager<span class="token punctuation">(</span><span class="token number">881</span><span class="token punctuation">)</span>-+-<span class="token punctuation">&#123;</span>NetworkManager<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">905</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>                     <span class="token variable"><span class="token variable">`</span>-<span class="token punctuation">&#123;</span>NetworkManager<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">909</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>-VGAuthService<span class="token punctuation">(</span><span class="token number">867</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>-atd<span class="token punctuation">(</span><span class="token number">27679</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>-auditd<span class="token punctuation">(</span><span class="token number">843</span><span class="token punctuation">)</span>-+-audispd<span class="token punctuation">(</span><span class="token number">62781</span><span class="token punctuation">)</span>-+-sedispatch<span class="token punctuation">(</span><span class="token number">62782</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>             <span class="token operator">|</span>                <span class="token variable">`</span></span>-<span class="token punctuation">&#123;</span>audispd<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">62783</span><span class="token punctuation">)</span>
           <span class="token operator">|</span>             `-<span class="token punctuation">&#123;</span>auditd<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">844</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="进程查看工具"><a class="markdownIt-Anchor" href="#进程查看工具"></a> 进程查看工具</h1>
<p>使用<code>top</code>可以持续监测进程的运行状态。在启动<code>top</code>时可以使用以下参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code></td>
<td>定义界面刷新时间，默认为 5 秒</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>以批次的方式执行<code>top</code>，通常搭配重定向将批处理结果输出到文件</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>与<code>-b</code>搭配，设定刷新的总次数</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>指定某个 PID 进行监测</td>
</tr>
</tbody>
</table>
<p>在 top 程序中常用的交互按键如下:</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code></td>
<td>显示在<code>top</code>中可以输入的按键命令</td>
</tr>
<tr>
<td><code>P</code></td>
<td>以 CPU 使用率排序</td>
</tr>
<tr>
<td><code>M</code></td>
<td>以内存使用量排序</td>
</tr>
<tr>
<td><code>N</code></td>
<td>以 PID 排序</td>
</tr>
<tr>
<td><code>T</code></td>
<td>由该进程使用的 CPU 时间累积(TIME+)排序</td>
</tr>
<tr>
<td><code>k</code></td>
<td>给某个 PID 发送一个信号，相当于<code>kill</code>命令</td>
</tr>
<tr>
<td><code>r</code></td>
<td>给某个 PID 重新分配一个<code>nice</code>值</td>
</tr>
<tr>
<td><code>f</code></td>
<td>设置排序依据</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出<code>top</code></td>
</tr>
</tbody>
</table>
<p>进入<code>top</code>界面查看，按 CPU 使用率排序是默认选项：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">top</span>
<span class="token function">top</span> - 05:47:44 up <span class="token number">4</span> days, <span class="token number">14</span>:38,  <span class="token number">2</span> users,  load average: <span class="token number">0.00</span>, <span class="token number">0.01</span>, <span class="token number">0.05</span>
Tasks: <span class="token number">229</span> total,   <span class="token number">2</span> running, <span class="token number">227</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni,100.0 id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span>  <span class="token number">3861280</span> total,  <span class="token number">2434616</span> free,   <span class="token number">278880</span> used,  <span class="token number">1147784</span> buff/cache
KiB Swap:  <span class="token number">2097148</span> total,  <span class="token number">2097148</span> free,        <span class="token number">0</span> used.  <span class="token number">3277072</span> avail Mem 

   PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
     <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">193840</span>   <span class="token number">6964</span>   <span class="token number">4200</span> S   <span class="token number">0.3</span>  <span class="token number">0.2</span>   <span class="token number">1</span>:49.89 systemd
 <span class="token number">10771</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:51.26 kworker/3:0
 <span class="token number">46205</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">162104</span>   <span class="token number">2340</span>   <span class="token number">1576</span> R   <span class="token number">0.3</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:00.02 <span class="token function">top</span>
     <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.11 kthreadd
     <span class="token number">4</span> root       <span class="token number">0</span> <span class="token parameter variable">-20</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kworker/0:0H
     <span class="token number">6</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 ksoftirqd/0  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顶部总共有五行，每个参数用逗号隔开。用上例做说明详细定义。</p>
<p>第一行（top）：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>05:47:44 up 4 days, 14:38</td>
<td>当前时间和系统运行时间 4 天 14 小时 38 分钟</td>
</tr>
<tr>
<td>2 users</td>
<td>已登录系统的用户数</td>
</tr>
<tr>
<td>load average: 0.00, 0.01, 0.05</td>
<td>系统在 1 分钟、5 分钟和 15 分钟内的平均工作负载，多核处理器需要除以核心数</td>
</tr>
</tbody>
</table>
<p>第二行（Tasks）：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>229 total</td>
<td>当前进程总数</td>
</tr>
<tr>
<td>2 running, 227 sleeping, 0 stopped, 0 zombie</td>
<td>运行状态为运行中（r）、睡眠中（s）、停止（t）和僵尸（z）的进程树数量</td>
</tr>
</tbody>
</table>
<p>第三行（%Cpu(s)）多核处理器可以使用数字键 1 来切换不同 CPU 的负载率：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0 us</td>
<td>用户空间占用 CPU</td>
</tr>
<tr>
<td>0.1 sy</td>
<td>内核空间占用 CPU</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td>
</tr>
<tr>
<td>99.9 id</td>
<td>空闲 CPU 百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入输出的 CPU 时间百分比，磁盘读写速度造成的卡顿体现在此</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬件 CPU 中断占用百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断占用百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>虚拟机占用百分比</td>
</tr>
</tbody>
</table>
<p>第四行（KiB Mem）：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>3861280 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>2434616 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>278880 used</td>
<td>使用中的物理内存总量</td>
</tr>
<tr>
<td>1147784 buff/cache</td>
<td>作为内核缓存的内存量</td>
</tr>
</tbody>
</table>
<p>第五行（KiB Swap）：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2097148 total</td>
<td>交换空间总量</td>
</tr>
<tr>
<td>2097148 free</td>
<td>交换空间空闲量</td>
</tr>
<tr>
<td>0 used</td>
<td>交换空间使用量</td>
</tr>
<tr>
<td>3277072 avail Mem</td>
<td>可用内存</td>
</tr>
</tbody>
</table>
<h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1>
<p>使用 <code>kill</code> 命令可以将 <code>signal</code> 传送给某个工作或 <code>PID</code>：<code>kill -signal PID</code></p>
<p><code>kill</code> 参数可使用的信号(<code>signal</code>)能用 <code>kill -l</code> 查询，常用的有：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>重新读取一次参数的配置文件，类似<code>reload</code>重新启动</td>
</tr>
<tr>
<td>-2</td>
<td>中断信号，与[Ctrl]+c 发出的一样</td>
</tr>
<tr>
<td>-9</td>
<td>立刻强制中断一个进程运行</td>
</tr>
<tr>
<td>-15</td>
<td>以正常的程序方式终止进程(默认信号)</td>
</tr>
<tr>
<td>-19</td>
<td>暂停进程，与[Ctrl]+z 发出的一样</td>
</tr>
</tbody>
</table>
<p><code>kill</code>的目标可以是<code>PID</code>（直接输入数字）也可以是后台工作号码(<code>%n</code>)。例如将后台第 3 个任务终止：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">kill</span> %2 <span class="token punctuation">;</span> <span class="token function">jobs</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>   Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>-  Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">kill</span> %2 <span class="token punctuation">;</span> <span class="token function">jobs</span>
-bash: kill: <span class="token punctuation">(</span><span class="token number">37698</span><span class="token punctuation">)</span> - No such process
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>   Terminated              <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>-  Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">kill</span> %2 <span class="token punctuation">;</span> <span class="token function">jobs</span>
-bash: kill: %2: no such job
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>-  Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到工作状态由<code>Running</code>转为<code>Terminated</code>，最后消失在后台工作列表中。</p>
<p>加入<code>-2</code>发送中断信号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token parameter variable">-2</span> %3<span class="token punctuation">;</span><span class="token function">jobs</span>
-bash: kill: <span class="token punctuation">(</span><span class="token number">37916</span><span class="token punctuation">)</span> - No such process
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>-  Interrupt               <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>工作状态先变为<code>Interrupt</code>，然后再消失。</p>
<p>使用<code>-9</code>强制结束工作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token parameter variable">-9</span> %4 <span class="token punctuation">;</span> <span class="token function">jobs</span>
-bash: kill: <span class="token punctuation">(</span><span class="token number">39089</span><span class="token punctuation">)</span> - No such process
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>   Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>-  Killed                  <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>工作状态先变为<code>killed</code>，然后消失。</p>
<p>还可以通过<code>pkill</code>命令来将所有某个命令名称启动的进程全部删除。例如关闭<code>http</code>相关的进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">pkill</span> <span class="token parameter variable">-ec</span> http
httpd killed <span class="token punctuation">(</span>pid <span class="token number">6860</span><span class="token punctuation">)</span>
httpd killed <span class="token punctuation">(</span>pid <span class="token number">6861</span><span class="token punctuation">)</span>
httpd killed <span class="token punctuation">(</span>pid <span class="token number">6862</span><span class="token punctuation">)</span>
httpd killed <span class="token punctuation">(</span>pid <span class="token number">6863</span><span class="token punctuation">)</span>
httpd killed <span class="token punctuation">(</span>pid <span class="token number">6864</span><span class="token punctuation">)</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用<code>killall</code>命令也可以达到<code>pkill</code>同样的效果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 thin1<span class="token punctuation">]</span>$ <span class="token function">killall</span> <span class="token parameter variable">-1</span> rsyslogd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="进程优先级"><a class="markdownIt-Anchor" href="#进程优先级"></a> 进程优先级</h1>
<p>程序优先执行序（PRI，Priority），值越低代表执行越优先，PRI 值由内核动态调整，用户无法直接调整 PRI 值。</p>
<p>用户能调整的是<code>nice</code>值，<code>nice</code>值与<code>pri</code>值求和得出程序实际优先值。<code>nice</code>值的设置规则：</p>
<ul>
<li><code>nice</code>值可调整范围为-20~19；</li>
<li><code>root</code>可以随意调整他人进程<code>nice</code>值；</li>
<li>一般用户只能调整自己进程的<code>nice</code>值，范围是 0~19；</li>
</ul>
<p>用<code>nice</code>命令能在程序启动时设置<code>nice</code>值。例如以-10 的<code>nice</code>值启动<code>top</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">nice</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-10</span> <span class="token function">top</span> <span class="token parameter variable">-d</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对已存在的进程除了可以用<code>top</code>设置外，还能用<code>renice</code>命令重新调整。例如调整<code>bash</code>的<code>nice</code>值为 10：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">renice</span> <span class="token number">10</span> <span class="token number">104660</span>
<span class="token number">104660</span> <span class="token punctuation">(</span>process ID<span class="token punctuation">)</span> old priority <span class="token number">0</span>, new priority <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改了<code>bash</code>的<code>nice</code>值后，使用<code>bash</code>运行的命令也会继承这一<code>nice</code>值。也就是<code>nice</code>会由父程序传递给子程序。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程前后台切换</title>
    <url>/517799084/</url>
    <content><![CDATA[<h1 id="工作控制"><a class="markdownIt-Anchor" href="#工作控制"></a> 工作控制</h1>
<p>工作控制是一种由内核支持、shell 实现的功能，允许用户同时运行多个进程，其中一个进程在前台（foreground），其他进程在后台（background）运行。用户可以在前台和后台之间切换、挂起和显示进程状态。</p>
<p>将一个进程放入后台运行，该进程必须不需要与用户交互，且不能使用 Ctrl+c 来终止运行。</p>
<h1 id="后台运行"><a class="markdownIt-Anchor" href="#后台运行"></a> 后台运行</h1>
<p>在命令后加入空格和&amp;符号即可将进程放入后台运行，这也被称为异步进程（Asynchronous Process）运行程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> <span class="token number">1</span>.iso <span class="token parameter variable">-C</span> lost+found/ <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">36961</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>中括号内的数字为工作号码（job number），后续数字为工作在系统中的 PID。</p>
<p>后台工作完成后会给前台发信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Done                    <span class="token function">cp</span> <span class="token parameter variable">-i</span> <span class="token number">1</span>.iso <span class="token number">1</span>.copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>后台运行的工作如果有标准输出（stdout）和标准错误输出（stderr），依然会实时输出到屏幕。可以在执行时将这些数据重定向，以免影响前台工作。</p>
<h1 id="后台暂停"><a class="markdownIt-Anchor" href="#后台暂停"></a> 后台暂停</h1>
<p>使用 Ctrl+z 把当前的前台工作停止放到后台：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt 
-rw-r--r--.  <span class="token number">1</span> root root         <span class="token number">0</span> Sep <span class="token number">11</span> <span class="token number">10</span>:11 list_error.txt
-rw-r--r--.  <span class="token number">1</span> root root        <span class="token number">54</span> Sep <span class="token number">11</span> <span class="token number">10</span>:16 list.txt
^Z
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数字 2 表示这是后台中的第 2 个工作，加号 + 代表最近一个被丢进后台的工作。</p>
<h1 id="后台状态"><a class="markdownIt-Anchor" href="#后台状态"></a> 后台状态</h1>
<p>使用 <code>jobs</code> 命令查看当前后台工作状态。可用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>除了列出 job number 与命令外，同时列出 PID</td>
</tr>
<tr>
<td>-r</td>
<td>仅列出后台运行的工作</td>
</tr>
<tr>
<td>-s</td>
<td>仅列出后台暂停的工作</td>
</tr>
</tbody>
</table>
<p>使用 <code>-l</code> 参数查看当前后台工作状态与工作 PID：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">jobs</span> <span class="token parameter variable">-l</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>- <span class="token number">37687</span> Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root1.txt
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>+ <span class="token number">37698</span> Stopped                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> root.txt
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token number">37916</span> Running                 <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>加号 <code>+</code> 代表最近一个被放置到后台的工作，减号 <code>-</code> 代表倒数第二个被放置到后台中的工作，其他工作没有符号。</p>
<h1 id="后台转前台"><a class="markdownIt-Anchor" href="#后台转前台"></a> 后台转前台</h1>
<p>使用 <code>fg</code> 命令将后台工作转到前台处理。例如将 3 号工作取出到前台：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fg</span> %3
<span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="后台转运行"><a class="markdownIt-Anchor" href="#后台转运行"></a> 后台转运行</h1>
<p>使用 <code>bg</code> 命令启动后台暂停中工作为后台运行。例如将后台暂停的 3 号工作转为后台运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">bg</span> <span class="token variable">$3</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>+ <span class="token function">tail</span> <span class="token parameter variable">-f</span> list_error.txt <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="脱机运行"><a class="markdownIt-Anchor" href="#脱机运行"></a> 脱机运行</h1>
<p>由于登陆后在 shell 中运行的命令父进程是 bash，所以当 shell 会话中断时，后台的程序也会跟着被中断。</p>
<p>想要保持程序一直运行与终端状态脱离关系，可以使用 <code>nohup</code> 命令来处理。命令格式为：<code>nohup [命令与参数] &amp;</code></p>
<p>例如保持 <code>sh13.sh</code> 脚本脱机运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">nohup</span> ./sh13.sh <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">40062</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注销用户后重新登录，使用<code>ps</code>命令查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> sh13
root      <span class="token number">40062</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">113284</span>  <span class="token number">1184</span> ?        S    03:53   <span class="token number">0</span>:00 /bin/bash ./sh13.sh
root      <span class="token number">40219</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">112812</span>   <span class="token number">968</span> pts/0    S+   03:55   <span class="token number">0</span>:00 <span class="token function">grep</span> <span class="token parameter variable">--color</span><span class="token operator">=</span>auto sh13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到程序（PID=40062）依然在运行中，可以使用 <code>kill</code> 命令来终止运行。</p>
<p>程序的输出会被重定向到 <code>~/nohup.out</code> 文件。也可以手动指定 <code>1&gt;</code> 和 <code>2&gt;</code> 到其他文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 中程序与进程关系</title>
    <url>/630034191/</url>
    <content><![CDATA[<h1 id="进程与程序"><a class="markdownIt-Anchor" href="#进程与程序"></a> 进程与程序</h1>
<p>程序（Program）是可执行的二进制文件。</p>
<p>当触发执行程序动作后，程序内容及程序数据会加载到内存中，成为一个运行中的程序，即进程（Process）。</p>
<p>系统为这个进程分配一个 ID，称为 PID（Program ID）。同时，根据触发这个进程的用户及相关属性关系，为这个 PID 设置一组有效的权限。</p>
<h1 id="子进程与父进程"><a class="markdownIt-Anchor" href="#子进程与父进程"></a> 子进程与父进程</h1>
<p>登录系统后，会获得一个 bash 的 shell。通过 bash 提供的接口执行另一个命令，如 <code>vim</code>，它也会被分配一个 PID。此时，原本的 bash 就是 <code>vim</code> 的父进程。父进程的 PID 可以用 PPID（Parent ID）表示。</p>
<p>通常，子进程会继承父进程的相关权限和环境变量。</p>
<p>例如，在 bash 中执行 <code>bash</code>，再用<code>ps -l</code>命令查看：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">bash</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-l</span>
F S   <span class="token environment constant">UID</span>    PID   <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
<span class="token number">4</span> S     <span class="token number">0</span>   <span class="token number">5713</span>   <span class="token number">5709</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">28920</span> do_wai pts/0    00:00:00 <span class="token function">bash</span>
<span class="token number">4</span> S     <span class="token number">0</span>  <span class="token number">35555</span>   <span class="token number">5713</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">28919</span> do_wai pts/0    00:00:00 <span class="token function">bash</span>
<span class="token number">0</span> R     <span class="token number">0</span>  <span class="token number">35570</span>  <span class="token number">35555</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">38332</span> -      pts/0    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到第一个 bash 的 PID 5517 是第二个 bash 的 PPID。</p>
<h1 id="过程调用的流程"><a class="markdownIt-Anchor" href="#过程调用的流程"></a> 过程调用的流程</h1>
<p>父进程和子进程之间的互相调用过程通常称为 fork-and-exec 的流程。进程都会通过父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制的子进程再以 exec 的方式执行实际要进行的进程，最终成为一个子进程的存在。</p>
<p>其过程从上往下执行如下示意：</p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>状态</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>父进程</td>
<td>PID=x，程序=a</td>
</tr>
<tr>
<td>中间暂存进程</td>
<td>PID=y，程序=a，PPID=x</td>
</tr>
<tr>
<td>子进程</td>
<td>PID=y，程序=b，PPID=x</td>
</tr>
</tbody>
</table>
<h1 id="内部程序沟通"><a class="markdownIt-Anchor" href="#内部程序沟通"></a> 内部程序沟通</h1>
<p>在系统内，许多进程需要互相交换信息。除了通过文件进行沟通，还包括共享内存（Shared Memory）、消息队列（Message Queues）、管道（Pipe）等方式，统称为内部程序沟通（Interprocess Communication）。可以用命令 <code>ipcs</code> 观察沟通状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ ipcs

 Message Queues 
key        msqid      owner      perms      used-bytes   messages    

 Shared Memory Segments 
key        shmid      owner      perms      bytes      nattch     status      

 Semaphore Arrays 
key        semid      owner      perms      nsems   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过 <code>ipcrm</code> 命令将看到的 interprocess 删除。</p>
<h1 id="多用户与多任务环境"><a class="markdownIt-Anchor" href="#多用户与多任务环境"></a> 多用户与多任务环境</h1>
<p>多用户系统也叫分时系统（Time-Share System），指多个用户可以在同一时间使用计算机系统。与 Linux 相比，Windows 系统是单用户系统。</p>
<p>多任务是指 Linux 可以同时执行几个任务，它可以在还未执行完一个任务时又执行另一项任务。</p>
<p>每个用户权限不同，所以登录后获得的 shell 的 PID 不同。而 CPU 速度 1GHz 代表 CPU 每秒可以运行 10<sup>9</sup>次命令，每个工作都占用 CPU 的几个命令次数。Linux 可以让 CPU 在各个进程间进行切换。所以实际上，所谓多任务处理是 CPU 快速地执行多个任务，看上去就像它们同时被执行一样。CPU 切换进程的工作与这些工作进入到 CPU 运行的调度会影响到系统的整体性能。由于 CPU 性能出众，所以可以支持多个用户同时登录运行不同程序，这就是多用户与多任务环境。</p>
<h1 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h1>
<p>造成僵尸进程的原因是该进程应该已经执行完毕或因故应该要终止时，该进程的父进程很可能已经死亡，无法完整将该进程结束掉，而造成那个进程一直滞留在内存。</p>
<p>使用 <code>ps</code> 命令查看进程时，如果发现某个进程的 CMD 后面有 <code>&lt;defunct&gt;</code>，就代表该进程是僵尸进程。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 工作调度与定时任务</title>
    <url>/3847284551/</url>
    <content><![CDATA[<h1 id="系统例行性工作"><a class="markdownIt-Anchor" href="#系统例行性工作"></a> 系统例行性工作</h1>
<p>在 Linux 系统常见的例行性任务有：</p>
<ul>
<li>
<p><strong>进行日志文件的轮替</strong></p>
<p>Linux 会主动将系统所发生的各种事件都记录到日志文件，日志轮替会不时检查，将旧日志与新日志分别存放。</p>
</li>
<li>
<p><strong>日志文件分析</strong></p>
<p>CentOS 提供 <code>logwatch</code> 来主动分析日志信息。</p>
</li>
<li>
<p><strong>更新 locate 数据库</strong></p>
<p>默认每天都更新一次存放在 <code>/var/lib/mlocate</code> 中的数据库。</p>
</li>
<li>
<p><strong>更新 RPM 软件数据库</strong></p>
<p>由于系统中软件经常变更，需要系统帮我们将文件名做个排序记录，生成 RPM 数据库。</p>
</li>
<li>
<p><strong>删除临时文件</strong></p>
<p>系统通过调用 <code>tmpwatch</code> 命令来删除软件运行时所产生的不再需要的临时文件。</p>
</li>
<li>
<p><strong>与网络服务有关的分析行为</strong></p>
<p>如果安装了 WWW 服务器，系统会主动分析软件的入口文件。</p>
</li>
</ul>
<h1 id="单次工作调度"><a class="markdownIt-Anchor" href="#单次工作调度"></a> 单次工作调度</h1>
<p>单次工作调度任务主要由 atd 服务提供，使用 <code>at</code> 命令来生成所需要运行的工作，再将工作写入 <code>/var/spool/at</code> 目录内。</p>
<p>可以运行 <code>at</code> 的账号记录在 <code>/etc/at.allow</code> 中，禁止运行 <code>at</code> 的账号记录在 <code>/etc/at.deny</code> 中。如果两个文件都不存在，则只有 root 可以使用 <code>at</code> 命令。如果账号在两个文件中都有记录，以 <code>/etc/at.allow</code> 优先。</p>
<p>可以使用 <code>service</code> 命令查询启动 <code>atd</code> 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">service</span> atd status
Redirecting to /bin/systemctl status atd.service
a—? atd.service - Job spooling tools
   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/atd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>
   Active: inactive <span class="token punctuation">(</span>dead<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">service</span> atd start
Redirecting to /bin/systemctl start atd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置开机启动使用 <code>chkconfig</code> 配置或 <code>systemctl enable atd</code> 开启：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chkconfig</span> atd on
Note: Forwarding request to <span class="token string">'systemctl enable atd.service'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>at</code> 命令的基本语法为 <code>at [-mldv] 时间</code>，其中可以使用的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-m</td>
<td>当 <code>at</code> 的工作完成后，即使没有输出信息，也会发送邮件通知用户工作已完成</td>
</tr>
<tr>
<td>-l</td>
<td>相当于 <code>atq</code>，列出目前系统上所有该用户的 <code>at</code> 调度</td>
</tr>
<tr>
<td>-d</td>
<td>相当于 <code>atrm</code>，可以取消一个在 <code>at</code> 调度中的任务</td>
</tr>
<tr>
<td>-v</td>
<td>可以使用较明显的时间格式列出 <code>at</code> 调度中的任务列表</td>
</tr>
<tr>
<td>-c</td>
<td>可以列出后面接的该项工作的实际命令内容</td>
</tr>
</tbody>
</table>
<p><code>at</code> 命令还支持多种可用的时间格式，包括：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明（范例）</th>
</tr>
</thead>
<tbody>
<tr>
<td>HH:MM</td>
<td>在今天 HH:MM进行，若超时改在明天（15:00）</td>
</tr>
<tr>
<td>HH:MM YYYY-MM-DD</td>
<td>规定在特定日期和时间执行（16:32 2043-04-01）</td>
</tr>
<tr>
<td>HH:MM[am|pm] [M] [D]</td>
<td>规定在特定日期和时间进行（01pm March 23）</td>
</tr>
<tr>
<td>HH:MM[am|pm] + n [minutes|hours|days|weeks]</td>
<td>在某个时间点加上指定时间后进行（04am + 2 days）</td>
</tr>
</tbody>
</table>
<p>例如，设置在 1 分钟后运行 <code>ls /root</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ at now + 1minutes
at<span class="token operator">></span> <span class="token function">ls</span> /root
at<span class="token operator">></span> <span class="token operator">&lt;</span>EOT<span class="token operator">></span>
job <span class="token number">1</span> at Tue Sep <span class="token number">14</span> 00:22:00 <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>工作内容输入完毕后，使用 <code>Ctrl+d</code> 结束，系统会出现一行提示信息。</p>
<p>查询第 3 号任务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ at <span class="token parameter variable">-c</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>at</code> 执行命令产生的 <code>stdout</code> 和 <code>stderr</code> 会传送到执行者的邮箱。如果想在终端看到输出，可以重定向输出到 <code>/dev/tty1</code>（或 <code>pts/0</code>）。</p>
<p>删除一个 <code>at</code> 调度中的任务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ at <span class="token parameter variable">-l</span>
<span class="token number">7</span>       Tue Sep <span class="token number">14</span> <span class="token number">18</span>:15:00 <span class="token number">2021</span> a root
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ at <span class="token parameter variable">-d</span> <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>batch</code> 命令来控制在 CPU 工作负载小于 0.8 时执行。否则暂缓执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ batch
at<span class="token operator">></span> <span class="token function">sync</span>
at<span class="token operator">></span> <span class="token operator">&lt;</span>EOT<span class="token operator">></span>
job <span class="token number">9</span> at Tue Sep <span class="token number">14</span> 00:58:00 <span class="token number">2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="循环工作调度"><a class="markdownIt-Anchor" href="#循环工作调度"></a> 循环工作调度</h1>
<p>循环执行例行工作调度由 <code>crond</code> 这个系统服务控制。</p>
<p>调用 <code>cron</code> 的用户限制和 <code>at</code> 一样保存在文件中。允许账户保存在 <code>/etc/cron.allow</code>，禁止用户保存在 <code>/etc/cron.deny</code>。系统默认保留 <code>cron.deny</code>，也就是除了 <code>cron.deny</code> 中定义的用户外均可执行 <code>cron</code>。</p>
<p>用户使用 <code>crontab</code> 命令新建工作调度后，工作被记录到 <code>/var/spool/cron</code> 里面，而且以账号为分类分别建立文件。</p>
<p><code>cron</code> 执行的每一项工作都会被记录到 <code>/var/log/cron</code> 这个日志文件中。</p>
<p>命令语法: <code>crontab [-u username] [-l|-e|-r]</code></p>
<p>使用参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u</td>
<td>只有 root 可以调用，帮助其他用户新建/删除 <code>crontab</code> 工作调度</td>
</tr>
<tr>
<td>-e</td>
<td>编辑 <code>crontab</code> 的工作内容</td>
</tr>
<tr>
<td>-l</td>
<td>查询 <code>crontab</code> 的工作内容</td>
</tr>
<tr>
<td>-r</td>
<td>删除所有的 <code>crontab</code> 的工作内容</td>
</tr>
</tbody>
</table>
<p>例如每天 13:15 执行一次清空命令历史记录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">crontab</span> <span class="token parameter variable">-e</span>
no <span class="token function">crontab</span> <span class="token keyword">for</span> root - using an empty one
<span class="token number">15</span> <span class="token number">13</span> * * * <span class="token function">history</span> <span class="token parameter variable">-c</span>
<span class="token string">"/tmp/crontab.0bZmP6"</span> 1L, 22C written
crontab: installing new <span class="token function">crontab</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编辑 <code>cron</code> 时分为 6 个字段设置为：<code>分钟 小时 日期 月份 周 命令</code></p>
<p>周时间设置为 0 等同于 7 表示星期天。</p>
<p>设定时间时可用的一些特殊字符说明如下：</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*（星号）</td>
<td>代表任何时刻都接受的意思。例如日、月、周都是 *，代表无论何日的 13:15 都会执行</td>
</tr>
<tr>
<td>,（逗号）</td>
<td>代表分隔时段的意思，例如在小时字段设置 4,11,15 代表执行时间为 4 点、11 点和 15 点</td>
</tr>
<tr>
<td>-（减号）</td>
<td>代表一段时间范围，例如在小时字段设置 8-12 代表执行时间为 8 点到 12 点每小时执行一次</td>
</tr>
<tr>
<td>/n（斜线）</td>
<td>n 代表数字，即是每隔 n 单位间隔的意思。例如在分钟字段设置 <code>*/5</code> 代表每五分钟执行一次</td>
</tr>
</tbody>
</table>
<p><code>cron</code> 不可以使用“几月几号且为星期几”的模式工作，也就是在日、月、周都设置的情况下会报错</p>
<p>例如，每天在早上 7 点和下午 8 点执行 <code>/root/backup.sh</code> 备份脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">crontab</span> <span class="token parameter variable">-e</span>
*  <span class="token number">7,20</span> * * * <span class="token function">bash</span> /root/backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="系统例行调度"><a class="markdownIt-Anchor" href="#系统例行调度"></a> 系统例行调度</h1>
<p>系统例行性任务保存在 <code>/etc/crontab</code> 文件中。<code>cron</code> 每分钟会去读取一次 <code>/etc/crontab</code> 和 <code>/var/spool/cron</code>，所以直接编辑完 <code>/etc/crontab</code> 文件后保存退出即可添加系统调度工作。</p>
<p>查看 <code>/etc/crontab</code> 文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/crontab
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span class="token assign-left variable">MAILTO</span><span class="token operator">=</span>root

<span class="token comment"># For details see man 4 crontabs</span>
<span class="token comment"># Example of job definition:</span>
<span class="token comment"># .---------------- minute (0 - 59)</span>
<span class="token comment"># |  .------------- hour (0 - 23)</span>
<span class="token comment"># |  |  .---------- day of month (1 - 31)</span>
<span class="token comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="token comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span class="token comment"># |  |  |  |  |</span>
<span class="token comment"># *  *  *  *  * user-name  command to be executed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><strong>MAILTO</strong></p>
<p>表示将 <code>stdout</code> 和 <code>stderr</code> 用邮件发送给指定用户或指定邮箱。</p>
</li>
<li>
<p><strong>user-name</strong></p>
<p>执行命令使用的用户身份，例如 <code>root</code>。</p>
</li>
<li>
<p><strong>command to be executed</strong></p>
<p>除了直接运行命令外，还可以以目录为目标批量运行脚本。例如 <code>run-parts /etc/cron.hourly</code>，意思代表将 <code>/etc/cron.hourly/</code> 目录下的所有脚本执行。</p>
</li>
</ul>
<h1 id="唤醒停机期间的工作任务"><a class="markdownIt-Anchor" href="#唤醒停机期间的工作任务"></a> 唤醒停机期间的工作任务</h1>
<p>如果在<code>crond</code>设定的任务运行时段系统已关机，那么需要借助<code>anacron</code>将关机期间系统<code>crontab</code>运行。</p>
<p><code>anacron</code>以小时为单位或在开机后立刻进行检查，将停机期间没有进行的<code>crontab</code>任务执行一遍。</p>
<p>一般不用修改<code>anacron</code>的默认设置，需要手动执行<code>anacron</code>命令语法如下：</p>
<p><code>anacron [-sfn] [job]..</code></p>
<p><code>anacron -u [job]..</code></p>
<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s</td>
<td>开始连续执行各项工作，会依据时间记录文件的数据判断是否进行</td>
</tr>
<tr>
<td>-f</td>
<td>强制进行，不判断事件记录文件的时间戳</td>
</tr>
<tr>
<td>-n</td>
<td>立刻进行未进行的任务，而不延迟等待时间</td>
</tr>
<tr>
<td>-u</td>
<td>仅更新事件记录文件的时间戳，不进行任何工作</td>
</tr>
<tr>
<td>job</td>
<td>由<code>/etc/anacrontab</code>定义的各项工作名称</td>
</tr>
</tbody>
</table>
<p>查看<code>/etc/anacrontab</code>文件的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/anacrontab 
<span class="token comment"># /etc/anacrontab: configuration file for anacron</span>
<span class="token comment"># See anacron(8) and anacrontab(5) for details.</span>
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/sh
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span class="token assign-left variable">MAILTO</span><span class="token operator">=</span>root
<span class="token comment"># the maximal random delay added to the base delay of the jobs</span>
<span class="token assign-left variable">RANDOM_DELAY</span><span class="token operator">=</span><span class="token number">45</span>
<span class="token comment"># the jobs will be started during the following hours only</span>
<span class="token assign-left variable">START_HOURS_RANGE</span><span class="token operator">=</span><span class="token number">3</span>-22

<span class="token comment">#period in days   delay in minutes   job-identifier   command</span>
<span class="token number">1</span>       <span class="token number">5</span>       cron.daily              <span class="token function">nice</span> run-parts /etc/cron.daily
<span class="token number">7</span>       <span class="token number">25</span>      cron.weekly             <span class="token function">nice</span> run-parts /etc/cron.weekly
@monthly <span class="token number">45</span>     cron.monthly            <span class="token function">nice</span> run-parts /etc/cron.monthly<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>任务设置分别为四个字段：执行间隔天数、延迟时间（分钟）、工作名称、实际命令。</p>
<p>查看<code>/var/spool/anacron/cron.daily</code>文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /var/spool/anacron/cron.daily
<span class="token number">20210913</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>用每天进行的任务分析一下<code>anacron</code>的执行过程：</p>
<ol>
<li>由<code>/etc/anacrontab</code>分析到<code>cron.daily</code>这项工作的天数为 1 天；</li>
<li>由<code>/var/spool/anacron/cron.daily</code>取出最近一次执行<code>anacron</code>的时间戳；</li>
<li>将取出的时间与目前的时间比较，如果差异天数大于等于 1 天旧准备进行命令；</li>
<li>根据<code>/etc/anacrontab</code>的设置将延迟 5 分钟；</li>
<li>延迟时间过后开始执行后续命令，即<code>run-parts /etc/cron.daily</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Sed 命令简单使用</title>
    <url>/507701603/</url>
    <content><![CDATA[<h1 id="字符流编辑器"><a class="markdownIt-Anchor" href="#字符流编辑器"></a> 字符流编辑器</h1>
<p>SED 是一个非交互式的面向字符流的编辑器（Stream Editor），输入流通过程序并输出直接送到标准输出端，<strong>输入文件本身不会发生改变</strong>，是操作、过滤和转换文本内容的强大工具。</p>
<p>SED 可以把输出重定向到文件，但不允许直接送到输入文件。</p>
<p>命令语法：<code>sed [-nefr] [动作]</code>。</p>
<p>主要参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>使用安静模式。只有被处理后的数据才会被列出来。</td>
</tr>
<tr>
<td>-e</td>
<td>直接在命令行模式上进行 sed 的动作编辑。</td>
</tr>
<tr>
<td>-f</td>
<td>指定加载的 sed 脚本。</td>
</tr>
<tr>
<td>-r</td>
<td>设置成支持扩展型正则表达式，默认是基础正则表达式。</td>
</tr>
<tr>
<td>-i</td>
<td>直接修改读取的文件内容，不在屏幕输出。</td>
</tr>
</tbody>
</table>
<p>动作说明：</p>
<p><code>[n1 [,n2]] function</code></p>
<p>function 参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>新增，在当前行后添加一行或多行。</td>
</tr>
<tr>
<td>c</td>
<td>替换行，c 后面接字符串，替换 n1，n2 之间的行。</td>
</tr>
<tr>
<td>d</td>
<td>删除行，只会删除输出中的内容，必须提供地址访问。</td>
</tr>
<tr>
<td>i</td>
<td>插入，在当前行之前插入文本。</td>
</tr>
<tr>
<td>s</td>
<td>替换数据，可以直接进行替换的工作。</td>
</tr>
<tr>
<td>p</td>
<td>打印，和 -n 一起合用来屏蔽 sed 的默认输出。</td>
</tr>
<tr>
<td>q</td>
<td>第一个模式匹配完成后立即退出。</td>
</tr>
<tr>
<td>r</td>
<td>从文件中读取输入行，类似重定向 &lt;。</td>
</tr>
<tr>
<td>=</td>
<td>显示文件行号。</td>
</tr>
<tr>
<td>!</td>
<td>对所选以外的所有行应用命令。</td>
</tr>
</tbody>
</table>
<p>替换标志（Substitution Flag）：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>表示替换行内第 n 次匹配的值。</td>
</tr>
<tr>
<td>i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td>g</td>
<td>在行内进行全局替换，不设置只会替换每行第一次出现的原始字段。</td>
</tr>
<tr>
<td>p</td>
<td>只打印替换过的行。</td>
</tr>
<tr>
<td>w</td>
<td>将行写入文件。</td>
</tr>
</tbody>
</table>
<h1 id="寻址模式"><a class="markdownIt-Anchor" href="#寻址模式"></a> 寻址模式</h1>
<ul>
<li>
<p><strong>addr1,add2</strong></p>
<p>定址 addr1, addr2 决定用于对哪些行进行编辑。地址的形式可以是数字、正则表达式或二者结合。</p>
<p>如果没有指定地址，sed 将处理输入文件中的所有行。</p>
<p>如果定址是一个数字，则这个数字代表行号。</p>
<p>如果是逗号分隔的两个行号，那么需要处理的定址就是两行之间的范围（包括两行在内）。</p>
</li>
<li>
<p><strong>addr1,+N</strong></p>
<p>从 addr1 这行到往下 N 行匹配，总共匹配 N+1 行。</p>
</li>
<li>
<p><strong>first~step</strong></p>
<p>first 指起始匹配行，step 指步长，例如 <code>sed -n 2~5p</code> 表示从第 2 行开始匹配，隔 5 行匹配一次，即 2，7，12…</p>
</li>
<li>
<p><strong>$</strong></p>
<p>表示匹配最后一行。</p>
</li>
<li>
<p><strong>/REGEXP/</strong></p>
<p>表示匹配正则那一行，通过 // 之间的正则来匹配。</p>
</li>
<li>
<p><strong>\cREGEXPc</strong></p>
<p>表示匹配正则那一行，通过 \c 和 c 之间的正则来匹配，c 可以是任一字符。</p>
</li>
</ul>
<h1 id="在命令行使用"><a class="markdownIt-Anchor" href="#在命令行使用"></a> 在命令行使用</h1>
<p>例如打印并替换 <code>list</code> 文件中的 <code>BOB</code> 为 <code>Candy</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token string">'s/BOB/Candy/'</span> list
Alice eats apples.
Bob pets cats.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同时多个替换命令可以在 ‘’ 内使用；分割两个指令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token string">'s/BOB/Candy/;s/aaa/bbb/'</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以用 <code>-e</code> 参数来运行多条指令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'s/BOB/Candy/'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/aaa/bbb/'</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>把单引号 ‘’ 内的内容用大括号 <code>&#123;&#125;</code> 括起来，可以多行输入执行多条命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'&#123;
s/i/@/
s/@/III/p
&#125;'</span> test.txt
<span class="token number">102</span>,Jason SmIIIth,IT Manager
<span class="token number">103</span>,Raj Reddy,SysadmIIIn
<span class="token number">105</span>,Jane MIIIller,Sales Manager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="在脚本中使用"><a class="markdownIt-Anchor" href="#在脚本中使用"></a> 在脚本中使用</h1>
<p>在 sed 和 awk 中，每个指令都包括模式和过程。</p>
<p>模式是由斜杠 / 分割的正则表达式。</p>
<p>过程指定一个或多个将被执行的动作，过程必须用大括号括起。</p>
<p><strong>Sed 脚本执行流程:</strong></p>
<ol>
<li>sed 每次从 input-file 中读取一行记录，并执行命令，也就是会在第一行运用脚本所有内容。</li>
<li>处理下一行，直到文件结束。</li>
<li>脚本执行遵从下面简单易记的顺序：Read，Execute，Print，Repeat（读取，执行，打印，重复），简称 REPR。</li>
</ol>
<p>调用时直接在 <code>-f</code> 参数后接脚本名。例如用 <code>SED.sed</code> 脚本处理 <code>list</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-f</span> SED.sed list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>脚本中命令一行单独一条命令即可。</p>
<h1 id="打印显示"><a class="markdownIt-Anchor" href="#打印显示"></a> 打印显示</h1>
<p>使用<code>p</code>动作将文件内容打印出来。例如从第 3 行打印到最后一行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'3,$p'</span> c.cfg 
<span class="token number">1.4</span>
1a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>打印正则匹配<code>halt</code>开头的行到<code>operator</code>开头的行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/^halt/,/^operator/p'</span> b.cfg 
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="写入到文件"><a class="markdownIt-Anchor" href="#写入到文件"></a> 写入到文件</h1>
<p>使用 <code>w</code> 动作将指定内容写入到文件中，而不是在屏幕显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'1,3 w cnew.txt'</span> c.cfg<span class="token punctuation">;</span><span class="token function">cat</span> cnew.txt
abcac
abc<span class="token punctuation">\</span>n
<span class="token number">1.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用<code>-i</code>参数，则直接将修改应用到文件。例如去除文件中的#注释行和空行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-r</span> <span class="token string">'/^#|^$/d'</span> ac.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="删除指定行"><a class="markdownIt-Anchor" href="#删除指定行"></a> 删除指定行</h1>
<p>使用<code>d</code>动作定义要删除的范围。例如将文件内容 2 到 5 行删除并打印：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">nl</span> b.cfg <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5d'</span>
     <span class="token number">1</span>  root:x:0:0:root:/root:/bin/bash
     <span class="token number">6</span>  sync:x:5:0:sync:/sbin:/bin/sync
     <span class="token number">7</span>  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除第一次匹配到的<code>sync</code>行，并删除后面 2 行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">nl</span> b.cfg <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/sync/,+2d'</span>
     <span class="token number">4</span>  adm:x:3:4:adm:/var/adm:/sbin/nologin
     <span class="token number">5</span>  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
     <span class="token number">9</span>  mail:x:8:12:mail:/var/spool/mail:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据</h1>
<p>使用 <code>a</code> 或 <code>i</code> 动作将字符串插入到指定行之后或之前：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">'/^root/a 1999'</span> b.cfg 
root:x:0:0:root:/root:/bin/bash
<span class="token number">1999</span>
bin:x:1:1:bin:/bin:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>增加多行内容可以用 <code>\</code> 来断行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">'/^root/a 1999 \
2000 
'</span> b.cfg
root:x:0:0:root:/root:/bin/bash
<span class="token number">1999</span> 
<span class="token number">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="替换数据"><a class="markdownIt-Anchor" href="#替换数据"></a> 替换数据</h1>
<p>整行替换使用<code>c</code>动作将行内容替换成指定内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">'/^root/c 1999 \'</span> b.cfg 
<span class="token number">1999</span> 
bin:x:1:1:bin:/bin:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以行为单位替换行内数据使用<code>s</code>动作。格式为：<code>'s/要被替换的字符串/新字符串/替换标记'</code></p>
<p>例如将配置文件内<code>root</code>行的的<code>notempty</code>替换成<code>emptyok</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token string">'/root/s/notempty/emptyok/g'</span> a.cfg <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'empty'</span>
pwpolicy root <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span>
pwpolicy user <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span>
pwpolicy luks <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了使用全局替换的<code>g</code>标志外，还可以使用数字来表示替换行内第几次匹配结果。</p>
<p>例如替换每行第 2 次出现的<code>a</code>为<code>A</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token string">'s/a/A/2'</span> c.cfg 
abcAca
abc<span class="token punctuation">\</span>nA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>还有<code>p</code>标记，用来只打印修改后的行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'s/a/A/3p'</span> c.cfg 
abcacA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以自由设置<strong>分界符号</strong>，这样可以方便使用作为字符串的<code>/</code>符号。</p>
<p>例如使用<code>@</code>作为分界符，替换文件中的<code>/root/etc/</code>为<code>/etc/</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token string">'s@/root/etc/@/etc/@'</span> c.cfg 
abcaca
/etc/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>替换位置为<code>&amp;</code>时，代表它会被替换成匹配到的被替换字符串或正则表达式。</p>
<p>例如将行号数字用大括号<code>&#123;&#125;</code>括起来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">nl</span> c.cfg <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[0-9]/&#123;&amp;&#125;/1'</span>
     <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>        abcaca
     <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">&#125;</span>        /root/etc/
     <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">&#125;</span>        <span class="token number">1.4</span>
     <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">&#125;</span>        1a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sed</code>支持<strong>分组替换</strong>，每个分组数据用<code>()</code>括起来。</p>
<p>例如抽取第 1 和 3 组分组数据，并在第 3 分组数据用<code>[]</code>括起来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">'s/(^[a-z]+)(\:.)(\:[0-9]+\:).*/\1[\3]/g'</span> b.cfg
root<span class="token punctuation">[</span>:0:<span class="token punctuation">]</span>
bin<span class="token punctuation">[</span>:1:<span class="token punctuation">]</span>
daemon<span class="token punctuation">[</span>:2:<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 中文件属性详解</title>
    <url>/1872252014/</url>
    <content><![CDATA[<h1 id="查看文件属性"><a class="markdownIt-Anchor" href="#查看文件属性"></a> 查看文件属性</h1>
<p>执行 <code>ls -la</code> 命令后，可以查看当前目录下所有文件的权限和属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-la</span>
total <span class="token number">32</span>
dr-xr-x---.  <span class="token number">4</span> root root  <span class="token number">175</span> Sep  <span class="token number">8</span> <span class="token number">22</span>:48 <span class="token builtin class-name">.</span>
dr-xr-xr-x. <span class="token number">17</span> root root  <span class="token number">224</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:37 <span class="token punctuation">..</span>
-rw-------.  <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:38 anaconda-ks.cfg
-rw-------.  <span class="token number">1</span> root root  <span class="token number">847</span> Sep  <span class="token number">8</span> <span class="token number">12</span>:32 .bash_history
-rw-r--r--.  <span class="token number">1</span> root root   <span class="token number">18</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .bash_logout
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">176</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .bash_profile
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">176</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .bashrc
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">100</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .cshrc
drwxr-xr-x.  <span class="token number">2</span> root root    <span class="token number">6</span> Sep  <span class="token number">8</span> <span class="token number">22</span>:48 dir1
drwxr-----.  <span class="token number">3</span> root root   <span class="token number">19</span> Sep  <span class="token number">7</span> 05:51 .pki
-rw-r--r--.  <span class="token number">1</span> root root  <span class="token number">129</span> Dec <span class="token number">28</span>  <span class="token number">2013</span> .tcshrc
-rw-------.  <span class="token number">1</span> root root  <span class="token number">508</span> Sep  <span class="token number">7</span> 05:52 .viminfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>total 为该目录下的所有数据所占用的实际块数量乘以块大小的值。</p>
<p>从左到右以空格分隔成七列，分别代表：类型和权限、连接数、所有者、所有组、大小、修改时间、文件名。</p>
<h1 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h1>
<p>第一列第一个字段用来表示文件的类型，文件类型有下面几种：</p>
<table>
<thead>
<tr>
<th><strong>标记</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件</td>
<td>文本文件、数据文件、可执行程序等都作为普通文件存储。</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
<td>目录不存放常规数据，它用来组织访问其他文件。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
<td>指处理数据时每次只能处理一个字符的设备，例如鼠标、键盘（一次性读取设备）。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件</td>
<td>指处理数据时每次能处理大块数据的设备，例如硬盘。</td>
</tr>
<tr>
<td>s</td>
<td>本地域套接字</td>
<td>实现进程间通信的连接，本地域套接字由系统调用 socket 创建。</td>
</tr>
<tr>
<td>p</td>
<td>有名管道(FIFO)</td>
<td>让运行在同一主机上的两个进程相互通信，和 socket 文件相似。</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
<td>也叫做软链接（Linkfile），通过名字指向文件。</td>
</tr>
</tbody>
</table>
<p>执行 <code>ls</code> 命令后，文件的颜色有以下含义：</p>
<table>
<thead>
<tr>
<th><strong>颜色</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>灰色</td>
<td>普通文件</td>
</tr>
<tr>
<td>蓝色</td>
<td>目录</td>
</tr>
<tr>
<td>绿色</td>
<td>可执行文件</td>
</tr>
<tr>
<td>黄色</td>
<td>特殊文件</td>
</tr>
<tr>
<td>红色</td>
<td>压缩文件</td>
</tr>
</tbody>
</table>
<h1 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h1>
<p>第一列后九个字段以三个为一组，分别表示：</p>
<ul>
<li>文件所有者权限</li>
<li>同用户组权限</li>
<li>其他用户权限</li>
</ul>
<p>权限为 “rwx” 的三个参数组合，没有权限显示为 “-” 减号。</p>
<h1 id="连接节点"><a class="markdownIt-Anchor" href="#连接节点"></a> 连接节点</h1>
<p>第二列数字表示节点，每个文件都会将它的权限与属性记录到文件系统的 inode 中。</p>
<p>这个属性记录的就是有多少不同的文件名连接到相同的一个 inode 号码。</p>
<h1 id="所有者所有组"><a class="markdownIt-Anchor" href="#所有者所有组"></a> 所有者/所有组</h1>
<p>第三列和第四列分别表示文件所属的用户和用户组。</p>
<h1 id="文件大小"><a class="markdownIt-Anchor" href="#文件大小"></a> 文件大小</h1>
<p>第五列表示文件的容量大小，默认单位为 Bytes。</p>
<p>目录显示的大小不是文件夹大小，而是目录元数据的大小。</p>
<h1 id="修改日期"><a class="markdownIt-Anchor" href="#修改日期"></a> 修改日期</h1>
<p>第六列为文件的创建日期或最近修改时间。</p>
<p>如果修改时间距离太久，那时间部分会显示成年份。</p>
<h1 id="文件名"><a class="markdownIt-Anchor" href="#文件名"></a> 文件名</h1>
<p>第七列为文件名或文件夹名。</p>
<p>Linux 的文件名是大小写敏感的。</p>
<p>文件或目录名的第一个字母是 “.” 表示隐藏文件。</p>
<p><strong>文件名规则</strong>：</p>
<ul>
<li>由大写字母、小写字母、数字和一些特殊符号组成；</li>
<li>不可以包含 * ? &lt; &gt; ( ) [ ] { } / \ | &quot; ` ＆ ; ! 等符号；</li>
<li>＋-可以出现在文件名中，但是不能作为文件名中的第一个字母；</li>
<li>文件名中一般不应该包含空格；</li>
<li>使用 Ext 文件系统时，文件名最长 255 个字符，路径最长 4096 个字符。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件与目录权限</title>
    <url>/46662635/</url>
    <content><![CDATA[<h1 id="基本权限"><a class="markdownIt-Anchor" href="#基本权限"></a> 基本权限</h1>
<p>基本权限有三种，分别是：读（r，Read）、写（w，Write）、执行（x，eXecute）。</p>
<p>同样的权限标记对于文件和目录代表不同的意义。</p>
<h2 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h2>
<p>文件包括一般文本文件、数据库和二进制可执行文件。文件权限只针对文件内容而言，和改名、删除等操作无关。</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>字符</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>r</td>
<td>读取文件内容。例如使用 <code>cat</code> 命令查看，使用 <code>vim</code> 以只读方式打开。</td>
</tr>
<tr>
<td>2</td>
<td>w</td>
<td>编辑修改文件内容，但不包括删除文件。例如使用 <code>vim</code>、<code>sed</code> 等对文件内容进行修改并保存。</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>文件具有可以被系统执行的权限。例如命令和脚本必须拥有此权限才能直接执行。</td>
</tr>
</tbody>
</table>
<h2 id="目录权限"><a class="markdownIt-Anchor" href="#目录权限"></a> 目录权限</h2>
<p>目录主要的内容是记录文件名清单，所以目录权限实际关联的是目录下文件属性查看与更改。</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>字符</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>r</td>
<td>仅查询目录下的文件或目录名称，无法看到属性，相当于执行不加参数的 <code>ls</code> 命令。</td>
</tr>
<tr>
<td>2</td>
<td>w</td>
<td>改变目录结构清单权限，也就是在目录下新建、删除、重命名文件或目录。</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>进入目录的权限，查询目录下的文件属性。</td>
</tr>
</tbody>
</table>
<h1 id="权限参考"><a class="markdownIt-Anchor" href="#权限参考"></a> 权限参考</h1>
<p>根据使用场景来配置权限。</p>
<p><strong>用户进入目录所需权限</strong>：</p>
<ul>
<li>目录需要 x 权限，来运行 <code>cd</code> 切换目录。</li>
<li>目录需要 r 权限，来使用 <code>ls</code> 命令查看目录中文件列表。</li>
</ul>
<p><strong>用户读取目录内文件所需权限</strong>：</p>
<ul>
<li>目录需要 x 权限来进入目录。</li>
<li>文件需要 r 权限来运行 <code>cat</code>、<code>more</code> 等读取文件命令。</li>
</ul>
<p><strong>用户修改目录内文件所需权限</strong>：</p>
<ul>
<li>目录需要 x 权限来进入目录。</li>
<li>文件需要 r 和 w 权限来使用 <code>vi</code> 等工具进行文件读写。</li>
</ul>
<p><strong>用户创建一个文件所需权限</strong>：</p>
<ul>
<li>目录需要 w 和 x 权限来创建文件。</li>
</ul>
<p><strong>用户执行目录下的命令所需权限</strong>：</p>
<ul>
<li>目录需要 x 权限来进入目录。</li>
<li>文件需要 x 权限来运行命令。</li>
</ul>
<h1 id="特殊权限"><a class="markdownIt-Anchor" href="#特殊权限"></a> 特殊权限</h1>
<p>在 Linux 系统中，还有一些特殊权限。</p>
<h2 id="suid"><a class="markdownIt-Anchor" href="#suid"></a> SUID</h2>
<p>当 s 标志出现在文件所有者的 x 权限上时，被称为 Set UID，其含义为：</p>
<ul>
<li>SUID 权限仅对二进制程序有效，不能用在脚本上；</li>
<li>执行者对该程序需要具有 x 的可执行权限；</li>
<li>本权限仅在执行该程序的过程中（run-time）有效；</li>
<li>执行者将具有该程序所有者的权限。</li>
</ul>
<p>例如一般用户运行 <code>passwd</code> 命令修改密码，需要修改 <code>/etc/shadow</code> 文件。但是该文件的权限只有 root 可读写，而用户运行 passwd 程序时，会暂时获得 passwd 程序的 root 权限，从而可以通过 <code>passwd</code> 命令修改 <code>/etc/shadow</code> 文件。</p>
<p>这是因为运行 <code>passwd</code> 后会启动一个新的进程，该进程会产生一个新的 PID。在该 PID 产生时，SUID 会给予该 PID 特殊的权限设置，使得执行者在该进程中具有该程序所有者的权限。</p>
<h2 id="sgid"><a class="markdownIt-Anchor" href="#sgid"></a> SGID</h2>
<p>当 s 标志出现在文件所属组的 x 权限上时，被称为 Set GID。SGID 可以针对文件或目录来设置。</p>
<p>针对文件，SGID 有以下功能：</p>
<ul>
<li>SGID 对二进制程序有效；</li>
<li>程序执行者对该程序来说，需要具备 x 的权限；</li>
<li>执行者在执行的过程中将会获得该程序所属组的权限。</li>
</ul>
<p>例如，一般用户使用 <code>locate</code> 这个程序可以查询 <code>/var/lib/mlocate/mlocate.db</code> 文件的内容，会暂时获得 slocate 用户组的权限。</p>
<p>针对目录，SGID 有以下功能：</p>
<ul>
<li>用户若对此目录具有 r 和 x 的权限时，该用户能够进入此目录；</li>
<li>用户在此目录下的有效用户组将会变成该目录的用户组；</li>
<li>若用户在此目录下具有 w 的权限，则用户所创建的新文件的所属组与此目录的所属组相同。</li>
</ul>
<h2 id="sbit"><a class="markdownIt-Anchor" href="#sbit"></a> SBIT</h2>
<p>当 t 出现在文件所有者的其他用户 x 权限上时，被称为 Sticky Bit。其含义为：</p>
<ul>
<li>SBIT 权限仅对目录有效；</li>
<li>当用户对该目录具有 w 和 x 权限时，即具有写入权限时；</li>
<li>当用户在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件。</li>
</ul>
<p>例如，用户 1 对目录 A 具有 w 的权限，里面还有其他用户的文件。此时，目录 A 加上了 SBIT 权限时，用户 1 只能修改自己创建的文件，无法删除他人文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 主流文件系统</title>
    <url>/2794564793/</url>
    <content><![CDATA[<h1 id="查看文件系统支持"><a class="markdownIt-Anchor" href="#查看文件系统支持"></a> 查看文件系统支持</h1>
<p>Linux 系统现支持的文件系统格式如下：</p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ext</td>
<td>Linux 扩展文件系统（Extended Filesystem），最早的 Linux 文件系统。</td>
</tr>
<tr>
<td>ext2</td>
<td>第 2 代扩展文件系统，在 ext 的基础上提供了更多的功能。ext2 支持 undelete（反删除）和大文件。</td>
</tr>
<tr>
<td>ext3</td>
<td>第 3 代扩展文件系统，支持日志功能。ext3 支持大文件。但不支持反删除（undelete）操作。</td>
</tr>
<tr>
<td>ext4</td>
<td>第 4 代扩展文件系统，支持高级日志功能。</td>
</tr>
<tr>
<td>hpfs</td>
<td>OS/2 高性能文件系统</td>
</tr>
<tr>
<td>jfs</td>
<td>IBM 日志文件系统。</td>
</tr>
<tr>
<td>iso9660</td>
<td>ISO 9660 文件系统（CD-ROM）。</td>
</tr>
<tr>
<td>minix</td>
<td>MINIX 文件系统。</td>
</tr>
<tr>
<td>msdos</td>
<td>微软的 FAT16。</td>
</tr>
<tr>
<td>ncp</td>
<td>Netware 文件系统。</td>
</tr>
<tr>
<td>nfs</td>
<td>网络文件系统。</td>
</tr>
<tr>
<td>ntfs</td>
<td>支持 Microsoft NT 文件系统。</td>
</tr>
<tr>
<td>proc</td>
<td>访问系统信息。</td>
</tr>
<tr>
<td>ReiserFS</td>
<td>高级 Linux 文件系统，支持大文件，支持反删除，几乎能恢复 90% 以上的数据，有时能恢复到 100%。</td>
</tr>
<tr>
<td>smb</td>
<td>支持网络访问的 Samba SMB 文件系统。</td>
</tr>
<tr>
<td>sysv</td>
<td>较早期的 Unix 文件系统。</td>
</tr>
<tr>
<td>ufs</td>
<td>BSD 文件系统。</td>
</tr>
<tr>
<td>umsdos</td>
<td>建立在 msdos 上的类 Unix 文件系统。</td>
</tr>
<tr>
<td>vfat</td>
<td>Windows 95 文件系统（FAT32）。</td>
</tr>
<tr>
<td>XFS</td>
<td>高性能 64 位日志文件系统。</td>
</tr>
</tbody>
</table>
<p>可以通过查看 <code>fs</code> 目录了解支持的文件系统有哪些：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /lib/modules/<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">)</span></span>/kernel/fs
total <span class="token number">20</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">5992</span> Aug <span class="token number">31</span> <span class="token number">11</span>:05 binfmt_misc.ko.xz
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">25</span> Sep  <span class="token number">7</span> 05:54 btrfs
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">30</span> Sep  <span class="token number">7</span> 05:54 cachefiles
drwxr-xr-x. <span class="token number">2</span> root root   <span class="token number">24</span> Sep  <span class="token number">7</span> 05:54 ceph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看系统目前已加载到内存中支持的文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   ramfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>整个 Linux 系统都是通过虚拟文件系统（VFS，Virtual Filesystem Switch）的内核功能来读取文件系统。虚拟文件系统会管理各种文件系统中的数据，并统一提供给系统调用使用。</p>
<h1 id="日志式文件系统"><a class="markdownIt-Anchor" href="#日志式文件系统"></a> 日志式文件系统</h1>
<p>Linux 中有三种广泛使用的日志文件方法，每种的保护等级都不相同：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据模式</td>
<td>索引节点和文件都会被写入日志。所有写入储存设备的数据都要写两次，因此数据安全但性能较差。</td>
</tr>
<tr>
<td>有序模式</td>
<td>只有索引节点数据会被写入日志，数据写入成功后立即删除。</td>
</tr>
<tr>
<td>回写模式</td>
<td>只有索引节点数据会被写入日志，但不控制文件数据何时写入。</td>
</tr>
</tbody>
</table>
<h2 id="异步处理"><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h2>
<p>当系统加载一个文件到内存后，如果长时间没有改动，则内存区段中的文件数据会被设置为 clean。如果更改了，则设置为 dirty。系统会不定时将内存中设置为 dirty 的数据写回磁盘。这个过程叫做异步处理（Asynchronously）。</p>
<ul>
<li>系统会将常用的文件数据放置在主储存器的缓冲区，以加速文件系统的读写。</li>
<li>可以通过 <code>sync</code> 命令将 dirty 数据写回到硬盘。</li>
<li>正常关机时会调用 <code>sync</code> 将内存中数据写回到硬盘。</li>
<li>非正常关机时可能会造成数据损毁。日志文件系统下次启动时会读取日志文件并处理上次留下的未写入的数据。</li>
</ul>
<h2 id="数据不一致状态"><a class="markdownIt-Anchor" href="#数据不一致状态"></a> 数据不一致状态</h2>
<p>假如文件写入过程中突然断电，写入的数据仅有 inode table 和 data block，最后一个同步更新中间数据的步骤没有完成就会发生数据不一致状态（Inconsistent）。</p>
<p>在 Ext2 文件系统中发生这个问题，系统在重启后会通过 Super Block 当中记录的 valid bit（是否有挂载）与文件系统的 state 等状态判断是否强制进行数据一致性的检查，需要的话运行磁盘扫描程序。</p>
<h2 id="日志文件系统种类"><a class="markdownIt-Anchor" href="#日志文件系统种类"></a> 日志文件系统种类</h2>
<p>日志文件系统（Journaling file system）为了避免文件系统不一致的情况发生，在文件系统中规划出一个块，用来记录写入或修改文件时的步骤。</p>
<ul>
<li>当系统要写入一个文件时，会先在日志记录块中记录该文件准备要写入的信息。</li>
<li>当完成数据与元数据的更新后，将该文件的记录标记为完成。</li>
<li>这样当出现问题时，系统只需检查日志记录块，就知道哪个文件发生了问题，从而进行一致性检查。</li>
</ul>
<p>在上述示例中的 <code>/dev/sdb1</code> 中，journal 块指向 inode 8 号记录，其容量为 16MB，用于处理日志记录。</p>
<p>常见的日志文件系统类型如下：</p>
<ul>
<li>
<p><strong>ext3 文件系统</strong></p>
</li>
<li>
<p>采用与 ext2 文件系统相同的索引节点表结构，但为每个存储设备增加了一个日志文件，将准备写入存储设备的数据先记录在日志中。</p>
<ul>
<li>默认情况下，ext3 文件系统使用有序模式的日志功能。也可以在创建文件系统时添加选项，将日志方法更改为数据模式或回写模式。</li>
</ul>
</li>
<li>
<p><strong>ext4 文件系统</strong></p>
<ul>
<li>除了支持数据压缩和加密，ext4 文件系统还引入了一种称为&quot;区段&quot;（Extent）的特性。区段在存储设备上按块分配空间，但在索引节点表中只保留起始块的位置。</li>
<li>另一个特性是块预分配技术（Block Preallocation）。如果要为一个会变大的文件预留空间，ext4 文件系统可以为该文件预分配所有需要的块，并使用 0 填充。</li>
</ul>
</li>
<li>
<p><strong>Reiser 文件系统</strong></p>
<ul>
<li>ReiserFS 文件系统仅支持回写日志模式，并具有两个特性。</li>
<li>第一个特性是在线调整已有文件系统的大小。</li>
<li>第二个特性是尾部压缩处理（Tailpacking），可以将一个文件的数据填入另一个文件的数据块中的空白空间，从而节省容量。</li>
</ul>
</li>
<li>
<p><strong>JFS 文件系统</strong></p>
<ul>
<li>JFS 文件系统采用有序日志方法。其特点是采用基于区段的文件分配，为每个写入存储设备的文件分配一组块，以减少存储设备上的碎片。</li>
</ul>
</li>
<li>
<p><strong>XFS 文件系统</strong></p>
<ul>
<li>XFS 文件系统采用回写日志模式，并与 Reiser 类似，支持在线调整文件系统大小。</li>
<li>需要注意的是，XFS 文件系统只能扩容，无法缩容。</li>
</ul>
</li>
</ul>
<h1 id="ext-文件系统结构"><a class="markdownIt-Anchor" href="#ext-文件系统结构"></a> Ext 文件系统结构</h1>
<p>在 Linux 中，选择分区格式化的目的是选择文件系统，并按照文件系统标准对数据进行初始化。</p>
<p>当选择 ext 文件系统进行格式化后，磁盘结构将包含一个引导扇区（用于安装操作系统）和多个块组（Block Group）。具体结构如下图所示：</p>
<p><img data-src="../../../images/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.gif" alt="Ext文件系统结构" /></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>启动扇区（含0号block）<span class="token punctuation">]</span><span class="token punctuation">[</span>SuperBlock<span class="token punctuation">]</span><span class="token punctuation">[</span>File System Description<span class="token punctuation">]</span><span class="token punctuation">[</span>块对照表<span class="token punctuation">]</span><span class="token punctuation">[</span>Inode对照表<span class="token punctuation">]</span><span class="token punctuation">[</span>Inode表格<span class="token punctuation">]</span><span class="token punctuation">[</span>数据块<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，启动扇区占用的大小为 1KB。当块的大小设为 1024B 时，启动扇区将占用 0 号 block。而在块的大小超过 1024B 时，启动扇区之前是引导扇区，其后是占用 1K 的超级块（SuperBlock）。</p>
<p>每个块组又包含分为六个区域：</p>
<ul>
<li><strong>超级块</strong>（SuperBlock）：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式和相关信息。</li>
<li><strong>文件系统描述</strong>（File System Description）：描述每个块组的起止 block 号码，并说明块组中每个区域（superblock、inode、data、bitmap）的起止 block 号码。</li>
<li><strong>块对照表</strong>（Block Bitmap）：辅助块组找到可用的 block 来写入数据。在删除文件时，相应的 block 号码会被标记为未使用。</li>
<li><strong>Inode 对照表</strong>（Inode Bitmap）：类似于块对照表，用于记录已使用和未使用的 inode 号码。</li>
<li><strong>Inode 表格</strong>（Inode Table）：记录文件的属性，每个文件占用一个 inode，并记录该文件数据所在的 block 号码。</li>
<li><strong>数据块</strong>（Data Block）：实际存储文件内容的区域。如果文件大小超过一个 block 的容量，将占用多个数据块。</li>
</ul>
<p>与 FAT 文件系统对比：</p>
<ul>
<li>Linux 文件系统中，每个 inode 和 block 都有编号。在读取文件时，先读取相应的 inode 记录，得到文件实际存放的 block 号码，然后将整个文件读取出来。这种数据访问方法被称为索引式文件系统（indexed allocation）。</li>
<li>FAT 文件系统中没有 inode 的概念，每个 block 号码都记录在前一个 block 中。在读取文件时，必须逐个追踪这些 block，硬盘需要转动多次才能读取到最后一个 block。因此，需要进行磁盘碎片整理，将同一个文件所占用的 block 整理在一起，以提高磁头搜索效率。</li>
</ul>
<h2 id="数据块"><a class="markdownIt-Anchor" href="#数据块"></a> 数据块</h2>
<p>数据块是放置文件内容的地方，在 Ext2 中支持的块大小有 1KB、2KB 和 4KB，格式化时可选择块大小，每个块都有编号。</p>
<p>不同块大小支持的分区大小和单文件大小有所不同：</p>
<table>
<thead>
<tr>
<th>块大小</th>
<th>1KB</th>
<th>2KB</th>
<th>4KB</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大单一文件限制</td>
<td>16GB</td>
<td>256GB</td>
<td>2TB</td>
</tr>
<tr>
<td>最大文件系统总容量</td>
<td>2TB</td>
<td>8TB</td>
<td>16TB</td>
</tr>
</tbody>
</table>
<p>每个 block 内最多放置一个文件的数据，如果文件超过 block 大小，会占用多个 block。文件大小小于 block 大小时，block 内剩余容量也不能再被利用。</p>
<h2 id="inode-表格"><a class="markdownIt-Anchor" href="#inode-表格"></a> Inode 表格</h2>
<p>inode 的内容主要记录文件的属性及文件实际数据存放的 block 号码。</p>
<p>inode 记录的文件数据有下面这些：</p>
<ul>
<li>该文件的访问模式（read/write/execute）；</li>
<li>该文件的所有者与组（owner/group）；</li>
<li>该文件的大小；</li>
<li>该文件创建或状态改变的时间（ctime）；</li>
<li>最近一次读取的时间（atime）；</li>
<li>最近修改的时间（mtime）；</li>
<li>定义文件特性的标志（flag），比如 SUID 等；</li>
<li>该文件真正内容的指向（pointer）。</li>
</ul>
<p>inode 的特点：</p>
<ul>
<li>每个 inode 大小均固定为 128Bytes（ext4 和 xfs 可设置到 256Bytes）；</li>
<li>每个文件都仅占用一个 inode；</li>
<li>文件系统能创建的文件数量与 inode 数量有关；</li>
<li>系统读取 inode 时，会匹配 inode 上记录权限与用户是否符合，符合才继续读取 block 内容。</li>
</ul>
<p>inode 记录方式：</p>
<ul>
<li>每个 inode 记录 block 号码的区域定义为：12 个直接，1 个间接，1 个双间接和 1 个三间接记录区；</li>
<li>12 个直接记录能直接取得 block 号码，间接则是再拿一个 block 来当作记录 block 号码的记录区。双间接和三间接则是 block 再次指向下一个记录编号的 block 号码，以此最多三层指向；</li>
<li>以 1k 大小 block 块计算，总共能记录的文件大小为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>12</mn><mo>×</mo><mn>1</mn><mi>K</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mi>K</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi>B</mi><mo>=</mo><mn>256</mn><mi>K</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>256</mn><mo>×</mo><mn>256</mn><mi>K</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>256</mn><mo>×</mo><mn>256</mn><mo>×</mo><mn>256</mn><mi>K</mi><mo stretchy="false">)</mo><mo>=</mo><mn>16</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">(12\times1K)+(1K/4B=256K)+(256\times256K)+(256\times256\times256K)=16GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>；</li>
<li>现在使用 256Bytes 容量大小的 inode，还可以记录更多文件系统信息，包括 ACL 及 SELinux 类型等。记录的单一文件大小达 16TB，且单一文件系统总容量可达 1EB。</li>
</ul>
<h2 id="超级块"><a class="markdownIt-Anchor" href="#超级块"></a> 超级块</h2>
<p>超级块是记录整个文件系统相关信息的地方，一般超级块的大小为 1024 字节。</p>
<p>超级块记录的信息有：</p>
<ul>
<li>block 与 inode 的总量；</li>
<li>未使用与已使用的 inode/block 数量；</li>
<li>block 与 inode 的大小；</li>
<li>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等；</li>
<li>一个 valid bit 数值，若此文件系统已被挂载则值为 0，未挂载为 1。</li>
</ul>
<p>由于超级块的重要性，除了第一个块组中含有超级块外，其他块组中可能还存在超级块的备份，用于在关键时刻进行救援修复。</p>
<h2 id="查询文件系统详情"><a class="markdownIt-Anchor" href="#查询文件系统详情"></a> 查询文件系统详情</h2>
<p>使用 <code>dumpe2fs</code> 命令可以查询 ext 文件系统信息。例如查询设备 <code>/dev/sdb1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ dumpe2fs /dev/sdb1
dumpe2fs <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Filesystem volume name:   <span class="token operator">&lt;</span>none<span class="token operator">></span>
Last mounted on:          <span class="token operator">&lt;</span>not available<span class="token operator">></span>
Filesystem UUID:          3789ee36-8f38-441c-ac01-c0a9ca8171a1
Filesystem magic number:  0xEF53
Filesystem revision <span class="token comment">#:    1 (dynamic)</span>
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery sparse_super large_file
Filesystem flags:         signed_directory_hash 
Default <span class="token function">mount</span> options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              <span class="token number">65536</span>
Block count:              <span class="token number">261888</span>
Reserved block count:     <span class="token number">13094</span>
Free blocks:              <span class="token number">253344</span>
Free inodes:              <span class="token number">65525</span>
First block:              <span class="token number">0</span>
Block size:               <span class="token number">4096</span>
Fragment size:            <span class="token number">4096</span>
Reserved GDT blocks:      <span class="token number">63</span>
Blocks per group:         <span class="token number">32768</span>
Fragments per group:      <span class="token number">32768</span>
Inodes per group:         <span class="token number">8192</span>
Inode blocks per group:   <span class="token number">512</span>
Filesystem created:       Thu Sep  <span class="token number">9</span> <span class="token number">15</span>:10:34 <span class="token number">2021</span>
Last <span class="token function">mount</span> time:          Thu Sep  <span class="token number">9</span> <span class="token number">15</span>:11:11 <span class="token number">2021</span>
Last <span class="token function">write</span> time:          Thu Sep  <span class="token number">9</span> <span class="token number">15</span>:11:11 <span class="token number">2021</span>
Mount count:              <span class="token number">1</span>
Maximum <span class="token function">mount</span> count:      <span class="token parameter variable">-1</span>
Last checked:             Thu Sep  <span class="token number">9</span> <span class="token number">15</span>:10:34 <span class="token number">2021</span>
Check interval:           <span class="token number">0</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>none<span class="token operator">></span><span class="token punctuation">)</span>
Reserved blocks uid:      <span class="token number">0</span> <span class="token punctuation">(</span>user root<span class="token punctuation">)</span>
Reserved blocks gid:      <span class="token number">0</span> <span class="token punctuation">(</span>group root<span class="token punctuation">)</span>
First inode:              <span class="token number">11</span>
Inode size:               <span class="token number">256</span>
Required extra isize:     <span class="token number">28</span>
Desired extra isize:      <span class="token number">28</span>
Journal inode:            <span class="token number">8</span>
Default directory hash:   half_md4
Directory Hash Seed:      32744b35-d887-4ba9-9431-c5a9d63b9474
Journal backup:           inode blocks
Journal features:         <span class="token punctuation">(</span>none<span class="token punctuation">)</span>
Journal size:             16M
Journal length:           <span class="token number">4096</span>
Journal sequence:         0x00000002
Journal start:            <span class="token number">1</span>


Group <span class="token number">0</span>: <span class="token punctuation">(</span>Blocks <span class="token number">0</span>-32767<span class="token punctuation">)</span>
  Primary superblock at <span class="token number">0</span>, Group descriptors at <span class="token number">1</span>-1
  Reserved GDT blocks at <span class="token number">2</span>-64
  Block bitmap at <span class="token number">65</span> <span class="token punctuation">(</span>+65<span class="token punctuation">)</span>, Inode bitmap at <span class="token number">66</span> <span class="token punctuation">(</span>+66<span class="token punctuation">)</span>
  Inode table at <span class="token number">67</span>-578 <span class="token punctuation">(</span>+67<span class="token punctuation">)</span>
  <span class="token number">32183</span> <span class="token function">free</span> blocks, <span class="token number">8181</span> <span class="token function">free</span> inodes, <span class="token number">2</span> directories
  Free blocks: <span class="token number">585</span>-32767
  Free inodes: <span class="token number">12</span>-8192
Group <span class="token number">1</span>: <span class="token punctuation">(</span>Blocks <span class="token number">32768</span>-65535<span class="token punctuation">)</span>
  Backup superblock at <span class="token number">32768</span>, Group descriptors at <span class="token number">32769</span>-32769
  Reserved GDT blocks at <span class="token number">32770</span>-32832
  Block bitmap at <span class="token number">32833</span> <span class="token punctuation">(</span>+65<span class="token punctuation">)</span>, Inode bitmap at <span class="token number">32834</span> <span class="token punctuation">(</span>+66<span class="token punctuation">)</span>
  Inode table at <span class="token number">32835</span>-33346 <span class="token punctuation">(</span>+67<span class="token punctuation">)</span>
  <span class="token number">32189</span> <span class="token function">free</span> blocks, <span class="token number">8192</span> <span class="token function">free</span> inodes, <span class="token number">0</span> directories
  Free blocks: <span class="token number">33347</span>-65535
  Free inodes: <span class="token number">8193</span>-16384
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到这块磁盘格式化成了 ext3 文件系统后的 inode/block 数量，目前状态为 clean 正常等，这些信息是由 superblock 记录的。后面以 Group 开头的段为各个块组的信息。</p>
<h1 id="xfs-文件系统结构"><a class="markdownIt-Anchor" href="#xfs-文件系统结构"></a> XFS 文件系统结构</h1>
<p>由于 Ext 文件系统在格式化时采用的是预先规划出所有 inode/block/metadata 等数据，当磁盘容量很小时问题不大，但处理按 TB 计的大硬盘时，仅格式化就需要花费很长时间。</p>
<p>而 XFS 是针对大文件和数据设计的日志式文件系统。XFS 具备了 Ext 文件系统的所有功能，因此被作为 CentOS 7 中的默认文件系统。</p>
<p>XFS 文件系统在数据分布上主要划分为三部分：数据区、文件系统活动登录区和实时运行区。</p>
<h2 id="数据区"><a class="markdownIt-Anchor" href="#数据区"></a> 数据区</h2>
<p>数据区（Data Section）结构基本与 Ext 文件系统相同，包括 inode/data block/superblock 等数据，并且也是分为多个存储区组（Allocation Groups）来分别放置文件系统所需数据。</p>
<p>每个存储区组都包含了：</p>
<ul>
<li>整个文件系统的 superblock；</li>
<li>剩余空间管理机制；</li>
<li>inode 的分配与追踪。</li>
</ul>
<p>此外，inode 与 block 都是系统需要用时才动态配置产生。block 容量可以设置成 512 字节到 64KB，inode 的容量可以设置成 256 字节到 2MB。这是与 Ext 文件系统的主要区别。</p>
<h2 id="文件系统活动日志区"><a class="markdownIt-Anchor" href="#文件系统活动日志区"></a> 文件系统活动日志区</h2>
<p>在文件系统活动日志区（Log Section）中，主要被用来记录文件系统的变化，有点像日志系统。文件的变化会在这里记录下来，直到变化完整写入到硬盘后，记录才会终止。</p>
<p>在遇到突发情况而造成文件系统损毁时，系统会检查日志区，看系统之前正在操作的文件，再检查文件是否正确，依次修复文件系统。</p>
<p>由于此区块读写频繁，因此可以指定单独的磁盘作为 XFS 文件系统的日志区。</p>
<h2 id="实时运行区"><a class="markdownIt-Anchor" href="#实时运行区"></a> 实时运行区</h2>
<p>当有文件要被创建时，XFS 会在实时运行区（Realtime Section）中找一到多个 extent 区块，将文件放置在这个区块内，等到分配完成再写入到数据区的 inode 和 block 中。</p>
<p>extent 区块在格式化时可以指定，范围从 4KB 到 1GB，一般默认设置为 64KB 容量。</p>
<h2 id="查询文件系统详情-2"><a class="markdownIt-Anchor" href="#查询文件系统详情-2"></a> 查询文件系统详情</h2>
<p>在 XFS 文件系统中，使用 <code>xfs_info</code> 命令来查看分区详情：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ xfs_info /dev/mapper/centos-root
meta-data<span class="token operator">=</span>/dev/mapper/centos-root <span class="token assign-left variable">isize</span><span class="token operator">=</span><span class="token number">512</span>    <span class="token assign-left variable">agcount</span><span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">agsize</span><span class="token operator">=</span><span class="token number">1113856</span> blks
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">attr</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">projid32bit</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">crc</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token assign-left variable">finobt</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">spinodes</span><span class="token operator">=</span><span class="token number">0</span>
data     <span class="token operator">=</span>                       <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">4455424</span>, <span class="token assign-left variable">imaxpct</span><span class="token operator">=</span><span class="token number">25</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span>      <span class="token assign-left variable">swidth</span><span class="token operator">=</span><span class="token number">0</span> blks
naming   <span class="token operator">=</span>version <span class="token number">2</span>              <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   ascii-ci<span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ftype</span><span class="token operator">=</span><span class="token number">1</span>
log      <span class="token operator">=</span>internal               <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">2560</span>, <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token number">2</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span> blks, lazy-count<span class="token operator">=</span><span class="token number">1</span>
realtime <span class="token operator">=</span>none                   <span class="token assign-left variable">extsz</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">rtextents</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面简单解释下字段含义：</p>
<ul>
<li>第 1 行：
<ul>
<li>isize=512 指定 inode 的容量每个 512 字节大小。</li>
<li>agcount=4 是储存区群组的个数，共有 4 个。可以根据 CPU 核心数量进行调整。</li>
<li>agsize=1113856 blks 每个储存区群组具有 1113856 个 block。</li>
</ul>
</li>
<li>第 2 行：
<ul>
<li>sectsz=512 指逻辑扇区容量设置为 512 字节。</li>
</ul>
</li>
<li>第 4 行：
<ul>
<li>bsize=4096 指每个 block 大小为 4KB，可以通过 bsize*blocks 得到分区总容量为 17821696KB ≈ 16GB。</li>
<li>blocks=4455424 指系统总共有 4455424 个 blocks，可以通过 agsize*agcount 计算得到。</li>
</ul>
</li>
<li>第 5 行：
<ul>
<li>sunit=0 和 RAID 的 stripe 设置有关。</li>
<li>swidth=0 和 RAID 的工作盘数量有关。</li>
</ul>
</li>
<li>第 7 行：
<ul>
<li>internal 表示日志区的位置在文件系统内部，而不是外部设备。</li>
<li>bsize=4096 日志区 block 大小为 4KB。</li>
<li>blocks=2560 日志区 block 总数为 2560，根据此可以计算出日志区大小为 10MB。</li>
</ul>
</li>
<li>第 9 行：
<ul>
<li>extsz=4096 指 extent 大小为 4KB。</li>
</ul>
</li>
</ul>
<h1 id="文件与目录数据结构"><a class="markdownIt-Anchor" href="#文件与目录数据结构"></a> 文件与目录数据结构</h1>
<p>每个文件或目录都会占用一个 inode，且可依据文件内容的大小来分配多个 block 给该文件使用。</p>
<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>
<p>当在系统中新建一个目录时，至少会分配一个 inode 与一个 block 给该目录：</p>
<ul>
<li>inode 记录本目录相关权限、属性与本目录 block 号码。</li>
<li>block 记录在这个目录下的文件名与该文件（或目录）对应的 inode 号码。</li>
</ul>
<p>例如使用 <code>ls -i</code> 查看目录 ext333 内文件所占用 inode 号码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-li</span>
total <span class="token number">16</span>
<span class="token number">12</span> -rw-r--r--. <span class="token number">1</span> root root     <span class="token number">0</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:37 fist.log
<span class="token number">11</span> drwx------. <span class="token number">2</span> root root <span class="token number">16384</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:10 lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>fist.log</code> 文件的 inode 号码是 12，<code>lost+found</code> 目录的 inode 号码是 11，这些就是记录在 <code>ext333</code> 目录 block 中的数据。</p>
<p>再查看一下目录占用的大小：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-dh</span> /ext333/lost+found/ /ext333/
drwxr-xr-x. <span class="token number">3</span> root root <span class="token number">4</span>.0K Sep  <span class="token number">9</span> <span class="token number">15</span>:37 /ext333/
drwx------. <span class="token number">2</span> root root  16K Sep  <span class="token number">9</span> <span class="token number">15</span>:10 /ext333/lost+found/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到 <code>ext333</code> 目录大小为 4KB，而分区时设置的一个 block 大小也是 4KB，因此它使用了 1 个 block 来记录文件和目录 inode 号码信息。另外 <code>lost+found</code> 目录大小 16KB，说明记录信息太多 1 个 block 不够用，分配了 4 个 block 来记录。</p>
<h2 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h2>
<p>当新建一个一般文件时，系统会分配一个 inode 与相对于该文件大小的 block 数量给该文件。</p>
<p>假设 block 大小为 4KB，inode 大小为 128B，要新建 100KB 大小的文件，那么会分配到 1 个 inode 与 25 个 block 来储存该文件。由于 inode 只有 12 个直接指向，因此还要额外分配 1 个 block 来作为 block 号码记录用，文件实际上需要 26 个 block 来储存。</p>
<h2 id="目录树读取"><a class="markdownIt-Anchor" href="#目录树读取"></a> 目录树读取</h2>
<p>inode 本身并不记录文件名，文件名的记录在目录的 block 当中。所以给目录写权限，实际上操作的是修改目录的 block 数据。</p>
<p>删除文件记录（<code>rm</code> 命令），修改文件指向 inode 记录（<code>mv</code> 命令），或者新增文件指向 inode 记录（<code>cp</code> 命令），对应的就是在目录下进行删除、重命名、新增操作。</p>
<p>以下面记录为例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-di</span> /ext333/ /ext333/lost+found/ /ext333/lost+found/pass 
<span class="token number">2</span>  drwxr-xr-x. <span class="token number">3</span> root root  <span class="token number">4096</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:37 /ext333/
<span class="token number">11</span> drwx------. <span class="token number">2</span> root root <span class="token number">16384</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:54 /ext333/lost+found/
<span class="token number">14</span> -rw-r--r--. <span class="token number">1</span> root root     <span class="token number">5</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:54 /ext333/lost+found/pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设 root 要读取 <code>/ext333/lost+found/pass</code> 这个文件，顺序是这样的：</p>
<ol>
<li>通过挂载点的信息找到 inode 号码为 2 的 <code>ext333</code> 目录，查询 2 号 inode 内容，得到目录权限配置为 755。由于存在 x 权限，因此用户可以进入到 <code>ext333</code> 目录中。由于存在 r 权限，因此用户可以读取目录 <code>ext333</code> 的 block 内容。</li>
<li>通过读取 <code>ext333</code> 目录的 block 内容，得到 <code>lost+found</code> 目录的 inode 号码为 11。继续查询 11 号 inode 内容，得知权限为 rwx，因此继续进入 <code>lost+found</code> 目录，并读取目录的 block 内容。</li>
<li>通过读取目录 <code>lost+found</code> 的 block 内容得知 <code>pass</code> 文件的 inode 号码为 14。继续查询 14 号 inode 内容，得到权限为 rw。由于存在 r 权限，因此获得数据实际存放的 block 地址。</li>
<li>读取 <code>pass</code> 文件的 block 内容。</li>
</ol>
<h2 id="新增文件"><a class="markdownIt-Anchor" href="#新增文件"></a> 新增文件</h2>
<p>新增一个文件或目录时，文件系统的行为如下：</p>
<ol>
<li>首先确定用户是否对欲添加文件的目录拥有 w 和 x 权限，只有具备这两个权限才能进行添加操作；</li>
<li>根据 inode bitmap 寻找一个未使用的 inode 号码，并将新文件的权限和属性写入该 inode 中；</li>
<li>根据 block bitmap 寻找一个未使用的 block 号码，将实际数据写入该 block 中，并更新 inode 的 block 指向数据；</li>
<li>同步更新 inode bitmap 和 block bitmap 中的写入的 inode 与 block 数据，并更新 superblock 的内容。</li>
</ol>
<p>inode table 与 data block 被称为数据存储区域，而其他区域，如 superblock、block bitmap 和 inode bitmap 等，被称为中间区域（metadata）。</p>
<h1 id="写时复制文件系统"><a class="markdownIt-Anchor" href="#写时复制文件系统"></a> 写时复制文件系统</h1>
<p>写时复制（COW，Copy-On-Write）利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照，修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置。即使数据修改已经完成，之前的旧数据也不会被重写。最流行的 COW 文件系统有以下两种：</p>
<ul>
<li>
<p><strong>ZFS 文件系统</strong></p>
<p>ZFS（Z File System）是一个稳定的文件系统，被应用于 Sun 公司的 OpenSolaris 系统中，但它并非开源。开源版本被称为 OpenZFS 项目。</p>
</li>
<li>
<p><strong>Btrfs 文件系统</strong></p>
<p>Btrfs 文件系统也被称为 B 树文件系统，它稳定且易用，能够动态调整已挂载文件系统的大小。目前，OpenSUSE Linux 将 Btrfs 作为其默认文件系统。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>计算机硬件基础</title>
    <url>/3847559470/</url>
    <content><![CDATA[<h1 id="计算机简介"><a class="markdownIt-Anchor" href="#计算机简介"></a> 计算机简介</h1>
<p>计算机是一种拥有输入和输出设备的机器，它可以通过输入设备接受用户的输入，并经过中央处理器的数学与逻辑单元的处理，将这些输入转换成有用的信息进行生成或储存。因此，计算机可以说是一种具有高度智能化的信息处理工具。</p>
<h2 id="计算机组成"><a class="markdownIt-Anchor" href="#计算机组成"></a> 计算机组成</h2>
<p>计算机通常由五大部分组成，它们分别是输入单元、输出单元、中央处理器（CPU）内部的控制单元、算术逻辑单元和内存。这些部分协同工作，使得计算机能够完成复杂的计算和数据处理任务。其中，输入单元用于接收用户的输入信息，输出单元用于向用户展示计算机处理结果，控制单元则负责控制计算机的整个运作过程，算术逻辑单元则处理计算机的算术和逻辑运算，而内存则用于储存数据和程序。这五大部分共同构成了现代计算机的核心。</p>
<h2 id="计算机分类"><a class="markdownIt-Anchor" href="#计算机分类"></a> 计算机分类</h2>
<p>根据用途的不同，计算机可以被分为以下几类：</p>
<ul>
<li>
<p><strong>超级计算机</strong>（Supercomputer）：</p>
<p>这是最快也最贵的计算机，通常用于需要进行高速计算的项目中，比如军事、气象、太空、模拟等。</p>
</li>
<li>
<p><strong>大型计算机</strong>（Mainframe Computer）：</p>
<p>这种计算机用于处理大规模的数据和复杂的运算，常见于证券、银行、大型企业数据库服务器等场所。</p>
</li>
<li>
<p><strong>迷你计算机</strong>（Minicomputer）：</p>
<p>迷你计算机是低配版的大型计算机，适用于那些场所环境要求不那么严格的场合，比如科研、工程分析、工厂等。</p>
</li>
<li>
<p><strong>工作站</strong>（Workstation）：</p>
<p>工作站是专门针对特定用途而设计的计算机，比如图形工作站、机器学习等。与个人电脑相比，工作站更强调稳定性。</p>
</li>
<li>
<p><strong>微型计算机</strong>（Microcomputer）：</p>
<p>微型计算机也称为个人计算机（PC），包括移动设备和桌面型电脑等。它们是普及度最高的计算机类型，广泛应用于个人和办公场所，具有性价比高和易于携带的优点。</p>
</li>
</ul>
<h1 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> CPU</h1>
<p>中央处理器（CPU，Central Processing Unit）是计算机中最重要的组成部分之一，它是一个集成了微指令集和特定功能的芯片。CPU 通过执行指令来控制计算机的操作，包括算术逻辑运算、数据存储和检索等核心功能。因此，CPU 可以被认为是计算机的” 大脑 “，它的性能直接影响计算机的整体运行速度和效率。</p>
<h2 id="cpu-的组成单元"><a class="markdownIt-Anchor" href="#cpu-的组成单元"></a> CPU 的组成单元</h2>
<ul>
<li>
<p><strong>算术逻辑单元</strong></p>
<p>算术逻辑单元（ALU）是 CPU 中的一个重要组成部分，它主要负责执行算术运算和逻辑运算，如加、减、乘、除、与、或、非等。ALU 的运算结果将被存储在寄存器中，供其他单元继续使用。</p>
</li>
<li>
<p><strong>控制单元</strong></p>
<p>控制单元（CU）是 CPU 中的另一个重要组成部分，它主要负责协调和控制 CPU 各个单元之间的工作。CU 从内存中读取指令，并解析指令，然后根据指令的要求控制其他单元的操作。CU 还可以将运算结果写回内存或输出到外设。</p>
</li>
</ul>
<p>通过 ALU 和 CU 的紧密配合，CPU 能够实现各种复杂的计算和操作，从而实现计算机的各种功能。</p>
<h2 id="cpu-指令集"><a class="markdownIt-Anchor" href="#cpu-指令集"></a> CPU 指令集</h2>
<p>CPU 的指令集根据设计理念的不同，可以分为精简指令集（RISC）和复杂指令集（CISC）两种类型：</p>
<ul>
<li>
<p><strong>精简指令集</strong>（RISC，Reduced Instruction Set Computing）</p>
<p>精简指令集的微指令集比较简单明了，每个指令的执行时间都很短，完成的操作比较单一，执行效率高。常见的 RISC CPU 包括 Sun 公司的 SPARC 系列（主要用于学术和银行等大型工作站）、IBM 公司的 Power Architecture（包括 PowerPC，例如索尼 PS 游戏机）和 ARM 系列（主要用于手机、网络设备等嵌入式系统）。</p>
</li>
<li>
<p><strong>复杂指令集</strong>（CISC，Complex Instruction Set Computer）</p>
<p>复杂指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而复杂，每条指令的长度不同，执行时间较长，但每个指令可以处理的工作较为丰富。常见的 CISC CPU 包括 AMD 和 Intel 的 x86、x64 架构处理器，其中 “x86” 是因为最早的 Intel 元组型号 8086 发展而来，架构从 8 位升级到 32 位，现在普遍使用的是 64 位 CPU，称为 x86_64 架构。</p>
</li>
</ul>
<p>不同的指令集在硬件设计和编程语言的选择上有所区别，选择适合自己需求的 CPU 和指令集对于系统的性能和稳定性有着重要的影响。</p>
<h2 id="微指令集"><a class="markdownIt-Anchor" href="#微指令集"></a> 微指令集</h2>
<p>除了硬件参数差异（比如二级缓存大小）外，不同 x86 架构的 CPU 还有微指令集的区别。例如，Intel 处理器具有独特的指令集，如用于虚拟化（Intel-VT）、视频硬解码（MMX，SSE）等，可以有效提高特定工作的运行效率。</p>
<p>选择适合自己需求的 CPU 和指令集对于系统的性能和稳定性都有着重要的影响。特定的微指令集能够支持特定的操作，例如 SSE 指令集可以提高多媒体应用程序的性能，因此在开发需要高性能计算的应用程序时需要仔细选择微指令集。</p>
<h2 id="多核心"><a class="markdownIt-Anchor" href="#多核心"></a> 多核心</h2>
<p>多核心是指将两个或更多的运算核心嵌入到一颗 CPU 封装中。与单核 CPU 相比，多核 CPU 可以同时执行更多的指令，从而提高系统的运行效率。多核心处理器广泛应用于需要高性能计算的领域，如科学研究、金融分析、人工智能等。同时，多核心处理器也可以提高普通用户在运行多任务时的体验，例如同时打开多个应用程序或运行多个虚拟机。</p>
<h2 id="cpu-频率"><a class="markdownIt-Anchor" href="#cpu-频率"></a> CPU 频率</h2>
<p>CPU 频率是指 CPU 每秒钟所执行的时钟周期数，通常以赫兹（Hz）为单位。频率越高表示 CPU 单位时间内可以执行更多的指令和计算任务。例如，CPU 的频率为 4.0 GHz 表示这颗 CPU 在一秒内可以执行 4 × 10^9 次时钟周期。</p>
<p>但是，CPU 频率并不是衡量 CPU 性能的唯一指标，还需要考虑 CPU 架构、核心数量、缓存大小、指令集支持等因素。相同频率的 CPU 在性能上可能存在巨大差异。因此，在选择 CPU 时需要全面考虑性能、功耗和预算等因素。</p>
<h2 id="南桥和北桥"><a class="markdownIt-Anchor" href="#南桥和北桥"></a> 南桥和北桥</h2>
<p>南桥和北桥是主板芯片组中的两个核心部件，它们起到协调 CPU 和其他系统组件之间通信的作用。</p>
<ul>
<li>
<p><strong>北桥</strong></p>
<p>北桥是主板芯片组中的一部分，负责连接 CPU 和内存、显卡等高速设备，以及提供系统总线。早期，北桥还包含了内存控制器等重要的子系统，但随着技术的进步，现在内存控制器已经整合到了 CPU 封装中，因此北桥的功能逐渐减弱。</p>
</li>
<li>
<p><strong>南桥</strong></p>
<p>南桥则负责连接低速设备接口，如硬盘、USB、网卡等，提供输入输出总线。此外，南桥还包括了一些重要的子系统，如硬盘控制器、USB 控制器、声卡等。</p>
</li>
</ul>
<p>在现代 CPU 架构中，北桥的功能已经被整合到了 CPU 封装中，因此南北桥已经不再是主板设计的必要组成部分。但是，南北桥的功能仍然存在于芯片组中，并且是支持 CPU 和其他系统组件之间通信的关键组件之一。</p>
<h2 id="32-位与-64-位"><a class="markdownIt-Anchor" href="#32-位与-64-位"></a> 32 位与 64 位</h2>
<p>CPU 的字组大小，也被称为 word size，指的是 CPU 每次能够处理的数据量。32 位 CPU 的字组大小基于 CPU 解析的大小，即 4 个字节。而 64 位 CPU 能够一次性读写 8 个字节（64 位）的数据。</p>
<p>通常情况下，CPU 的字组大小会影响总线宽度和内存读写能力。由于 32 位 CPU 的字组大小为 4 个字节，其最大寻址能力为 2^32 个字节，相当于 4GB。因此，最多只能支持 4GB 内存大小。相比之下，64 位 CPU 的字组大小为 8 个字节，其最大寻址能力为 2^64 个字节，相当于 16EB。因此，64 位 CPU 能够支持更大的内存容量。</p>
<h2 id="外频与倍频"><a class="markdownIt-Anchor" href="#外频与倍频"></a> 外频与倍频</h2>
<p>在早期的 CPU 架构中，北桥用于连接 CPU、内存和显卡设备，因此每个设备都必须与北桥连接，并且具有相同的工作频率。为了解决这个问题，前端总线（FSB，Front Side Bus）应运而生。然而，由于 CPU 的运算速度远远超过其他设备，因此需要使用外频和倍频来满足 FSB 的频率要求。</p>
<p>外频指的是 CPU 与外部元件进行数据传输时的速度。而倍频是 CPU 内部用来加速工作性能的一个倍数。</p>
<p>CPU 的实际频率可以通过以下公式计算：CPU 频率 = 外频 x 倍频。通过调整外频和倍频的值，可以提高 CPU 的性能。</p>
<h2 id="超线程"><a class="markdownIt-Anchor" href="#超线程"></a> 超线程</h2>
<p>超线程（HT，Hyper-Threading）是一种在 CPU 内部将重要的寄存器（register）分为两组的技术，使得每组寄存器都可以供程序使用。因此，两个程序可以同时竞争 CPU 的运算单元，而不需要通过操作系统的多任务切换。</p>
<p>通过 HT 机制，操作系统可以使用实际核心的两倍数量，并且让每个核心逻辑上分离。在支持多核心运行的程序时，只要运算达不到 100% 的 CPU 使用率，超线程确实能帮助提升执行速度，更好地利用 CPU 性能。</p>
<p>在某些情况下，超线程可能会降低性能，例如在 CPU 达到 100% 使用率时，超线程可能会增加 CPU 的开销并导致性能下降。</p>
<h2 id="多级缓存"><a class="markdownIt-Anchor" href="#多级缓存"></a> 多级缓存</h2>
<p>一般 CPU 拥有二级 (L2 Cache) 或更多级缓存，由比 DRAM 速度更快的静态随机访问内存 (SRAM, Static Random Access Memory) 组成，用于存放一些常用的数据。这样，数据可以不通过内存读取，从而大幅提升性能。</p>
<h1 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h1>
<p>CPU 处理的数据来源于内存，而处理完毕的数据也要先写回内存，再从内存传输到输出单元。</p>
<p>内存的主要组件是动态随机访问内存 (DRAM, Dynamic Random Access Memory)，只有在通电时才能记录和使用。由于断电后数据会消失，因此也被称为挥发性内存。</p>
<h2 id="内存类型"><a class="markdownIt-Anchor" href="#内存类型"></a> 内存类型</h2>
<p>内存从 SDRAM 发展为 DDR（Double Data Rate），也就是所谓的双倍数据传输速度 SDRAM，它可以在一次工作周期中进行两次数据传输。例如 DDR400 的内存，代表数据宽度为 64bit，外频为 200MHz，频率为 400MHz，频宽为 3.2GB/s。</p>
<p>下一代 CXL（Compute Express Link） DRAM 作为一种开放性的互联协议，拥有更高的带宽，能够让 CPU 与 GPU、FPGA 或其他加速器之间实现高速高效的互联，满足现今高性能异构计算的要求，并且提供更高的带宽及更好的内存一致性。作为下一代接口，与主 DRAM 一起使用的时候，可以扩大带宽和容量，预计将广泛应用在人工智能（AI）和机器学习（ML）领域。</p>
<h2 id="内存速度"><a class="markdownIt-Anchor" href="#内存速度"></a> 内存速度</h2>
<p>内存工作频率由 CPU 内的内存控制器决定。例如，假如内存频率为 1600MHz，总线宽度为 64bit，理论最大传输速度为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1600</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo>∗</mo><mn>64</mn><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>1600</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo>∗</mo><mn>8</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>=</mo><mn>12800</mn><mi>M</mi><mi>B</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>12.8</mn><mi>G</mi><mi>B</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1600MHz * 64bit = 1600MHz * 8Bytes = 12800MB/s = 12.8GB/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">.</span><span class="mord">8</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<h2 id="多通道设计"><a class="markdownIt-Anchor" href="#多通道设计"></a> 多通道设计</h2>
<p>当两条同样的内存插入支持内存双通道的主板中时，总线宽度由 64bit 升级到 128bit，传输速度翻倍。这是双通道内存的设计理念。</p>
<p>除了双通道外，服务器提供三信道甚至四信道的内存环境。</p>
<h2 id="物理地址扩展"><a class="markdownIt-Anchor" href="#物理地址扩展"></a> 物理地址扩展</h2>
<p>物理地址扩展（PAE）是基于 x86 服务器的一种功能，它使运行 Windows Server 版本的计算机可以支持 4GB 以上物理内存。物理地址扩展允许将最多 64GB 的物理内存用作常规的 4 KB 页面，并扩展内核能使用的位数以将物理内存地址从 32 位扩展到 36 位。</p>
<h1 id="主板"><a class="markdownIt-Anchor" href="#主板"></a> 主板</h1>
<p>主板（Mainboard）是一种电脑硬件，由芯片组构成，用于沟通和连接各种设备，为 CPU 提供支持和资源。</p>
<p>现代主板一般集成了许多设备元件，如声卡、网卡、显卡、磁盘整合卡等。</p>
<h2 id="cmos-芯片"><a class="markdownIt-Anchor" href="#cmos-芯片"></a> CMOS 芯片</h2>
<p>CMOS 芯片是一种低功耗的、非易失性的芯片，它用于记录主板的重要参数，例如系统时间、CPU 频率、设备 I/O 地址和 IRQ 等信息。由于这些参数需要在断电后仍能保持，CMOS 芯片需要额外的电子供电来保存这些设置。</p>
<h2 id="bios"><a class="markdownIt-Anchor" href="#bios"></a> BIOS</h2>
<p>BIOS (Basic Input Output System) 是一种固化在主板上的程序，用于初始化和测试硬件设备，加载操作系统，并提供各种底层服务和功能。BIOS 存储在闪存（Flash Memory）或 EEPROM 中，可以在开机时被执行。主要用途是加载和修改 CMOS（Complementary Metal-Oxide Semiconductor）中的参数，例如系统时间、CPU 频率、设备 I/O 地址和 IRQ 等。同时，BIOS 也尝试调用存储设备中的开机程序，以启动操作系统。</p>
<p>通常在开机时按下 [del] 键或 [F1] 键可以进入 BIOS 设置界面，进行各种参数设置和硬件配置。</p>
<h2 id="uefi"><a class="markdownIt-Anchor" href="#uefi"></a> UEFI</h2>
<p>UEFI (Unified Extensible Firmware Interface) 是新一代的固件接口标准，相比于传统的 BIOS 更加先进。UEFI 可以使用一个特制的 shell 来做一些管理工作。</p>
<h2 id="固件"><a class="markdownIt-Anchor" href="#固件"></a> 固件</h2>
<p>固件 (firmware) 是绑定在硬件上的控制软件，例如磁盘阵列卡、网卡等。通常储存在只读存储器 (Read Only Memory, ROM) 中，以保证固件的安全性。</p>
<h2 id="pci-插槽"><a class="markdownIt-Anchor" href="#pci-插槽"></a> PCI 插槽</h2>
<p>主板上的扩展插槽主要有 PCI 和 PCI-E 两种类型，它们的速度和频宽如下：</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>宽度 (bit)</th>
<th>速度 (MHz)</th>
<th>频宽</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCI</td>
<td>32</td>
<td>33</td>
<td>133 MB/s</td>
</tr>
<tr>
<td>PCI 2.2</td>
<td>64</td>
<td>66</td>
<td>533 MB/s</td>
</tr>
<tr>
<td>PCI-X</td>
<td>64</td>
<td>133</td>
<td>1064 MB/s</td>
</tr>
<tr>
<td>AGP 4x</td>
<td>32</td>
<td>66x4</td>
<td>1066 MB/s</td>
</tr>
<tr>
<td>AGP 8x</td>
<td>32</td>
<td>66x8</td>
<td>2133 MB/s</td>
</tr>
<tr>
<td>PCI-E 1.0 x4</td>
<td></td>
<td></td>
<td>1 GB/s</td>
</tr>
<tr>
<td>PCI-E 2.0 x2</td>
<td></td>
<td></td>
<td>1 GB/s</td>
</tr>
<tr>
<td>PCI-E 3.0 x1</td>
<td></td>
<td></td>
<td>1 GB/s</td>
</tr>
<tr>
<td>PCI-E 4.0 x1</td>
<td></td>
<td></td>
<td>2 GB/s</td>
</tr>
<tr>
<td>PCI-E 5.0 x1</td>
<td></td>
<td></td>
<td>4 GB/s</td>
</tr>
</tbody>
</table>
<p>一般来说，PCI-E 的规格由插槽的长度决定，PCI-E 插槽的工作模式可以参考主板的说明书。如果将一个速度为 x16 的设备插在一个速度为 x8 的 PCI-E 插槽上，该设备将以 x8 的速度运行。</p>
<p>例如，一个 CPU 通常支持 16 个信道（PCI-E 3.0 x16），如果主板上有三个 PCI-E 插槽，那么 PCI-E 插槽的速度可以工作在以下模式：1 x16，2 x8，1 x8 + 2 x4，具体取决于插入的设备数量。</p>
<h2 id="usb-接口"><a class="markdownIt-Anchor" href="#usb-接口"></a> USB 接口</h2>
<p>USB 接口一般用来连接 U 盘、移动硬盘盒、键盘、鼠标等设备。各版本的带宽与速度对比如下：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>带宽</th>
<th>速度 (MB/s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>USB 1.0</td>
<td>12 Mbit/s</td>
<td>1.5</td>
</tr>
<tr>
<td>USB 2.0</td>
<td>480 Mbit/s</td>
<td>60</td>
</tr>
<tr>
<td>USB 3.0</td>
<td>5 Gbit/s</td>
<td>500</td>
</tr>
<tr>
<td>USB 3.1</td>
<td>10 Gbit/s</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>为了方便区分版本，主板给 USB 接口采用不同颜色进行显示：白色代表 USB 2.0，蓝色代表 USB 3.0，红色代表 USB 3.1。</p>
<h2 id="其他接口"><a class="markdownIt-Anchor" href="#其他接口"></a> 其他接口</h2>
<p>主板上常见的其他接口如下：</p>
<ul>
<li>
<p><strong>音频输入与输出</strong></p>
<p>一些 3.5mm 圆形插孔，一般用绿色表示耳机插孔，粉红色表示麦克风输入插孔。</p>
</li>
<li>
<p><strong>RJ-45 网络接口</strong></p>
<p>方形接口，用来插入网线。</p>
</li>
<li>
<p><strong>HDMI 接口</strong></p>
<p>HDMI 接口一般用于视频输出。如果主板上有板载显卡，一般会提供该接口。</p>
</li>
</ul>
<h2 id="设备-io-地址与-irq-中断信道"><a class="markdownIt-Anchor" href="#设备-io-地址与-irq-中断信道"></a> 设备 I/O 地址与 IRQ 中断信道</h2>
<p>主板芯片组通过 I/O 地址和 IRQ 中断信道来控制设备。</p>
<ul>
<li>
<p><strong>I/O 地址</strong></p>
<p>I/O 地址用来标识对应的设备，如果两个设备使用相同的 I/O 地址会造成地址冲突，导致设备无法正常工作。</p>
</li>
<li>
<p><strong>IRQ 中断信道</strong></p>
<p>IRQ 用来标识设备工作状态，以方便 CPU 分配工作任务。每个设备都有自己的 IRQ 中断信道，当设备需要 CPU 处理时，会通过 IRQ 向 CPU 发出中断请求。CPU 会停止当前的任务，处理中断请求，并在完成处理后返回原先的任务。</p>
</li>
</ul>
<h1 id="显卡"><a class="markdownIt-Anchor" href="#显卡"></a> 显卡</h1>
<p>显卡是计算机中的一种重要的组件，主要负责图像和影像的显示，也被称为视频显卡（Video Card）或图形加速卡（Graphics Card）。</p>
<h2 id="显存"><a class="markdownIt-Anchor" href="#显存"></a> 显存</h2>
<p>由于每个图像需要占用内存空间来存储颜色信息，因此显卡上有一个专门用于存储图像信息的内存，称为显存。</p>
<h2 id="gpu"><a class="markdownIt-Anchor" href="#gpu"></a> GPU</h2>
<p>除了负责图像显示，显卡上还有一个专门用于进行 3D 运算的加速芯片，称为 GPU。</p>
<h2 id="显卡插槽"><a class="markdownIt-Anchor" href="#显卡插槽"></a> 显卡插槽</h2>
<p>由于显卡需要大量的数据传输，因此使用能提供高带宽的 PCI-E 插槽。</p>
<h2 id="显卡接口"><a class="markdownIt-Anchor" href="#显卡接口"></a> 显卡接口</h2>
<p>常见显卡上用来连接显示器的接口如下:</p>
<ul>
<li>
<p><strong>D-Sub(VGA)</strong></p>
<p>是较早之前的连接接口，主要为 15 针的连接，用于模拟信号传输。</p>
</li>
<li>
<p><strong>DVI</strong></p>
<p>有提供数字传输的 DVI-D 和整合数字和模拟传输的 DVI-I 两种类型。</p>
</li>
<li>
<p><strong>HDMI</strong></p>
<p>可以同时传输图像和声音。</p>
</li>
<li>
<p><strong>DP(DisplayPort)</strong></p>
<p>类似于 HDMI。</p>
</li>
</ul>
<h1 id="硬盘"><a class="markdownIt-Anchor" href="#硬盘"></a> 硬盘</h1>
<p>硬盘是计算机中用于存储数据的设备，一般分为机械硬盘和固态硬盘。</p>
<h2 id="机械硬盘的组成"><a class="markdownIt-Anchor" href="#机械硬盘的组成"></a> 机械硬盘的组成</h2>
<p>传统机械硬盘（HDD，Hard Disk Drive）的物理结构如下：</p>
<ul>
<li>
<p><strong>盘片</strong></p>
<p>数据记录介质，可以有一个或多个盘片。</p>
</li>
<li>
<p><strong>主轴电机</strong></p>
<p>带动盘片旋转，转速越高，读写速度越快。常见的转速有 7200 rpm（转 / 分钟）和 5400 rpm。</p>
</li>
<li>
<p><strong>读写磁头</strong></p>
<p>读取和写入数据，每个盘片面都有一个磁头。</p>
</li>
<li>
<p><strong>机械臂</strong></p>
<p>控制磁头的位置，使其能够读取或写入指定的盘片面。</p>
</li>
</ul>
<p>此外，硬盘电路板上还有一个小容量的闪存用作缓冲内存，用于临时提高硬盘性能。</p>
<p>机械硬盘非常脆弱，因此在通电状态下绝对不要发生碰撞或直接拔插电源线。否则可能会导致逻辑坏道（文件系统损坏）或物理坏道。</p>
<h2 id="机械硬盘盘片"><a class="markdownIt-Anchor" href="#机械硬盘盘片"></a> 机械硬盘盘片</h2>
<p>机械硬盘盘片的表面结构如下：</p>
<ul>
<li>
<p><strong>扇区（sector）</strong></p>
<p>盘片同心圆上切出的小块区域，是硬盘的最小物理存储单元。传统硬盘的扇区容量为 512 字节，而现代硬盘则采用了 4KB 扇区设计。</p>
</li>
<li>
<p><strong>磁道（track）</strong></p>
<p>盘片同心圆上的一个圆环，由一系列相同半径的扇区组成。</p>
</li>
<li>
<p><strong>柱面（cylinder）</strong></p>
<p>所有盘片同心圆上的同一磁道就构成一个柱面。</p>
</li>
</ul>
<p>由于同心圆外圈的扇区比内圈的扇区多，因此硬盘的数据读写是从外向内进行的。</p>
<p>传统机械硬盘的容量计算公式为：磁头数 * 柱面 * 扇区数 * 512Bytes</p>
<h2 id="硬盘传输接口"><a class="markdownIt-Anchor" href="#硬盘传输接口"></a> 硬盘传输接口</h2>
<p>硬盘与主板连接接口经过多次改版，目前主流的有 SATA 和 SAS 接口。</p>
<ul>
<li>
<p><strong>IDE 接口</strong></p>
<p>使用的平行线可以连接两个设备，因此有主 / 从 (Master/Slave) 构架，可以通过跳针设置。</p>
<p>接口传输速度为 Ultra 133 规格，理论速度最高 133MB/s。</p>
</li>
<li>
<p><strong>SATA 接口</strong></p>
<p>在家用机上 IDE 接口的替代接口。SATA 的平行线将数据传输和供电分开。一条平行线对应一个设备，没有跳针设计。</p>
<p>目前主流使用的 SATA 3.0 版本传输速度为 600MB/s。</p>
</li>
<li>
<p><strong>SCSI 接口</strong></p>
<p>在以前服务器硬盘常用接口。硬盘在控制器上含有一块处理器，用来支持一些高级功能。</p>
</li>
<li>
<p><strong>SAS 接口</strong></p>
<p>SAS（Serial Attached SCSI）是串行式 SCSI 的意思，目前已在服务器领域全面取代了 SCSI。</p>
<p>SAS 3.0 的传输速度能达到 1200MB/s。</p>
</li>
</ul>
<h2 id="固态硬盘"><a class="markdownIt-Anchor" href="#固态硬盘"></a> 固态硬盘</h2>
<p>固态硬盘 (SSD, Solid State Disk) 以 NAND 闪存作为储存介质，因此不存在机械硬盘的磁头、盘片等结构，也没有数据分散的问题，读写速度和延迟时间比机械硬盘更优秀。</p>
<p>固态硬盘的寿命和速度取决于使用的内存颗粒类型，常见的类型从好到差分别为 SLC、MLC、TLC、QLC。</p>
<p>一般而言，电脑使用固态硬盘作为系统盘，数据储存在机械硬盘上，可以有效提升整个系统性能。</p>
<h1 id="电源"><a class="markdownIt-Anchor" href="#电源"></a> 电源</h1>
<p>电源供应器（Power Supply Unit，PSU）用于给主板、CPU、显卡和硬盘等硬件供电。选择质量好的电源可以有效降低硬件意外损坏的概率。</p>
<p>如果使用诸如 AIDA 等软件对未超频的电脑进行测试时，在测试过程中出现中途断电或重启等情况，说明电源的额定功率不够或者不稳定。需要减少设备连接或者更换更高功率的电源。</p>
<p>在选购电源时，除了考虑电源的额定功率之外，还需要考虑能源转换率，也就是 $ 输入功率 / 输出功率 $ 的值。转换率值越大越好。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 中磁盘分区基础知识</title>
    <url>/3200821655/</url>
    <content><![CDATA[<h1 id="磁盘设备名"><a class="markdownIt-Anchor" href="#磁盘设备名"></a> 磁盘设备名</h1>
<p>在新版 Linux 中，IDE 和 SATA 的磁盘命名没有区别。</p>
<h2 id="ide-接口硬盘"><a class="markdownIt-Anchor" href="#ide-接口硬盘"></a> IDE 接口硬盘</h2>
<p>由于一个 IDE 接口可以连接两个 IDE 设备，一般主板可以接 4 个 IDE 设备。在系统中，IDE 设备的命名如下：</p>
<table>
<thead>
<tr>
<th><strong>IDE(Jumper)</strong></th>
<th><strong>Master</strong></th>
<th><strong>Slave</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE1(Primary)</td>
<td>/dev/hda</td>
<td>/dev/hdb</td>
</tr>
<tr>
<td>IDE2(Secondary)</td>
<td>/dev/hdc</td>
<td>/dev/hdd</td>
</tr>
</tbody>
</table>
<h2 id="sata-接口硬盘"><a class="markdownIt-Anchor" href="#sata-接口硬盘"></a> SATA 接口硬盘</h2>
<p>SATA 接口设备名由 Linux 内核检测到磁盘的顺序从 a 开始排列，与插槽号无关。例如，两块磁盘插到 SATA1 和 SATA5 插槽上，系统中识别为 sda 和 sdb。</p>
<h1 id="磁盘阵列"><a class="markdownIt-Anchor" href="#磁盘阵列"></a> 磁盘阵列</h1>
<p>磁盘阵列（RAID，Redundant Arrays of Inexpensive Disks）即容错廉价磁盘阵列，指通过一些技术（软件或硬件）将多个较小的磁盘整合成一个较大的磁盘设备，并且具有一定数据保护的功能。</p>
<h2 id="磁盘阵列类型"><a class="markdownIt-Anchor" href="#磁盘阵列类型"></a> 磁盘阵列类型</h2>
<p>磁盘整列有两种组建方式。</p>
<h3 id="硬件磁盘阵列"><a class="markdownIt-Anchor" href="#硬件磁盘阵列"></a> 硬件磁盘阵列</h3>
<p>硬件（hardware）磁盘阵列通过磁盘阵列卡完成组建任务，拥有专门芯片来处理 RAID 任务。性能比较好，例如用来处理 RAID 5 的同位检查码计算，并不会重复消耗原本系统的 I/O 总线。硬件磁盘阵列的设备文件名为/dev/sd[a-p]。</p>
<h3 id="软件磁盘阵列"><a class="markdownIt-Anchor" href="#软件磁盘阵列"></a> 软件磁盘阵列</h3>
<p>软件（software）磁盘阵列利用软件来仿真磁盘阵列功能，与 CPU 运算和 I/O 总线速度关系很大。在 CentOS 中提供的软件磁盘阵列软件为 mdadm，支持以分区为单位组建 RAID0/1/5 等。软件磁盘阵列使用的设备文件名是系统的设备文件/dev/md[0-1]。</p>
<h2 id="磁盘阵列等级"><a class="markdownIt-Anchor" href="#磁盘阵列等级"></a> 磁盘阵列等级</h2>
<p>常见磁盘阵列等级有 4 种：RAID 0（等量模式，stripe）、RAID 1（映像模式，mirror）、RAID 0+1 或 RAID 1+0、RAID 5。</p>
<h3 id="raid-0"><a class="markdownIt-Anchor" href="#raid-0"></a> RAID 0</h3>
<p>此模式下，RAID 会将磁盘先切出等量的区块（名为 chunk，大小 4KB ~ 1MB），写入文件时，该文件依据块大小切割好，依序放到各个磁盘中去。</p>
<p>磁盘可用容量为所有磁盘容量之和。</p>
<p>读写性能最佳。</p>
<p>安全性最糟，任意一块磁盘损坏，所有文件数据将缺损，所有数据都会丢失。</p>
<h3 id="raid-1"><a class="markdownIt-Anchor" href="#raid-1"></a> RAID 1</h3>
<p>此模式让同一份数据完整保存在两块磁盘上面，写入文件时，该文件复制为两份，并分别写入到各个磁盘中去。</p>
<p>磁盘可用容量为所有磁盘容量之和的一半。</p>
<p>写性能在使用软阵列时不好，因为南桥芯片的 I/O 性能有限，同时写入会导致带宽不够。读取性能和 RAID 0 一样。</p>
<p>安全性最好。</p>
<h3 id="raid-01raid-10"><a class="markdownIt-Anchor" href="#raid-01raid-10"></a> RAID 0+1，RAID 1+0</h3>
<p>所谓 RAID 0+1 就是先让两块磁盘组成 RAID 0，再将两组 RAID 0 组成一组 RAID 1。RAID 1+0 则是先组 RAID 0，再组成 RAID 1。</p>
<p>磁盘可用容量和 RAID 1 一样只有一半可用。</p>
<p>读写性能和 RAID 0 一样。</p>
<p>安全性和 RAID 1 一样。</p>
<h3 id="raid-5"><a class="markdownIt-Anchor" href="#raid-5"></a> RAID 5</h3>
<p>至少需要三块以上磁盘才能组建。在每个循环的写入过程中，每块磁盘还加入一个同位检查数据（Parity），这个数据会记录其他磁盘的备份数据，用于磁盘损坏时的恢复。</p>
<p>磁盘可用容量为总磁盘容量减一块磁盘容量。</p>
<p>读写取性能介于 RAID 1 和 RAID 0 之间。</p>
<p>安全性能方面，只接受损坏不超过一块的硬盘情况下恢复数据。</p>
<h2 id="预备磁盘"><a class="markdownIt-Anchor" href="#预备磁盘"></a> 预备磁盘</h2>
<p>磁盘阵列中的磁盘损坏时，可更换坏掉的磁盘并插入新的磁盘，磁盘阵列会主动重建数据。这通常需要在关机重启时进行，但 SAS 支持热插拔，可以避免重启。</p>
<p>为实现系统实时主动重建，需要预备磁盘。预备磁盘是指一块或多块未包含在原磁盘阵列等级中的磁盘。只有在磁盘阵列中出现磁盘损坏时，才会主动将预备磁盘引入磁盘阵列中进行数据重建。</p>
<h1 id="逻辑卷管理器"><a class="markdownIt-Anchor" href="#逻辑卷管理器"></a> 逻辑卷管理器</h1>
<p>逻辑卷管理器（LVM，Logical Volume Manager）通过软件组合几个物理分区（PV），将它们称为一块看起来是独立的大磁盘（VG），然后再将这块大磁盘分成可使用分区（LV），最终挂载使用。</p>
<h2 id="物理卷"><a class="markdownIt-Anchor" href="#物理卷"></a> 物理卷</h2>
<p>物理卷（PV，Physical Volume）分区需要通过 <code>fdisk</code> 调整系统标识符（system ID）为 8e（LVM 的标识符），然后通过 <code>pvcreate</code> 命令将其转换为 LVM 的最底层物理卷（PV），才能利用这些 PV。</p>
<h2 id="卷用户组"><a class="markdownIt-Anchor" href="#卷用户组"></a> 卷用户组</h2>
<p>LVM 将许多 PV 整合成卷用户组(VG，Volume Group)，在 32 位系统下每个 VG 最多仅能包含 65534 个 PE。如果使用 LVM 默认参数，则一个 VG 最大可达 256GB 容量。在 64 位系统下已不存在限制。</p>
<h2 id="物理扩展块"><a class="markdownIt-Anchor" href="#物理扩展块"></a> 物理扩展块</h2>
<p>LVM 默认使用 4MB 的物理扩展块（PE，即 Physical Extent），它是整个 LVM 中最小的存储块，类似于文件系统中的 block 大小。</p>
<h2 id="逻辑卷"><a class="markdownIt-Anchor" href="#逻辑卷"></a> 逻辑卷</h2>
<p>VG 会被切分成逻辑卷（LV，即 Logical Volume），这个 LV 就是最后可以被格式化使用的分区。</p>
<p>LV 的大小与此 LV 内的 PE 总数有关。</p>
<p>为了方便用户利用 LVM 管理其系统，LV 的设备文件名通常指定为 <code>/dev/vgname/lvname</code> 的样式。</p>
<p>更改文件系统容量本质是通过交换 PE 来进行数据转换，将原本 LV 内的 PE 转移到其他设备中以降低 LV 容量，或将其他设备的 PE 加到此 LV 中以增大容量。</p>
<p>对 LV 数据写入机制有两种：</p>
<ul>
<li>
<p><strong>线性模式</strong>（linear）：如果有两个分区 sdb1 和 sdb2 加入到 VG 中，并且整个 VG 只有一个 LV 时，数据会先将 sdb1 写满，再开始写 sdb2。</p>
</li>
<li>
<p><strong>交错模式</strong>（striped）：类似于 RAID 0 的模式，同时向两个分区内写入数据。</p>
</li>
</ul>
<p>LVM 的重点在于可以弹性调整文件系统容量，而不是性能优先，因此默认使用线性模式进行读写。</p>
<h1 id="mbr-分区表"><a class="markdownIt-Anchor" href="#mbr-分区表"></a> MBR 分区表</h1>
<p>目前主流分区表格式有 MBR 和 GPT。早期的 Linux 系统为了兼容 Windows 磁盘，使用的是支持 Windows 的 MBR。</p>
<p>MBR 分区表无法支持 2T 以上容量的硬盘。</p>
<h2 id="第一个扇区"><a class="markdownIt-Anchor" href="#第一个扇区"></a> 第一个扇区</h2>
<p>MBR 分区表第一个扇区（512Bytes）用来记录三个重要的信息：</p>
<ul>
<li>
<p><strong>主引导分区</strong>（MBR，Master Boot Record）：用来安装引导加载程序的地方，有 446Bytes 大小。</p>
</li>
<li>
<p><strong>分区表</strong>（Partition Table）：记录整块硬盘的分区状态，有 64Bytes 大小。</p>
</li>
<li>
<p><strong>引导记录标识</strong>（BRID）：用来判断设备是否可以用于启动，只有 2 Bytes 大小。值为 55 或 AA 表示可引导。</p>
</li>
</ul>
<p>如果第一个扇区出现物理坏道，整块硬盘都不可用。</p>
<h2 id="主引导分区"><a class="markdownIt-Anchor" href="#主引导分区"></a> 主引导分区</h2>
<p>MBR 只有 446Bytes，主要提供以下功能：</p>
<ul>
<li>提供菜单，可以选择不同开机选项，实现多重引导；</li>
<li>载入内核文件，指向可开机的程序区段开启动系统；</li>
<li>转交其他 Loader，将引导加载功能转交给其他 Loader 负责。</li>
</ul>
<h2 id="分区表"><a class="markdownIt-Anchor" href="#分区表"></a> 分区表</h2>
<p>分区表记录了每个分区的起始柱面号，分区只是针对那 64Bytes 的分区表进行设置。由于只有 64Bytes 大小，所以仅能写入四组分区信息。这四组分区信息分为主（Primary）或扩展（Extended）分区。</p>
<p>主分区和扩展分区在 Linux 系统中表示为 <code>sda[1-4]</code>。</p>
<p>分区的最小单位为柱面（Cylinder），通常每个分区都包含一个或多个柱面。</p>
<h2 id="扩展分区"><a class="markdownIt-Anchor" href="#扩展分区"></a> 扩展分区</h2>
<p>扩展分区是指利用额外的扇区来记录分区信息，但无法进行格式化。可以在扩展分区中创建逻辑分区，具体做法是在每个逻辑分区的最前面几个扇区记录分区信息。需要注意的是，一个磁盘最多只能有一个扩展分区，这是操作系统的限制。</p>
<p>为了确保磁盘的连续性，通常将扩展分区的柱面号分配在所有主分区之后。这样可以更好地利用磁盘空间，并有助于提高磁盘读写效率。</p>
<h2 id="逻辑分区"><a class="markdownIt-Anchor" href="#逻辑分区"></a> 逻辑分区</h2>
<p>从扩展分区分出的分区也称为逻辑分区（Logical Partition）。在 Linux 系统中，逻辑分区从 hda5 开始计算。</p>
<p>在一个扩展分区内，相邻的逻辑分区可以合并。如果不相邻，则只能重建扩展分区。</p>
<p>需要注意的是，如果扩展分区被破坏，所有的逻辑分区将被删除，因为逻辑分区的信息都记录在扩展分区中。</p>
<h1 id="gpt-分区表"><a class="markdownIt-Anchor" href="#gpt-分区表"></a> GPT 分区表</h1>
<p>GPT 分区表是为了适应 4K 扇区的硬盘和固态硬盘而设计的，它抛弃了原先以柱面为单位的计算法，改用逻辑区块位址（LBA，Logical Block Address）来规划分区。默认大小为 512Bytes，第一个 LBA 为 LBA0。</p>
<p>GPT 分区表使用前 34 个 LBA 区块来记录分区信息。此外，磁盘最后 33 个 LBA 区块会用于存储分区表备份，以保障分区信息的安全。</p>
<h2 id="mbr-兼容区块"><a class="markdownIt-Anchor" href="#mbr-兼容区块"></a> MBR 兼容区块</h2>
<p>GPT 分区表中的 LBA0 用来兼容 MBR 格式。不同之处在于，原本分区表记录段仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 磁盘。</p>
<h2 id="gpt-表头记录"><a class="markdownIt-Anchor" href="#gpt-表头记录"></a> GPT 表头记录</h2>
<p>GPT 分区表中的 LBA1 记录了分区表本身的位置和大小，备份分区表存放位置，以及分区表校验机制码（CRC32）。如果系统检测到分区表有错误，可以通过这个记录区来获取备份分区表并进行恢复。</p>
<h2 id="分区表-2"><a class="markdownIt-Anchor" href="#分区表-2"></a> 分区表</h2>
<p>分区表存放在 LBA2-33 位置。从 LBA2 开始，每个 LBA 都可以记录 4 笔分区记录，所以默认可以记录 128 个分区记录。</p>
<p>每笔记录占用 128 字节空间，具体内容如下表：</p>
<table>
<thead>
<tr>
<th>起始字节</th>
<th>长度</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>16 字节</td>
<td>分区类型 GUID</td>
</tr>
<tr>
<td>16</td>
<td>16 字节</td>
<td>分区 GUID</td>
</tr>
<tr>
<td>32</td>
<td>8 字节</td>
<td>起始 LBA（小端序）</td>
</tr>
<tr>
<td>40</td>
<td>8 字节</td>
<td>末尾 LBA</td>
</tr>
<tr>
<td>48</td>
<td>8 字节</td>
<td>属性标签（如 bit60 表示“只读”）</td>
</tr>
<tr>
<td>56</td>
<td>72 字节</td>
<td>分区名，可以包括 36 个 UTF-16（小端序）字符</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令行使用基础</title>
    <url>/1784829336/</url>
    <content><![CDATA[<h1 id="终端类型"><a class="markdownIt-Anchor" href="#终端类型"></a> 终端类型</h1>
<p>只使用文本的终端被称为字符终端（Character Terminal）或基于文本的终端（Text-Based Terminal），统称命令行界面（CLI，Command Line Interface）。其硬件设备标准代表是 DEC 公司 1978 年生产的 VT100。</p>
<p>图形终端（Graphics Terminal）不仅可以处理文本，还可以显示任何能使用小点在屏幕上进行绘制的内容，也就是可以通过图形用户界面（GUI，Graphical User Interface）和服务端交互。Unix 的 GUI 都基于 X Window System。在图形终端中，用户可以通过鼠标、键盘和触摸屏等设备进行交互操作，相比于命令行界面，图形终端更加直观和易用。</p>
<p>在现代计算机系统中，通常都同时支持命令行界面和图形界面。命令行界面通常用于系统维护、编程和高级用户操作等任务，而图形界面则主要用于日常应用程序的操作和交互。</p>
<p>可以通过查看 <code>$TERM</code> 变量来了解当前使用的终端配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$TERM</span>
vt100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="常用组合快捷键"><a class="markdownIt-Anchor" href="#常用组合快捷键"></a> 常用组合快捷键</h1>
<p>在终端中常用的快捷键如下：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>【Tab】</td>
<td>命令补全/文件名补齐。</td>
</tr>
<tr>
<td>【Ctrl】+C</td>
<td>中断操作，停止程序运行。</td>
</tr>
<tr>
<td>【Ctrl】+D</td>
<td>键盘输入结束/退出终端/删除光标后字符。</td>
</tr>
<tr>
<td>【Ctrl】+Z</td>
<td>暂停当前进程并丢入后台。</td>
</tr>
<tr>
<td>【Ctrl】+S</td>
<td>暂停当前程序，暂停后按下任意键恢复运行。</td>
</tr>
<tr>
<td>【Ctrl】+A</td>
<td>将光标移动到命令行首。</td>
</tr>
<tr>
<td>【Ctrl】+E</td>
<td>将光标移动到命令行尾。</td>
</tr>
<tr>
<td>【Ctrl】+L</td>
<td>清屏。</td>
</tr>
<tr>
<td>【Ctrl】+【Shift】+N</td>
<td>新建终端窗口。</td>
</tr>
</tbody>
</table>
<h1 id="命令提示符"><a class="markdownIt-Anchor" href="#命令提示符"></a> 命令提示符</h1>
<p>成功登录系统后，终端会显示如下命令提示符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>各字段的含义如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>root</td>
<td>标识当前登录的用户身份</td>
</tr>
<tr>
<td>101c7</td>
<td>表示当前主机的名称</td>
</tr>
<tr>
<td>~</td>
<td>表示当前所在的目录。其中，~表示当前用户的主目录，是一个变量。</td>
</tr>
<tr>
<td>#</td>
<td>如果当前用户为 root，命令提示符为 #；如果为普通用户，则为 $。</td>
</tr>
</tbody>
</table>
<h1 id="命令格式"><a class="markdownIt-Anchor" href="#命令格式"></a> 命令格式</h1>
<p>一般命令格式如下，中括号 [] 表示非必须输入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">命令名称 <span class="token punctuation">[</span>-选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数1<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数2<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="命令名称"><a class="markdownIt-Anchor" href="#命令名称"></a> 命令名称</h2>
<p>一行命令第一个输入的部分绝对是命令（command）或可执行文件。</p>
<p>当命令太长时，可以使用反斜杠 \ 来转义回车（必须立刻接特殊字符才能转义），使命令输入连续到下一行。</p>
<p>命令严格区分大小写，通常由小写字母构成。</p>
<h2 id="选项"><a class="markdownIt-Anchor" href="#选项"></a> 选项</h2>
<p>选项（options）前通常会加 - 号，例如 -h。</p>
<p>有时表示输入选项完整全名，则使用 – 符号，例如 <code>--help</code>。</p>
<p>多个选项可以用一个 - 连接起来，例如 -abc，表示同时使用 a、b、c 三个选项。</p>
<h2 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h2>
<p>参数（parameter）用于向希望运行的程序传递信息，通常是一些文件名，告诉命令从哪里可以得到输入，以及把输出送到什么地方。</p>
<p>参数之间用空格隔开，多个空格会被视为一个空格。如果参数中含有空格，应该使用双引号或单引号将其括起来，例如：<code>&quot;file name&quot;</code>。</p>
<h1 id="执行命令"><a class="markdownIt-Anchor" href="#执行命令"></a> 执行命令</h1>
<p>在命令行执行命令时，通常有以下两种情况：</p>
<ul>
<li>按下回车键后，命令立即运行并显示结果，等待下一条命令输入。</li>
<li>进入到该命令的环境中，直到结束该命令才回到命令提示符的环境。</li>
</ul>
<p>在命令正常执行完毕后，会返回一个值。如果命令执行成功，则返回值为 0。如果命令执行过程中出错没有完成全部工作，则返回一个非零值（可以通过变量$?查看）。</p>
<h2 id="命令执行顺序"><a class="markdownIt-Anchor" href="#命令执行顺序"></a> 命令执行顺序</h2>
<p>命令的执行顺序按照以下优先级排列：</p>
<ol>
<li>以相对/绝对路径执行命令，例如 <code>/bin/ls</code> 或 <code>ls</code>。</li>
<li>由别名（alias）找到该命令来执行。</li>
<li>由 bash 内置的（builtin）命令来执行。</li>
<li>通过$PATH 变量的顺序找到的第一个命令来执行。</li>
</ol>
<h2 id="执行多条命令"><a class="markdownIt-Anchor" href="#执行多条命令"></a> 执行多条命令</h2>
<p>可以用分号将多条命令写在同一行，这些命令将会依次执行。</p>
<p>例如：查看 root.txt 文件属性；修改其权限为 6755；再次查看 root.txt 的属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll root.txt <span class="token punctuation">;</span> <span class="token function">chmod</span> <span class="token number">6775</span> root.txt <span class="token punctuation">;</span> ll root.txt 
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">7549</span> Sep <span class="token number">11</span> <span class="token number">11</span>:59 root.txt
-rwsrwsr-x. <span class="token number">1</span> root root <span class="token number">7549</span> Sep <span class="token number">11</span> <span class="token number">11</span>:59 root.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="报错信息"><a class="markdownIt-Anchor" href="#报错信息"></a> 报错信息</h2>
<p>以下是两条报错信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">cat</span> nohup.out <span class="token punctuation">;</span> catt
cat: nohup.out: Permission denied
bash: catt: <span class="token builtin class-name">command</span> not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面的报错信息使用冒号 : 分隔成了三段，分别表示：命令、参数和报错原因。</p>
<h1 id="命令别名"><a class="markdownIt-Anchor" href="#命令别名"></a> 命令别名</h1>
<p>使用<code>alias</code>命令可以为命令或一组命令指定自定义名称。例如，将命令<code>ll -a | more</code>设置为<code>lm</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">lm</span><span class="token operator">=</span><span class="token string">'ll -a | more'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要查询已定义的别名，可以使用<code>-p</code>参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">alias</span> <span class="token parameter variable">-p</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">cp</span><span class="token operator">=</span><span class="token string">'cp -i'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">egrep</span><span class="token operator">=</span><span class="token string">'egrep --color=auto'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果要取消别名，使用<code>unalias</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">unalias</span> lm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要临时挂起别名，例如想要使用原始的<code>ls</code>命令而不是带有<code>--color=auto</code>参数的别名<code>ls</code>，可以在命令前面加上反斜杠\字符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token punctuation">\</span>ls <span class="token parameter variable">-la</span>
total <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="历史命令"><a class="markdownIt-Anchor" href="#历史命令"></a> 历史命令</h1>
<p>使用快捷键 [Ctrl]+r 可以搜索历史命令记录。搜索结果继续按 [Ctrl]+r 显示上一个找到的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>reverse-i-search<span class="token punctuation">)</span>`history': <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以使用 <code>history</code> 命令查询输入过的历史命令列表。默认情况下，历史命令保存在 <code>~/.bash_history</code> 中。只有在注销登录后，此次会话所执行的命令才会写入文件中。</p>
<p>可用参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>清除所有记录。</td>
</tr>
<tr>
<td>-d</td>
<td>删除指定编号的命令记录。</td>
</tr>
<tr>
<td>-a</td>
<td>插入当前历史记录到指定文件末尾，默认会将此次会话的历史记录写入到 .bash_history 文件中。</td>
</tr>
<tr>
<td>-w</td>
<td>写入当前的历史记录到指定文件中。</td>
</tr>
</tbody>
</table>
<p>例如，要显示最近的 5 条历史记录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">history</span> <span class="token number">5</span>
  <span class="token number">888</span>  <span class="token function">date</span>
  <span class="token number">889</span>  <span class="token function">time</span>
  <span class="token number">890</span>  w <span class="token parameter variable">-i</span>
  <span class="token number">891</span>  <span class="token function">cat</span> .bash_history 
  <span class="token number">892</span>  <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过<code>!记录编号</code>直接执行对应的命令。例如，要重新运行第 890 条记录，可以输入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token operator">!</span><span class="token number">890</span>
w <span class="token parameter variable">-i</span>
<span class="token number">23</span>:41:23 up <span class="token number">1</span> day,  <span class="token number">8</span>:32,  <span class="token number">2</span> users,  load average: <span class="token number">0.00</span>, <span class="token number">0.01</span>, <span class="token number">0.05</span>
<span class="token environment constant">USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    <span class="token number">192.168</span>.2.101    04:01    <span class="token number">3</span>.00s  <span class="token number">0</span>.84s  <span class="token number">0</span>.00s w <span class="token parameter variable">-i</span>
root     pts/1    <span class="token number">192.168</span>.2.101    <span class="token number">15</span>:12    <span class="token number">8</span>:28m  <span class="token number">0</span>.01s  <span class="token number">0</span>.01s <span class="token parameter variable">-bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用<code>!!</code>，则会执行上一个命令。</p>
<h1 id="清屏"><a class="markdownIt-Anchor" href="#清屏"></a> 清屏</h1>
<p>直接输入 <code>clear</code> 命令能清屏：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">clear</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>0.基础概论</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 权限配置管理</title>
    <url>/2354164977/</url>
    <content><![CDATA[<h1 id="修改文件所属用户组"><a class="markdownIt-Anchor" href="#修改文件所属用户组"></a> 修改文件所属用户组</h1>
<p>使用 <code>chgrp</code> 可以改变一个文件的所属用户组，目标组名必须已经存在于 <code>/etc/group</code>。</p>
<p>例如修改 <code>dir1</code> 文件夹的所属组为 <code>tss</code>：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chgrp</span> tss dir1 <span class="token punctuation">;</span> ll
total <span class="token number">4</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:38 anaconda-ks.cfg
drwxr-xr-x. <span class="token number">2</span> <span class="token function">ftp</span>  tss    <span class="token number">16</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用选项 <code>-R</code> 可以递归修改目录 <code>dir1</code> 下内容的所属组：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chgrp</span> input <span class="token parameter variable">-R</span> dir1 <span class="token punctuation">;</span> ll dir1
total <span class="token number">0</span>
-rw-r--r--. <span class="token number">1</span> root input <span class="token number">0</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="修改文件所有者"><a class="markdownIt-Anchor" href="#修改文件所有者"></a> 修改文件所有者</h1>
<p>使用<code>chown</code>命令可以修改文件或目录的所有者和所属组。目标用户名必须已经存在于<code>/etc/passwd</code>文件中。</p>
<p>例如，将文件夹<code>dir1</code>的所有者设置为<code>lp</code>，所属组设置为<code>tape</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> lp:tape dir1 <span class="token punctuation">;</span> ll
total <span class="token number">4</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:38 anaconda-ks.cfg
drwxr-xr-x. <span class="token number">2</span> lp   tape   <span class="token number">16</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>-R</code>参数可以递归修改目录下的文件或子目录的所有者和所属组：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token parameter variable">-R</span> ftp:ftp dir1 <span class="token punctuation">;</span> ll dir1
total <span class="token number">0</span>
-rw-r--r--. <span class="token number">1</span> <span class="token function">ftp</span> <span class="token function">ftp</span> <span class="token number">0</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="修改文件权限"><a class="markdownIt-Anchor" href="#修改文件权限"></a> 修改文件权限</h1>
<p>使用<code>chmod</code>设置权限（只有文件所有者和 root 能执行），可以使用数字或字符来更改，数字类型采用数字累加来代表：</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>字符</th>
<th>权限（文件/目录）</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>r</td>
<td>读取文件内容/查看目录下的文件或目录名称（无法看到属性）</td>
</tr>
<tr>
<td>2</td>
<td>w</td>
<td>修改文件内容（不包含删除）/在目录下新建、删除、重命名文件或目录</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>文件可以被系统执行/进入目录、遍历目录</td>
</tr>
</tbody>
</table>
<p>特殊权限：</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>权限（文件/目录）</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>SUID（用在文件上）</td>
</tr>
<tr>
<td>2</td>
<td>SGID</td>
</tr>
<tr>
<td>1</td>
<td>SBIT（用在目录上）</td>
</tr>
</tbody>
</table>
<p>例如修改<code>dir1</code>文件夹的权限为<code>rwxrw---x</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">761</span> dir1 <span class="token punctuation">;</span> ll
total <span class="token number">4</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:38 anaconda-ks.cfg
drwxrw---x. <span class="token number">2</span> <span class="token function">ftp</span>  tss    <span class="token number">16</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>用字符类型改变文件权限方式：</p>
<ul>
<li>用<code>u</code>、<code>g</code>、<code>o</code>、<code>a</code>分别表示所有者、组、其他人和所有人。</li>
<li>用<code>+</code>、<code>-</code>、<code>=</code>分别表示增加、去除、设置权限。如果没有指定权限，则该权限不会发生变化。</li>
</ul>
<p>例如设置 <code>dir1</code> 文件夹及其下的所有文件权限为 <code>rwxrwxr--</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token assign-left variable">u</span><span class="token operator">=</span>rwx,g<span class="token operator">=</span>rwx,o<span class="token operator">=</span>r dir1
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll dir1
total <span class="token number">0</span>
-rwxrwxr--. <span class="token number">1</span> <span class="token function">ftp</span> root <span class="token number">0</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置 <code>dir</code> 文件夹禁止进入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> a-x dir1 <span class="token punctuation">;</span> ll
total <span class="token number">4</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">1260</span> Sep  <span class="token number">7</span> <span class="token number">13</span>:38 anaconda-ks.cfg
drw-rw-r--. <span class="token number">2</span> <span class="token function">ftp</span>  tss    <span class="token number">16</span> Sep  <span class="token number">8</span> <span class="token number">23</span>:29 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要给文件 <code>2</code> 设置 SUID/SGID 的权限（也可以使用 <code>u+s,g+s,o+t</code> 命令来设置 SUID、SGID、SBIT），可以使用以下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">6755</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token number">2</span>
-rwsr-sr-x. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 07:57 <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当用户没有执行权限却设置了特殊权限时，特殊权限中的 <code>s</code> 和 <code>t</code> 会变成 <code>S</code> 和 <code>T</code>，表示无效权限。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">chmod</span> <span class="token number">7666</span> <span class="token number">2</span><span class="token punctuation">;</span> ll <span class="token number">2</span>
-rwSrwSrwT. <span class="token number">1</span> root root <span class="token number">0</span> Sep  <span class="token number">9</span> 08:57 <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="修改默认权限"><a class="markdownIt-Anchor" href="#修改默认权限"></a> 修改默认权限</h1>
<p>文件创建时默认（<code>umask</code> 为 <code>000</code> 的情况）权限是 <code>666</code>，文件夹是 <code>777</code>，可以使用 <code>umask</code> 来对这一权限进一步削弱。</p>
<p><code>root</code> 用户的 <code>umask</code> 默认为 <code>022</code>，一般用户为 <code>002</code>。使用 <code>umask</code> 修改的值必须写入到 <code>.profile</code> 文件中才能一直生效。</p>
<p>查看目前用户在新建文件和目录时的权限默认值：</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token builtin class-name">umask</span>
0022<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上述命令表示新建文件不包括属组和其他用户的写权限。如果要添加属组的写权限，需要定义 <code>umask</code> 值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token builtin class-name">umask</span> 002 <span class="token punctuation">;</span> <span class="token builtin class-name">umask</span>
0002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="访问控制列表"><a class="markdownIt-Anchor" href="#访问控制列表"></a> 访问控制列表</h1>
<p>在默认权限无法满足要求时，可以考虑使用访问控制列表。</p>
<h2 id="acl-访问控制列表"><a class="markdownIt-Anchor" href="#acl-访问控制列表"></a> ACL 访问控制列表</h2>
<p>ACL 是 Access Control List 的缩写，主要用于提供传统权限之外的具体权限设置。ACL 可以针对单个用户或组、单个文件或目录进行权限控制。</p>
<p>默认情况下，系统会自动启用 ACL 支持。可以使用 <code>dumpe2fs -h</code> 命令查询挂载参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> sd
/dev/sda1 on /boot <span class="token builtin class-name">type</span> xfs <span class="token punctuation">(</span>rw,relatime,seclabel,attr2,inode64,noquota<span class="token punctuation">)</span>
/dev/sdb4 on /root/sdb4m <span class="token builtin class-name">type</span> ext3 <span class="token punctuation">(</span>rw,relatime,seclabel,data<span class="token operator">=</span>ordered<span class="token punctuation">)</span>
/dev/sdb5 on /ext333 <span class="token builtin class-name">type</span> ext3 <span class="token punctuation">(</span>rw,relatime,seclabel,data<span class="token operator">=</span>ordered<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ dumpe2fs <span class="token parameter variable">-h</span> /dev/sdb4 <span class="token operator">|</span> <span class="token function">grep</span> acl
dumpe2fs <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Default <span class="token function">mount</span> options:    user_xattr acl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>若要手动挂载 ACL，可以使用 <code>mount -o remount,acl /</code> 命令，或者修改启动配置 <code>/etc/fstab</code>。</p>
<h2 id="设置-acl"><a class="markdownIt-Anchor" href="#设置-acl"></a> 设置 ACL</h2>
<p>可以使用 <code>setfacl</code> 来设置某个文件或目录的 ACL 规定，命令用法如下：</p>
<p><code>setfacl [-bkRd] [&#123;-m|-x&#125; acl 参数] 目标</code></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-m</td>
<td>设置后续的 ACL 参数给文件使用</td>
</tr>
<tr>
<td>-x</td>
<td>删除后续的 ACL 参数</td>
</tr>
<tr>
<td>-b</td>
<td>删除所有的 ACL 设置参数</td>
</tr>
<tr>
<td>-k</td>
<td>删除默认的 ACL 参数</td>
</tr>
<tr>
<td>-R</td>
<td>递归设置</td>
</tr>
<tr>
<td>-d</td>
<td>设置默认 ACL 参数，只对目录有效，目录下新建的数据都会用此默认值</td>
</tr>
</tbody>
</table>
<p>针对单个用户设置，例如给用户 <code>user1</code> 设置目录 <code>dir1</code> 的读取和执行权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ setfacl <span class="token parameter variable">-m</span> u:user1:rx dir1
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-d</span> dir1
drwxr-xr-x+ <span class="token number">2</span> root root <span class="token number">2048</span> Sep <span class="token number">13</span> 07:34 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到权限部分多了一个加号 <code>+</code>。</p>
<h2 id="查询-acl"><a class="markdownIt-Anchor" href="#查询-acl"></a> 查询 ACL</h2>
<p>要查询特殊权限，可以使用 <code>getfacl</code> 命令，该命令参数与 <code>setfacl</code> 相同。例如，要查询 <code>dir1</code> 的权限内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ getfacl dir1
<span class="token comment"># file: dir1</span>
<span class="token comment"># owner: root</span>
<span class="token comment"># group: root</span>
user::rwx
user:user1:r-x
group::r-x
mask::r-x
other::r--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>user</code>、<code>group</code>、<code>other</code> 代表普通权限。另外，还有一条刚设置的 <code>user1</code> 权限。</p>
<h2 id="有效权限"><a class="markdownIt-Anchor" href="#有效权限"></a> 有效权限</h2>
<p>ACL 中的 <code>mask</code> 规定了最大权限，也就是单独设置的权限不能超过 <code>mask</code> 显示的权限。</p>
<p>首先，给用户组 <code>user1</code> 设置目录 <code>dir1</code> 的写权限：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ setfacl <span class="token parameter variable">-m</span> g:user1:w dir1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，将 <code>dir1</code> 的 <code>mask</code> 权限设置为只读：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ setfacl <span class="token parameter variable">-m</span> m:r dir1
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ getfacl dir1
<span class="token comment"># file: dir1</span>
<span class="token comment"># owner: root</span>
<span class="token comment"># group: root</span>
user::rwx
user:user1:r-x                  <span class="token comment">#effective:r--</span>
group::r-x                      <span class="token comment">#effective:r--</span>
group:user1:-w-                 <span class="token comment">#effective:---</span>
mask::r--
other::r-x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，<code>effective</code> 后面显示的才是有效权限。</p>
<h2 id="权限继承"><a class="markdownIt-Anchor" href="#权限继承"></a> 权限继承</h2>
<p>可以使用 <code>d:[ug]:用户列表:[rwx]</code> 命令设置 ACL 权限被后续子文件夹和目录继承：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ setfacl <span class="token parameter variable">-m</span> d:g:user1:w dir1
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> dir2 <span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token parameter variable">-ld</span> dir2 <span class="token punctuation">;</span> getfacl dir2
drwxrwxr-x+ <span class="token number">2</span> root root <span class="token number">2048</span> Sep <span class="token number">13</span> 07:56 dir2
<span class="token comment"># file: dir2</span>
<span class="token comment"># owner: root</span>
<span class="token comment"># group: root</span>
user::rwx
group::r-x
group:user1:-w-
mask::rwx
other::r-x
default:user::rwx
default:group::r-x
default:group:user1:-w-
default:mask::rwx
default:other::r-x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样设置后，<code>dir2</code> 目录会继承 <code>dir1</code> 目录的 ACL 权限。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 磁盘管理</title>
    <url>/3491093041/</url>
    <content><![CDATA[<h1 id="磁盘查询"><a class="markdownIt-Anchor" href="#磁盘查询"></a> 磁盘查询</h1>
<p>主要是 <code>df</code> 这个命令，经常用来查询系统中磁盘剩余空间。比如发现根目录 <code>/</code> 满了，说明系统危险了。</p>
<h2 id="查询磁盘容量"><a class="markdownIt-Anchor" href="#查询磁盘容量"></a> 查询磁盘容量</h2>
<p>使用 <code>df</code> 查看磁盘使用量，<code>df</code> 读取的是在 Superblock 内的信息。</p>
<p>例如查看系统内所有的文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-h</span>
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 <span class="token number">1</span>.9G     <span class="token number">0</span>  <span class="token number">1</span>.9G   <span class="token number">0</span>% /dev
tmpfs                    <span class="token number">1</span>.9G     <span class="token number">0</span>  <span class="token number">1</span>.9G   <span class="token number">0</span>% /dev/shm
tmpfs                    <span class="token number">1</span>.9G   12M  <span class="token number">1</span>.9G   <span class="token number">1</span>% /run
tmpfs                    <span class="token number">1</span>.9G     <span class="token number">0</span>  <span class="token number">1</span>.9G   <span class="token number">0</span>% /sys/fs/cgroup
/dev/mapper/centos-root   17G  <span class="token number">2</span>.1G   15G  <span class="token number">13</span>% /
/dev/sda1               1014M  187M  828M  <span class="token number">19</span>% /boot
tmpfs                    378M     <span class="token number">0</span>  378M   <span class="token number">0</span>% /run/user/0
/dev/sdb1                991M  <span class="token number">1</span>.3M  939M   <span class="token number">1</span>% /ext333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当查询目标是目录或文件时，<code>df</code> 会自动分析该目录所在分区，实际看到的是分区容量信息。</p>
<p>将所有特殊文件格式和名称（例如内存挂载点 <code>/proc</code>）都列出来，可以使用 <code>-aT</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-aT</span>
Filesystem              Type        1K-blocks    Used Available Use% Mounted on
sysfs                   sysfs               <span class="token number">0</span>       <span class="token number">0</span>         <span class="token number">0</span>    - /sys
proc                    proc                <span class="token number">0</span>       <span class="token number">0</span>         <span class="token number">0</span>    - /proc
/dev/mapper/centos-root xfs          <span class="token number">17811456</span> <span class="token number">2724256</span>  <span class="token number">15087200</span>  <span class="token number">16</span>% /
/dev/sda1               xfs           <span class="token number">1038336</span>  <span class="token number">190536</span>    <span class="token number">847800</span>  <span class="token number">19</span>% /boot
/dev/mapper/VG400-LV400 ext3           <span class="token number">190145</span>   <span class="token number">63472</span>    <span class="token number">117934</span>  <span class="token number">35</span>% /ext333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询各分区中可用 inode 数量：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-ih</span>
Filesystem              Inodes IUsed IFree IUse% Mounted on
/dev/mapper/centos-root   <span class="token number">8</span>.5M   46K  <span class="token number">8</span>.5M    <span class="token number">1</span>% /
/dev/sda1                 512K   <span class="token number">335</span>  512K    <span class="token number">1</span>% /boot
tmpfs                     472K     <span class="token number">1</span>  472K    <span class="token number">1</span>% /run/user/0
/dev/sdb1                  64K    <span class="token number">13</span>   64K    <span class="token number">1</span>% /ext333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="列出分区信息"><a class="markdownIt-Anchor" href="#列出分区信息"></a> 列出分区信息</h2>
<p>可以使用命令 <code>lsblk</code> 来查询所有储存设备。</p>
<p>例如查看当前系统下所有磁盘与分区情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ lsblk <span class="token parameter variable">-i</span>
NAME                 MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                    <span class="token number">8</span>:0    <span class="token number">0</span>   20G  <span class="token number">0</span> disk 
<span class="token operator">|</span>-sda1                 <span class="token number">8</span>:1    <span class="token number">0</span>    1G  <span class="token number">0</span> part /boot
<span class="token variable"><span class="token variable">`</span><span class="token parameter variable">-sda2</span>                 <span class="token number">8</span>:2    <span class="token number">0</span>   19G  <span class="token number">0</span> part 
  <span class="token operator">|</span>-centos-root      <span class="token number">253</span>:0    <span class="token number">0</span>   17G  <span class="token number">0</span> lvm  /
  <span class="token variable">`</span></span>-centos-swap      <span class="token number">253</span>:1    <span class="token number">0</span>    2G  <span class="token number">0</span> lvm  <span class="token punctuation">[</span>SWAP<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 MAJ:MIN 代表主要 : 次要设备代码，RM 标记是否为可移动（removable）设备，RO 为是否以只读挂载。</p>
<p>也可以只单独查询某个磁盘，用 <code>-p</code> 参数显示分区全名：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ lsblk <span class="token parameter variable">-ip</span> /dev/sda
NAME                        MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
/dev/sda                      <span class="token number">8</span>:0    <span class="token number">0</span>  20G  <span class="token number">0</span> disk 
<span class="token operator">|</span>-/dev/sda1                   <span class="token number">8</span>:1    <span class="token number">0</span>   1G  <span class="token number">0</span> part /boot
<span class="token variable"><span class="token variable">`</span>-/dev/sda2                   <span class="token number">8</span>:2    <span class="token number">0</span>  19G  <span class="token number">0</span> part 
  <span class="token operator">|</span>-/dev/mapper/centos-root <span class="token number">253</span>:0    <span class="token number">0</span>  17G  <span class="token number">0</span> lvm  /
  <span class="token variable">`</span></span>-/dev/mapper/centos-swap <span class="token number">253</span>:1    <span class="token number">0</span>   2G  <span class="token number">0</span> lvm  <span class="token punctuation">[</span>SWAP<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UUID（Universally Unique Identifier）是全域单一识别码，也可以用 UUID 来挂载设备。使用 <code>blkid</code> 命令来查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ blkid
/dev/mapper/centos-root: <span class="token assign-left variable">UUID</span><span class="token operator">=</span><span class="token string">"bb5b6906-0dff-46c4-832e-1701522802e6"</span> <span class="token assign-left variable">TYPE</span><span class="token operator">=</span><span class="token string">"xfs"</span> 
/dev/sda2: <span class="token assign-left variable">UUID</span><span class="token operator">=</span><span class="token string">"0lYfzD-6Mqj-AtC4-Jgf1-LGpk-ODIk-xbJIa7"</span> <span class="token assign-left variable">TYPE</span><span class="token operator">=</span><span class="token string">"LVM2_member"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h1>
<p>如果是 MBR 分区表，使用 <code>fdisk</code> 分区；GPT 分区使用 <code>gdisk</code> 分区。两种工具在使用方法上没有区别。这里使用 <code>fdisk</code> 演示。</p>
<h2 id="查看分区"><a class="markdownIt-Anchor" href="#查看分区"></a> 查看分区</h2>
<p>例如，查看系统内的所有分区：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> <span class="token parameter variable">-l</span>
Disk /dev/sda: <span class="token number">21.5</span> GB, <span class="token number">21474836480</span> bytes, <span class="token number">41943040</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos
Disk identifier: 0x000a3a75

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        <span class="token number">2048</span>     <span class="token number">2099199</span>     <span class="token number">1048576</span>   <span class="token number">83</span>  Linux
/dev/sda2         <span class="token number">2099200</span>    <span class="token number">41943039</span>    <span class="token number">19921920</span>   8e  Linux LVM

Disk /dev/mapper/centos-root: <span class="token number">18.2</span> GB, <span class="token number">18249416704</span> bytes, <span class="token number">35643392</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes


Disk /dev/mapper/centos-swap: <span class="token number">2147</span> MB, <span class="token number">2147483648</span> bytes, <span class="token number">4194304</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由上述信息可见，sda 分了两个区，其中 sda 可做启动引导。</p>
<p>对新增的磁盘 sdb 进行操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> /dev/sdb
Welcome to <span class="token function">fdisk</span> <span class="token punctuation">(</span>util-linux <span class="token number">2.23</span>.2<span class="token punctuation">)</span>.

Changes will remain <span class="token keyword">in</span> memory only, <span class="token keyword">until</span> you decide to <span class="token function">write</span> them.
Be careful before using the <span class="token function">write</span> command.


Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进入 <code>fdisk</code> 后输入 <code>m</code> 可以查看帮助。常用命令有：<code>d</code> 删除分区，<code>n</code> 新增分区，<code>p</code> 显示分区表，<code>w</code> 写入分区信息并退出。</p>
<p>先看看分区状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: p

Disk /dev/sdb: <span class="token number">1073</span> MB, <span class="token number">1073741824</span> bytes, <span class="token number">2097152</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos
Disk identifier: 0x2de15e6d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            <span class="token number">2048</span>     <span class="token number">2097151</span>     <span class="token number">1047552</span>   <span class="token number">83</span>  Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由上表中可以看到：磁盘大小 1073 MB，扇区数 2097152，每个扇区大小 512 Bytes，分区开始扇区号 2048，截止扇区号 2097151，block 数（1KB 为单位）1047552。</p>
<h2 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h2>
<p>假设要删除 sdb1 分区，在等待命令页面输入 <code>d</code> 会提示要删除的分区编号（sdb 后面带的数字）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: d
Selected partition <span class="token number">1</span>
Partition <span class="token number">1</span> is deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>再次查看分区已经被删除了，保存退出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="新增分区"><a class="markdownIt-Anchor" href="#新增分区"></a> 新增分区</h2>
<p>输入 <code>n</code> 以后会进入新建分区交互界面：</p>
<ol>
<li>选择新增的分区类型是主分区 <code>p</code>；</li>
<li>设置为 4 号；</li>
<li>起始扇区号采用默认 2048；</li>
<li>结束扇区号可以输入扇区号，也可以输入大小，这里输入 <code>+100M</code> 大小：</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition type:
   p   primary <span class="token punctuation">(</span><span class="token number">0</span> primary, <span class="token number">0</span> extended, <span class="token number">4</span> <span class="token function">free</span><span class="token punctuation">)</span>
   e   extended
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: p
Using default response p
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-4, default <span class="token number">1</span><span class="token punctuation">)</span>: <span class="token number">4</span>
First sector <span class="token punctuation">(</span><span class="token number">2048</span>-2097151, default <span class="token number">2048</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">2048</span>
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">2048</span>-2097151, default <span class="token number">2097151</span><span class="token punctuation">)</span>: +100M
Partition <span class="token number">4</span> of <span class="token builtin class-name">type</span> Linux and of size <span class="token number">100</span> MiB is <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再新增一个 200M 大小的扩展分区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition type:
   p   primary <span class="token punctuation">(</span><span class="token number">1</span> primary, <span class="token number">0</span> extended, <span class="token number">3</span> <span class="token function">free</span><span class="token punctuation">)</span>
   e   extended
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: e
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-3, default <span class="token number">1</span><span class="token punctuation">)</span>: <span class="token number">1</span>
First sector <span class="token punctuation">(</span><span class="token number">206848</span>-2097151, default <span class="token number">206848</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">206848</span>
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">206848</span>-2097151, default <span class="token number">2097151</span><span class="token punctuation">)</span>: +200M
Partition <span class="token number">1</span> of <span class="token builtin class-name">type</span> Extended and of size <span class="token number">200</span> MiB is <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完成后输入 <code>p</code> 查看状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: p

Disk /dev/sdb: <span class="token number">1073</span> MB, <span class="token number">1073741824</span> bytes, <span class="token number">2097152</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos
Disk identifier: 0x951d99c8

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1          <span class="token number">206848</span>      <span class="token number">616447</span>      <span class="token number">204800</span>    <span class="token number">5</span>  Extended
/dev/sdb4            <span class="token number">2048</span>      <span class="token number">206847</span>      <span class="token number">102400</span>   <span class="token number">83</span>  Linux

Partition table entries are not <span class="token keyword">in</span> disk order<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到有个主分区名字为 sdb4，扩展分区名为 sdb1，是我们手动设定的样子。</p>
<p>在扩展分区上建立个 80M 大小的逻辑分区，选择类型时输入 <code>l</code>，系统会自动分配分区号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition type:
   p   primary <span class="token punctuation">(</span><span class="token number">1</span> primary, <span class="token number">1</span> extended, <span class="token number">2</span> <span class="token function">free</span><span class="token punctuation">)</span>
   l   logical <span class="token punctuation">(</span>numbered from <span class="token number">5</span><span class="token punctuation">)</span>
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: l
Adding logical partition <span class="token number">5</span>
First sector <span class="token punctuation">(</span><span class="token number">208896</span>-616447, default <span class="token number">208896</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">208896</span>
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">208896</span>-616447, default <span class="token number">616447</span><span class="token punctuation">)</span>: +80M
Partition <span class="token number">5</span> of <span class="token builtin class-name">type</span> Linux and of size <span class="token number">80</span> MiB is <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完成后输入 <code>w</code> 保存更改并退出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>提示说要重启让改动生效，可以使用 <code>partprobe</code> 命令让内核重新扫描分区表：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ partprobe <span class="token parameter variable">-s</span>
/dev/sda: msdos partitions <span class="token number">1</span> <span class="token number">2</span>
/dev/sdb: msdos partitions <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
/dev/sdc: msdos partitions <span class="token number">1</span>
/dev/sr0: msdos partitions <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面展示使用 <code>gdisk</code> 制作一个 500MB 大小 GPT 分区的过程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ gdisk /dev/sdd
GPT <span class="token function">fdisk</span> <span class="token punctuation">(</span>gdisk<span class="token punctuation">)</span> version <span class="token number">0.8</span>.10

Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-128, default <span class="token number">1</span><span class="token punctuation">)</span>: <span class="token number">1</span>
First sector <span class="token punctuation">(</span><span class="token number">34</span>-2097118, default <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">)</span> or <span class="token punctuation">&#123;</span>+-<span class="token punctuation">&#125;</span>size<span class="token punctuation">&#123;</span>KMGTP<span class="token punctuation">&#125;</span>: 
Last sector <span class="token punctuation">(</span><span class="token number">2048</span>-2097118, default <span class="token operator">=</span> <span class="token number">2097118</span><span class="token punctuation">)</span> or <span class="token punctuation">&#123;</span>+-<span class="token punctuation">&#125;</span>size<span class="token punctuation">&#123;</span>KMGTP<span class="token punctuation">&#125;</span>: +500MB
Current <span class="token builtin class-name">type</span> is <span class="token string">'Linux filesystem'</span>
Hex code or GUID <span class="token punctuation">(</span>L to show codes, Enter <span class="token operator">=</span> <span class="token number">8300</span><span class="token punctuation">)</span>: 
Changed <span class="token builtin class-name">type</span> of partition to <span class="token string">'Linux filesystem'</span>

Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w

Final checks complete. About to <span class="token function">write</span> GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS<span class="token operator">!</span><span class="token operator">!</span>

Do you want to proceed? <span class="token punctuation">(</span>Y/N<span class="token punctuation">)</span>: y
OK<span class="token punctuation">;</span> writing new GUID partition table <span class="token punctuation">(</span>GPT<span class="token punctuation">)</span> to /dev/sdd.
The operation has completed successfully.
<span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ partprobe <span class="token parameter variable">-s</span>
/dev/sda: msdos partitions <span class="token number">1</span> <span class="token number">2</span>
/dev/sdb: msdos partitions <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
/dev/sdc: msdos partitions <span class="token number">1</span>
/dev/sdd: gpt partitions <span class="token number">1</span>
/dev/sr0: msdos partitions <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="格式化分区"><a class="markdownIt-Anchor" href="#格式化分区"></a> 格式化分区</h2>
<p>建立分区后要格式化分区才可使用，格式化通过 <code>mkfs</code> 类命令操作。</p>
<p>将 sdb4 格式化成 ext3 文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkfs</span> <span class="token parameter variable">-t</span> ext3 /dev/sdb4 
<span class="token function">mke2fs</span> <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Filesystem <span class="token assign-left variable">label</span><span class="token operator">=</span>
OS type: Linux
Block <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">1024</span> <span class="token punctuation">(</span>log<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
Fragment <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">1024</span> <span class="token punctuation">(</span>log<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token assign-left variable">Stride</span><span class="token operator">=</span><span class="token number">0</span> blocks, Stripe <span class="token assign-left variable">width</span><span class="token operator">=</span><span class="token number">0</span> blocks
<span class="token number">25688</span> inodes, <span class="token number">102400</span> blocks
<span class="token number">5120</span> blocks <span class="token punctuation">(</span><span class="token number">5.00</span>%<span class="token punctuation">)</span> reserved <span class="token keyword">for</span> the super user
First data <span class="token assign-left variable">block</span><span class="token operator">=</span><span class="token number">1</span>
Maximum filesystem <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">67371008</span>
<span class="token number">13</span> block <span class="token function">groups</span>
<span class="token number">8192</span> blocks per group, <span class="token number">8192</span> fragments per group
<span class="token number">1976</span> inodes per group
Superblock backups stored on blocks: 
        <span class="token number">8193</span>, <span class="token number">24577</span>, <span class="token number">40961</span>, <span class="token number">57345</span>, <span class="token number">73729</span>

Allocating group tables: <span class="token keyword">done</span>                            
Writing inode tables: <span class="token keyword">done</span>                            
Creating journal <span class="token punctuation">(</span><span class="token number">4096</span> blocks<span class="token punctuation">)</span>: <span class="token keyword">done</span>
Writing superblocks and filesystem accounting information: <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要指定 label，block 大小，inode 数量等参数，需要使用 <code>mke2fs</code> 命令。</p>
<p>例如将 sdb4 设定卷标 boss，block 大小 2048，每 8192 bytes 分配一个 inode 后格式化成 ext3 文件系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mke2fs</span> <span class="token parameter variable">-j</span> <span class="token parameter variable">-L</span> <span class="token string">"boss"</span> <span class="token parameter variable">-b</span> <span class="token number">2048</span> <span class="token parameter variable">-i</span> <span class="token number">8192</span> /dev/sdb4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置文件系统不区分大小写：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mkfs.xfs <span class="token parameter variable">-L</span> datavolume <span class="token parameter variable">-f</span> <span class="token parameter variable">-n</span> <span class="token assign-left variable">version</span><span class="token operator">=</span>ci /dev/md0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用 <code>mkfs.xfs</code> 格式化 xfs 文件系统，要设定具体分区数值可用 <code>-d</code> 参数。指定储存区群组数量为 16 并强制格式化 sdd1：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ mkfs.xfs <span class="token parameter variable">-f</span> <span class="token parameter variable">-d</span> <span class="token assign-left variable">agcount</span><span class="token operator">=</span><span class="token number">16</span> /dev/sdd1
meta-data<span class="token operator">=</span>/dev/sdd1              <span class="token assign-left variable">isize</span><span class="token operator">=</span><span class="token number">512</span>    <span class="token assign-left variable">agcount</span><span class="token operator">=</span><span class="token number">16</span>, <span class="token assign-left variable">agsize</span><span class="token operator">=</span><span class="token number">8000</span> blks
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">attr</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">projid32bit</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">crc</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token assign-left variable">finobt</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">sparse</span><span class="token operator">=</span><span class="token number">0</span>
data     <span class="token operator">=</span>                       <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">128000</span>, <span class="token assign-left variable">imaxpct</span><span class="token operator">=</span><span class="token number">25</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span>      <span class="token assign-left variable">swidth</span><span class="token operator">=</span><span class="token number">0</span> blks
naming   <span class="token operator">=</span>version <span class="token number">2</span>              <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   ascii-ci<span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ftype</span><span class="token operator">=</span><span class="token number">1</span>
log      <span class="token operator">=</span>internal log           <span class="token assign-left variable">bsize</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">855</span>, <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token number">2</span>
         <span class="token operator">=</span>                       <span class="token assign-left variable">sectsz</span><span class="token operator">=</span><span class="token number">512</span>   <span class="token assign-left variable">sunit</span><span class="token operator">=</span><span class="token number">0</span> blks, lazy-count<span class="token operator">=</span><span class="token number">1</span>
realtime <span class="token operator">=</span>none                   <span class="token assign-left variable">extsz</span><span class="token operator">=</span><span class="token number">4096</span>   <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">rtextents</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="新建-swap-分区"><a class="markdownIt-Anchor" href="#新建-swap-分区"></a> 新建 swap 分区</h2>
<p>swap 内存交换空间用来在系统内存不足时，替代内存使用的硬盘空间。虽然内存不足的情况已经很少发生，但有些旧程序会要求使用 swap 分区，或者作为出现内存溢出等异常状态时缓冲一下，还是有必要建一个的。</p>
<p>下面将在 sdb 上使用空闲容量新建一个 256MB 大小的 swap 分区（代码 82）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition type:
   p   primary <span class="token punctuation">(</span><span class="token number">1</span> primary, <span class="token number">1</span> extended, <span class="token number">2</span> <span class="token function">free</span><span class="token punctuation">)</span>
   l   logical <span class="token punctuation">(</span>numbered from <span class="token number">5</span><span class="token punctuation">)</span>
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: p
Partition number <span class="token punctuation">(</span><span class="token number">2,3</span>, default <span class="token number">2</span><span class="token punctuation">)</span>: 
First sector <span class="token punctuation">(</span><span class="token number">616448</span>-2097151, default <span class="token number">616448</span><span class="token punctuation">)</span>: 
Using default value <span class="token number">616448</span>
Last sector, +sectors or +size<span class="token punctuation">&#123;</span>K,M,G<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token number">616448</span>-2097151, default <span class="token number">2097151</span><span class="token punctuation">)</span>: +256M
Partition <span class="token number">2</span> of <span class="token builtin class-name">type</span> Linux and of size <span class="token number">256</span> MiB is <span class="token builtin class-name">set</span>

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: t
Partition number <span class="token punctuation">(</span><span class="token number">1,2</span>,4,5, default <span class="token number">5</span><span class="token punctuation">)</span>: <span class="token number">2</span>
Hex code <span class="token punctuation">(</span>type L to list all codes<span class="token punctuation">)</span>: <span class="token number">82</span>
Changed <span class="token builtin class-name">type</span> of partition <span class="token string">'Linux'</span> to <span class="token string">'Linux swap / Solaris'</span>

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered<span class="token operator">!</span>

<span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ partprobe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用 <code>dd</code> 命令来创建一个空文件，当作 swap 分区使用。</p>
<p>使用 <code>mkswap</code> 格式化：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ <span class="token function">mkswap</span> /dev/sdb2
Setting up swapspace version <span class="token number">1</span>, size <span class="token operator">=</span> <span class="token number">262140</span> KiB
no label, <span class="token assign-left variable">UUID</span><span class="token operator">=</span>2cfd898c-2b54-467b-94a4-96c29567cb7d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接着用 <code>swapon</code> 命令加载 swap：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ <span class="token function">free</span>
              total        used        <span class="token function">free</span>      shared  buff/cache   available
Mem:        <span class="token number">3861280</span>      <span class="token number">248320</span>     <span class="token number">3108468</span>       <span class="token number">11880</span>      <span class="token number">504492</span>     <span class="token number">3329556</span>
Swap:       <span class="token number">2097148</span>           <span class="token number">0</span>     <span class="token number">2097148</span>
<span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ <span class="token function">swapon</span> /dev/sdb2
<span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ <span class="token function">free</span>
              total        used        <span class="token function">free</span>      shared  buff/cache   available
Mem:        <span class="token number">3861280</span>      <span class="token number">248636</span>     <span class="token number">3108120</span>       <span class="token number">11880</span>      <span class="token number">504524</span>     <span class="token number">3329304</span>
Swap:       <span class="token number">2359288</span>           <span class="token number">0</span>     <span class="token number">2359288</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以查看到已经在使用的 swap 设备有哪些：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 tinycore_iso<span class="token punctuation">]</span>$ <span class="token function">swapon</span> <span class="token parameter variable">-s</span>
Filename                                Type            Size    Used    Priority
/dev/dm-1                               partition       <span class="token number">2097148</span> <span class="token number">0</span>       <span class="token parameter variable">-2</span>
/dev/sdb2                               partition       <span class="token number">262140</span>  <span class="token number">0</span>       <span class="token parameter variable">-3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要开机启动记得修改 <code>/etc/fstab</code> 文件来开机挂载。</p>
<p>使用 <code>swapoff</code> 来关掉 swap file：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ swapoff /dev/sdb2<span class="token punctuation">;</span> <span class="token function">swapon</span> <span class="token parameter variable">-s</span>
Filename                                Type            Size    Used    Priority
/dev/dm-1                               partition       <span class="token number">2097148</span> <span class="token number">0</span>       <span class="token parameter variable">-2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="大容量磁盘分区"><a class="markdownIt-Anchor" href="#大容量磁盘分区"></a> 大容量磁盘分区</h2>
<p>由于 fdisk 无法支持 2TB 以上的分区，可以使用 <code>parted</code> 程序来分区，它同时支持 MBR 和 GPT 两种分区表格式。</p>
<p>查看当前的分区表资料：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">parted</span> /dev/sdb print
Model: VMware, VMware Virtual S <span class="token punctuation">(</span>scsi<span class="token punctuation">)</span>
Disk /dev/sdb: 1074MB
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End    Size    Type      File system     Flags
<span class="token number">4</span>      1049kB  106MB  105MB   primary   ext3
<span class="token number">1</span>      106MB   316MB  210MB   extended
<span class="token number">5</span>      107MB   191MB  <span class="token number">83</span>.9MB  logical
<span class="token number">2</span>      316MB   584MB  268MB   primary   linux-swap<span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建一个 ext3 格式 110M 大小的逻辑分区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">parted</span> /dev/sdb mkpart logical ext3 191MB 301MB
Warning: The resulting partition is not properly aligned <span class="token keyword">for</span> best performance.
Ignore/Cancel? Ignore                                                     
Information: You may need to update /etc/fstab.

<span class="token punctuation">[</span>root@101c7 <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">parted</span> /dev/sdb print
Model: VMware, VMware Virtual S <span class="token punctuation">(</span>scsi<span class="token punctuation">)</span>
Disk /dev/sdb: 1074MB
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End    Size    Type      File system     Flags
<span class="token number">4</span>      1049kB  106MB  105MB   primary   ext3
<span class="token number">1</span>      106MB   316MB  210MB   extended
<span class="token number">5</span>      107MB   191MB  <span class="token number">83</span>.9MB  logical
<span class="token number">6</span>      191MB   301MB  110MB   logical
<span class="token number">2</span>      316MB   584MB  268MB   primary   linux-swap<span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除刚刚新建的 sdb6 分区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">2</span><span class="token punctuation">]</span>$ <span class="token function">parted</span> /dev/sdb <span class="token function">rm</span> <span class="token number">6</span>
Information: You may need to update /etc/fstab.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="磁盘工具"><a class="markdownIt-Anchor" href="#磁盘工具"></a> 磁盘工具</h1>
<p>主要包括一些读写性能测试，文件系统修复等工具。</p>
<h2 id="ext-磁盘扫描"><a class="markdownIt-Anchor" href="#ext-磁盘扫描"></a> Ext 磁盘扫描</h2>
<p>Ext 文件系统可使用 <code>fsck</code> 来对磁盘进行扫描，检查文件系统错误。通常情况下只有出现问题才使用这个命令。</p>
<p>例如进入到单用户模式下，被检查的分区务必不可挂载到系统上，否则可能造成部分文件系统损坏。</p>
<p>可用参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-C</td>
<td>检验过程中显示进度</td>
</tr>
<tr>
<td>-f</td>
<td>强制检查，将所有状态为 clean 的扇区也纳入检查范围</td>
</tr>
<tr>
<td>-D</td>
<td>针对文件系统下的目录进行优化配置</td>
</tr>
<tr>
<td>-p</td>
<td>自动修复文件系统存在的问题</td>
</tr>
<tr>
<td>-b</td>
<td>接 superblock 位置，用来恢复主 superblock。一般备份在 1K=8193 / 2K=16384 / 4k=32768 位置</td>
</tr>
<tr>
<td>-c</td>
<td>对文件系统进行坏块检查，并添加到坏块列表中。</td>
</tr>
</tbody>
</table>
<p>检查 sdb4 分区：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fsck</span> <span class="token parameter variable">-C</span> <span class="token parameter variable">-f</span> /dev/sdb4
<span class="token function">fsck</span> from util-linux <span class="token number">2.23</span>.2
e2fsck <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Pass <span class="token number">1</span>: Checking inodes, blocks, and sizes
Pass <span class="token number">2</span>: Checking directory structure                                           
Pass <span class="token number">3</span>: Checking directory connectivity
Pass <span class="token number">4</span>: Checking reference counts
Pass <span class="token number">5</span>: Checking group summary information
boss: <span class="token number">11</span>/12800 files <span class="token punctuation">(</span><span class="token number">0.0</span>% non-contiguous<span class="token punctuation">)</span>, <span class="token number">5076</span>/51200 blocks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用备份恢复 sdb4 损坏的 superblock：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ fsck.ext3 <span class="token parameter variable">-b</span> <span class="token number">32768</span> /dev/sdb4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="xfs-磁盘扫描"><a class="markdownIt-Anchor" href="#xfs-磁盘扫描"></a> Xfs 磁盘扫描</h2>
<p>xfs 文件系统扫描使用 <code>xfs_repair</code> 工具。可用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>后面接文件文件而不是磁盘</td>
</tr>
<tr>
<td>-n</td>
<td>单纯检查并不修改文件系统的任何数据</td>
</tr>
<tr>
<td>-d</td>
<td>通常用在救援模式下面对根目录进行检查与修复的动作</td>
</tr>
</tbody>
</table>
<p>修复时同样要求先卸载目标分区，例如检查 <code>/dev/sdd1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ xfs_repair /dev/sdd1
Phase <span class="token number">1</span> - <span class="token function">find</span> and verify superblock<span class="token punctuation">..</span>.
Phase <span class="token number">2</span> - using internal log
Phase <span class="token number">3</span> - <span class="token keyword">for</span> each AG<span class="token punctuation">..</span>.
Phase <span class="token number">4</span> - check <span class="token keyword">for</span> duplicate blocks<span class="token punctuation">..</span>.
Phase <span class="token number">5</span> - rebuild AG headers and trees<span class="token punctuation">..</span>.
Phase <span class="token number">6</span> - check inode connectivity<span class="token punctuation">..</span>.
Phase <span class="token number">7</span> - verify and correct <span class="token function">link</span> counts<span class="token punctuation">..</span>.
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="坏道扫描"><a class="markdownIt-Anchor" href="#坏道扫描"></a> 坏道扫描</h2>
<p><code>badblocks</code> 命令用来检测硬盘扇区有没有坏道。其实等于 <code>mke2fs -c</code> 在进行格式化时处理磁盘表面的读取测试。</p>
<p>例如检查 sdb4 分区：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ badblocks <span class="token parameter variable">-sv</span> /dev/sdb4
Checking blocks <span class="token number">0</span> to <span class="token number">102399</span>
Checking <span class="token keyword">for</span> bad blocks <span class="token punctuation">(</span>read-only <span class="token builtin class-name">test</span><span class="token punctuation">)</span>: <span class="token keyword">done</span>                                                 
Pass completed, <span class="token number">0</span> bad blocks found. <span class="token punctuation">(</span><span class="token number">0</span>/0/0 errors<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修改设备代码"><a class="markdownIt-Anchor" href="#修改设备代码"></a> 修改设备代码</h2>
<p>有时需要手动处理设备文件，可以使用 <code>mknod</code> 命令来修改设备代码。</p>
<p>可修改的设备种类有 b（外部储存，移动硬盘），c（外部输入，鼠标），p（FIFO 文件）。</p>
<p>常见磁盘设备代码如下：</p>
<table>
<thead>
<tr>
<th>磁盘文件名</th>
<th>Major</th>
<th>Minor</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/sda</td>
<td>8</td>
<td>0-15</td>
</tr>
<tr>
<td>/dev/sdb</td>
<td>8</td>
<td>16-31</td>
</tr>
<tr>
<td>/dev/loop0</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>/dev/loop1</td>
<td>7</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>例如创建 sdb5 的设备代码 Maj:Min 为 8,21：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mknod</span> /dev/sdb5 b <span class="token number">8</span> <span class="token number">21</span><span class="token punctuation">;</span> ll /dev/sdb5
brw-rw----. <span class="token number">1</span> root disk <span class="token number">8</span>, <span class="token number">21</span> Sep <span class="token number">10</span> 04:08 /dev/sdb5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="修改分区卷标"><a class="markdownIt-Anchor" href="#修改分区卷标"></a> 修改分区卷标</h2>
<p>可以使用 <code>e2label</code> 来修改 ext 文件系统卷标（Label），卷标类似与 Win 中的 <code>本地磁盘</code>。</p>
<p>例如修改 sdb4 的卷标为 <code>P1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ e2label /dev/sdb4 <span class="token string">"P1"</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ dumpe2fs <span class="token parameter variable">-h</span> /dev/sdb4 <span class="token operator">|</span> <span class="token function">grep</span> name
dumpe2fs <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Filesystem volume name:   P1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可使用 <code>tune2fs</code> 命令来修改：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ tune2fs <span class="token parameter variable">-L</span> P2 /dev/sdb4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="修改-uuid"><a class="markdownIt-Anchor" href="#修改-uuid"></a> 修改 UUID</h2>
<p>XFS 文件系统使用 UUID 作为标识符，可以使用 <code>xfs_admin</code> 命令修改 UUID 和 Label。</p>
<p>例如修改 sdd1 的 Label name 为 xfs1：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ xfs_admin <span class="token parameter variable">-L</span> xfs1 /dev/sdd1
writing all SBs
new label <span class="token operator">=</span> <span class="token string">"xfs1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>修改 UUID 需要先生成 UUID 号码，可以使用 <code>uuidgen</code> 命令生成，然后再设置到 sdd1 上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ xfs_admin <span class="token parameter variable">-U</span> <span class="token variable"><span class="token variable">$(</span>uuidgen<span class="token variable">)</span></span> /dev/sdd1
Clearing log and setting UUID
writing all SBs
new UUID <span class="token operator">=</span> c96b6650-756a-4496-bf26-6e7286c55891<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="磁盘阵列"><a class="markdownIt-Anchor" href="#磁盘阵列"></a> 磁盘阵列</h1>
<p>使用 mdadm 软件模拟磁盘整列 RAID。如果需要监控 mdadm 建立的软磁盘阵列，可以使用 mdmonitor 服务。</p>
<h2 id="组建软磁盘阵列"><a class="markdownIt-Anchor" href="#组建软磁盘阵列"></a> 组建软磁盘阵列</h2>
<p>使用 <code>mdadm</code> 命令来设置软磁盘阵列，语法如下：</p>
<p><code>mdadm --detail /dev/md0</code></p>
<p><code>mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N --level=[015] --chuck=NK --spare-devices=N /dev/sdx /dev/hdx...</code></p>
<p>主要参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–create</td>
<td>新建 RAID 的参数</td>
</tr>
<tr>
<td>–auto=yes</td>
<td>决定新建后面接的软磁盘阵列设备，如 /dev/md0</td>
</tr>
<tr>
<td>–chunk=Nk</td>
<td>决定这个设备的 chunk 大小，一般是 64K 或 512K</td>
</tr>
<tr>
<td>–raid-devices=N</td>
<td>使用 N 个磁盘组件阵列</td>
</tr>
<tr>
<td>–spare-devices=N</td>
<td>使用 N 个磁盘作为备用设备</td>
</tr>
<tr>
<td>–level=[015]</td>
<td>设置磁盘阵列的等级</td>
</tr>
<tr>
<td>–detail</td>
<td>查询磁盘阵列设备的信息</td>
</tr>
</tbody>
</table>
<p>例如用组建 RAID 5 环境，每个分区为 10MB 大小（sdb6-9），有一块热备盘（sdb10），一块闲置盘（sdb11）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--create</span> <span class="token parameter variable">--auto</span><span class="token operator">=</span>yes /dev/md0 <span class="token parameter variable">--level</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">--chunk</span><span class="token operator">=</span>512K --raid-devices<span class="token operator">=</span><span class="token number">4</span> --spare-devices<span class="token operator">=</span><span class="token number">1</span> /dev/sdb<span class="token punctuation">&#123;</span><span class="token number">6,7</span>,8,9,10<span class="token punctuation">&#125;</span>
mdadm: Defaulting to version <span class="token number">1.2</span> metadata
mdadm: array /dev/md0 started.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果设置错误，可以使用 <code>mdadm --zero-superblock DEVICE</code> 命令来清空每个组成磁盘的超级块区。</p>
<p>查看组建好的软 RAID 5 设备 <code>/dev/md0</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--detail</span> /dev/md0
/dev/md0:
           Version <span class="token builtin class-name">:</span> <span class="token number">1.2</span>
     Creation Time <span class="token builtin class-name">:</span> Mon Sep <span class="token number">13</span> <span class="token number">15</span>:24:49 <span class="token number">2021</span>
        Raid Level <span class="token builtin class-name">:</span> raid5
        Array Size <span class="token builtin class-name">:</span> <span class="token number">24576</span> <span class="token punctuation">(</span><span class="token number">24.00</span> MiB <span class="token number">25.17</span> MB<span class="token punctuation">)</span>
     Used Dev Size <span class="token builtin class-name">:</span> <span class="token number">8192</span> <span class="token punctuation">(</span><span class="token number">8.00</span> MiB <span class="token number">8.39</span> MB<span class="token punctuation">)</span>
      Raid Devices <span class="token builtin class-name">:</span> <span class="token number">4</span>
     Total Devices <span class="token builtin class-name">:</span> <span class="token number">5</span>
       Persistence <span class="token builtin class-name">:</span> Superblock is persistent

       Update Time <span class="token builtin class-name">:</span> Mon Sep <span class="token number">13</span> <span class="token number">15</span>:24:50 <span class="token number">2021</span>
             State <span class="token builtin class-name">:</span> clean 
    Active Devices <span class="token builtin class-name">:</span> <span class="token number">4</span>
   Working Devices <span class="token builtin class-name">:</span> <span class="token number">5</span>
    Failed Devices <span class="token builtin class-name">:</span> <span class="token number">0</span>
     Spare Devices <span class="token builtin class-name">:</span> <span class="token number">1</span>

            Layout <span class="token builtin class-name">:</span> left-symmetric
        Chunk Size <span class="token builtin class-name">:</span> 512K

Consistency Policy <span class="token builtin class-name">:</span> resync

              Name <span class="token builtin class-name">:</span> 101c7:0  <span class="token punctuation">(</span>local to <span class="token function">host</span> 101c7<span class="token punctuation">)</span>
              UUID <span class="token builtin class-name">:</span> f64354f8:cf945331:eee97c66:84776736
            Events <span class="token builtin class-name">:</span> <span class="token number">18</span>

    Number   Major   Minor   RaidDevice State
       <span class="token number">0</span>       <span class="token number">8</span>       <span class="token number">22</span>        <span class="token number">0</span>      active <span class="token function">sync</span>   /dev/sdb6
       <span class="token number">1</span>       <span class="token number">8</span>       <span class="token number">23</span>        <span class="token number">1</span>      active <span class="token function">sync</span>   /dev/sdb7
       <span class="token number">2</span>       <span class="token number">8</span>       <span class="token number">24</span>        <span class="token number">2</span>      active <span class="token function">sync</span>   /dev/sdb8
       <span class="token number">5</span>       <span class="token number">8</span>       <span class="token number">25</span>        <span class="token number">3</span>      active <span class="token function">sync</span>   /dev/sdb9

       <span class="token number">4</span>       <span class="token number">8</span>       <span class="token number">26</span>        -      spare   /dev/sdb10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以通过 <code>/proc/mdstat</code> 文件查看磁盘阵列情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/mdstat 
Personalities <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>raid6<span class="token punctuation">]</span> <span class="token punctuation">[</span>raid5<span class="token punctuation">]</span> <span class="token punctuation">[</span>raid4<span class="token punctuation">]</span> 
md0 <span class="token builtin class-name">:</span> active raid5 sdb9<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> sdb10<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> sdb8<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> sdb7<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> sdb6<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token number">24576</span> blocks super <span class="token number">1.2</span> level <span class="token number">5</span>, 512k chunk, algorithm <span class="token number">2</span> <span class="token punctuation">[</span><span class="token number">4</span>/4<span class="token punctuation">]</span> <span class="token punctuation">[</span>UUUU<span class="token punctuation">]</span>
      
unused devices: <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>格式化并挂载 RAID 到 <code>/mnt/raid</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkfs</span> <span class="token parameter variable">-t</span> ext3 /dev/md0
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /mnt/raid <span class="token punctuation">;</span> <span class="token function">mount</span> /dev/md0 /mnt/raid <span class="token punctuation">;</span> <span class="token function">df</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'md0'</span>
/dev/md0                    <span class="token number">22773</span>     <span class="token number">209</span>     <span class="token number">21336</span>   <span class="token number">1</span>% /mnt/raid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果格式化成 xfs 格式，可以手动设置 su 和 sw 值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mkfs.xfs <span class="token parameter variable">-f</span> <span class="token parameter variable">-d</span> <span class="token assign-left variable">su</span><span class="token operator">=</span>512k, <span class="token assign-left variable">sw</span><span class="token operator">=</span><span class="token number">3</span> <span class="token parameter variable">-r</span> <span class="token assign-left variable">extsize</span><span class="token operator">=</span>1536k /dev/md0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="恢复磁盘阵列数据"><a class="markdownIt-Anchor" href="#恢复磁盘阵列数据"></a> 恢复磁盘阵列数据</h2>
<p><code>mdadm</code> 命令救援模式语法为：</p>
<p><code>mdadm --manage /dev/md[0-9] [--add 设备] [--remove 设备] [--fail 设备]</code></p>
<p>模拟磁盘出错可以使用 <code>--fail</code> 参数，模拟 sdb6 出错：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--manage</span> /dev/md0 <span class="token parameter variable">--fail</span> /dev/sdb6
mdadm: <span class="token builtin class-name">set</span> /dev/sdb6 faulty <span class="token keyword">in</span> /dev/md0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再次查看 RAID 状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/mdstat
Personalities <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>raid6<span class="token punctuation">]</span> <span class="token punctuation">[</span>raid5<span class="token punctuation">]</span> <span class="token punctuation">[</span>raid4<span class="token punctuation">]</span> 
md0 <span class="token builtin class-name">:</span> active raid5 sdb9<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> sdb10<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> sdb8<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> sdb7<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> sdb6<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span>
      <span class="token number">24576</span> blocks super <span class="token number">1.2</span> level <span class="token number">5</span>, 512k chunk, algorithm <span class="token number">2</span> <span class="token punctuation">[</span><span class="token number">4</span>/4<span class="token punctuation">]</span> <span class="token punctuation">[</span>UUUU<span class="token punctuation">]</span>
      
unused devices: <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>磁盘阵列已经自动恢复好了。将闲置磁盘 sdb11 替换掉损坏的 sdb6：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--manage</span> /dev/md0 <span class="token parameter variable">--add</span> /dev/sdb11 <span class="token parameter variable">--remove</span> /dev/sdb6
mdadm: added /dev/sdb11
mdadm: hot removed /dev/sdb6 from /dev/md0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="自动挂载-raid"><a class="markdownIt-Anchor" href="#自动挂载-raid"></a> 自动挂载 RAID</h2>
<p>设置 <code>/etc/mdadm.conf</code> 文件来将 RAID 设备自动挂载：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--detail</span> /dev/md0 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> uuid
              UUID <span class="token builtin class-name">:</span> f64354f8:cf945331:eee97c66:84776736
<span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/mdadm.conf
ARRAY /dev/md0 <span class="token assign-left variable">UUID</span><span class="token operator">=</span>f64354f8:cf945331:eee97c66:84776736
<span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/fstab
/dev/md0        /mnt/raid       ext3    defaults        <span class="token number">1</span>       <span class="token number">2</span>
<span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">umount</span> /dev/md0<span class="token punctuation">;</span> <span class="token function">mount</span> <span class="token parameter variable">-a</span>
<span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">df</span> /mnt/raid
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/md0           <span class="token number">22773</span>   <span class="token number">212</span>     <span class="token number">21333</span>   <span class="token number">1</span>% /mnt/raid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="关闭软-raid"><a class="markdownIt-Anchor" href="#关闭软-raid"></a> 关闭软 RAID</h2>
<p>先删除配置文件 <code>/etc/fstab</code> 中 <code>/dev/md0</code> 的挂载行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/fstab
<span class="token comment"># /dev/md0      /mnt/raid       ext3    defaults        1       2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>卸载 <code>/dev/md0</code> 并关闭：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">umount</span> /dev/md0
<span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">mdadm</span> <span class="token parameter variable">--stop</span> /dev/md0
mdadm: stopped /dev/md0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果要重新启用使用 <code>mdadm --assemble --scan /dev/md0</code> 命令。</p>
<p>最后删除 <code>/etc/mdadm.conf</code> 中与 md0 有关的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 mnt<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/mdadm.conf 
<span class="token comment"># ARRAY /dev/md0 UUID=f64354f8:cf945331:eee97c66:84776736</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="lvm"><a class="markdownIt-Anchor" href="#lvm"></a> LVM</h1>
<p>如果安装系统分区使用默认配置，系统会自动建立 LVM 格式。</p>
<h2 id="建立-pv"><a class="markdownIt-Anchor" href="#建立-pv"></a> 建立 PV</h2>
<p>首先用 <code>fdisk</code> 建立分区，假设四个分区为 <code>sdb1-4</code>，然后用 <code>fdisk</code> 依次更改 <code>system ID</code> 为 <code>8e</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> /dev/sdb
Welcome to <span class="token function">fdisk</span> <span class="token punctuation">(</span>util-linux <span class="token number">2.23</span>.2<span class="token punctuation">)</span>.

Changes will remain <span class="token keyword">in</span> memory only, <span class="token keyword">until</span> you decide to <span class="token function">write</span> them.
Be careful before using the <span class="token function">write</span> command.


Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: p

Disk /dev/sdb: <span class="token number">1073</span> MB, <span class="token number">1073741824</span> bytes, <span class="token number">2097152</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos
Disk identifier: 0x0006fb94

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            <span class="token number">2048</span>      <span class="token number">206847</span>      <span class="token number">102400</span>   8e  Linux LVM
/dev/sdb2          <span class="token number">206848</span>      <span class="token number">411647</span>      <span class="token number">102400</span>   8e  Linux LVM
/dev/sdb3          <span class="token number">411648</span>      <span class="token number">616447</span>      <span class="token number">102400</span>   8e  Linux LVM
/dev/sdb4          <span class="token number">616448</span>      <span class="token number">821247</span>      <span class="token number">102400</span>   8e  Linux LVM

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: t
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-4, default <span class="token number">4</span><span class="token punctuation">)</span>: <span class="token number">1</span>
Hex code <span class="token punctuation">(</span>type L to list all codes<span class="token punctuation">)</span>: 8e
Changed <span class="token builtin class-name">type</span> of partition <span class="token string">'Linux LVM'</span> to <span class="token string">'Linux LVM'</span>

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered<span class="token operator">!</span>

Calling ioctl<span class="token punctuation">(</span><span class="token punctuation">)</span> to re-read partition table.
Syncing disks.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置好后更新系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ partprobe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>PV 有关的命令有下面这些：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pvcreate</td>
<td>将物理分区新建成 PV</td>
</tr>
<tr>
<td>pvscan</td>
<td>查询目前系统里的 PV</td>
</tr>
<tr>
<td>pvdisplay</td>
<td>显示出目前系统上面的 PV 状态</td>
</tr>
<tr>
<td>pvremove</td>
<td>将 PV 属性删除</td>
</tr>
</tbody>
</table>
<p>先使用 <code>pvcreate</code> 命令将 <code>sdb1-4</code> 转换成 PV：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvcreate /dev/sdb<span class="token punctuation">&#123;</span><span class="token number">1,2</span>,3,4<span class="token punctuation">&#125;</span>
WARNING: ext3 signature detected on /dev/sdb1 at offset <span class="token number">1080</span>. Wipe it? <span class="token punctuation">[</span>y/n<span class="token punctuation">]</span>: y
  Wiping ext3 signature on /dev/sdb1.
WARNING: dos signature detected on /dev/sdb2 at offset <span class="token number">510</span>. Wipe it? <span class="token punctuation">[</span>y/n<span class="token punctuation">]</span>: y
  Wiping dos signature on /dev/sdb2.
WARNING: swap signature detected on /dev/sdb4 at offset <span class="token number">4086</span>. Wipe it? <span class="token punctuation">[</span>y/n<span class="token punctuation">]</span>: y
  Wiping swap signature on /dev/sdb4.
  Physical volume <span class="token string">"/dev/sdb1"</span> successfully created.
  Physical volume <span class="token string">"/dev/sdb2"</span> successfully created.
  Physical volume <span class="token string">"/dev/sdb3"</span> successfully created.
  Physical volume <span class="token string">"/dev/sdb4"</span> successfully created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后使用 <code>pvscan</code> 查询已存在的 PV：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvscan
  PV /dev/sda2   VG centos          lvm2 <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.00</span> GiB / <span class="token number">0</span>    free<span class="token punctuation">]</span>
  PV /dev/sdb2                      lvm2 <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
  PV /dev/sdb1                      lvm2 <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
  PV /dev/sdb3                      lvm2 <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
  PV /dev/sdb4                      lvm2 <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
  Total: <span class="token number">5</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.39</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> use: <span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.00</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> no VG: <span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">400.00</span> MiB<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后 <code>pvdisplay</code> 查看每个 PV 的详细信息，确认准确无误：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvdisplay
<span class="token string">"/dev/sdb2"</span> is a new physical volume of <span class="token string">"100.00 MiB"</span>
  --- NEW Physical volume ---
  PV Name               /dev/sdb2
  VG Name               
  PV Size               <span class="token number">100.00</span> MiB
  Allocatable           NO
  PE Size               <span class="token number">0</span>   
  Total PE              <span class="token number">0</span>
  Free PE               <span class="token number">0</span>
  Allocated PE          <span class="token number">0</span>
  PV UUID               0pMJ0Q-1h7w-1fMb-OTKS-Xqa5-sjQj-XSUdSi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建立-vg"><a class="markdownIt-Anchor" href="#建立-vg"></a> 建立 VG</h2>
<p>与 VG 相关的命令有下面这些：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>vgcreate</td>
<td>新建 VG 的命令</td>
</tr>
<tr>
<td>vgscan</td>
<td>查找系统上的 VG</td>
</tr>
<tr>
<td>vgdisplay</td>
<td>显示系统上的 VG 状态</td>
</tr>
<tr>
<td>vgextend</td>
<td>在 VG 内增加额外 PV</td>
</tr>
<tr>
<td>vgreduce</td>
<td>在 VG 内删除 PV</td>
</tr>
<tr>
<td>vgchange</td>
<td>设置 VG 是否启动 (active)</td>
</tr>
<tr>
<td>vgremove</td>
<td>删除一个 VG</td>
</tr>
</tbody>
</table>
<p>新建 VG 使用 <code>vgcreate</code> 命令的语法如下：</p>
<p><code>vgcreate [-s PE大小[MGT]] VG名称 PV名称</code></p>
<p>将 <code>/dev/sdb1-3</code> 新建成一个 VG 名为 VG400，并指定 PE 为 4MB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgcreate <span class="token parameter variable">-s</span> 4M VG400 /dev/sdb<span class="token punctuation">&#123;</span><span class="token number">1,2</span>,3<span class="token punctuation">&#125;</span>
  Volume group <span class="token string">"VG400"</span> successfully created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看 VG 和 PV 的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgscan
  Reading volume <span class="token function">groups</span> from cache.
  Found volume group <span class="token string">"centos"</span> using metadata <span class="token builtin class-name">type</span> lvm2
  Found volume group <span class="token string">"VG400"</span> using metadata <span class="token builtin class-name">type</span> lvm2
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvscan
  PV /dev/sda2   VG centos          lvm2 <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.00</span> GiB / <span class="token number">0</span>    free<span class="token punctuation">]</span>
  PV /dev/sdb1   VG VG400           lvm2 <span class="token punctuation">[</span><span class="token number">96.00</span> MiB / <span class="token number">96.00</span> MiB free<span class="token punctuation">]</span>
  PV /dev/sdb2   VG VG400           lvm2 <span class="token punctuation">[</span><span class="token number">96.00</span> MiB / <span class="token number">96.00</span> MiB free<span class="token punctuation">]</span>
  PV /dev/sdb3   VG VG400           lvm2 <span class="token punctuation">[</span><span class="token number">96.00</span> MiB / <span class="token number">96.00</span> MiB free<span class="token punctuation">]</span>
  PV /dev/sdb4                      lvm2 <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
  Total: <span class="token number">5</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.38</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> use: <span class="token number">4</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token number">19.28</span> GiB<span class="token punctuation">]</span> / <span class="token keyword">in</span> no VG: <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">100.00</span> MiB<span class="token punctuation">]</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgdisplay
--- Volume group ---
  VG Name               VG400
  System ID             
  Format                lvm2
  Metadata Areas        <span class="token number">3</span>
  Metadata Sequence No  <span class="token number">1</span>
  VG Access             read/write
  VG Status             resizable
  MAX LV                <span class="token number">0</span>
  Cur LV                <span class="token number">0</span>
  Open LV               <span class="token number">0</span>
  Max PV                <span class="token number">0</span>
  Cur PV                <span class="token number">3</span>
  Act PV                <span class="token number">3</span>
  VG Size               <span class="token number">288.00</span> MiB
  PE Size               <span class="token number">4.00</span> MiB
  Total PE              <span class="token number">72</span>
  Alloc PE / Size       <span class="token number">0</span> / <span class="token number">0</span>   
  Free  PE / Size       <span class="token number">72</span> / <span class="token number">288.00</span> MiB
  VG UUID               mWWhO0-wuDl-z62s-BPZZ-L1Ck-0Pbs-DNTCIf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 3 个 PV 已经加入到 VG400 当中了，VG 容量 288MB，PE 大小 4MB，总共有 72 个 PV。</p>
<p>要给 VG 扩容，将剩下的 <code>sdb4</code> 加入到 <code>VG400</code> 中可以使用 <code>vgextend</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgextend VG400 /dev/sdb4
  Volume group <span class="token string">"VG400"</span> successfully extended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="建立-lv"><a class="markdownIt-Anchor" href="#建立-lv"></a> 建立 LV</h2>
<p>和 LV 有关的命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>lvcreate</td>
<td>新建 LV</td>
</tr>
<tr>
<td>lvscan</td>
<td>查询系统上的 LV</td>
</tr>
<tr>
<td>lvdisplay</td>
<td>显示系统上的 LV 状态</td>
</tr>
<tr>
<td>lvextend</td>
<td>在 LV 里面增加容量</td>
</tr>
<tr>
<td>lvreduce</td>
<td>在 LV 里面减少容量</td>
</tr>
<tr>
<td>lvremove</td>
<td>删除一个 LV</td>
</tr>
<tr>
<td>lvresize</td>
<td>对 LV 进行容量大小调整</td>
</tr>
</tbody>
</table>
<p>建立 LV 使用命令 <code>lvcreate</code> 基本语法如下：</p>
<p><code>lvcreate [-L 容量[MGT]] [-n LV名称] VG名称</code></p>
<p><code>lvcreate [-l PE个数] [-n LV名称] VG名称</code></p>
<p>将整个 <code>VG400</code> 分配给 <code>LV400</code>（不带 <code>-l</code> 参数默认会分配全部容量）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-l</span> <span class="token number">96</span> <span class="token parameter variable">-n</span> LV400 VG400
  Logical volume <span class="token string">"LV400"</span> created.
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvdisplay
  --- Logical volume ---
  LV Path                /dev/VG400/LV400
  LV Name                LV400
  VG Name                VG400
  LV UUID                21Hgtc-LzS0-2XvL-XiXD-3DPd-94Cu-zQfcvU
  LV Write Access        read/write
  LV Creation host, <span class="token function">time</span> 101c7, <span class="token number">2021</span>-09-13 <span class="token number">17</span>:26:08 <span class="token parameter variable">-0400</span>
  LV Status              available
  <span class="token comment"># open                 0</span>
  LV Size                <span class="token number">384.00</span> MiB
  Current LE             <span class="token number">96</span>
  Segments               <span class="token number">4</span>
  Allocation             inherit
  Read ahead sectors     auto
  - currently <span class="token builtin class-name">set</span> to     <span class="token number">8192</span>
  Block device           <span class="token number">253</span>:2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>LV400</code> 格式化成 <code>ext3</code> 并挂载到 <code>/ext333</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mkfs.ext3 /dev/VG400/LV400 
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> /dev/VG400/LV400 /ext333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">df</span>
Filesystem              1K-blocks    Used Available Use% Mounted on
devtmpfs                  <span class="token number">1918780</span>       <span class="token number">0</span>   <span class="token number">1918780</span>   <span class="token number">0</span>% /dev
tmpfs                     <span class="token number">1930640</span>       <span class="token number">0</span>   <span class="token number">1930640</span>   <span class="token number">0</span>% /dev/shm
tmpfs                     <span class="token number">1930640</span>   <span class="token number">11924</span>   <span class="token number">1918716</span>   <span class="token number">1</span>% /run
tmpfs                     <span class="token number">1930640</span>       <span class="token number">0</span>   <span class="token number">1930640</span>   <span class="token number">0</span>% /sys/fs/cgroup
/dev/mapper/centos-root  <span class="token number">17811456</span> <span class="token number">2598096</span>  <span class="token number">15213360</span>  <span class="token number">15</span>% /
/dev/sda1                 <span class="token number">1038336</span>  <span class="token number">190536</span>    <span class="token number">847800</span>  <span class="token number">19</span>% /boot
tmpfs                      <span class="token number">386128</span>       <span class="token number">0</span>    <span class="token number">386128</span>   <span class="token number">0</span>% /run/user/0
/dev/mapper/VG400-LV400    <span class="token number">372615</span>    <span class="token number">2095</span>    <span class="token number">350860</span>   <span class="token number">1</span>% /ext333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lvm-扩容"><a class="markdownIt-Anchor" href="#lvm-扩容"></a> LVM 扩容</h2>
<p>扩容分为以下步骤:</p>
<ol>
<li>用 <code>fdisk</code> 设置新分区 system ID 为 8e；</li>
<li>利用 <code>pvcreate</code> 构建 PV；</li>
<li>利用 <code>vgextend</code> 将 PV 加入 VG；</li>
<li>利用 <code>lvresize</code> 将新加入 VG 内的 PE 加入到 LV 中；</li>
<li>利用 <code>resize2fs</code> 将文件系统容量增加。</li>
</ol>
<p>先扫描新增加的 SCSI 接口硬盘：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"- - -"</span> <span class="token operator">></span> /sys/class/scsi_host/host0/scan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对新扫描到的硬盘 <code>/dev/sdc</code> 进行分区，并设置 8e 标志：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> /dev/sdc
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: t
Hex code <span class="token punctuation">(</span>type L to list all codes<span class="token punctuation">)</span>: 8e
Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ partprobe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>sdc1</code> 建立 PV：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvcreate /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 <code>sdc1</code> 加入到 <code>VG400</code> 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgextend VG400 /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>lvresize</code> 命令对 <code>LV400</code> 进行扩容。如果要使用所有空闲容量可以使用 <code>+100%FREE</code> 参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvresize <span class="token parameter variable">-l</span> +255 /dev/VG400/LV400 
  Size of logical volume VG400/LV400 changed from <span class="token number">384.00</span> MiB <span class="token punctuation">(</span><span class="token number">96</span> extents<span class="token punctuation">)</span> to <span class="token number">1.37</span> GiB <span class="token punctuation">(</span><span class="token number">351</span> extents<span class="token punctuation">)</span>.
  Logical volume VG400/LV400 successfully resized.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最后使用 <code>resize2fs</code> 扩容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ resize2fs /dev/VG400/LV400 
resize2fs <span class="token number">1.42</span>.9 <span class="token punctuation">(</span><span class="token number">28</span>-Dec-2013<span class="token punctuation">)</span>
Filesystem at /dev/VG400/LV400 is mounted on /ext333<span class="token punctuation">;</span> on-line resizing required
old_desc_blocks <span class="token operator">=</span> <span class="token number">2</span>, new_desc_blocks <span class="token operator">=</span> <span class="token number">6</span>
The filesystem on /dev/VG400/LV400 is now <span class="token number">1437696</span> blocks long.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>xfs</code> 文件系统使用的是 <code>xfs_growfs</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_growfs /dev/VG400/LV400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="lvm-缩容"><a class="markdownIt-Anchor" href="#lvm-缩容"></a> LVM 缩容</h2>
<p>XFS 文件系统不支持缩容。如果要进行缩容，需要将 <code>/dev/sdc1</code> 抽出来，首先需要 <code>umount</code> 挂载点：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">umount</span> /ext333/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后对 <code>LV400</code> 运行磁盘检查：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ e2fsck <span class="token parameter variable">-f</span> /dev/VG400/LV400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用 <code>resize2fs</code> 命令对 <code>LV400</code> 的容量进行缩减 <code>sdc1</code> 的大小：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ resize2fs /dev/VG400/LV400 200M<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重新挂载 <code>LV400</code> 到 <code>/ext333</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> /dev/VG400/LV400 /ext333/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>去除 <code>sdc1</code> 上的 PE 数 <code>255</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvresize <span class="token parameter variable">-l</span> <span class="token parameter variable">-255</span> /dev/VG400/LV400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>转移 <code>sdc1</code> 上 PE 的数据到 <code>sdb2</code>。<code>pvmove</code> 同样可以用来在想要更换物理磁盘时使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvmove /dev/sdc1 /dev/sdb2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 <code>sdc1</code> 移出 <code>VG400</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ vgreduce VG400 /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后删除 <code>sdc1</code> 上的 <code>pv</code> 标记：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ pvremove /dev/sdc1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="lvm-thin-volume"><a class="markdownIt-Anchor" href="#lvm-thin-volume"></a> LVM Thin Volume</h2>
<p>LVM Thin Volume 先创建一个磁盘容量储存池（Thin Pool），再由这个储存池去产生一个指定要固定容量大小的 LV 设备，它可以设定任意大小，但在需要用到时才从储存池划取所需容量。只要实际用量不超过储存池总容量就行。</p>
<p>先从 <code>VG400</code> 的剩余容量中取出 100 MB 来创建储存池 <code>vpool</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-L</span> 100M <span class="token parameter variable">-T</span> /dev/VG400/vpool
  Thin pool volume with chunk size <span class="token number">64.00</span> KiB can address at <span class="token function">most</span> <span class="token number">15.81</span> TiB of data.
  Logical volume <span class="token string">"vpool"</span> created.
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvdisplay /dev/VG400/vpool
  --- Logical volume ---
  LV Name                vpool
  VG Name                VG400
  LV UUID                Zl8N7t-SiIF-edLi-COKJ-PrVx-Ma7H-vA1e2U
  LV Write Access        read/write
  LV Creation host, <span class="token function">time</span> 101c7, <span class="token number">2021</span>-09-17 <span class="token number">16</span>:43:00 <span class="token parameter variable">-0400</span>
  LV Pool metadata       vpool_tmeta
  LV Pool data           vpool_tdata
  LV Status              available
  <span class="token comment"># open                 0</span>
  LV Size                <span class="token number">100.00</span> MiB
  Allocated pool data    <span class="token number">0.00</span>%
  Allocated metadata     <span class="token number">10.84</span>%
  Current LE             <span class="token number">25</span>
  Segments               <span class="token number">1</span>
  Allocation             inherit
  Read ahead sectors     auto
  - currently <span class="token builtin class-name">set</span> to     <span class="token number">8192</span>
  Block device           <span class="token number">253</span>:8
  <span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvs VG400
  LV     VG    Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  LV400  VG400 owi-aos--- <span class="token number">384</span>.00m                                                    
  VG400m VG400 swi-I-s---  <span class="token number">96</span>.00m      LV400  <span class="token number">100.00</span>                                 
  vpool  VG400 twi-a-tz-- <span class="token number">100</span>.00m             <span class="token number">0.00</span>   <span class="token number">10.84</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 <code>vthin1</code> 设备，大小定为 1 GB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-V</span> 1G <span class="token parameter variable">-T</span> /dev/VG400/vpool <span class="token parameter variable">-n</span> vthin1
  WARNING: Sum of all thin volume sizes <span class="token punctuation">(</span><span class="token number">34.00</span> GiB<span class="token punctuation">)</span> exceeds the size of thin pool VG400/vpool and the size of whole volume group <span class="token punctuation">(</span><span class="token number">1.37</span> GiB<span class="token punctuation">)</span>.
  WARNING: You have not turned on protection against thin pools running out of space.
  WARNING: Set activation/thin_pool_autoextend_threshold below <span class="token number">100</span> to trigger automatic extension of thin pools before they get full.
  Logical volume <span class="token string">"vthin1"</span> created.
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvs VG400
  LV     VG    Attr       LSize   Pool  Origin Data%  Meta%  Move Log Cpy%Sync Convert
  LV400  VG400 owi-aos--- <span class="token number">384</span>.00m                                                     
  VG400m VG400 swi-I-s---  <span class="token number">96</span>.00m       LV400  <span class="token number">100.00</span>                                 
  vpool  VG400 twi-aotzD- <span class="token number">100</span>.00m              <span class="token number">100.00</span> <span class="token number">12.11</span>                           
  vthin1 VG400 Vwi-a-tz--  <span class="token number">34</span>.00g vpool        <span class="token number">0.29</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>格式化成 xfs 文件系统并挂载到 <code>/root/thin1</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ mkfs.xfs /dev/VG400/vthin1
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> /dev/VG400/vthin1 /root/thin1/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-hT</span>
/dev/mapper/VG400-LV400  ext3      186M   62M  116M  <span class="token number">35</span>% /ext333
/dev/sdd1                xfs       497M   56M  441M  <span class="token number">12</span>% /xfs333
/dev/mapper/VG400-vthin1 xfs      1014M   33M  982M   <span class="token number">4</span>% /root/thin1
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvs
  LV     VG     Attr       LSize   Pool  Origin Data%  Meta%  Move Log Cpy%Sync Convert
  LV400  VG400  owi-aos--- <span class="token number">384</span>.00m                                                     
  VG400m VG400  swi-I-s---  <span class="token number">96</span>.00m       LV400  <span class="token number">100.00</span>                                 
  vpool  VG400  twi-aotz-- <span class="token number">100</span>.00m              <span class="token number">10.69</span>  <span class="token number">10.94</span>                           
  vthin1 VG400  Vwi-aotz--   <span class="token number">1</span>.00g vpool        <span class="token number">1.04</span>         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用储存池一定要注意容量问题，否则超容量使用会造成数据损毁，并且没有系统提示。</p>
<h2 id="lvm-快照"><a class="markdownIt-Anchor" href="#lvm-快照"></a> LVM 快照</h2>
<p>LVM 可以使用系统快照（snapshot）功能来备份需要的原始数据。快照区与被快照区为不同 LV 中，但要在同一个 VG 上面。</p>
<p>这里使用 <code>sdc1</code> 作为快照区使用。使用 <code>lvcreate -s</code> 来新建系统快照区 <code>VG400m</code>，并给予一个 PV 占用的 PE 数量 24：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvcreate <span class="token parameter variable">-l</span> <span class="token number">24</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-n</span> VG400m /dev/VG400/LV400 
  Logical volume <span class="token string">"VG400m"</span> created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用 <code>lvdisplay</code> 查看一下新建的快照区 <code>snap_lv400</code> 信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ lvdisplay
  --- Logical volume ---
  LV Path                /dev/VG400/VG400m
  LV Name                VG400m
  VG Name                VG400
  LV UUID                cNZB7T-8D2u-IlRt-05sP-e8We-R4ox-WDNqW1
  LV Write Access        read/write
  LV Creation host, <span class="token function">time</span> 101c7, <span class="token number">2021</span>-09-13 <span class="token number">18</span>:22:45 <span class="token parameter variable">-0400</span>
  LV snapshot status     active destination <span class="token keyword">for</span> LV400
  LV Status              available
  <span class="token comment"># open                 0</span>
  LV Size                <span class="token number">384.00</span> MiB
  Current LE             <span class="token number">96</span>
  COW-table size         <span class="token number">96.00</span> MiB
  COW-table LE           <span class="token number">24</span>
  Allocated to snapshot  <span class="token number">0.01</span>%
  Snapshot chunk size    <span class="token number">4.00</span> KiB
  Segments               <span class="token number">1</span>
  Allocation             inherit
  Read ahead sectors     auto
  - currently <span class="token builtin class-name">set</span> to     <span class="token number">8192</span>
  Block device           <span class="token number">253</span>:5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 COW-table size 是快照区的实际容量。可以将快照区挂载后查看内容，取出里面数据。</p>
<p>如果是 xfs 文件系统挂载时得使用 <code>nouuid</code> 参数。</p>
<p>要想建立快照区，必须注意快照区剩余容量要能装得下原始数据，如果快照区容纳不了，快照功能会失效。</p>
<p>也可以将快照挂载后卸载原先 LV，使用快照区作为测试环境在上面测试，测试完毕后直接将快照区删除。</p>
<p>要删除快照，先 <code>umount</code> 再使用 <code>lvremove</code> 命令即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 磁盘配额管理</title>
    <url>/3427262780/</url>
    <content><![CDATA[<h1 id="磁盘配额简介"><a class="markdownIt-Anchor" href="#磁盘配额简介"></a> 磁盘配额简介</h1>
<p>Linux 下磁盘配额功能叫 <code>quota</code>。</p>
<h2 id="一般用途"><a class="markdownIt-Anchor" href="#一般用途"></a> 一般用途</h2>
<ul>
<li>限制服务使用空间容量；</li>
<li>限制某一用户组所能使用的最大磁盘配额；</li>
<li>限制某一用户的最大磁盘配额；</li>
<li>限制某一目录的最大磁盘配额。</li>
</ul>
<h2 id="使用限制"><a class="markdownIt-Anchor" href="#使用限制"></a> 使用限制</h2>
<ul>
<li><code>EXT</code> 文件系统下仅能针对整个文件系统设置；</li>
<li>针对单一目录的设置（<code>prjquota</code>）和针对群组的设置（<code>grpquota</code>）不能共存；</li>
<li>内核必须支持；</li>
<li>只对一般身份用户有效。比如 <code>root</code> 就不能设置配额。也不能针对目录来设置（<code>ext</code> 文件系统）；</li>
<li>若启用 <code>SELinux</code>，非所有目录都可设置 <code>quota</code>。</li>
</ul>
<h2 id="设置选项"><a class="markdownIt-Anchor" href="#设置选项"></a> 设置选项</h2>
<ul>
<li>分别针对使用者，群组或个别目录（<code>user</code>，<code>group</code> &amp; <code>project</code>）；</li>
<li>容量限制（<code>block</code>）或文件数量限制（<code>inode</code>）；</li>
<li>警告（<code>soft</code>）与限制值（<code>hard</code>）；</li>
<li>宽限时间（<code>grace time</code>），在用量介于 <code>soft</code> 与 <code>hard</code> 之间时给予警告，并给予宽限时间（默认 7 天）。如果在宽限期内没把用量降到 <code>soft</code> 值之下，<code>soft</code> 限制值会替代 <code>hard</code> 值作为 <code>quota</code> 的限制。</li>
</ul>
<h2 id="开启-quota-支持"><a class="markdownIt-Anchor" href="#开启-quota-支持"></a> 开启 Quota 支持</h2>
<p><code>ext</code> 和 <code>xfs</code> 文件系统默认支持 <code>quota</code>，要手动加入 <code>quota</code> 支持可以使用 <code>mount -o remount,usrquota,grpquota /</code> 命令来重新挂载。<code>usrquota</code> 和 <code>grpquota</code> 参数分别代表用户与用户组支持参数。</p>
<p>写入配置文件可以修改 <code>/etc/fstab</code> 文件，在挂载参数后面加入 <code>usrquota</code> 和 <code>grpquota</code> 或 <code>prjquota</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/fstab
/dev/sdb4 /root/sdb4m                    ext3    defaults        <span class="token number">0</span> <span class="token number">0</span>
/dev/sdd1 /xfs333                  xfs           defaults,usrquota,grpquota  <span class="token number">0</span> <span class="token number">0</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">umount</span> /xfs333
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-a</span>
mount: /dev/sdb4 is already mounted or /root/sdb4m busy
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> sdd
/dev/sdd1 on /xfs333 <span class="token builtin class-name">type</span> xfs <span class="token punctuation">(</span>rw,relatime,seclabel,attr2,inode64,usrquota,grpquota<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ext-文件系统磁盘配额"><a class="markdownIt-Anchor" href="#ext-文件系统磁盘配额"></a> EXT 文件系统磁盘配额</h1>
<p>由于 EXT 文件系统中使用的工具和 XFS 文件系统不同，因此分别记录。</p>
<h2 id="新建-quota-配置文件"><a class="markdownIt-Anchor" href="#新建-quota-配置文件"></a> 新建 Quota 配置文件</h2>
<p>Quota 是通过分析整个文件系统中每个用户(用户组)拥有的文件总数与总容量，将数据记录在该文件系统的最顶层目录，然后在该配置文件中再使用每个账号或组的限制值去规定磁盘使用量。</p>
<p>可以使用<code>quotacheck</code>命令来新建 Quota 配置文件，用法如下：</p>
<p><code>quotacheck [-avugfM] [挂载点]</code></p>
<p>主要参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>扫描所有在<code>/etc/mtab</code>内 Quota 支持的文件系统，加入此参数后可不写挂载点</td>
</tr>
<tr>
<td>-u</td>
<td>针对用户扫描文件与目录使用情况，会新建<code>aquota.user</code></td>
</tr>
<tr>
<td>-g</td>
<td>针对用户组扫描文件与目录使用情况，会新建<code>aquota.group</code></td>
</tr>
<tr>
<td>-v</td>
<td>显示扫描过程</td>
</tr>
<tr>
<td>-f</td>
<td>强制扫描文件系统，并写入新的 Quota 配置文件</td>
</tr>
<tr>
<td>-M</td>
<td>强制以读写的方式扫描文件系统</td>
</tr>
</tbody>
</table>
<p>对整个系统执行扫描并新建配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">quotacheck</span> <span class="token parameter variable">-avug</span>
quotacheck: Your kernel probably supports journaled <span class="token function">quota</span> but you are not using it. Consider switching to journaled <span class="token function">quota</span> to avoid running <span class="token function">quotacheck</span> after an unclean shutdown.
quotacheck: Scanning /dev/sdb4 <span class="token punctuation">[</span>/root/sdb4m<span class="token punctuation">]</span> <span class="token keyword">done</span>
quotacheck: Cannot <span class="token function">stat</span> old user <span class="token function">quota</span> <span class="token function">file</span> /root/sdb4m/aquota.user: No such <span class="token function">file</span> or directory. Usage will not be subtracted.
quotacheck: Checked <span class="token number">8</span> directories and <span class="token number">19</span> files
quotacheck: Old <span class="token function">file</span> not found.
quotacheck: Old <span class="token function">file</span> not found.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在挂载点查询新建的配额配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-d</span> /root/sdb4m/aq*
-rw-------. <span class="token number">1</span> root root <span class="token number">7168</span> Sep <span class="token number">13</span> <span class="token number">13</span>:26 /root/sdb4m/aquota.group
-rw-------. <span class="token number">1</span> root root <span class="token number">7168</span> Sep <span class="token number">13</span> <span class="token number">13</span>:26 /root/sdb4m/aquota.user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>配置文件不用手动去编辑，因为实际上是 Quota 的数据文件，内容会一直变动。</p>
<h2 id="启动与关闭-quota"><a class="markdownIt-Anchor" href="#启动与关闭-quota"></a> 启动与关闭 Quota</h2>
<p>启动 quota 服务使用命令<code>quotaon</code>，加入<code>-auvg</code>参数来启动所有功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ quotaon <span class="token parameter variable">-avug</span>
/dev/sdb4 <span class="token punctuation">[</span>/root/sdb4m<span class="token punctuation">]</span>: group quotas turned on
/dev/sdb4 <span class="token punctuation">[</span>/root/sdb4m<span class="token punctuation">]</span>: user quotas turned on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>quota 启动一次后，系统的<code>/etc/rc.d/rc.sysinit</code>初始化脚本都会自动执行该命令。</p>
<p>关闭 quota 服务使用<code>quotaoff</code>命令，用<code>-a</code>参数关闭所有功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ quotaoff <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="编辑-quota"><a class="markdownIt-Anchor" href="#编辑-quota"></a> 编辑 Quota</h2>
<p>编辑配额使用<code>edquota</code>命令，语法如下：</p>
<p><code>edquota [-u 用户名] [-g 组]</code></p>
<p><code>edquota -t 宽限时间</code></p>
<p><code>edquota -p 范本账号 -u 新账号</code></p>
<p>例如设置用户<code>user1</code>的 Quota 限制值为 hard=10MB，soft=8MB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ edquota <span class="token parameter variable">-u</span> user1
Disk quotas <span class="token keyword">for</span> user user1 <span class="token punctuation">(</span>uid <span class="token number">1003</span><span class="token punctuation">)</span>:
  Filesystem                   blocks       soft       hard     inodes     soft     hard
  /dev/sdb4                         <span class="token number">2</span>       <span class="token number">8000</span>      <span class="token number">10000</span>          <span class="token number">1</span>        <span class="token number">0</span>        <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>会进入到编辑页面，总共七个字段说明如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Filesystem</td>
<td>说明针对的文件系统</td>
</tr>
<tr>
<td>2</td>
<td>blocks</td>
<td>磁盘容量，单位为 KB</td>
</tr>
<tr>
<td>3</td>
<td>soft</td>
<td>磁盘容量的 soft 限制值，单位 KB</td>
</tr>
<tr>
<td>4</td>
<td>hard</td>
<td>磁盘容量的 hard 限制值，单位 KB</td>
</tr>
<tr>
<td>5</td>
<td>inodes</td>
<td>文件数量</td>
</tr>
<tr>
<td>6</td>
<td>soft</td>
<td>文件数量的 soft 限制值</td>
</tr>
<tr>
<td>7</td>
<td>hard</td>
<td>文件数量的 hard 限制值</td>
</tr>
</tbody>
</table>
<p>修改宽限时间为 14 天：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ edquota <span class="token parameter variable">-t</span>
Grace period before enforcing soft limits <span class="token keyword">for</span> users:
Time <span class="token function">units</span> may be: days, hours, minutes, or seconds
  Filesystem             Block grace period     Inode grace period
  /dev/sdb4                    14days                  7days<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="设置-quota"><a class="markdownIt-Anchor" href="#设置-quota"></a> 设置 Quota</h2>
<p>除了修改配置文件，还可以通过<code>setquota</code>命令来设置 Quota 的值。命令语法如下：</p>
<p><code>setquota [-u|-g] 用户名|组名 容量限制(soft) 容量限制(hard) 文件数限制(soft) 文件数限制(hard)</code></p>
<p>例如，将<code>user1</code>的文件数限制设置为 1000/2000：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ setquota <span class="token parameter variable">-u</span> user1 <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1000</span> <span class="token number">2000</span> /root/sdb4m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="quota-报表"><a class="markdownIt-Anchor" href="#quota-报表"></a> Quota 报表</h2>
<p>针对用户或组查询限额报表使用 <code>quota</code> 命令，命令语法如下：</p>
<p><code>quota [-uvs] [用户名]</code></p>
<p><code>quota [-gvs] [组名]</code></p>
<p>例如查询用户<code>user1</code>的限额：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">quota</span> <span class="token parameter variable">-uvs</span> user1
Disk quotas <span class="token keyword">for</span> user user1 <span class="token punctuation">(</span>uid <span class="token number">1003</span><span class="token punctuation">)</span>: 
     Filesystem   space   <span class="token function">quota</span>   limit   grace   files   <span class="token function">quota</span>   limit   grace
      /dev/sdb4   9250K*  8000K  10000K  13days       <span class="token number">5</span>       <span class="token number">0</span>       <span class="token number">0</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示的内容和<code>edquota</code>编辑时看到的字段差不多，多了一个宽限日期。</p>
<p>针对整个文件系统配额查询可以使用<code>repquota</code>命令：</p>
<p><code>repquota -a [-vugs]</code></p>
<p>参数如下:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>直接到<code>/etc/mtab</code>查询具有 quota 标志的文件系统，并报告 quota 的结果</td>
</tr>
<tr>
<td>-v</td>
<td>输出的数据将含有文件系统相关的详细信息</td>
</tr>
<tr>
<td>-u</td>
<td>显示出用户的 quota 限值</td>
</tr>
<tr>
<td>-g</td>
<td>显示出个别用户组的 quota 限值</td>
</tr>
<tr>
<td>-s</td>
<td>以 M，G 为单位显示结果</td>
</tr>
</tbody>
</table>
<p>例如查询所有用户的 quota 限制情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ repquota <span class="token parameter variable">-auvs</span>
*** Report <span class="token keyword">for</span> user quotas on device /dev/sdb4
Block grace time: 14days<span class="token punctuation">;</span> Inode grace time: 7days
                        Space limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --     78K      0K      0K             <span class="token number">17</span>     <span class="token number">0</span>     <span class="token number">0</span>       
user1     +-   9250K   8000K  10000K 13days       <span class="token number">5</span>     <span class="token number">0</span>     <span class="token number">0</span>       

Statistics:
Total blocks: <span class="token number">7</span>
Data blocks: <span class="token number">1</span>
Entries: <span class="token number">2</span>
Used average: <span class="token number">2.000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="xfs-文件系统磁盘配额"><a class="markdownIt-Anchor" href="#xfs-文件系统磁盘配额"></a> XFS 文件系统磁盘配额</h1>
<p>在 xfs 文件系统下，主要使用 <code>xfs_quota</code> 命令进行配额管理。</p>
<h2 id="查询状态"><a class="markdownIt-Anchor" href="#查询状态"></a> 查询状态</h2>
<p>基本使用方法为:<code>xfs_quota -x -c &quot;指令&quot; [挂载点]</code>，其中 <code>-x</code> 表示使用专家模式，<code>-c</code> 后面加的指令有以下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>print</td>
<td>单纯列出目前主机内的文件系统参数等数据</td>
</tr>
<tr>
<td>df</td>
<td>与原本 <code>df</code> 一样的功能，可加上 <code>-b</code>、<code>-i</code>、<code>-h</code> 等参数</td>
</tr>
<tr>
<td>report</td>
<td>列出目前的 quota 项目，有 <code>-ugr</code> 及 <code>-bi</code> 等数据</td>
</tr>
<tr>
<td>state</td>
<td>说明目前支持 quota 的文件系统信息，有没有启动相关项目等</td>
</tr>
</tbody>
</table>
<p>在使用了 <code>usrquota</code>、<code>grpquota</code> 参数挂载完文件系统后，可以用 <code>print</code> 指令查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"print"</span>
Filesystem          Pathname
/                   /dev/mapper/centos-root
/boot               /dev/sda1
/xfs333             /dev/sdd1 <span class="token punctuation">(</span>uquota, gquota<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询挂载点 <code>/xfs333</code> 文件系统使用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"df -h"</span> /xfs333/
Filesystem     Size   Used  Avail Use% Pathname
/dev/sdd1    <span class="token number">496</span>.7M  <span class="token number">55</span>.8M <span class="token number">440</span>.8M  <span class="token number">11</span>% /xfs333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>列出目前 <code>/xfs333</code> 的所有用户 quota 限制值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -ubih"</span> /xfs333
User <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
User ID      Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
root        <span class="token number">30</span>.0M      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">7</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到目前只有 <code>root</code> 在目录中使用了 30MB，而且没有设限。使用 <code>state</code> 指令查询 <code>/xfs333</code> 的 quota 功能启用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"state"</span>
User <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: ON
  Enforcement: ON
  Inode: <span class="token comment">#68 (1 blocks, 1 extents)</span>
Group <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: ON
  Enforcement: ON
  Inode: <span class="token comment">#69 (1 blocks, 1 extents)</span>
Project <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: OFF
  Enforcement: OFF
  Inode: <span class="token comment">#69 (1 blocks, 1 extents)</span>
Blocks grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span>
Inodes grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span>
Realtime Blocks grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="针对用户和组设置-quota"><a class="markdownIt-Anchor" href="#针对用户和组设置-quota"></a> 针对用户和组设置 Quota</h2>
<p>设置使用的命令格式为：</p>
<p><code>xfs_quota -x -c &quot;limit [-ug] b[soft|hard]=限制值 i[soft|hard]=限制值 用户或组名&quot; 挂载点</code></p>
<p><code>xfs_quota -x -c &quot;timer [-ug] [-bir] Ndays&quot;</code></p>
<p>上面命令为限制 block 和 inode，下面命令为设置 grace 时间。针对用户/组设置使用<code>-u</code>/<code>-g</code>参数。</p>
<p>例如限制用户<code>user1</code>对<code>/xfs333</code>的<code>bsoft</code>为 100MB，<code>bhard</code>为 110MB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"limit -u bsoft=100M bhard=110M user1"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -ubih"</span> /xfs333/
User <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
User ID      Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
root        <span class="token number">30</span>.0M      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">7</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>
user1           <span class="token number">0</span>   100M   110M  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>限制用户组<code>users</code>对<code>/xfs333</code>的<code>bsoft</code>为 50MB，<code>bhard</code>为 60MB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"limit -g bsoft=50M bhard=60M users"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -gbih"</span> /xfs333/
Group <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
Group ID     Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
root        <span class="token number">30</span>.0M      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">7</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>
<span class="token function">users</span>           <span class="token number">0</span>    50M    60M  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置<code>/xfs333</code>的 grace time 为 14 天：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"timer -g -b 14days"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"timer -u -b 14days"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"state"</span> /xfs333/
Blocks grace time: <span class="token punctuation">[</span><span class="token number">14</span> days<span class="token punctuation">]</span>
Inodes grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span>
Realtime Blocks grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试一下对用户的实际限制情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 xfs333<span class="token punctuation">]</span>$ <span class="token function">df</span>
Filesystem              1K-blocks    Used Available Use% Mounted on
/dev/sdd1                  <span class="token number">508580</span>   <span class="token number">26416</span>    <span class="token number">482164</span>   <span class="token number">6</span>% /xfs333
<span class="token punctuation">[</span>user1@101c7 test<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>100M <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">100</span>
File size limit exceeded
<span class="token punctuation">[</span>user1@101c7 test<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>200M <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">100</span>
dd: error writing â€˜200Mâ€™: Disk <span class="token function">quota</span> exceeded
<span class="token punctuation">[</span>user1@101c7 test<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-h</span>
total 110M
-rw-rw-r--. <span class="token number">1</span> user1 user1 79M Sep <span class="token number">17</span> <span class="token number">14</span>:20 100M
-rw-rw-r--. <span class="token number">1</span> user1 user1 31M Sep <span class="token number">17</span> <span class="token number">14</span>:20 200M
<span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -ubih"</span> /xfs333/
User <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
User ID      Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
root            <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span><span class="token number">0</span> days<span class="token punctuation">]</span>      <span class="token number">3</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>
user1      <span class="token number">109</span>.1M   100M   110M  00 <span class="token punctuation">[</span><span class="token number">13</span> days<span class="token punctuation">]</span>      <span class="token number">3</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到针对 <code>user1</code> 的限制已经生效，grace time 开始计时。</p>
<p>再看看针对组的实际限制情况，使用 gid 为 <code>users</code> 的用户 <code>user4</code> 测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user4@101c7 test<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>200M <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">200</span>
dd: error writing â€˜200Mâ€™: Disk <span class="token function">quota</span> exceeded
<span class="token number">61</span>+0 records <span class="token keyword">in</span>
<span class="token number">60</span>+0 records out
<span class="token number">62914560</span> bytes <span class="token punctuation">(</span><span class="token number">63</span> MB<span class="token punctuation">)</span> copied, <span class="token number">0.0394094</span> s, <span class="token number">1.6</span> GB/s
<span class="token punctuation">[</span>user4@101c7 test<span class="token punctuation">]</span>$ ll <span class="token parameter variable">-h</span>
total 60M
-rw-r--r--. <span class="token number">1</span> user4 <span class="token function">users</span> 60M Sep <span class="token number">17</span> <span class="token number">14</span>:26 200M
<span class="token punctuation">[</span>root@101c7 xfs333<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -gbih"</span> /xfs333/
Group <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
Group ID     Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
root            <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span><span class="token number">0</span> days<span class="token punctuation">]</span>      <span class="token number">3</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>
<span class="token function">users</span>         60M    50M    60M  00 <span class="token punctuation">[</span><span class="token number">13</span> days<span class="token punctuation">]</span>      <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样已经生效。</p>
<h2 id="针对目录设置-quota"><a class="markdownIt-Anchor" href="#针对目录设置-quota"></a> 针对目录设置 Quota</h2>
<p>先修改<code>/etc/fstab</code>内<code>grpquota</code>挂载参数为<code>prjquota</code>，再重新挂载目录。查看状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"state"</span>
Project <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: ON
  Enforcement: ON
  Inode: <span class="token comment">#69 (3 blocks, 3 extents)</span>
Blocks grace time: <span class="token punctuation">[</span><span class="token number">14</span> days<span class="token punctuation">]</span>
Inodes grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span>
Realtime Blocks grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后针对目录<code>/xfs333/test</code>设置 Project 名称和 ID 为<code>dirquo:23</code>到配置文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"23:/xfs333/test"</span> <span class="token operator">></span> /etc/projects
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"dirquo:23"</span>  <span class="token operator">>></span> /etc/projid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>下面初始化方案：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"project -s dirquo"</span>
Setting up project dirquo <span class="token punctuation">(</span>path /xfs333/test<span class="token punctuation">)</span><span class="token punctuation">..</span>.
Processed <span class="token number">1</span> <span class="token punctuation">(</span>/etc/projects and cmdline<span class="token punctuation">)</span> paths <span class="token keyword">for</span> project dirquo with recursion depth infinite <span class="token punctuation">(</span>-1<span class="token punctuation">)</span>.
<span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"print"</span> /xfs333/
Filesystem          Pathname
/xfs333             /dev/sdd1 <span class="token punctuation">(</span>uquota, pquota<span class="token punctuation">)</span>
/xfs333/test        /dev/sdd1 <span class="token punctuation">(</span>project <span class="token number">23</span>, dirquo<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -pbih"</span> /xfs333/
Project <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks                            Inodes              
Project ID   Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace  
---------- --------------------------------- --------------------------------- 
<span class="token comment">#0              0      0      0  00 [------]      2      0      0  00 [------]</span>
dirquo        60M      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span>      <span class="token number">3</span>      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开始设置对目录的容量为 20M/30M 限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"limit -p bsoft=20M bhard=30M dirquo"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 /<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -pbin"</span> /xfs333/
Project <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                               Blocks                                          Inodes                     
Project ID       Used       Soft       Hard    Warn/Grace           Used       Soft       Hard    Warn/ Grace     
---------- -------------------------------------------------- -------------------------------------------------- 
<span class="token comment">#0                   0          0          0     00 [--------]          2          0          0     00 [--------]</span>
<span class="token comment">#23              61440      20480      30720     00 [--none--]          3          0          0     00 [--------]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目前容量使用已经超过配额，直接使用<code>root</code>测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">44</span>
dd: failed to <span class="token function">open</span> â€˜44â€™: Disk <span class="token function">quota</span> exceeded
<span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ <span class="token function">rm</span> <span class="token parameter variable">-rf</span> 200M 
<span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">44</span>
dd: error writing â€˜44â€™: No space left on device
<span class="token number">31</span>+0 records <span class="token keyword">in</span>
<span class="token number">30</span>+0 records out
<span class="token number">31457280</span> bytes <span class="token punctuation">(</span><span class="token number">31</span> MB<span class="token punctuation">)</span> copied, <span class="token number">0.0373182</span> s, <span class="token number">843</span> MB/s
<span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -pbin"</span> /xfs333/
Project <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                               Blocks                                          Inodes                     
Project ID       Used       Soft       Hard    Warn/Grace           Used       Soft       Hard    Warn/ Grace     
---------- -------------------------------------------------- -------------------------------------------------- 
<span class="token comment">#0                   0          0          0     00 [--------]          2          0          0     00 [--------]</span>
<span class="token comment">#23              30720      20480      30720     00 [14 days]          3          0          0     00 [--------]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一次<code>dd</code>直接拒绝说达到配额限制，将原文件删除后再试，跑到 33MB 提示没有空间，所以对目录限制是不挑用户的。</p>
<h2 id="管理-quota-功能"><a class="markdownIt-Anchor" href="#管理-quota-功能"></a> 管理 Quota 功能</h2>
<p>可以使用下面的指令来启停 quota 功能：</p>
<ul>
<li><strong>disable</strong>: 暂停 quota 限制</li>
<li><strong>enable</strong>: 恢复 quota 限制</li>
<li><strong>off</strong>: 完全关闭 quota 限制，需要重新挂载文件系统才能再次启用</li>
<li><strong>remove</strong>: 需要在 off 状态下执行，移除 quota 的限制设置。</li>
</ul>
<p>暂停后 quota 限制解除，但还是会继续计算用量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"state"</span> /xfs333/
User <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: ON
  Enforcement: OFF
  Inode: <span class="token comment">#68 (2 blocks, 2 extents)</span>
Group <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: OFF
  Enforcement: OFF
  Inode: <span class="token comment">#69 (3 blocks, 3 extents)</span>
Project <span class="token function">quota</span> state on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
  Accounting: ON
  Enforcement: OFF
  Inode: <span class="token comment">#69 (3 blocks, 3 extents)</span>
Blocks grace time: <span class="token punctuation">[</span><span class="token number">14</span> days<span class="token punctuation">]</span>
Inodes grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span>
Realtime Blocks grace time: <span class="token punctuation">[</span><span class="token number">7</span> days<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重新启用 quota：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"enable -up"</span> /xfs333/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>完全关闭 quota 并取移除 project 限制：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"off -up"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 test<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"enable -up"</span> /xfs333/
XFS_QUOTAON: Function not implemented
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"remove -p"</span> /xfs333/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">umount</span> /xfs333/<span class="token punctuation">;</span> <span class="token function">mount</span> <span class="token parameter variable">-a</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_quota <span class="token parameter variable">-x</span> <span class="token parameter variable">-c</span> <span class="token string">"report -phb"</span> /xfs333/
Project <span class="token function">quota</span> on /xfs333 <span class="token punctuation">(</span>/dev/sdd1<span class="token punctuation">)</span>
                        Blocks              
Project ID   Used   Soft   Hard Warn/Grace   
---------- --------------------------------- 
<span class="token comment">#0              0      0      0  00 [------]</span>
dirquo        30M      <span class="token number">0</span>      <span class="token number">0</span>  00 <span class="token punctuation">[</span>------<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 dirquo 的设置已经清零了，remove 会清除所有 project 限制。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2.系统管理</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 自带帮助查询</title>
    <url>/4039294623/</url>
    <content><![CDATA[<h1 id="帮助命令"><a class="markdownIt-Anchor" href="#帮助命令"></a> 帮助命令</h1>
<p>某些命令可以使用 <code>--help</code> 参数来查看简短的帮助信息。例如，要查看命令 <code>mkdir</code> 的帮助信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token parameter variable">--help</span>
Usage: <span class="token function">mkdir</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. DIRECTORY<span class="token punctuation">..</span>.
Create the DIRECTORY<span class="token punctuation">(</span>ies<span class="token punctuation">)</span>, <span class="token keyword">if</span> they <span class="token keyword">do</span> not already exist.

Mandatory arguments to long options are mandatory <span class="token keyword">for</span> short options too.
  -m, <span class="token parameter variable">--mode</span><span class="token operator">=</span>MODE   <span class="token builtin class-name">set</span> <span class="token function">file</span> mode <span class="token punctuation">(</span>as <span class="token keyword">in</span> <span class="token function">chmod</span><span class="token punctuation">)</span>, not <span class="token assign-left variable">a</span><span class="token operator">=</span>rwx - <span class="token builtin class-name">umask</span>
  -p, <span class="token parameter variable">--parents</span>     no error <span class="token keyword">if</span> existing, <span class="token function">make</span> parent directories as needed
  -v, <span class="token parameter variable">--verbose</span>     print a message <span class="token keyword">for</span> each created directory
  <span class="token parameter variable">-Z</span>                   <span class="token builtin class-name">set</span> SELinux security context of each created directory
                         to the default <span class="token builtin class-name">type</span>
      --context<span class="token punctuation">[</span><span class="token operator">=</span>CTX<span class="token punctuation">]</span>  like -Z, or <span class="token keyword">if</span> CTX is specified <span class="token keyword">then</span> <span class="token builtin class-name">set</span> the SELinux
                         or SMACK security context to CTX
      <span class="token parameter variable">--help</span>     display this <span class="token builtin class-name">help</span> and <span class="token builtin class-name">exit</span>
      <span class="token parameter variable">--version</span>  output version information and <span class="token builtin class-name">exit</span>

GNU coreutils online help: <span class="token operator">&lt;</span>http://www.gnu.org/software/coreutils/<span class="token operator">></span>
For complete documentation, run: info coreutils 'mkdir invocation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一些特殊符号的含义：</p>
<ul>
<li>省略号<code>...</code>：表示可以有多个选项或参数。</li>
<li>中括号<code>[]</code>：之间的任何内容都是可选的。</li>
<li>大括号<code>&#123;&#125;</code>：表示应该选择由|隔开的各项中一个。</li>
<li>尖括号<code>&lt;&gt;</code>：内为变量表示参数可变。</li>
<li>不带中括号<code>[]</code>：表示<strong>必选项</strong>，必须作为命令的一部分输入。</li>
</ul>
<h1 id="查询手册"><a class="markdownIt-Anchor" href="#查询手册"></a> 查询手册</h1>
<p>使用 <code>man</code> 命令可以查询操作手册（manual），所有内建命令都有对应的操作手册页面。</p>
<p>手册存放在 <code>/usr/share/man</code> 目录中，可以通过修改 <code>/etc/man_db.conf</code> 文件来定义 man 查询手册的位置。</p>
<p>例如使用 <code>man</code> 命令查询 <code>mkdir</code> 命令的手册：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token function">mkdir</span>
MKDIR<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                                      User Commands                                     MKDIR<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

NAME
       <span class="token function">mkdir</span> - <span class="token function">make</span> directories

SYNOPSIS
       <span class="token function">mkdir</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. DIRECTORY<span class="token punctuation">..</span>.

DESCRIPTION
       Create the DIRECTORY<span class="token punctuation">(</span>ies<span class="token punctuation">)</span>, <span class="token keyword">if</span> they <span class="token keyword">do</span> not already exist.

       Mandatory arguments to long options are mandatory <span class="token keyword">for</span> short options too.

       -m, <span class="token parameter variable">--mode</span><span class="token operator">=</span>MODE
              <span class="token builtin class-name">set</span> <span class="token function">file</span> mode <span class="token punctuation">(</span>as <span class="token keyword">in</span> <span class="token function">chmod</span><span class="token punctuation">)</span>, not <span class="token assign-left variable">a</span><span class="token operator">=</span>rwx - <span class="token builtin class-name">umask</span>

       -p, <span class="token parameter variable">--parents</span>
              no error <span class="token keyword">if</span> existing, <span class="token function">make</span> parent directories as needed

       -v, <span class="token parameter variable">--verbose</span>
              print a message <span class="token keyword">for</span> each created directory

 Manual page mkdir<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> line <span class="token number">1</span> <span class="token punctuation">(</span>press h <span class="token keyword">for</span> <span class="token builtin class-name">help</span> or q to quit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 man 页面使用方向键浏览，用空格或[PageUp]，[PageDown]翻页。</p>
<p>输入/关键字来向下（?关键字向上）搜索手册中的内容，在搜索中按 n 和 N 进行正向查询和反向查询。</p>
<p>使用 <code>-f</code> 选项查询命令相关说明文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token parameter variable">-f</span> <span class="token function">date</span>
<span class="token function">date</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             - print or <span class="token builtin class-name">set</span> the system <span class="token function">date</span> and <span class="token function">time</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通常查询显示的是最低编号的内容（可以在 man_db.conf 中设置）。可以使用数字指定查询相应区块文档：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token parameter variable">-f</span> info
info <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             - <span class="token builtin class-name">read</span> Info documents
info <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>             - readable online documentation
<span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token number">5</span> info
INFO<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                                    File Formats Manual                                   INFO<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>

NAME
       info - readable online documentation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用 <code>-k</code> 选项进行模糊查询：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token parameter variable">-k</span> setse
setsebool <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>        - <span class="token builtin class-name">set</span> SELinux boolean value
<span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">man</span> <span class="token parameter variable">-k</span> sets
cpupower <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>         - Shows and sets processor power related values
ExtUtils::XSSymSet <span class="token punctuation">(</span>3pm<span class="token punctuation">)</span> - keep sets of symbol names palatable to the VMS linker
ipset <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>            - administration tool <span class="token keyword">for</span> IP sets
setsebool <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>        - <span class="token builtin class-name">set</span> SELinux boolean value
setsid <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>           - run a program <span class="token keyword">in</span> a new session
systemd.preset <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>   - Service enablement presets<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>man 手册约定：</p>
<table>
<thead>
<tr>
<th>区域号</th>
<th>所涵盖的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>可执行程序或 shell 命令。</td>
</tr>
<tr>
<td>2</td>
<td>系统内核可调用的函数和工具等。</td>
</tr>
<tr>
<td>3</td>
<td>一些常用函数（Function）与函数库（Library），大部分为 C 的函数库（libc）。</td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在 <code>/dev</code> 下的文件。</td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者是某些文件的格式。</td>
</tr>
<tr>
<td>6</td>
<td>游戏和演示。</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协议等，例如文件系统、网络协议等名词解释。</td>
</tr>
<tr>
<td>8</td>
<td>只有超级用户和系统管理员可使用的系统管理命令。</td>
</tr>
<tr>
<td>9</td>
<td>内核例程，与 Kernel 有关的文件。</td>
</tr>
</tbody>
</table>
<h1 id="查询-info-文档"><a class="markdownIt-Anchor" href="#查询-info-文档"></a> 查询 Info 文档</h1>
<p>类似于在命令行中浏览网页，使用<code>info</code>可以查询存放在 <code>/usr/share/info/</code> 目录下的文档。例如，可以使用以下命令查询有关 <code>mkdir</code> 的信息：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ info <span class="token function">mkdir</span>
File: libc.info,  Node: Creating Directories,  Next: File Attributes,  Prev: Renaming Files,  Up: File Sys<span class="token punctuation">\</span>
tem Interface

<span class="token number">14.8</span> Creating Directories
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>

Directories are created with the <span class="token string">'mkdir'</span> function.  <span class="token punctuation">(</span>There is also a
shell <span class="token builtin class-name">command</span> <span class="token string">'mkdir'</span> <span class="token function">which</span> does the same thing.<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，File 表示 info 页面的数据来源文件，Node 表示页面所属节点。<a href="http://xn--3ds.info">在.info</a> 的说明文件中，每个节点都有定位与链接，类似于超链接，可以快速跳转。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 下压缩和解压操作</title>
    <url>/635683850/</url>
    <content><![CDATA[<h1 id="常见压缩格式"><a class="markdownIt-Anchor" href="#常见压缩格式"></a> 常见压缩格式</h1>
<p>各种压缩工具使用的压缩技术不同，最后生成的文件后缀也不同，下面是 Linux 下常用的几种压缩格式：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>对应程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress 程序压缩的文件</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip 程序压缩的文件</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip 程序压缩的文件</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody>
</table>
<p>gzip 和 bzip2 都只能针对单个文件进行压缩和解压缩，而 tar 可以调用它们来集中打包文件。</p>
<h1 id="单文件压缩解压"><a class="markdownIt-Anchor" href="#单文件压缩解压"></a> 单文件压缩解压</h1>
<p><code>compress</code> 程序已经不再被使用，<code>gzip</code> 为系统内置程序，可用的参数有下面这些：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>将压缩的数据输出到屏幕上，可通过数据流重定向来处理</td>
</tr>
<tr>
<td>-d</td>
<td>解压缩的参数</td>
</tr>
<tr>
<td>-t</td>
<td>可以检验压缩包看有无损坏</td>
</tr>
<tr>
<td>-v</td>
<td>可以显示出源文件/压缩文件的压缩比等信息</td>
</tr>
<tr>
<td>-#</td>
<td>压缩等级，-1 最快，-9 压缩比最高</td>
</tr>
</tbody>
</table>
<p>例如压缩当前目录下的 b.log 文件，不加参数会自动删除原文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ ll
total <span class="token number">184</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:48 b.log
-rw-r--r--. <span class="token number">1</span> root root    <span class="token number">178</span> Sep  <span class="token number">9</span> 05:57 c.log
<span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">gzip</span> <span class="token parameter variable">-v</span> b.log 
b.log:   <span class="token number">93.2</span>% -- replaced with b.log.gz
<span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ ll
total <span class="token number">20</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">12439</span> Sep  <span class="token number">9</span> 05:48 b.log.gz
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">178</span> Sep  <span class="token number">9</span> 05:57 c.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>-d</code> 参数将文件解压时会删除原压缩文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">gzip</span> <span class="token parameter variable">-d</span> b.log.gz <span class="token punctuation">;</span> ll
total <span class="token number">184</span>
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:48 b.log
-rw-r--r--. <span class="token number">1</span> root root    <span class="token number">178</span> Sep  <span class="token number">9</span> 05:57 c.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将文件按最高压缩比压缩并保留原文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">gzip</span> <span class="token parameter variable">-9</span> <span class="token parameter variable">-c</span> b.log <span class="token operator">></span> b.gz <span class="token punctuation">;</span> ll
total <span class="token number">196</span>
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">11764</span> Sep <span class="token number">10</span> <span class="token number">11</span>:09 b.gz
-rw-------. <span class="token number">1</span> root root <span class="token number">182023</span> Sep  <span class="token number">9</span> 05:48 b.log
-rw-r--r--. <span class="token number">1</span> root root    <span class="token number">178</span> Sep  <span class="token number">9</span> 05:57 c.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>读取被压缩的纯文本文件可以使用 <code>zcat</code> 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ zcat b.gz <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-2</span>
<span class="token assign-left variable">type</span><span class="token operator">=</span>CRED_DISP <span class="token assign-left variable">msg</span><span class="token operator">=</span>audit<span class="token punctuation">(</span><span class="token number">1631178061.322</span>:415<span class="token punctuation">)</span>: <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">60628</span> <span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">auid</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ses</span><span class="token operator">=</span><span class="token number">22</span> <span class="token assign-left variable">subj</span><span class="token operator">=</span>system_u:system_r:crond_t:s0-s0:c0.c1023 <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">'op=PAM:setcred grantors=pam_env,pam_unix acct="root" exe="/usr/sbin/crond" hostname=? addr=? terminal=cron res=success'</span>
<span class="token assign-left variable">type</span><span class="token operator">=</span>USER_END <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>bzip2</code> 和 <code>xz</code> 的用法与 <code>gzip</code> 差不多，只是在压缩比上有区别。</p>
<h1 id="打包命令"><a class="markdownIt-Anchor" href="#打包命令"></a> 打包命令</h1>
<p>使用<code>gzip</code>对目录进行压缩时，其会将目录内的所有文件分别压缩。</p>
<p>将多个文件或目录包成一个大文件的命令称为打包，可以使用 <code>tar</code> 进行。</p>
<p><code>tar</code> 命令五个主要参数必备其一，不可以同时使用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>新建打包文件；</td>
</tr>
<tr>
<td>-t</td>
<td>查看打包文件的内容含有哪些文件；</td>
</tr>
<tr>
<td>-x</td>
<td>解压打包文件，搭配-C 指定解压到的目录；</td>
</tr>
<tr>
<td>-r</td>
<td>向压缩归档文件末尾追加文件；</td>
</tr>
<tr>
<td>-u</td>
<td>更新原压缩包中的文件。</td>
</tr>
</tbody>
</table>
<p><code>tar</code> 命令其他参数，其中 <code>-f</code> 是必备：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-j</td>
<td>通过<code>bzip2</code>的支持进行压缩解压，文件最好用<code>.tar.bz2</code>后缀；</td>
</tr>
<tr>
<td>-z</td>
<td>通过<code>gzip</code>的支持进行压缩解压，文件最好用<code>.tar.gz</code>后缀；</td>
</tr>
<tr>
<td>-J</td>
<td>通过<code>xz</code>的支持进行压缩解压，文件最好用<code>.tar.xz</code>后缀；</td>
</tr>
<tr>
<td>-v</td>
<td>在压缩解压过程中，将正在处理的文件名显示出来；</td>
</tr>
<tr>
<td>-f filename</td>
<td>接要被处理的文件名；</td>
</tr>
<tr>
<td>-C dir</td>
<td>解压时指定目标目录，不指定则在当前目录解压。</td>
</tr>
</tbody>
</table>
<p>备份时要用到的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>保留备份数据的原本权限和属性，常用于备份重要的配置文件；</td>
</tr>
<tr>
<td>-P</td>
<td>保留绝对路径，即允许备份数据中含有根目录；</td>
</tr>
<tr>
<td>–exclude=FILE</td>
<td>压缩过程中，排除掉文件 <code>FILE</code>。</td>
</tr>
</tbody>
</table>
<p>命令简记如下：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>压缩</td>
<td><code>tar -zcvf 压缩文件名.tar.gz 原文件</code></td>
</tr>
<tr>
<td>解压</td>
<td><code>tar -zxvf 压缩文件名.tar.gz -C 目标目录</code></td>
</tr>
<tr>
<td>查询</td>
<td><code>tar -ztvf 压缩文件名.tar.gz</code></td>
</tr>
</tbody>
</table>
<h1 id="压缩文件"><a class="markdownIt-Anchor" href="#压缩文件"></a> 压缩文件</h1>
<p>例如，使用 <code>gzip</code> 压缩备份 <code>/etc</code> 这个目录到 <code>/root</code> 下面，使用 <code>-p</code> 参数保留源文件权限和属性：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zpcv</span> <span class="token parameter variable">-f</span> /root/etc.tar.gz /etc
/etc/vimoutlinerrc
/etc/ntp.conf
/etc/updatedb.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>压缩时排除某些文件可以用 <code>--exclude=</code> 参数。例如，排除掉 <code>22</code> 文件夹：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zcv</span> <span class="token parameter variable">-f</span> <span class="token number">2</span>.tar.gz <span class="token parameter variable">--exclude</span><span class="token operator">=</span>/root/2/22 /root/2
tar: Removing leading `/' from member names
/root/2/
/root/2/1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用<code>--new</code>（包含<code>mtime</code>和<code>ctime</code>）和<code>--newer-mtime</code>时间参数来筛选文件。</p>
<p>比如打包<code>/root/audit/</code>下面修改日期在<code>2021年09月10日</code>之后的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zcv</span> <span class="token parameter variable">-f</span> new10.tar.gz --newer-mtime<span class="token operator">=</span><span class="token string">"2021/09/10"</span> /root/audit/*
tar: Option --newer-mtime: Treating <span class="token function">date</span> <span class="token variable"><span class="token variable">`</span><span class="token number">2021</span>/09/10' as <span class="token number">2021</span>-09-10 00:00:00
tar: Removing leading <span class="token variable">`</span></span>/' from member names
tar: /root/audit/b.log: <span class="token function">file</span> is unchanged<span class="token punctuation">;</span> not dumped
/root/audit/c.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查看压缩包"><a class="markdownIt-Anchor" href="#查看压缩包"></a> 查看压缩包</h1>
<p>使用以下命令可以查看压缩文件的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-ztv</span> <span class="token parameter variable">-f</span> /root/etc.tar.gz 
-rw-r--r-- root/root       <span class="token number">111</span> <span class="token number">2019</span>-11-27 <span class="token number">11</span>:47 etc/sysconfig/ntpdate
-rw-r--r-- root/root        <span class="token number">45</span> <span class="token number">2019</span>-11-27 <span class="token number">11</span>:47 etc/sysconfig/ntpd
drwxr-xr-x root/root         <span class="token number">0</span> <span class="token number">2021</span>-09-07 <span class="token number">13</span>:35 etc/xdg/
drwxr-xr-x root/root         <span class="token number">0</span> <span class="token number">2018</span>-04-11 00:59 etc/xdg/autostart/
drwxr-xr-x root/root         <span class="token number">0</span> <span class="token number">2021</span>-09-07 05:53 etc/xdg/systemd/
lrwxrwxrwx root/root         <span class="token number">0</span> <span class="token number">2021</span>-09-07 05:53 etc/xdg/systemd/user -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/systemd/user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从显示结果可以看到根目录，也就是文件名开头的 <code>/</code> 被移除了，这样做是为了安全。</p>
<p>如果使用 <code>-P</code> 保留根目录，则解压后的文件会是绝对路径，本地存在的相同文件会被压缩包内文件覆盖。</p>
<h1 id="解压文件"><a class="markdownIt-Anchor" href="#解压文件"></a> 解压文件</h1>
<p>解压缩文件 <code>etc.tar.gz</code> 到 <code>/tmp</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zxv</span> <span class="token parameter variable">-f</span> etc.tar.gz <span class="token parameter variable">-C</span> /tmp
etc/gdbinit.d/golang.gdb
etc/vimoutlinerrc
etc/ntp.conf
etc/updatedb.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解压 <code>etc.tar.gz</code> 中的单独文件 <code>etc/sudo.conf</code> 到当前目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">tar</span> <span class="token parameter variable">-zxv</span> <span class="token parameter variable">-f</span> etc.tar.gz etc/sudo.conf
etc/sudo.conf
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll etc/
total <span class="token number">4</span>
-rw-r-----. <span class="token number">1</span> root root <span class="token number">1786</span> Sep <span class="token number">30</span>  <span class="token number">2020</span> sudo.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 引导启动配置与关机</title>
    <url>/3107904477/</url>
    <content><![CDATA[<h1 id="启动引导程序"><a class="markdownIt-Anchor" href="#启动引导程序"></a> 启动引导程序</h1>
<p>目前在 Linux 下主要的引导启动程序是 Grub（Grand Unified Bootloader）或 Grub2。通常，Grub2 的主程序会将配置文件放到 <code>/boot/grub2</code> 目录下。而 Grub 则直接修改 <code>/boot/grub/grub.conf</code>，这是一个非常简单的配置文件。</p>
<p>Grub2 引导程序的特点有：</p>
<ul>
<li>
<p>它能够识别和支持更多的文件系统，并且可以使用 Grub2 的主程序在文件系统中直接搜索内核文件名。</p>
</li>
<li>
<p>在启动时，可以自行编辑和修改启动设置项目，类似于 bash 的命令模式。</p>
</li>
<li>
<p>它能够动态搜索配置文件，无需在修改配置后重新安装 Grub2。</p>
</li>
</ul>
<p>Grub2 对硬盘的代号设置与 Linux 中不同，一般用下面代号：</p>
<ul>
<li>
<p><code>(hd0,1)</code>：这是默认的语法，Grub2 会自动判断分区的格式。</p>
</li>
<li>
<p><code>(hd0,msdos1)</code>：这表示磁盘的分区采用传统的 MBR 模式。</p>
</li>
<li>
<p><code>(hd0,gpt1)</code>：这表示磁盘的分区采用 GPT 模式。</p>
</li>
</ul>
<p>硬盘代号用小括号 <code>()</code> 括起来，并按搜索顺序对硬盘进行编号，第一个分区从 1 开始计算，与 Grub 的从 0 开始计算不同。</p>
<p>默认情况下，系统已经安装了 Grub2。在特殊情况下，如果需要手动安装 Grub2，可以使用 <code>grub2-install</code> 命令。例如，将其安装到 <code>/dev/sdc</code> 下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ grub2-install /dev/sdc
Installing <span class="token keyword">for</span> i386-pc platform.
Installation finished. No error reported.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="grub2-配置文件"><a class="markdownIt-Anchor" href="#grub2-配置文件"></a> Grub2 配置文件</h2>
<p>Grub2 的配置文件路径为 <code>/boot/grub2/grub.cfg</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /boot/grub2/grub.cfg
<span class="token comment">#</span>
<span class="token comment"># DO NOT EDIT THIS FILE</span>
<span class="token comment">#</span>
<span class="token comment"># It is automatically generated by grub2-mkconfig using templates</span>
<span class="token comment"># from /etc/grub.d and settings from /etc/default/grub</span>
<span class="token comment">#</span>

<span class="token comment">### BEGIN /etc/grub.d/00_header ###</span>
<span class="token builtin class-name">set</span> <span class="token assign-left variable">pager</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token variable">$prefix</span>/grubenv <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此文件内容繁多，开头第一句就警告应该由 <code>grub2-mkconfig</code> 命令来创建配置，而不是直接修改它。</p>
<p>第一部分以 <code>### BEGIN /etc/grub.d/00_header ###</code> 开头，包含了环境设置和默认值设置等内容。其中比较重要的是 <code>set default</code> 默认开机选项和 <code>set timeout</code> 默认超时时间。</p>
<p>第四部分以 <code>### BEGIN /etc/grub.d/10_linux ###</code> 开头，设置了各个开机选择项 <code>menuentry</code>。每个选项都具有不同的启动参数和模块载入。其中比较重要的内容包括：</p>
<ul>
<li>
<p><code>set root</code>：设置 Grub2 配置文件所在的分区 <code>(hd0,msdos1)</code>，可以使用 <code>mount</code> 命令查看挂载的分区。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> boot
/dev/sda1 on /boot <span class="token builtin class-name">type</span> xfs <span class="token punctuation">(</span>rw,relatime,seclabel,attr2,inode64,noquota<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fdisk</span> <span class="token parameter variable">-l</span>
Disk /dev/sda: <span class="token number">21.5</span> GB, <span class="token number">21474836480</span> bytes, <span class="token number">41943040</span> sectors
Units <span class="token operator">=</span> sectors of <span class="token number">1</span> * <span class="token number">512</span> <span class="token operator">=</span> <span class="token number">512</span> bytes
Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: <span class="token number">512</span> bytes / <span class="token number">512</span> bytes
Disk label type: dos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果显示 <code>/boot</code> 被挂载在 <code>/dev/sda1</code> 下，分区格式为 MBR。</p>
</li>
<li>
<p><code>linux16 /vmlinuz</code>：指定内核文件以及内核文件运行时的参数。由于 <code>/boot</code> 是独立分区，这里的内核文件路径是 <code>(hd0,msdos1)/vmlinuz</code>。如果 <code>/boot</code> 挂载在根目录下，内核文件路径将变为 <code>(hd0,msdos1)/boot/vmlinuz</code>，即 <code>linux16 /boot/vmlinuz</code>。<code>root</code> 后面指定的是 Linux 系统中根目录挂载的设备。</p>
</li>
<li>
<p><code>initrd16 /initramfs</code>：指定虚拟文件系统 img 的位置。</p>
</li>
</ul>
<h2 id="grub2-配置维护"><a class="markdownIt-Anchor" href="#grub2-配置维护"></a> Grub2 配置维护</h2>
<p>可以通过修改 <code>/etc/default/grub</code> 文件和 <code>/etc/grub.d/</code> 目录内的相关配置文件来修改 Grub2 的配置。</p>
<p>查看 <code>/etc/default/grub</code> 文件的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/default/grub 
<span class="token assign-left variable">GRUB_TIMEOUT</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token assign-left variable">GRUB_DISTRIBUTOR</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">sed</span> <span class="token string">'s, release .*$,,g'</span> /etc/system-release<span class="token variable">)</span></span>"</span>
<span class="token assign-left variable">GRUB_DEFAULT</span><span class="token operator">=</span>saved
<span class="token assign-left variable">GRUB_DISABLE_SUBMENU</span><span class="token operator">=</span>true
<span class="token assign-left variable">GRUB_TERMINAL_OUTPUT</span><span class="token operator">=</span><span class="token string">"console"</span>
<span class="token assign-left variable">GRUB_CMDLINE_LINUX</span><span class="token operator">=</span><span class="token string">"crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"</span>
<span class="token assign-left variable">GRUB_DISABLE_RECOVERY</span><span class="token operator">=</span><span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，重要选项的含义如下：</p>
<ul>
<li>
<p><code>GRUB_TIMEOUT</code>：设置选择菜单等待超时的秒数。设为 0 表示不等待，设为 -1 表示必须手动选择。</p>
</li>
<li>
<p><code>GRUB_TIMEOUT_STYLE</code>：可以设置的值为 <code>menu</code>、<code>countdown</code>、<code>hidden</code> 等，默认为 <code>menu</code>。该参数用于确定是否显示菜单。将其设置为 <code>countdown</code> 或 <code>hidden</code> 可使用户看不到任何内容。</p>
</li>
<li>
<p><code>GRUB_DEFAULT</code>：菜单默认选择的项目。可以设置为 <code>saved</code>、数字、title 名、ID 名等，具体取决于 <code>menuentry</code> 的设置。例如，如果配置中定义了三个 <code>menuentry</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuentry <span class="token string">'CentOS'</span> <span class="token parameter variable">--unrestricted</span> <span class="token variable">$menuentry_id_option</span> <span class="token string">'linux-1'</span>
menuentry <span class="token string">'Debian'</span> <span class="token parameter variable">--unrestricted</span> <span class="token variable">$menuentry_id_option</span> <span class="token string">'gnulinux'</span>
menuentry <span class="token string">'Windows'</span> <span class="token parameter variable">--unrestricted</span> <span class="token variable">$menuentry_id_option</span> <span class="token string">'win'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么对应 <code>GRUB_DEFAULT</code> 的值：</p>
<ul>
<li>值为 1 表示选择排在第二个定义的 Debian 系统，因为数字编号从 0 开始。</li>
<li>值为 win 表示选择排在第三个定义的 Windows 系统，通过 ID 选取。</li>
<li>值为 saved 表示使用 <code>grub2-set-default</code> 来设置默认值，通常默认为 0。</li>
</ul>
</li>
<li>
<p><code>GRUB_TERMINAL_OUTPUT</code>：信息输出的终端模式。可以设置的值有 <code>console</code>、<code>serial</code>、<code>gfxterm</code>、<code>vga_text</code> 等。</p>
</li>
<li>
<p><code>GRUB_CMDLINE_LINUX</code>：内核的额外参数功能，用于设置内核启动时需要添加的额外参数。</p>
</li>
</ul>
<p>例如，将菜单等待时间修改为 30 秒，然后使用 <code>grub2-mkconfig</code> 命令重建 <code>grub.cfg</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/GRUB_TIMEOUT=5/GRUB_TIMEOUT=30/g'</span> /etc/default/grub <span class="token punctuation">;</span> <span class="token function">head</span> <span class="token parameter variable">-1</span> /etc/default/grub
<span class="token assign-left variable">GRUB_TIMEOUT</span><span class="token operator">=</span><span class="token number">30</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ grub2-mkconfig <span class="token parameter variable">-o</span> /boot/grub2/grub.cfg
Generating grub configuration <span class="token function">file</span> <span class="token punctuation">..</span>.
Found linux image: /boot/vmlinuz-3.10.0-1160.41.1.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img
Found linux image: /boot/vmlinuz-3.10.0-862.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-862.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
Found initrd image: /boot/initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
<span class="token keyword">done</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token function">timeout</span> /boot/grub2/grub.cfg
<span class="token keyword">if</span> <span class="token punctuation">[</span> x<span class="token variable">$feature_timeout_style</span> <span class="token operator">=</span> xy <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout_style</span><span class="token operator">=</span>menu
  <span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">30</span>
<span class="token comment"># Fallback normal timeout code in case the timeout_style feature is</span>
  <span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来看一下 <code>/etc/grub.d</code> 文件夹的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ ll /etc/grub.d
total <span class="token number">72</span>
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">8702</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 00_header
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">1043</span> Mar <span class="token number">21</span>  <span class="token number">2019</span> 00_tuned
-rwxr-xr-x. <span class="token number">1</span> root root   <span class="token number">232</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 01_users
-rwxr-xr-x. <span class="token number">1</span> root root <span class="token number">10781</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 10_linux
-rwxr-xr-x. <span class="token number">1</span> root root <span class="token number">10275</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 20_linux_xen
-rwxr-xr-x. <span class="token number">1</span> root root  <span class="token number">2559</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 20_ppc_terminfo
-rwxr-xr-x. <span class="token number">1</span> root root <span class="token number">11169</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 30_os-prober
-rwxr-xr-x. <span class="token number">1</span> root root   <span class="token number">214</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 40_custom
-rwxr-xr-x. <span class="token number">1</span> root root   <span class="token number">216</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> 41_custom
-rw-r--r--. <span class="token number">1</span> root root   <span class="token number">483</span> Mar <span class="token number">16</span>  <span class="token number">2021</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到文件名与 <code>grub.cfg</code> 中的段头对应。其中主要的文件包括：</p>
<ul>
<li><code>00_header</code>：用于创建初始的显示项目，包括需要加载的模块分析、屏幕终端格式、倒数秒数、菜单是否隐藏等。大部分设置在 <code>/etc/default/grub</code> 中的变量会在这个脚本中使用，用于重建 <code>grub.cfg</code>。</li>
<li><code>01_users</code>：用于设置账号密码，以控制每个菜单选项的访问权限。权限分为三种：不受限（<code>unrestricted</code>）、用户（<code>users</code>）、超级用户（<code>superusers</code>）。只有超级用户可以使用启动项编辑模式。</li>
<li><code>10_linux</code>：根据分析 <code>/boot</code> 下面的文件，尝试找到正确的 Linux 内核文件与虚拟文件系统镜像等，脚本会将找到的文件路径写入到 <code>grub.cfg</code> 中。因为每一个内核文件都会建立一个启动选项，所以可以适当删除旧内核文件来精简启动菜单。</li>
<li><code>30_os-prober</code>：这个脚本用来找其他分区中可能存在的操作系统，如果找到则将其加入启动菜单中。可以在 <code>/etc/default/grub</code> 中加上 <code>GRUB_DISABLE_OS_PROBER=true</code> 参数来取消这一扫描。</li>
<li><code>40_custom</code>：用来手动添加菜单项目。例如想新增一个 <code>menuentry</code> 来指定开机进入图形模式，可以在 <code>grub.cfg</code> 中复制一个 <code>menuentry</code> 段，修改对应的 <code>title</code>、<code>id</code> 与 <code>linux16</code> 后面的参数（增加 <code>systemd.unit=graphical.target</code>），然后再用 <code>grub2-mkconfig</code> 命令重建 <code>grub.cfg</code> 即可。</li>
</ul>
<h2 id="设置多重引导"><a class="markdownIt-Anchor" href="#设置多重引导"></a> 设置多重引导</h2>
<p>多重引导使用开机管理程序的链接（Chain Loader）功能，将开机引导程序指向其他位置。只需要设置另一个开机引导程序所在分区代号和所在扇区就可以了。</p>
<p>假设系统有一块硬盘两个分区，分别装了 Linux（sdb1）和 Windows（sdb2），我们需要增加两个开机选项，一个指向 Windows 开机菜单，一个回到 MBR 的默认环境。<code>40_custom</code> 文件内容大致如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/grub.d/40_custom 
<span class="token comment">#!/bin/sh</span>
<span class="token builtin class-name">exec</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> +3 <span class="token variable">$0</span>
<span class="token comment"># This file provides an easy way to add custom menu entries.  Simply type the</span>
<span class="token comment"># menu entries you want to add after this comment.  Be careful not to change</span>
<span class="token comment"># the 'exec tail' line above.</span>
menuentry <span class="token string">'Windows'</span> <span class="token parameter variable">--id</span> <span class="token string">'win'</span> <span class="token punctuation">&#123;</span>
        insmod chain
        insmod ntfs
        <span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token punctuation">(</span>hd0,msdos2<span class="token punctuation">)</span>
        chainloader +1
menuentry <span class="token string">'MBR'</span> <span class="token parameter variable">--id</span> <span class="token string">'mbr'</span> <span class="token punctuation">&#123;</span>
        insmod chain
        <span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token punctuation">(</span>hd0<span class="token punctuation">)</span>
        chainloader +1
<span class="token string">"/etc/grub.d/40_custom"</span> 14L, 469C written
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中最重要的是载入 <code>chain</code> 和 <code>ntfs</code> 模块，由此 Grub2 才能正确读取文件系统执行 Chain Loader 功能。</p>
<h2 id="启动项编辑模式"><a class="markdownIt-Anchor" href="#启动项编辑模式"></a> 启动项编辑模式</h2>
<p>在启动菜单出现后，可以按下 <code>e</code> 进入启动项编辑模式。也就是直接编辑 <code>grub.cfg</code> 文件内容。</p>
<p>例如，可以在 <code>systemd.unit</code> 中指定为 <code>rescue.target</code>，这样就能直接进入救援模式，而不需要先进入系统。修改完毕后，使用快捷键 <code>[Ctrl]+x</code> 来执行。</p>
<h1 id="启动异常处理"><a class="markdownIt-Anchor" href="#启动异常处理"></a> 启动异常处理</h1>
<p>通常因为某些不正常的设置或不正常关机导致无法顺利开机时,可以进入 rescue 模式去处理.</p>
<h2 id="忘记-root-密码"><a class="markdownIt-Anchor" href="#忘记-root-密码"></a> 忘记 root 密码</h2>
<p>在使用 grub 做引导的系统可以这样处理：</p>
<ol>
<li>启动系统，在选择启动项的界面下，按 <code>e</code> 进入默认启动项 grub 编辑模式。</li>
<li>移动到有 kernel 那行，再按一次 <code>e</code> 进入编辑界面，在最后方输入 <code>single</code>。</li>
<li>按下回车，再按下 <code>b</code> 就可以进入单用户维护模式。</li>
<li>这一模式下可以直接用 <code>passwd</code> 命令修改 root 密码。</li>
</ol>
<p>CentOS 7 中 rescue 模式也需要 root 密码才能登录，因此可以进入 emergency 救援模式：</p>
<ol>
<li>按 <code>e</code> 进入编辑默认启动项 grub，找到 linux16 那行，在最末尾输入 <code>init=/bin/sh</code>，按 <code>[Ctrl]+x</code> 执行；</li>
<li>进入 emergency 模式后，输入 <code>mount -o remount,rw /</code> 命令将根目录挂载为可读写模式；</li>
<li>然后使用 <code>passwd</code> 命令设置新的 root 密码；</li>
<li>最后输入 <code>touch /.autorelabel</code> 更新系统信息，让 SELinux 生效；</li>
<li>执行 <code>exec /sbin/init</code> 或 <code>reboot</code> 即可退出救援模式。</li>
</ol>
<p>通过 rd.break（Ram Disk 里面的操作系统）内核启动参数也可以处理：</p>
<ol>
<li>同样在编辑默认启动项 grub，在 linux16 那行末尾加入 <code>rd.break</code> 参数，按 <code>[Ctrl]+x</code> 执行；</li>
<li>此时进入的是 Ram Disk 环境，系统被挂载到 <code>/sysroot</code> 目录下，用 <code>mount -o remount,rw /sysroot</code> 重新挂载；</li>
<li>用命令 <code>chroot /sysroot</code> 来切换根目录，并使用 <code>passwd</code> 命令修改密码；</li>
<li>同样用 <code>touch /.autorelabel</code> 来变回 SELinux 的安全标签。重启即可。</li>
</ol>
<p><code>touch /.autorelabel</code> 命令的作用：</p>
<ul>
<li>
<p>在救援模式下系统没有 SELinux，所以用 <code>passwd</code> 命令修改了 <code>/etc/shadow</code> 文件后，它的 SELinux 安全标签会被取消，在 SELinux 为 Enforcing 模式下会无法登录系统。</p>
</li>
<li>
<p>创建 <code>/.autorelabel</code> 文件就是要让系统在开机时自动使用默认 SELinux 类型重写入 SELinux 安全标签到每个文件。</p>
</li>
<li>
<p>如果不想让每个文件都更新标签，可以改完密码后，将 SELinux 运行模式改为 permissive（修改 <code>/etc/selinux/config</code> 文件）。再重新开机后运行 <code>restorecon -Rv /etc</code> 仅恢复 <code>/etc</code> 目录下的默认安全上下文类型。最后将 SELinux 配置文件的运行模式改回 enforcing，用 <code>setenforce 1</code> 来生效。</p>
</li>
</ul>
<h2 id="文件系统错误"><a class="markdownIt-Anchor" href="#文件系统错误"></a> 文件系统错误</h2>
<p>断电或不正常关机会导致文件系统错误，通常是软件数据问题。如果根目录没有损坏，可以进入维护模式下使用<code>fsck</code>命令修复<code>ext4</code>格式的分区。修复完毕后以<code>reboot</code>重启即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">fsck</span> /dev/sda2
<span class="token function">fsck</span> from util-linux <span class="token number">2.23</span>.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果是<code>xfs</code>格式分区则使用<code>xfs_repair</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ xfs_repair /dev/sda2
xfs_repair: cannot <span class="token function">open</span> /dev/sda2: Device or resource busy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果整个硬盘只有一个大区，那文件系统错误一定是根目录的问题。这时候需要将硬盘拔下来，接到另外一台 Linux 系统的机器上，并且不要挂载，以<code>root</code>身份执行<code>fsck</code>或<code>xfs_repair</code>命令修复。</p>
<p>还有一种方法是使用 U 盘刻成 Live CD，在 U 盘启动的系统中执行修复命令。</p>
<h1 id="关机重启"><a class="markdownIt-Anchor" href="#关机重启"></a> 关机重启</h1>
<p>切换运行级别和模式并不会重启.</p>
<h2 id="查看用户在线状态"><a class="markdownIt-Anchor" href="#查看用户在线状态"></a> 查看用户在线状态</h2>
<p>如果有其他用户在线，强制关机可能会导致用户文件丢失，可以先使用<code>who</code>命令查看当前已登录的用户信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">who</span> <span class="token parameter variable">-Hu</span>
NAME     LINE         TIME             IDLE          PID COMMENT
root     tty1         <span class="token number">2021</span>-09-11 09:35  old          <span class="token number">897</span>
root     pts/0        <span class="token number">2021</span>-09-15 <span class="token number">12</span>:12   <span class="token builtin class-name">.</span>          <span class="token number">5334</span> <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span>
root     pts/1        <span class="token number">2021</span>-09-14 08:40  old        <span class="token number">55207</span> <span class="token punctuation">(</span><span class="token number">192.168</span>.2.101<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数据写回"><a class="markdownIt-Anchor" href="#数据写回"></a> 数据写回</h2>
<p>默认情况下，某些加载到内存中的数据不会直接被写回硬盘，而是暂存在内存中。可以手动同步将数据写入硬盘：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">sync</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用重启或关机命令前也会自动调用<code>sync</code>命令。</p>
<p>当非管理员使用<code>sync</code>命令时，只会更新该用户的操作数据。</p>
<h2 id="关机操作"><a class="markdownIt-Anchor" href="#关机操作"></a> 关机操作</h2>
<p>通常使用 <code>shutdown</code> 命令来进行关机操作。</p>
<p>立即关机：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">shutdown</span> <span class="token parameter variable">-h</span> now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>预定在 21:00 关机。如果当前时间超过 21:00 则会在隔天 21:00 才关机：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user1@101c7 root<span class="token punctuation">]</span>$ <span class="token function">shutdown</span> <span class="token parameter variable">-h</span> <span class="token number">21</span>:00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>预定 2 分钟后关机，并发送消息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">shutdown</span> <span class="token parameter variable">-P</span> <span class="token number">120</span> <span class="token string">"will  poweroff"</span>
Shutdown scheduled <span class="token keyword">for</span> Wed <span class="token number">2021</span>-09-15 <span class="token number">16</span>:01:48 EDT, use <span class="token string">'shutdown -c'</span> to cancel.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>取消即将进行的关机操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">shutdown</span> <span class="token parameter variable">-c</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ 
Broadcast message from root@101c7 <span class="token punctuation">(</span>Wed <span class="token number">2021</span>-09-15 <span class="token number">14</span>:01:54 EDT<span class="token punctuation">)</span>:

The system <span class="token function">shutdown</span> has been cancelled at Wed <span class="token number">2021</span>-09-15 <span class="token number">14</span>:02:54 EDT<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="重启操作"><a class="markdownIt-Anchor" href="#重启操作"></a> 重启操作</h2>
<p>重启命令可用 <code>reboot</code> 或 <code>halt</code>，选择其一即可。</p>
<p>立即强制关机：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">halt</span> <span class="token parameter variable">-P</span> <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同步后重启系统：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">sync</span><span class="token punctuation">;</span> <span class="token function">sync</span><span class="token punctuation">;</span> <span class="token function">sync</span><span class="token punctuation">;</span> <span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="切换执行等级"><a class="markdownIt-Anchor" href="#切换执行等级"></a> 切换执行等级</h2>
<p>可以通过 <code>init</code> 命令来切换运行级别，例如进入单用户维护模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span>$ init <span class="token number">1</span>
Broadcast message from root@localhost.localdomain on pts/1 <span class="token punctuation">(</span>Fri <span class="token number">2019</span>-07-05 <span class="token number">15</span>:40:59 CST<span class="token punctuation">)</span>:

The system is going down to rescue mode NOW<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 CentOS 7 中则是由 <code>systemctl</code> 来管理模式之间的切换，例如切换到救援模式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ systemctl isolate rescue.target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件内容处理</title>
    <url>/3847284551/</url>
    <content><![CDATA[<h1 id="提取数据列"><a class="markdownIt-Anchor" href="#提取数据列"></a> 提取数据列</h1>
<p>可以使用 <code>cut</code> 命令按行提取数据并删除所需部分，命令格式如下：</p>
<p><code>cut -d '分隔字符' -f 编号</code></p>
<p><code>cut -c 字符范围</code></p>
<p>可用参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>后面接分隔字符，与 -f 一起使用。</td>
</tr>
<tr>
<td>-f</td>
<td>选取被切割后的第几段数据。</td>
</tr>
<tr>
<td>-c</td>
<td>以字符为单位取出固定字符区间。</td>
</tr>
</tbody>
</table>
<p>例如以 <code>:</code> 为分隔符，取出 <code>PATH</code> 变量第 3 和第 5 段：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 abc<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">":"</span> <span class="token parameter variable">-f</span> <span class="token number">3,5</span>
/usr/sbin:/root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>将 <code>export</code> 输出信息取得第 12 个字符以后的所有字符串：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 abc<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span><span class="token operator">|</span><span class="token function">head</span> -4<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token string">"-----"</span><span class="token punctuation">;</span><span class="token builtin class-name">export</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-c</span> <span class="token number">12</span>- <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-4</span>
<span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">HISTCONTROL</span></span><span class="token operator">=</span><span class="token string">"ignoredups"</span>
<span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token string">"1000"</span>
<span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span><span class="token string">"/root"</span>
<span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span><span class="token string">"101c7"</span>
-----
<span class="token assign-left variable"><span class="token environment constant">HISTCONTROL</span></span><span class="token operator">=</span><span class="token string">"ignoredups"</span>
<span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token string">"1000"</span>
<span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span><span class="token string">"/root"</span>
<span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span><span class="token string">"101c7"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要选取的值是 12 到 20 个字符，那么使用 <code>cut -c 12-20</code>。</p>
<h1 id="抓取数据"><a class="markdownIt-Anchor" href="#抓取数据"></a> 抓取数据</h1>
<p>使用 grep 则是分析一行信息,有需要的信息则将整行取出.简单语法如下:</p>
<p><code>grep [-acinv] '查找字符串' 文件名</code></p>
<p><code>grep -[AB] '查找字符串' 文件名</code></p>
<p>可用参数如下:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>将二进制文件以 text 文件的方式查找数据</td>
</tr>
<tr>
<td>-c</td>
<td>计算找到 ‘查找字符串’ 的次数</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-n</td>
<td>输出行号</td>
</tr>
<tr>
<td>-v</td>
<td>反向选择</td>
</tr>
<tr>
<td>-E</td>
<td>使用扩展正则表达式，默认使用基础正则表达式</td>
</tr>
<tr>
<td>-P</td>
<td>使用 Perl 正则表达式</td>
</tr>
<tr>
<td>-F</td>
<td>关闭正则表达式模式，将所有的字母都看作单词</td>
</tr>
<tr>
<td>-A/Bn</td>
<td>列出找到结果的后/前 n 行</td>
</tr>
</tbody>
</table>
<p>例如取出 /etc/man_db.conf 中含有 MANPATH 的行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token string">'MANPATH'</span> /etc/man_db.conf 
<span class="token comment"># MANDATORY_MANPATH                     manpath_element</span>
<span class="token comment"># MANPATH_MAP           path_element    manpath_element</span>
<span class="token comment"># every automatically generated MANPATH includes these fields</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>忽略大小写，使用扩展正则表达式搜索打印出以 pw 开头的行，并显示行号：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> anaconda-ks.cfg <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-i</span> <span class="token string">'^pw.*'</span>
<span class="token number">45</span>:pwpolicy root <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span>
<span class="token number">46</span>:pwpolicy user <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span>
<span class="token number">47</span>:pwpolicy luks <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>向搜索以 # 开头以 s 结尾的行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-vn</span> <span class="token string">'^#.*s$'</span> anaconda-ks.cfg 
<span class="token number">1</span>:<span class="token comment">#version=DEVEL</span>
<span class="token number">2</span>:<span class="token comment"># System authorization information</span>
<span class="token number">3</span>:auth <span class="token parameter variable">--enableshadow</span> <span class="token parameter variable">--passalgo</span><span class="token operator">=</span>sha512<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="排序命令"><a class="markdownIt-Anchor" href="#排序命令"></a> 排序命令</h1>
<p>使用 <code>sort</code> 命令能对文件内容进行排序。该命令的主要参数包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>忽略大小写差异；</td>
</tr>
<tr>
<td>-b</td>
<td>忽略最前面的空格；</td>
</tr>
<tr>
<td>-M</td>
<td>以月份的名字来排序；</td>
</tr>
<tr>
<td>-n</td>
<td>使用纯数字进行排序；</td>
</tr>
<tr>
<td>-r</td>
<td>反向排序；</td>
</tr>
<tr>
<td>-u</td>
<td>去除重复行；</td>
</tr>
<tr>
<td>-t</td>
<td>分隔符，默认是 TAB；</td>
</tr>
<tr>
<td>-k</td>
<td>以哪个分割区间来进行排序。</td>
</tr>
</tbody>
</table>
<p>例如，将 <code>passwd</code> 文件内容按第一个字符排序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-4</span>
adm:x:3:4:adm:/var/adm:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
chrony:x:998:996::/var/lib/chrony:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以 <code>:</code> 为分隔符，按第 3 列（数字）排序。也可以使用 <code>-k 3,4</code> 参数来先按第三列排序，再按第四列排序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-t</span> <span class="token string">':'</span> <span class="token parameter variable">-k</span> <span class="token number">3</span> <span class="token parameter variable">-n</span> <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-5</span>
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要统计重复数据，可以使用 <code>uniq</code> 命令。需要注意的是，<code>uniq</code> 的输入必须是有序的。例如，使用 <code>-c</code> 参数统计用户登录次数，再以从少到多排序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ last <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">' '</span> <span class="token parameter variable">-f</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-c</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-t</span> <span class="token string">' '</span> <span class="token parameter variable">-k</span> <span class="token number">1</span> <span class="token parameter variable">-n</span>
      <span class="token number">1</span> 
      <span class="token number">1</span> wtmp
      <span class="token number">3</span> <span class="token function">reboot</span>
     <span class="token number">13</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="统计文件信息"><a class="markdownIt-Anchor" href="#统计文件信息"></a> 统计文件信息</h1>
<p>使用 <code>wc</code> 命令来统计文件信息，包括行数、单词数和文件大小。该命令可用的选项包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>查询文件内容行数；</td>
</tr>
<tr>
<td>-w</td>
<td>查询文件单词数；</td>
</tr>
<tr>
<td>-c</td>
<td>查询文件大小（单位 B）。</td>
</tr>
</tbody>
</table>
<p>默认参数为 <code>-lwc</code>。例如，查询文件 <code>anaconda-ks.cfg</code> 的行数、单词数和大小：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">wc</span> anaconda-ks.cfg 
  <span class="token number">48</span>  <span class="token number">122</span> <span class="token number">1260</span> anaconda-ks.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="字符转换命令"><a class="markdownIt-Anchor" href="#字符转换命令"></a> 字符转换命令</h1>
<p>可以使用 <code>tr</code> 命令删除一段信息中的文字，或进行文字信息的替换。该命令可用的参数包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>删除信息中的字符串；</td>
</tr>
<tr>
<td>-s</td>
<td>替换掉重复的字符。</td>
</tr>
</tbody>
</table>
<p>例如，将 <code>last</code> 命令输出的信息中所有小写字母转换为大写：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ last <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'[a-z]'</span> <span class="token string">'[A-Z]'</span>
ROOT     TTY1                          SAT SEP <span class="token number">11</span> 09:35   STILL LOGGED IN   
ROOT     PTS/1        <span class="token number">192.168</span>.2.101    SAT SEP <span class="token number">11</span> 08:58   STILL LOGGED IN <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>删除所有 <code>passwd</code> 文件中的 DOS 断行符 <code>\r</code> 并另存为 <code>px.txt</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">tr</span> <span class="token parameter variable">-d</span> <span class="token string">'\r'</span> <span class="token operator">></span> px.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="转换-tab-为空格"><a class="markdownIt-Anchor" href="#转换-tab-为空格"></a> 转换 Tab 为空格</h1>
<p>在 Linux 中，默认每隔 8 个字符有一个制表位（Tab Stop）。可以使用 <code>col</code> 命令将文件中的 Tab 转换成对等的空格。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token parameter variable">-A</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"#M"</span>
<span class="token comment">#MANDATORY_MANPATH ^I^I^I/usr/src/pvm3/man$</span>
<span class="token comment">#MINCATWIDTH^I80$</span>
<span class="token comment">#MAXCATWIDTH^I80$</span>
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/man_db.conf <span class="token operator">|</span> col <span class="token parameter variable">-x</span> <span class="token operator">|</span> <span class="token function">cat</span> <span class="token parameter variable">-A</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"#M"</span>
<span class="token comment">#MANDATORY_MANPATH                      /usr/src/pvm3/man$</span>
<span class="token comment">#MINCATWIDTH    80$</span>
<span class="token comment">#MAXCATWIDTH    80$</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上命令将制表位转换成了等效的空格，从而消除了 <code>^I</code> 的干扰。</p>
<p>另外，还可以使用 <code>expand</code> 命令将 Tab 转换成空格。例如，将 <code>/etc/man_db.conf</code> 文件中的制表位设置为 1，并将 Tab 转换成空格：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token string">"#M"</span> /etc/man_db.conf<span class="token operator">|</span> <span class="token function">expand</span> <span class="token parameter variable">-t</span> <span class="token number">1</span> 
<span class="token comment">#MANDATORY_MANPATH    /usr/src/pvm3/man</span>
<span class="token comment">#MINCATWIDTH 80</span>
<span class="token comment">#MAXCATWIDTH 80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要将行开头的空格转换成 Tab，可以使用 <code>unexpand</code> 命令。该命令不会操作行中间的空格，因为大多数时候，只需要使用 <code>unexpand</code> 程序进行缩进。您还可以使用 <code>-a</code> 选项将所有空格替换为 Tab。</p>
<h1 id="转换断行符"><a class="markdownIt-Anchor" href="#转换断行符"></a> 转换断行符</h1>
<p>在 Windows 中，文本文件的换行符是 <code>CRLF</code>（<code>\r\n</code>），而在 Linux 下则使用 <code>LF</code> 这个换行符。如果在 Linux 环境下执行 Windows 格式的脚本，可能会出现无法执行的错误。</p>
<p>可以通过 Notepad++ 的扩展搜索功能，将 \r 全部替换掉。也可以使用 <code>dos2unix</code> 和 <code>unix2dos</code> 命令来转换文本文件中的换行符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ dos2unix <span class="token parameter variable">-k</span> root.txt 
dos2unix: converting <span class="token function">file</span> root.txt to Unix <span class="token function">format</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="格式化行"><a class="markdownIt-Anchor" href="#格式化行"></a> 格式化行</h1>
<p>如果需要将长行分隔成短行，可以使用 <code>fold</code> 命令。例如，将 <code>anaconda-ks.cfg</code> 文件中的行宽设置为 10 并且不分离单词：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">fold</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-w</span> <span class="token number">10</span> anaconda-ks.cfg 
<span class="token comment">#version=D</span>
EVEL
<span class="token comment"># System </span>
authorizat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="格式化段落"><a class="markdownIt-Anchor" href="#格式化段落"></a> 格式化段落</h1>
<p>如果需要将段落中的各行连接在一起，使段落尽可能短小和紧凑，可以使用 <code>fmt</code> 命令。该命令假定段落由空行分隔，因此一个段落就是一个或多个连续的文本行，不包含空格。</p>
<p>例如，将文本文件 <code>anaconda-ks.cfg</code> 按照行宽 50 个字符重新格式化段落，并合并连续的空格：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token function">fmt</span> <span class="token parameter variable">-u</span> <span class="token parameter variable">-w</span> <span class="token number">50</span> anaconda-ks.cfg 
<span class="token comment">#version=DEVEL # System authorization information</span>
auth <span class="token parameter variable">--enableshadow</span> <span class="token parameter variable">--passalgo</span><span class="token operator">=</span>sha512 <span class="token comment"># Use</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="编码转换"><a class="markdownIt-Anchor" href="#编码转换"></a> 编码转换</h1>
<p>可以使用 <code>locale</code> 命令查看与系统编码相关的设置。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ locale
<span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8
<span class="token assign-left variable">LC_CTYPE</span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果需要修改系统编码以处理乱码问题，只需要重新定义对应的变量并导出即可。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8 <span class="token punctuation">;</span> locale
<span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8
<span class="token assign-left variable">LC_CTYPE</span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果需要转换文件编码，可以使用 <code>iconv</code> 命令将文件编码转换为另一种格式。例如，将 <code>1.txt</code> 文件的原始编码 <code>big5</code> 转换为 <code>UTF-8</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">iconv</span> <span class="token parameter variable">-f</span> big5 <span class="token parameter variable">-t</span> utf8 <span class="token number">1</span>.txt <span class="token parameter variable">-o</span> 1utf8.txt
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">file</span> 1utf8.txt 
1utf8.txt: ASCII text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>另外，还可以使用 <code>iconv</code> 命令将繁体中文转换为简体中文。例如，将 <code>1.txt</code> 中的繁体中文转换为简体中文 <code>GB2312</code> 编码格式，并将结果保存到 <code>1.gb.txt</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">iconv</span> <span class="token parameter variable">-f</span> utf8 <span class="token parameter variable">-t</span> big5 <span class="token number">1</span>.txt <span class="token operator">|</span> <span class="token function">iconv</span> <span class="token parameter variable">-f</span> big5 <span class="token parameter variable">-t</span> gb2312 <span class="token operator">|</span> <span class="token function">iconv</span> <span class="token parameter variable">-f</span> gb2312 <span class="token parameter variable">-t</span> utf8 <span class="token parameter variable">-o</span> <span class="token number">1</span>.gb.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="文件合并"><a class="markdownIt-Anchor" href="#文件合并"></a> 文件合并</h1>
<p>可以使用 <code>join</code> 命令将两个文件中有相同数据的那一行加在一起。例如，将 <code>passwd</code> 与 <code>shadow</code> 相关的数据整合成一列：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">join</span> <span class="token parameter variable">-t</span> <span class="token string">':'</span> /etc/passwd /etc/shadow
bin:x:1:1:bin:/bin:/sbin/nologin:*:17632:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin:*:17632:0:99999:7:::
adm:x:3:4:adm:/var/adm:/sbin/nologin:*:17632:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以使用 <code>paste</code> 命令将两个文件按行拼接在一起，用 Tab 分隔两个文件的行。例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">paste</span> /etc/passwd /etc/shadow <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-3</span>
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:17632:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:17632:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以上命令将 <code>passwd</code> 与 <code>shadow</code> 两个文件的每一行按顺序拼接在一起，并用 Tab 分隔两个文件的行。</p>
<h1 id="文件切割"><a class="markdownIt-Anchor" href="#文件切割"></a> 文件切割</h1>
<p>可以使用 split 命令将大文件分割成小文件，参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-b</code></td>
<td>以指定大小进行切割</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>以行数来进行切割</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>以两位的数字而不是字母作为后缀</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>指定在后缀中使用的数字或字符的数量</td>
</tr>
<tr>
<td><code>PREFIX</code></td>
<td>代表前导符,可作为切割文件的前导文字</td>
</tr>
</tbody>
</table>
<p>例如将 <code>test.iso</code> 切割成每个文件大小为 5M：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">split</span> <span class="token parameter variable">-b</span> 5M test.iso file.sp <span class="token operator">|</span> ll <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'file'</span>
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">5242880</span> Sep <span class="token number">11</span> <span class="token number">12</span>:35 file.spaa
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">5242880</span> Sep <span class="token number">11</span> <span class="token number">12</span>:35 file.spab
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">5242880</span> Sep <span class="token number">11</span> <span class="token number">12</span>:35 file.spac
-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">5242880</span> Sep <span class="token number">11</span> <span class="token number">12</span>:35 file.spad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用数据流重定向来合并切割后的文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cat</span> file1.spa* <span class="token operator">>></span> test1.iso<span class="token punctuation">;</span>ll <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'test'</span>
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">20971520</span> Sep <span class="token number">11</span> <span class="token number">12</span>:38 test1.iso
-rw-r--r--. <span class="token number">1</span> root root <span class="token number">20971520</span> Sep <span class="token number">11</span> <span class="token number">12</span>:33 test.iso<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果不带参数，<code>split</code> 命令会以 1000 行作为切割条件。可以使用 <code>-l</code> 选项指定每 5 行记录成一个文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-la</span> <span class="token operator">|</span> <span class="token function">split</span> <span class="token parameter variable">-l</span> <span class="token number">10</span> - lsla<span class="token punctuation">;</span><span class="token function">wc</span> <span class="token parameter variable">-l</span> lsla*
<span class="token number">10</span> lslaaa
  <span class="token number">3</span> lslaab
<span class="token number">13</span> total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般来说，如果需要标准输入输出且没有文件，只有 <code>-</code> 时，<code>-</code> 就被当成标准输入或标准输出。</p>
<h1 id="文件比较"><a class="markdownIt-Anchor" href="#文件比较"></a> 文件比较</h1>
<p>在 Linux 系统中，比较文件可以使用 <code>diff</code> 命令。<code>diff</code> 命令会输出将左边的文件转换为右边的文件所需的修改内容。</p>
<p>命令格式为：<code>diff [-bBi] 要比较的文件 基准文件</code></p>
<p>参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>忽略一行中仅有多个空白的区别，例如&quot;a  man&quot;与&quot;a man&quot;视为等同</td>
</tr>
<tr>
<td>-B</td>
<td>忽略空白行的区别</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>
<p>例如，比较 <code>c.cfg</code> 和 <code>cnew.txt</code> 两个文件的区别:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cat</span> c.cfg 
abcaca
/root/etc/
<span class="token number">1.4</span>
1a4
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cat</span> cnew.cfg 
abcaca
/root/etc
<span class="token number">1.4</span>
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">diff</span> c.cfg cnew.cfg 
2c2
<span class="token operator">&lt;</span> /root/etc/
---
<span class="token operator">></span> /root/etc
4d3
<span class="token operator">&lt;</span> 1a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>比较结果说明如下:</p>
<table>
<thead>
<tr>
<th><strong>行</strong></th>
<th><strong>值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>2c2</strong></td>
<td>左边和右边比第 2 行不一样（c=change 改变，d=delete 删除，a=append 追加）</td>
</tr>
<tr>
<td>2</td>
<td>&lt; /root/etc/</td>
<td>显示左边文件不同的第 2 行内容</td>
</tr>
<tr>
<td>3</td>
<td>—</td>
<td>左右两个文件区分显示的分隔符</td>
</tr>
<tr>
<td>4</td>
<td>&gt; /root/etc</td>
<td>显示右边文件不同的第 2 行内容</td>
</tr>
<tr>
<td>5</td>
<td><strong>4d3</strong></td>
<td>显示左边第 4 行和右边第 3 行比不同（d 代表删除）</td>
</tr>
<tr>
<td>6</td>
<td>&lt; 1a4</td>
<td>显示左边文件第 4 行内容，而右边第 4 行不存在（被删除）</td>
</tr>
</tbody>
</table>
<p>可以直接将文件比较的区别制作成补丁文件（也叫差分），供要比较的文件使用升级。优点是反升级和升级一样方便。制作补丁参数为 -Naur：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">diff</span> <span class="token parameter variable">-Naur</span> c.cfg cnew.cfg <span class="token operator">></span> c.patch<span class="token punctuation">;</span><span class="token function">cat</span> c.patch
--- c.cfg       <span class="token number">2021</span>-09-12 05:52:16.000000000 <span class="token parameter variable">-0400</span>
+++ cnew.cfg    <span class="token number">2021</span>-09-12 <span class="token number">13</span>:25:05.000000000 <span class="token parameter variable">-0400</span>
@@ -1,4 +1,3 @@
abcaca
-/root/etc/
+/root/etc
<span class="token number">1.4</span>
<span class="token parameter variable">-1a4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提供给左侧文件使用的补丁内容：</p>
<table>
<thead>
<tr>
<th><strong>行</strong></th>
<th><strong>值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>— c.cfg</td>
<td>左边文件信息，— 表示旧文件</td>
</tr>
<tr>
<td>2</td>
<td>+++ cnew.cfg</td>
<td>右边文件信息，+++ 表示新文件</td>
</tr>
<tr>
<td>3</td>
<td>@@ -1,4 +1,3 @@</td>
<td>修改数据的界定范围，旧文件在 1-4 行，新文件在 1-3 行</td>
</tr>
<tr>
<td>4</td>
<td>abcaca</td>
<td>第一行内容，内容前面没有符号表示不需要变动</td>
</tr>
<tr>
<td>5</td>
<td><strong>-/root/etc/</strong></td>
<td>左侧文件第二行内容。减号 - 表示删除此行</td>
</tr>
<tr>
<td>6</td>
<td><strong>+/root/etc</strong></td>
<td>右侧文件第二行内容。加号 + 表示增加此行</td>
</tr>
<tr>
<td>7</td>
<td>1.4</td>
<td>第三行内容</td>
</tr>
<tr>
<td>8</td>
<td><strong>-1a4</strong></td>
<td>左侧文件第四行内容，- 表示要删除此行</td>
</tr>
</tbody>
</table>
<p>打文件补丁使用 <code>patch</code> 命令，参数为 <code>-pN</code>，其中 N 为数字，表示取消几层目录的意思。</p>
<p>例如打补丁 c.patch：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ patch <span class="token parameter variable">-p0</span> <span class="token operator">&lt;</span>c.patch <span class="token punctuation">;</span> <span class="token function">cat</span> c.cfg 
patching <span class="token function">file</span> c.cfg
abcaca
/root/etc
<span class="token number">1.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>恢复旧文件内容使用参数 <code>-R -pN</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ patch <span class="token parameter variable">-R</span> <span class="token parameter variable">-p0</span> <span class="token operator">&lt;</span>c.patch <span class="token punctuation">;</span> <span class="token function">cat</span> c.cfg 
patching <span class="token function">file</span> c.cfg
abcaca
/root/etc/
<span class="token number">1.4</span>
1a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以用 <code>diff</code> 来比较目录下的区别。例如比较不同挂载点下的 lost+found 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">diff</span> /root/sdb4m/lost+found/ /ext333/lost+found/
Only <span class="token keyword">in</span> /root/sdb4m/lost+found/: <span class="token number">1</span>
Only <span class="token keyword">in</span> /root/sdb4m/lost+found/: <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>相对于 <code>diff</code> 以行为单位比较，<code>cmp</code> 则是以字节为单位去比较，因此可以比较任何类型的文件。例如还是比较 c.cfg 与 cnew.cfg：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cmp</span> c.cfg cnew.cfg 
c.cfg cnew.cfg differ: byte <span class="token number">17</span>, line <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其结果显示两个文件不同点在第 2 行，第 17 个字节处。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 挂载和卸载设备操作</title>
    <url>/848908018/</url>
    <content><![CDATA[<h1 id="常用设备名"><a class="markdownIt-Anchor" href="#常用设备名"></a> 常用设备名</h1>
<p>设备在 Linux 系统中显示为文件，常见设备以及设备在系统中文件名如下：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在系统内的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/USB 硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U 盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0-7]</td>
</tr>
<tr>
<td>打印机</td>
<td>25 针：/dev/lp[0-2] USB：/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>USB：/dev/usb/mouse[0-15] PS2：/dev/psaux</td>
</tr>
<tr>
<td>当前 CD/DVD ROM</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>当前鼠标</td>
<td>/dev/mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>IDE：/dev/ht0 SCSI：/dev/st0</td>
</tr>
</tbody>
</table>
<h1 id="挂载点"><a class="markdownIt-Anchor" href="#挂载点"></a> 挂载点</h1>
<p>在 Linux 中，挂载是将一个目录作为进入点，将磁盘分区的数据放置在该目录下，进入该目录等同于读取该分区中的内容。进入点的目录被称为挂载点，也就是虚拟目录中用于分配额外存储设备的目录。</p>
<p>例如，磁盘 1 挂载到根目录<code>/</code>，磁盘 2 挂载到<code>/ext333</code>目录，则<code>/ext333</code>目录下的文件最上层目录是<code>/ext333</code>，而不是<code>/</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ext333<span class="token punctuation">]</span>$ <span class="token function">ls</span> <span class="token parameter variable">-lid</span> /ext333/
<span class="token number">2</span> drwxr-xr-x. <span class="token number">3</span> root root <span class="token number">4096</span> Sep  <span class="token number">9</span> <span class="token number">15</span>:37 /ext333/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>ext</code>文件系统最顶层目录的 inode 一般为 2 号，而<code>xfs</code>文件系统最顶层目录的 inode 一般为 128 号。由于同一个文件系统中某个 inode 只会对应一个文件，因此可以通过 inode 号码来确认不同文件名是否为相同文件。</p>
<h1 id="挂载设备"><a class="markdownIt-Anchor" href="#挂载设备"></a> 挂载设备</h1>
<p>硬盘格式化后需要挂载在目录中才能访问，磁盘挂载前需要注意以下事项：</p>
<ul>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中。</li>
<li>单一目录不应该重复挂载多个文件系统。</li>
<li>作为挂载点的目录理论上应该都是空目录。</li>
</ul>
<p>如果用于挂载的目录不为空，则挂载文件系统后，原目录下的内容将暂时无法访问。</p>
<p><code>mount</code>命令可用选项如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a</code></td>
<td>依照配置文件<code>/etc/fstab</code>的数据将所有未挂载的磁盘都挂载上来</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>显示 Label 名称</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>加上文件系统类型来指定欲挂载的类型</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>默认系统会将实时挂载的情况实时写入<code>/etc/mtab</code>中。<code>-n</code>可以取消写入</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>利用文件系统的卷标名来挂载</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>后面接一些挂载时额外加上的参数，比如账号、密码、权限等</td>
</tr>
</tbody>
</table>
<p><code>-o</code>后接的可挂载参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ro</code>/<code>rw</code></td>
<td>挂载为只读或可读写</td>
</tr>
<tr>
<td><code>async</code>/<code>sync</code></td>
<td>修改默认写入方式同步或异步，默认异步</td>
</tr>
<tr>
<td><code>auto</code>/<code>noauto</code></td>
<td>允许此分区被以<code>mount -a</code>自动挂载</td>
</tr>
<tr>
<td><code>dev</code>/<code>nodev</code></td>
<td>是否允许分区上可创建设备文件，<code>dev</code>为允许</td>
</tr>
<tr>
<td><code>suid</code>/<code>nosuid</code></td>
<td>是否允许含有 suid/sgid 的文件格式</td>
</tr>
<tr>
<td><code>exec</code>/<code>noexec</code></td>
<td>是否允许拥有可执行文件</td>
</tr>
<tr>
<td><code>user</code>/<code>nouser</code></td>
<td>是否允许此分区让任何用户执行<code>mount</code>，一般只有<code>root</code>可用<code>mount</code></td>
</tr>
<tr>
<td><code>defaults</code></td>
<td>默认值为<code>rw</code>，<code>suid</code>，<code>dev</code>，<code>exec</code>，<code>auto</code>，<code>nouser</code>，<code>async</code></td>
</tr>
<tr>
<td><code>remount</code></td>
<td>重新挂载，重新更新参数时可以重新挂载</td>
</tr>
</tbody>
</table>
<p>例如将<code>/dev/sdb4</code>挂载到<code>/root/sdb4m</code>文件夹上：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> /dev/sdb4 /root/sdb4m/
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">df</span>
Filesystem              1K-blocks    Used Available Use% Mounted on
/dev/sda1                 <span class="token number">1038336</span>  <span class="token number">190536</span>    <span class="token number">847800</span>  <span class="token number">19</span>% /boot
tmpfs                      <span class="token number">386128</span>       <span class="token number">0</span>    <span class="token number">386128</span>   <span class="token number">0</span>% /run/user/0
/dev/sdb4                   <span class="token number">92580</span>     <span class="token number">332</span>     <span class="token number">87128</span>   <span class="token number">1</span>% /root/sdb4m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看挂载情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">grep</span> sdb
/dev/sdb4 on /root/sdb4m <span class="token builtin class-name">type</span> ext3 <span class="token punctuation">(</span>rw,relatime,seclabel,data<span class="token operator">=</span>ordered<span class="token punctuation">)</span> <span class="token punctuation">[</span>boss<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="重新挂载"><a class="markdownIt-Anchor" href="#重新挂载"></a> 重新挂载</h1>
<p>如果进入维护模式，根目录以只读状态挂载的，可以使用重挂载功能将其挂载成可读写：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-o</span> remount,rw,auto /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="卸载设备"><a class="markdownIt-Anchor" href="#卸载设备"></a> 卸载设备</h1>
<p>有些设备例如 CD 光驱，必须卸载了才能退出来。可以使用<code>umount</code>来卸载设备。</p>
<p>使用<code>-f</code>参数强制卸载，例如卸载硬盘<code>sdb4</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">umount</span> <span class="token parameter variable">-f</span> /root/sdb4m/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果加入<code>-f</code>卸载不掉还可以使用<code>-l</code>参数试试。</p>
<h1 id="开机挂载"><a class="markdownIt-Anchor" href="#开机挂载"></a> 开机挂载</h1>
<p>开机配置文件<code>/etc/fstab</code>实际上将挂载记录到<code>/etc/mtab</code>与<code>/proc/mounts</code>这两个文件中。</p>
<p>系统挂载的限制如下：</p>
<ul>
<li>根目录 <code>/</code> 必须挂载，并且必须先于其他挂载点进行挂载。</li>
<li>挂载点必须为已存在的目录。</li>
<li>每个挂载点在同一时间内，只能挂载一次。</li>
<li>每个分区在同一时间内，只能挂载一次。</li>
<li>若要进行卸载，必须先将工作目录移到挂载点之外。</li>
</ul>
<p>查看 <code>/etc/fstab</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/fstab
/dev/mapper/centos-root /                       xfs     defaults        <span class="token number">0</span> <span class="token number">0</span>
/dev/mapper/centos-swap swap                    swap    defaults        <span class="token number">0</span> <span class="token number">0</span>
        ^                ^                       ^         ^            ^ ^
      设备名            挂载点                  文件系统   挂载参数       备份 扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以第一条为例从左到右分别为:</p>
<ul>
<li>第一列：需要挂载的设备名、Label 或 UUID。</li>
<li>第二列：挂载点（必须是目录）。</li>
<li>第三列：文件系统类型。</li>
<li>第四列：挂载参数，如 <code>defaults</code>、<code>rw</code>、<code>ro</code>、<code>noauto</code> 等。这里的默认值等于 <code>mount -o default</code> 时用的值。</li>
<li>第五列：是否需要使用 dump 命令备份，<code>0</code> 代表不需要备份，<code>1</code> 表示每天需要备份。</li>
<li>第六列：用 <code>fsck</code> 检查文件系统顺序，<code>0</code> 表示不需要检查，<code>1</code> 代表在根文件系统 <code>/</code> 之前检查，<code>2</code> 代表在其他文件系统之后检查。</li>
</ul>
<p>其实<code>/etc/fstab</code>（file system table）就是将我们利用<code>mount</code>命令挂载时所用到的参数写入到了文件。</p>
<p>例如，要在 <code>/dev/sdb4</code> 开机自动挂载到 <code>/root/sdb4m</code> 目录下，可以在 <code>/etc/fstab</code> 中添加一行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> /etc/fstab
/dev/mapper/centos-root /                       xfs     defaults        <span class="token number">0</span> <span class="token number">0</span>
/dev/mapper/centos-swap swap                    swap    defaults        <span class="token number">0</span> <span class="token number">0</span>
/dev/sdb4 /root/sdb4m                           ext3    defaults        <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后用 <code>mount -a</code> 命令更新挂载状态:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-a</span> <span class="token punctuation">;</span> <span class="token function">df</span> <span class="token operator">|</span> <span class="token function">grep</span> sdb
/dev/sdb4                   <span class="token number">92580</span>     <span class="token number">332</span>     <span class="token number">87128</span>   <span class="token number">1</span>% /root/sdb4m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看到硬盘已经挂载成功了。当系统重启时，<code>/dev/sdb4</code> 就会自动挂载到 <code>/root/sdb4m</code> 目录下了。</p>
<h1 id="特殊设备挂载"><a class="markdownIt-Anchor" href="#特殊设备挂载"></a> 特殊设备挂载</h1>
<p>意思为直接挂载存在硬盘中的镜像文件。也可以挂载大文件，作为虚拟磁盘使用。</p>
<p>例如挂载<code>/root/TinyCore-current.iso</code>到<code>/mnt/tinycore_iso</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-o</span> loop /root/TinyCore-current.iso /mnt/tinycore_iso/
mount: /dev/loop0 is write-protected, mounting read-only
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token operator">|</span> <span class="token function">grep</span> loop
/dev/loop0                  <span class="token number">20348</span>   <span class="token number">20348</span>         <span class="token number">0</span> <span class="token number">100</span>% /mnt/tinycore_iso<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 CentOS 7 中可以省略<code>-o loop</code>参数。</p>
<h1 id="挂载内存盘"><a class="markdownIt-Anchor" href="#挂载内存盘"></a> 挂载内存盘</h1>
<p>所谓内存盘就是将一部分内存当作文件系统挂载起来，不过关机或卸载里面的资料会完全丢失。</p>
<p>在挂载时使用<code>-t ramfs none</code>参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token parameter variable">-t</span> ramfs none /root/ram
<span class="token punctuation">[</span>root@server1 ~<span class="token punctuation">]</span>$ <span class="token function">df</span> <span class="token parameter variable">-ha</span>
Filesystem               Size  Used Avail Use% Mounted on
none                        <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>    - /root/ram<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 用户配置与环境变量</title>
    <url>/1849958032/</url>
    <content><![CDATA[<h1 id="配置登录与欢迎信息"><a class="markdownIt-Anchor" href="#配置登录与欢迎信息"></a> 配置登录与欢迎信息</h1>
<p>通过终端 tty（teletypewriter）登录后的显示信息在 <code>/etc/issue</code> 配置，telnet 的在 <code>/etc/issue.net</code>，通告在 <code>/etc/motd</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/issue
<span class="token punctuation">\</span>S
Kernel <span class="token punctuation">\</span>r on an <span class="token punctuation">\</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以使用反斜杠调用变量，自定义显示登录后显示信息。</p>
<h1 id="bash-环境变量配置文件"><a class="markdownIt-Anchor" href="#bash-环境变量配置文件"></a> Bash 环境变量配置文件</h1>
<p>为了让自定义变量和别名在登录时便已准备好，可以将它们写入到配置文件。</p>
<p>交互式 shell 有两种类型：</p>
<ul>
<li>
<p>登录 shell（<strong>login shell</strong>）</p>
<p>取得 bash 时需要完整登录流程，比如通过 ssh 登录，通过 <code>su -l</code> 命令切换用户。</p>
</li>
<li>
<p>非登录 shell（<strong>non-login shell</strong>）</p>
<p>取得 bash 接口的方法不需要重复登录，也叫做交互式 shell。比如在原本的 bash 环境下再执行的 bash，或使用 <code>su</code> 命令直接切换用户。</p>
</li>
</ul>
<p>还有一种 shell 是非交互式 shell，系统执行 shell 脚本时用的就是这种 shell。可以通过 BASH_ENV 环境变量来设置一些初始值。</p>
<h2 id="login-shell"><a class="markdownIt-Anchor" href="#login-shell"></a> login shell</h2>
<p>下面两个文件只有 login shell 能读取：</p>
<ul>
<li>
<p><strong>/etc/profile</strong></p>
<p>保存着系统整体的设置，对所有用户都有效。设置的主要变量有：</p>
<ul>
<li>PATH：依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；</li>
<li>MAIL：依据账号设置好用户的 mailbox 到 /var/spool/mail/账号名；</li>
<li>USER：根据用户的账号设置此变量内容；</li>
<li>HOSTNAME：依据主机的 hostname 命令决定此变量内容；</li>
<li>HISTSIZE：历史命令记录条数；</li>
<li>调用 /etc/profile.d/*.sh 中的脚本，里面存放了比如 ll 与 ls 命令的别名，颜色配置等；</li>
<li>调用 /etc/locale.conf 来决定 bash 使用的语言；</li>
<li>调用 /usr/share/bash-completion/completions/* 下面和参数补齐有关的脚本。</li>
</ul>
<p>不建议修改这个文件，因为此文件内容会随着系统更新而自动更新。</p>
</li>
<li>
<p><strong>~/.bash_profile</strong>（或 bash_login，profile）</p>
<p>保存着用户的个人设置。默认设置有：</p>
<ul>
<li>PATH：定义了用户主文件夹 ~/bin/ 为额外的执行文件放置目录，并且设为了环境变量；</li>
<li>调用 ~/.bashrc 的设置内容，一般个性化配置写在 .bashrc 中。</li>
</ul>
</li>
</ul>
<p>一般来说，上两文件中适合记录：</p>
<ul>
<li>创建或修改环境变量的命令，例如 PATH 变量，umask 设置等。</li>
<li>执行所有一次性操作的命令。</li>
</ul>
<h2 id="non-login-shell"><a class="markdownIt-Anchor" href="#non-login-shell"></a> non-login shell</h2>
<p>non-login shell 仅会读取 ~/.bashrc 文件：</p>
<ul>
<li>
<p><strong>~/.bashrc</strong></p>
<p>以 rc 结尾的隐藏配置文件，代表 run commands，也就是特定程序每次启动时自动运行的命令。bashrc 会调用 /etc/bashrc 这个文件，主要根据不同 UID 规定了 umask 值，PS1 变量。</p>
</li>
</ul>
<p>其他一些配置文件：</p>
<ul>
<li>
<p><strong>~/.bash_history</strong></p>
<p>记录历史命令。记录的数量与 HISTSIZE 变量有关。</p>
</li>
<li>
<p><strong>~/.bash_logout</strong></p>
<p>记录当注销 Bash 后进行的操作，可以自己加入一些命令（如清空 /tmp）在其中。</p>
</li>
</ul>
<h1 id="读入环境配置文件"><a class="markdownIt-Anchor" href="#读入环境配置文件"></a> 读入环境配置文件</h1>
<p>通常修改了 .bashrc 文件配置后，需要注销登录才会生效。也可以利用 source 命令让配置文件立即生效。</p>
<p>例如让 /etc/profile 配置文件立马生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用小数点（.）也可以达到同样效果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">.</span> ~/.bash_profile <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>利用这个特性，可以将多个配置文件定义不同环境变量，需要切换时用 source 运行使其立刻生效。</p>
<h1 id="终端机和环境设置"><a class="markdownIt-Anchor" href="#终端机和环境设置"></a> 终端机和环境设置</h1>
<p>我们可以使用 <code>stty</code> 命令来设置终端机的输入按键代表意义。</p>
<p>首先，查看所有可设置参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ stty <span class="token parameter variable">-a</span>
speed <span class="token number">38400</span> baud<span class="token punctuation">;</span> rows <span class="token number">20</span><span class="token punctuation">;</span> columns <span class="token number">107</span><span class="token punctuation">;</span> line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
intr <span class="token operator">=</span> ^C<span class="token punctuation">;</span> quit <span class="token operator">=</span> ^<span class="token punctuation">\</span><span class="token punctuation">;</span> erase <span class="token operator">=</span> ^?<span class="token punctuation">;</span> <span class="token function">kill</span> <span class="token operator">=</span> ^U<span class="token punctuation">;</span> eof <span class="token operator">=</span> ^D<span class="token punctuation">;</span> eol <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span> eol2 <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span> swtch <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span>
start <span class="token operator">=</span> ^Q<span class="token punctuation">;</span> stop <span class="token operator">=</span> ^S<span class="token punctuation">;</span> susp <span class="token operator">=</span> ^Z<span class="token punctuation">;</span> rprnt <span class="token operator">=</span> ^R<span class="token punctuation">;</span> werase <span class="token operator">=</span> ^W<span class="token punctuation">;</span> lnext <span class="token operator">=</span> ^V<span class="token punctuation">;</span> flush <span class="token operator">=</span> ^O<span class="token punctuation">;</span> min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token function">time</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token parameter variable">-parenb</span> <span class="token parameter variable">-parodd</span> <span class="token parameter variable">-cmspar</span> cs8 <span class="token parameter variable">-hupcl</span> <span class="token parameter variable">-cstopb</span> cread <span class="token parameter variable">-clocal</span> <span class="token parameter variable">-crtscts</span>
<span class="token parameter variable">-ignbrk</span> <span class="token parameter variable">-brkint</span> <span class="token parameter variable">-ignpar</span> <span class="token parameter variable">-parmrk</span> <span class="token parameter variable">-inpck</span> <span class="token parameter variable">-istrip</span> <span class="token parameter variable">-inlcr</span> <span class="token parameter variable">-igncr</span> icrnl ixon <span class="token parameter variable">-ixoff</span> <span class="token parameter variable">-iuclc</span> <span class="token parameter variable">-ixany</span> <span class="token parameter variable">-imaxbel</span> <span class="token parameter variable">-iutf8</span>
opost <span class="token parameter variable">-olcuc</span> <span class="token parameter variable">-ocrnl</span> onlcr <span class="token parameter variable">-onocr</span> <span class="token parameter variable">-onlret</span> <span class="token parameter variable">-ofill</span> <span class="token parameter variable">-ofdel</span> nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten <span class="token builtin class-name">echo</span> echoe echok <span class="token parameter variable">-echonl</span> <span class="token parameter variable">-noflsh</span> <span class="token parameter variable">-xcase</span> <span class="token parameter variable">-tostop</span> <span class="token parameter variable">-echoprt</span> echoctl echoke<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，有几个比较重要的设置如下：</p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>eof</td>
<td>end of file 代表文件结束，输入终止。</td>
</tr>
<tr>
<td>erase</td>
<td>向后删除字符。</td>
</tr>
<tr>
<td>intr</td>
<td>向当前正在运行的程序发送一个中断信号（interrupt）。</td>
</tr>
<tr>
<td>kill</td>
<td>删除当前命令行上的所有文字。</td>
</tr>
<tr>
<td>quit</td>
<td>向当前正在运行的进程发送一个 quit 信号。</td>
</tr>
<tr>
<td>start</td>
<td>重新启动当前屏幕的输出显示。</td>
</tr>
<tr>
<td>stop</td>
<td>停止当前屏幕的输出显示。</td>
</tr>
<tr>
<td>susp</td>
<td>向正在运行的进程发送一个 terminal stop 信号。</td>
</tr>
</tbody>
</table>
<p><code>^</code> 代表 Ctrl 键，我们可以自定义按键。例如，将删除字符的组合键设置为 Ctrl+9：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ stty erase ^9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>除了 <code>stty</code>，还有 <code>set</code> 命令可以设置一些终端机设置值。我们可以使用 <code>set -o</code> 来查询可用选项：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server3 ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span>
allexport       off
braceexpand     on
emacs           on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>1.基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>Awk 命令简单用法</title>
    <url>/1712308461/</url>
    <content><![CDATA[<h1 id="命令语法"><a class="markdownIt-Anchor" href="#命令语法"></a> 命令语法</h1>
<p>awk 用于处理每一行的字段内的数据，默认字段的分隔符为空格或 <code>[Tab]</code>。</p>
<p>awk 的命令语法如下：</p>
<p><code>awk '条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...' 文件名</code></p>
<p>awk 后面接两个单引号 ‘’ 并加上大括号 {} 来设置想要对数据进行的处理操作。</p>
<p><code>$0</code> 代表整个输入行，<code>$n</code> 表示第 n 个字段。在应用脚本之前，awk 会先拆分输入记录。</p>
<p>每次从一个或多个文件中读入一行或从标准输入中读入一行，指令包含在小括号对中。</p>
<p>awk 将每个输入行解释为一条记录，行中的每个单词由空格或制表符分割解释为一个字段。</p>
<h1 id="awk-处理流程"><a class="markdownIt-Anchor" href="#awk-处理流程"></a> awk 处理流程</h1>
<p>整个 <code>awk</code> 的处理流程是：</p>
<ol>
<li>读入第一行，并将第一行的数据填入 <code>$0</code>, <code>$1</code>, <code>$2</code> 等变量中；</li>
<li>依据条件类型的限制，判断是否需要进行后面的动作；</li>
<li>完成所有动作与条件类型；</li>
<li>重复以上流程步骤，直到所有数据读完为止。</li>
</ol>
<h1 id="awk-内置变量"><a class="markdownIt-Anchor" href="#awk-内置变量"></a> awk 内置变量</h1>
<p><code>awk</code> 常用的内置变量如下表：</p>
<table>
<thead>
<tr>
<th><strong>变量名</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>NF</td>
<td>每一行(<code>$0</code>)拥有的字段总数(列数)</td>
</tr>
<tr>
<td>NR</td>
<td>目前 <code>awk</code> 所正在处理数据的行号</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔字符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>FIELDWIDTHS</td>
<td>定义分割数据字段依据的宽度</td>
</tr>
</tbody>
</table>
<h1 id="格式化打印"><a class="markdownIt-Anchor" href="#格式化打印"></a> 格式化打印</h1>
<p><code>printf</code> 可以帮我们将数据输出的结果格式化，并且支持一些特殊字符。</p>
<p>命令格式：</p>
<p><code>printf '打印样式' 实际内容</code></p>
<p>特殊样式：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>样式</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警告声音；</td>
</tr>
<tr>
<td>\b</td>
<td>退格键；</td>
</tr>
<tr>
<td>\f</td>
<td>清除屏幕；</td>
</tr>
<tr>
<td>\n</td>
<td>输出到新一行；</td>
</tr>
<tr>
<td>\r</td>
<td>回车键；</td>
</tr>
<tr>
<td>\t</td>
<td>水平 [tab] 按键；</td>
</tr>
<tr>
<td>\v</td>
<td>垂直 [tab] 按键；</td>
</tr>
<tr>
<td>\xNN</td>
<td>NN 为两位数的数字，可以转为字符；</td>
</tr>
<tr>
<td>%ns</td>
<td>n 为数字，s 表示字符串数量；</td>
</tr>
<tr>
<td>%ni</td>
<td>n 为数字，i 表示整数位数；</td>
</tr>
<tr>
<td>%<a href="http://N.nf">N.nf</a></td>
<td>n 与 N 为数字，f 代表多少位小数；</td>
</tr>
</tbody>
</table>
<h1 id="分割数据"><a class="markdownIt-Anchor" href="#分割数据"></a> 分割数据</h1>
<p>例如取出 <code>last</code> 命令结果中用户名（第一列）与登录 IP（第三列）地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ last <span class="token parameter variable">-n</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $1 "--" $3&#125;'</span>
root--Sat
root--192.168.2.101
root--192.168.2.101
root--192.168.2.101
root--192.168.2.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>print</code> 将结果打印出来是 <code>awk</code> 最常用功能。</p>
<p>将内置变量打印出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ last <span class="token parameter variable">-n</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $1 "  lines:" NR "   columes:" NF&#125;'</span>
root  lines:1   columes:9
root  lines:2   columes:10
root  lines:3   columes:10
root  lines:4   columes:10
root  lines:5   columes:10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>awk</code> 可以使用逻辑运算符来写判断条件。例如查找 UID 小于 10 的用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cat</span> b.cfg <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'BEGIN &#123;FS=":"&#125; $3&lt;10&#123;print $1 "\t" $3&#125;'</span>
root    <span class="token number">0</span>
bin     <span class="token number">1</span>
daemon  <span class="token number">2</span>
adm     <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>命令由两个组成，前面一个命令定义了分隔符 <code>FS</code> 的值为：（也可以使用 <code>-F</code> 参数），同时使用 <code>BEGIN</code> 这个关键字，预先设置 <code>awk</code> 的变量。第二部分做逻辑判断 <code>$3</code> 小于 10 的才运行后面 <code>print</code> 命令。</p>
<p>同时使用 <code>FS</code> 和 <code>OFS</code> 格式化输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">awk</span> <span class="token string">'BEGIN&#123;FS=","; OFS="--"&#125; &#123;print $1,$2&#125;'</span> user.csv 
user6--user6
user7--user7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>自定义按字符数来分割：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">awk</span> <span class="token string">'BEGIN&#123;FIELDWIDTHS="5 1"&#125; &#123;print $1,$2,$0&#125;'</span> user.csv 
user6 , user6,user6
user7 , user7,user7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果数据是多行形式，可以指定分隔符为 <code>\n</code>，以空行为界定新记录的分隔符：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@server1 bin<span class="token punctuation">]</span>$ <span class="token function">awk</span> <span class="token string">'BEGIN&#123;FS="\n"; RS=""&#125; &#123;print $0 $2&#125;'</span> user.csv 
user6,user6
<span class="token number">403403</span>
user7,user7
<span class="token number">404404</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>awk</code> 还可以使用正则表达式来进行模式匹配。例如只显示 <code>$1</code> 含有 <code>root</code> 字符串的用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">cat</span> b.cfg <span class="token operator">|</span> <span class="token function">awk</span> -F: <span class="token string">'/root/&#123;print $1 "\t" $3&#125;'</span>
root    <span class="token number">0</span>
operator        <span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 工具基本使用</title>
    <url>/17877528/</url>
    <content><![CDATA[<h1 id="vim-基础知识"><a class="markdownIt-Anchor" href="#vim-基础知识"></a> Vim 基础知识</h1>
<p>Vim（Vi IMproved）是一款强大的文本编辑器，是 Linux 和其他类 Unix 系统中最常用的编辑器之一。它不仅支持简单的文本编辑，还有许多高级功能，例如自动完成、宏录制、拼写检查和代码高亮等。Vim 是一个模式化编辑器，有多种不同的模式，其中最常用的是命令模式、插入模式和可视模式。</p>
<h2 id="vim-模式"><a class="markdownIt-Anchor" href="#vim-模式"></a> Vim 模式</h2>
<p>vi 分为三种模式，一般模式、编辑模式与命令行模式：</p>
<ul>
<li>
<p>一般指令模式（Command Mode）</p>
<p>用 vi 打开一个文件就进入一般模式，可以使用方向键来移动光标，删除，复制与粘贴。</p>
</li>
<li>
<p>编辑模式（Insert Mode）</p>
<p>在一般模式中，按下 “i o a r” 任何一个按键之后才会进入编辑模式，左下角会显示 INSERT 或 REPLACE 等字样。按 Esc 键可以返回一般模式。</p>
</li>
<li>
<p>命令行模式（Command-line Mode）</p>
<p>在一般模式下，输入 “: / ?” 三个中的任何一个按键，可以将光标移动到最下面一行，在此模式可以查找数据，读取保存，大量替换等操作。</p>
</li>
</ul>
<h2 id="界面介绍"><a class="markdownIt-Anchor" href="#界面介绍"></a> 界面介绍</h2>
<p>使用 <code>vi</code> 打开一个已存在的文件后，显示如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vi</span> anaconda-ks.cfg 
<span class="token comment">#version=DEVEL</span>
<span class="token comment"># System authorization information</span>
auth <span class="token parameter variable">--enableshadow</span> <span class="token parameter variable">--passalgo</span><span class="token operator">=</span>sha512
<span class="token comment"># Use CDROM installation media</span>
cdrom
<span class="token comment"># Use graphical install</span>
graphical
<span class="token comment"># Run the Setup Agent on first boot</span>
<span class="token string">"anaconda-ks.cfg"</span> 48L, 1260C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最下面一行分别展示了：</p>
<ul>
<li>“anaconda-ks.cfg”：文件名；</li>
<li>48L：文件有 48 行；</li>
<li>1260C：文件有 1260 个字符，也就是 1260B 大小。</li>
</ul>
<p>按下 <code>i</code> 键后，进入到编辑模式，最左下角显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-- INSERT --<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时可以自由输入文字。按下 <code>Esc</code> 键退回到一般模式，再输入 <code>:wq</code> 按回车可以保存并离开 <code>vi</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">:wq
<span class="token string">"anaconda-ks.cfg"</span> 48L, 1260C written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果文件权限只读，可以使用 <code>:wq!</code> 来强制写入。</p>
<h2 id="恢复功能"><a class="markdownIt-Anchor" href="#恢复功能"></a> 恢复功能</h2>
<p>恢复功能是指，当因为某些原因导致死机的情况下，能通过一些方法将之前未保存的数据找回来。</p>
<p>在使用 <code>vim</code> 编辑文件时，<code>vim</code> 会在被编辑文件同目录下新建一个名为 <code>.filename.swp</code> 的交换文件。每当键入 200 个字符或有 4 秒没有键入内容时，交换文件都会自动地更新。</p>
<p>例如用 <code>vi</code> 新建打开一个文件，在命令模式下按 <code>Ctrl+z</code> 中断，再查看 <code>.swp</code> 文件内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">vi</span> <span class="token number">1</span>.txt
a
b
~

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">vi</span> <span class="token number">1</span>.txt
<span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">cat</span> .1.txt.swp 
U3210<span class="token comment">#"! Utpad???</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 <code>swp</code> 实时保存了我们输入的内容。</p>
<p>再次打开文件时，会提示有 <code>swp</code> 临时文件存在：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">vim</span> <span class="token number">1</span>.txt 

E325: ATTENTION
Found a swap <span class="token function">file</span> by the name <span class="token string">".1.txt.swp"</span>
          owned by: root   dated: Sat Sep <span class="token number">11</span> 03:44:17 <span class="token number">2021</span>
         <span class="token function">file</span> name: ~root/4/1.txt
          modified: YES
         user name: root   <span class="token function">host</span> name: 101c7
        process ID: <span class="token number">87510</span> <span class="token punctuation">(</span>still running<span class="token punctuation">)</span>
While opening <span class="token function">file</span> <span class="token string">"1.txt"</span>
             dated: Sat Sep <span class="token number">11</span> 03:44:11 <span class="token number">2021</span>

<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Another program may be editing the same file.  If this is the case,
    be careful not to end up with two different instances of the same
    <span class="token function">file</span> when making changes.  Quit, or <span class="token builtin class-name">continue</span> with caution.
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> An edit session <span class="token keyword">for</span> this <span class="token function">file</span> crashed.
    If this is the case, use <span class="token string">":recover"</span> or <span class="token string">"vim -r 1.txt"</span>
    to recover the changes <span class="token punctuation">(</span>see <span class="token string">":help recovery"</span><span class="token punctuation">)</span>.
    If you did this already, delete the swap <span class="token function">file</span> <span class="token string">".1.txt.swp"</span>
    to avoid this message.

Swap <span class="token function">file</span> <span class="token string">".1.txt.swp"</span> already exists<span class="token operator">!</span>
<span class="token punctuation">[</span>O<span class="token punctuation">]</span>pen Read-Only, <span class="token punctuation">(</span>E<span class="token punctuation">)</span>dit anyway, <span class="token punctuation">(</span>R<span class="token punctuation">)</span>ecover, <span class="token punctuation">(</span>Q<span class="token punctuation">)</span>uit, <span class="token punctuation">(</span>A<span class="token punctuation">)</span>bort:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示会说明出现这一情况的两种原因：</p>
<ul>
<li>此文件正被另一个程序所使用；</li>
<li>文件在编辑过程中非正常退出。</li>
</ul>
<p>此时可以选择以哪种模式来打开：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>O</td>
<td>以只读模式打开，显示内容为没有保存的内容；</td>
</tr>
<tr>
<td>E</td>
<td>以正常模式编辑文件，不会载入暂存文件内容；</td>
</tr>
<tr>
<td>R</td>
<td>加载暂存文件内容，恢复之前的作业。修改完毕后需要手动删除 <code>.swp</code> 文件；</td>
</tr>
<tr>
<td>Q</td>
<td>直接退出不进行操作；</td>
</tr>
<tr>
<td>A</td>
<td>等同于 Q，直接退出。</td>
</tr>
</tbody>
</table>
<h2 id="环境设置"><a class="markdownIt-Anchor" href="#环境设置"></a> 环境设置</h2>
<p>在使用 <code>vim</code> 编辑文件时，文件会继承上一次编辑时的状态，比如光标出现在最后一行。这个记录操作文件保存在 <code>~/.viminfo</code> 里面。</p>
<p>在命令模式下用 <code>set</code> 修改的设置值保存在 <code>/etc/vimrc</code> 这个文件中，不建议动它。需要自定义设置可以新建 <code>~/.vimrc</code> 这个文件将希望设置的值写入。</p>
<p>例如设置自动缩进和行号功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vim</span> ~/.vimrc
<span class="token builtin class-name">set</span> nu          <span class="token string">"hanghao
set autoindent  "</span>suojin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>再次打开 <code>vim</code> 即可生效：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">vim</span> ~/.vimrc
  <span class="token number">1</span> <span class="token builtin class-name">set</span> nu          <span class="token string">"hanghao
  2 set autoindent  "</span>suojin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="vim-基本操作"><a class="markdownIt-Anchor" href="#vim-基本操作"></a> Vim 基本操作</h1>
<p>下面记录一些 Vim 的基本操作。</p>
<h2 id="一般模式"><a class="markdownIt-Anchor" href="#一般模式"></a> 一般模式</h2>
<p>光标移动针对的是在一般模式下快速浏览/定位文件。</p>
<h3 id="移动"><a class="markdownIt-Anchor" href="#移动"></a> 移动</h3>
<p>可以使用方向键 <code>←</code> <code>↓</code> <code>↑</code> <code>→</code> 或 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 操作光标左/右/下/上移一个字符。</p>
<p>可使用数字组合，例如 <code>30k</code> 代表光标向上移 30 行。</p>
<h3 id="翻页"><a class="markdownIt-Anchor" href="#翻页"></a> 翻页</h3>
<p>使用快捷键 <code>Ctrl+f</code>/<code>Ctrl+b</code> 来控制屏幕向下/上移动一页，相当于 <code>PageDown</code>/<code>PageUp</code>。</p>
<h3 id="跳转"><a class="markdownIt-Anchor" href="#跳转"></a> 跳转</h3>
<p>输入 <code>nG</code>（n 为数字）将光标移动到第 n 行位置。</p>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<p>使用 <code>x</code>/<code>X</code> 来删除当前光标后/前个字符。</p>
<p>可以使用数字组合，例如 <code>9x</code> 代表删除光标后连续 9 个字符。</p>
<h3 id="剪切"><a class="markdownIt-Anchor" href="#剪切"></a> 剪切</h3>
<p>使用 <code>dd</code> 剪切光标所在行。</p>
<p>可以使用数字组合，例如 <code>9dd</code> 代表向下删除 9 行。</p>
<h3 id="复制"><a class="markdownIt-Anchor" href="#复制"></a> 复制</h3>
<p>使用 <code>yy</code> 复制光标所在行。</p>
<p>可以使用数字组合，例如 <code>9yy</code> 代表复制向下 9 行。</p>
<p>按 <code>v</code> 键进入复制可视模式，在移动光标时高亮显示文本，选择完毕后按 <code>y</code> 复制选择内容。</p>
<h3 id="粘贴"><a class="markdownIt-Anchor" href="#粘贴"></a> 粘贴</h3>
<p>使用 <code>p</code>/<code>P</code> 来将剪贴板数据粘贴到光标下/上一行。</p>
<h3 id="撤销"><a class="markdownIt-Anchor" href="#撤销"></a> 撤销</h3>
<p>使用 <code>u</code> 来撤销上一次操作。</p>
<h3 id="重做"><a class="markdownIt-Anchor" href="#重做"></a> 重做</h3>
<p>使用 <code>Ctrl+r</code> 快捷键来反撤销操作。</p>
<h3 id="块选择模式"><a class="markdownIt-Anchor" href="#块选择模式"></a> 块选择模式</h3>
<p>按下<code>Ctrl+v</code>进入块选择模式，之后用方向键操作光标选择块：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 audit<span class="token punctuation">]</span>$ <span class="token function">vi</span> c.log 
c1  ass
c2  bss
c3  css
~
-- VISUAL BLOCK --  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此模式下按<code>y</code>复制，按<code>d</code>删除。</p>
<h2 id="编辑模式"><a class="markdownIt-Anchor" href="#编辑模式"></a> 编辑模式</h2>
<p>进入编辑模式有两个方式：</p>
<ul>
<li>
<p>按 i：进入到插入模式（Insert Mode）。</p>
</li>
<li>
<p>按 r/R：进入到替换/连续替换模式（Replace Mode）。</p>
</li>
</ul>
<p>在编辑模式中主要执行文本插入和修改操作。</p>
<h2 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h2>
<p>在命令行模式下，可以进行文件读写、保存、退出、搜索、替换等操作，按下冒号(:)即可进入命令行模式。</p>
<h3 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h3>
<p>搜索功能在命令模式下完成：</p>
<ul>
<li>
<p>/word：向下搜索字符串 <code>word</code>。</p>
</li>
<li>
<p>?word：向上搜索字符串 <code>word</code>。</p>
</li>
</ul>
<p>对搜索结果按键 <code>n/N</code> 进行向下/向上跳转。</p>
<h3 id="替换"><a class="markdownIt-Anchor" href="#替换"></a> 替换</h3>
<ul>
<li>
<p>替换表达式：<code>:&#123;作用范围&#125;s/&#123;搜索关键词&#125;/&#123;替换成关键词&#125;/&#123;替换标志&#125;</code></p>
</li>
<li>
<p>作用范围：n1,n2：n1 和 n2 为数字，表示在 n1 和 n2 行之间搜寻关键词并替换。例如在 100 到 200 行之间搜索：<code>100,200s/XS/xs/g</code></p>
<p>1,&amp;s：表示从第 1 行到最后一行。</p>
</li>
<li>
<p>替换标志</p>
<p>g：表示全部替换，否则只会替换找到的第一个结果。</p>
<p>i/I：表示搜索不区分/区分大小写，默认是区分大小写。</p>
<p>c：表示替换前提示确认。</p>
</li>
</ul>
<h3 id="保存"><a class="markdownIt-Anchor" href="#保存"></a> 保存</h3>
<p>:w 直接保存文件。</p>
<p>:w! 强制保存文件，针对某些设为只读权限的文件可以强制写入。</p>
<p>:w file2 另存为当前编辑的文件为<code>file2</code>。</p>
<h3 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h3>
<p>:r file1 读取文件<code>file1</code>，并将内容加到光标所在行后面。</p>
<h3 id="退出"><a class="markdownIt-Anchor" href="#退出"></a> 退出</h3>
<p>:q 直接退出。</p>
<p>:q! 强制退出，针对修改了文件内容不想保存情况下退出。</p>
<p>:wq! 强制保存并退出。</p>
<p><code>ZZ</code> 保存后退出，等同于<code>:wq</code>。</p>
<h3 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h3>
<p>使用 :set all 查看所有配置。使用 :set 查看有更改过的参数。</p>
<ul>
<li>
<p>行号：set nu 设置行号，默认设置 nonu 没有行号。</p>
</li>
<li>
<p>自动缩进：set autoindent 设置自动缩进，默认设置 noautoindent 没有自动缩进。</p>
</li>
<li>
<p>设置备份：set backup 设置自动保存备份文件，默认设置 nobackup 没有备份。</p>
</li>
<li>
<p>语法高亮：syntax on 依据语法来显示不同颜色。默认设置 syntax off。</p>
</li>
<li>
<p>跳转：输入数字 n 直接跳转到第 n 行。</p>
</li>
<li>
<p>显示文件名：f 显示正在编辑的文件名等信息。</p>
</li>
<li>
<p>执行命令：! command 暂时离开 vim 到命令行模式下执行命令并展示结果。</p>
</li>
</ul>
<h3 id="多窗口模式"><a class="markdownIt-Anchor" href="#多窗口模式"></a> 多窗口模式</h3>
<p>在命令模式下输入<code>:sp</code>可对当前文件切割成上下两个窗口显示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">111</span>
<span class="token number">11</span>
<span class="token number">1</span>
~
~
<span class="token number">1</span>.txt                                                                                    <span class="token number">3,1</span>            All
<span class="token number">111</span>
<span class="token number">11</span>
<span class="token number">1</span>
~
<span class="token number">1</span>.txt                                                                                    <span class="token number">1,1</span>            All
:sp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过按键<code>Ctrl+w</code>来切换窗口。</p>
<p>也可以用<code>:sp</code>指定文件名，这样上下窗口分别显示两个不同文件内容。</p>
<h3 id="同时编辑模式"><a class="markdownIt-Anchor" href="#同时编辑模式"></a> 同时编辑模式</h3>
<p>可以同时用<code>vim</code>打开多个文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 <span class="token number">4</span><span class="token punctuation">]</span>$ <span class="token function">vi</span> <span class="token number">1</span>.txt <span class="token number">2</span>.txt
<span class="token number">2</span> files to edit

~
~
<span class="token string">"1.txt"</span> 0L, 0C                                                                           <span class="token number">0,0</span>-1         All<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输入命令<code>:n</code>或<code>:N</code>来编辑下一个或上一个文件。</p>
<p>输入命令<code>:files</code>列出目前打开的所有文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/794273428/</url>
    <content><![CDATA[<h1 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义</h1>
<p>正则表达式是一种处理字符串的方法，以行为单位来进行字符串的处理行为。通过一些特殊符号的辅助，让用户轻松（？）达到查找、删除、替换某特定字符串的处理程序。</p>
<p>基础正则表达式（BRE）和扩展正则表达式（ERE）的区别在于支持的元字符不同：</p>
<ul>
<li><strong>BRE 支持的元字符</strong>：^ $ . * [ ]</li>
<li><strong>ERE 支持的元字符</strong>：^ $ . * [ ] + ( ) { } ? |</li>
</ul>
<h2 id="元字符"><a class="markdownIt-Anchor" href="#元字符"></a> 元字符</h2>
<p>元字符要代表字符串意思时必须用转义字符<code>\</code>转义，把元字符变成普通字符。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>名称</th>
<th>Unicode 值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>句点</td>
<td>U+002E</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>\</td>
<td>反斜线</td>
<td>U+005C</td>
<td>对字符转义</td>
</tr>
<tr>
<td>|</td>
<td>竖线符</td>
<td>U+007C</td>
<td>选择操作（或）</td>
</tr>
<tr>
<td>^</td>
<td>脱字符</td>
<td>U+005E</td>
<td>行起始锚位符</td>
</tr>
<tr>
<td>$</td>
<td>美元符</td>
<td>U+0024</td>
<td>行结束锚位符</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>U+003F</td>
<td>匹配零次或一次的量词</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
<td>U+002A</td>
<td>匹配零次或多次的量词</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
<td>U+002B</td>
<td>匹配一次或多次的量词</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
<td>U+005B</td>
<td>字符组起始</td>
</tr>
<tr>
<td>]</td>
<td>右方括号</td>
<td>U+005D</td>
<td>字符组结束</td>
</tr>
<tr>
<td>{</td>
<td>左花括号</td>
<td>U+007B</td>
<td>量词或代码块起始</td>
</tr>
<tr>
<td>}</td>
<td>右花括号</td>
<td>U+007D</td>
<td>量词或代码块结束</td>
</tr>
<tr>
<td>(</td>
<td>左括号</td>
<td>U+0028</td>
<td>分组起始</td>
</tr>
<tr>
<td>)</td>
<td>右括号</td>
<td>U+0029</td>
<td>分组结束</td>
</tr>
</tbody>
</table>
<p>在字符组内部，某些特殊字符会失去其特殊含义，而只表示字面意义。这些特殊字符包括：</p>
<ul>
<li><code>[</code> 表示字符组的开始。</li>
<li><code>]</code> 表示字符组的结束。</li>
<li><code>-</code> 表示字符组中的范围。</li>
<li><code>^</code> 表示字符组取反。</li>
</ul>
<p>例如在文件内容中查找 1.4：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'1.4'</span> c.cfg 
<span class="token number">1.4</span>
1a4
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'1\.4'</span> c.cfg 
<span class="token number">1.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字符简写式"><a class="markdownIt-Anchor" href="#字符简写式"></a> 字符简写式</h2>
<p>不同类型正则表达式所支持的字符简写式不同，下表用 B、E、P 代表基础、扩展、Perl 的支持状况：</p>
<table>
<thead>
<tr>
<th>字符简写式</th>
<th>描述</th>
<th>支持情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>报警符</td>
<td>P</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，用法等同于单词分界符</td>
<td>B E P</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界，单词中的元素</td>
<td>B E P</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符，等同于 [0-9]</td>
<td>P</td>
</tr>
<tr>
<td>\D</td>
<td>匹配除数字以外的所有字符</td>
<td>P</td>
</tr>
<tr>
<td>\f</td>
<td>换页符，等价于 \x0c 和 \cL</td>
<td>P</td>
</tr>
<tr>
<td>\r</td>
<td>回车符，等价于 \xd 和 \cM</td>
<td>P</td>
</tr>
<tr>
<td>\n</td>
<td>换行符，等价于 \x0a 和 \cJ</td>
<td>P</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格、制表符(\t)、换行符(\n)、回车符(\r)</td>
<td>P</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有文本内容，包括中文，不包含空格。等价于 [^\t\n\r] 或 [^\s]</td>
<td>P</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符，等价于 \x09 和 \cI</td>
<td>P</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符，等价于 \xb 和 \cK</td>
<td>P</td>
</tr>
<tr>
<td>\w</td>
<td>匹配英文字母、数字和下划线，等同于 [a-zA-Z0-9_]</td>
<td>B E P</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非 ASCII 字母字符、非数字以及非下划线字符。等同于 [^A-Za-z0-9_]</td>
<td>B E P</td>
</tr>
<tr>
<td>[\b]</td>
<td>退格字符</td>
<td>P</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符，代码可参考控制字符表</td>
<td>P</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>字符的 Unicode 值，代码可参考控制字符表</td>
<td>P</td>
</tr>
<tr>
<td>\dxxx</td>
<td>字符的十进制值</td>
<td>P</td>
</tr>
<tr>
<td>\oxxx</td>
<td>字符的八进制值</td>
<td>P</td>
</tr>
<tr>
<td>\x xx</td>
<td>字符的十六进制值</td>
<td>P</td>
</tr>
</tbody>
</table>
<h2 id="posix-字符类"><a class="markdownIt-Anchor" href="#posix-字符类"></a> POSIX 字符类</h2>
<p>不同的编码格式下，可能造成正则输出结果不一样，例如 LANG=zh_CN 情况下 a 和 A 的编号是相邻的。</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任何一个字母或数字，等价于 [a-zA-Z0-9]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任何一个字母，等价于 [a-zA-Z]</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格或制表符，等价于 [\t ]</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII 控制字符，ASCII 0 到 31，再加上 ASCII 127</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任何一个数字，等价于 [0-9]</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>和 [:print:] 一样，但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任何一个小写字母，等价于 [a-z]</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任何一个可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不属于 [:alnum:] 也不属于 [:cntrl:] 的任何一个字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>任何一个空白字符，包括空格，等价于 [^\f\n\r\t\v ]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任何一个大写字母，等价于 [A-Z]</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任何一个十六进制数字，等价于 [a-fA-F0-9]</td>
</tr>
</tbody>
</table>
<h2 id="控制字符表"><a class="markdownIt-Anchor" href="#控制字符表"></a> 控制字符表</h2>
<p>对照表如下：</p>
<table>
<thead>
<tr>
<th>控制字符</th>
<th>Unicode 值</th>
<th>简写</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>c@*</td>
<td>U+0000</td>
<td>NUL</td>
<td>空字符</td>
</tr>
<tr>
<td>\cA</td>
<td>U+0001</td>
<td>SOH</td>
<td>标题起始</td>
</tr>
<tr>
<td>\cB</td>
<td>U+0002</td>
<td>STX</td>
<td>文本起始</td>
</tr>
<tr>
<td>\cC</td>
<td>U+0003</td>
<td>ETX</td>
<td>文本结束</td>
</tr>
<tr>
<td>\cD</td>
<td>U+0004</td>
<td>EOT</td>
<td>传输结束</td>
</tr>
<tr>
<td>\cE</td>
<td>U+0005</td>
<td>ENQ</td>
<td>询问</td>
</tr>
<tr>
<td>\cF</td>
<td>U+0006</td>
<td>ACK</td>
<td>确认</td>
</tr>
<tr>
<td>\cG</td>
<td>U+0007</td>
<td>BEL</td>
<td>报警符</td>
</tr>
<tr>
<td>\cH</td>
<td>U+0008</td>
<td>BS</td>
<td>退格符</td>
</tr>
<tr>
<td>\cI</td>
<td>U+0009</td>
<td>HT</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\cJ</td>
<td>U+000A</td>
<td>LF</td>
<td>换行符</td>
</tr>
<tr>
<td>\cK</td>
<td>U+000B</td>
<td>VT</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\cL</td>
<td>U+000C</td>
<td>FF</td>
<td>换页</td>
</tr>
<tr>
<td>\cM</td>
<td>U+000D</td>
<td>CR</td>
<td>回车符</td>
</tr>
<tr>
<td>\cN</td>
<td>U+000E</td>
<td>SO</td>
<td>移出</td>
</tr>
<tr>
<td>\cO</td>
<td>U+000F</td>
<td>SI</td>
<td>移入</td>
</tr>
<tr>
<td>\cP</td>
<td>U+0010</td>
<td>DLE</td>
<td>数据链转义</td>
</tr>
<tr>
<td>\cQ</td>
<td>U+0011</td>
<td>DC1</td>
<td>设备控制符一</td>
</tr>
<tr>
<td>\cR</td>
<td>U+0012</td>
<td>DC2</td>
<td>设备控制符二</td>
</tr>
<tr>
<td>\cS</td>
<td>U+0013</td>
<td>DC3</td>
<td>设备控制符三</td>
</tr>
<tr>
<td>\cT</td>
<td>U+0014</td>
<td>DC4</td>
<td>设备控制符四</td>
</tr>
<tr>
<td>\cU</td>
<td>U+0015</td>
<td>NAK</td>
<td>否定性确认</td>
</tr>
<tr>
<td>\cV</td>
<td>U+0016</td>
<td>SYN</td>
<td>同步空闲</td>
</tr>
<tr>
<td>\cW</td>
<td>U+0017</td>
<td>ETB</td>
<td>传输块结尾</td>
</tr>
<tr>
<td>\cX</td>
<td>U+0018</td>
<td>CAN</td>
<td>取消</td>
</tr>
<tr>
<td>\cY</td>
<td>U+0019</td>
<td>EM</td>
<td>介质结尾</td>
</tr>
<tr>
<td>\cZ</td>
<td>U+001A</td>
<td>SUB</td>
<td>替换</td>
</tr>
<tr>
<td>\c[</td>
<td>U+001B</td>
<td>ESC</td>
<td>转义</td>
</tr>
<tr>
<td>\c\</td>
<td>U+001C</td>
<td>FS</td>
<td>信息分隔符四</td>
</tr>
<tr>
<td>\c]</td>
<td>U+001D</td>
<td>GS</td>
<td>信息分隔符三</td>
</tr>
<tr>
<td>\c^</td>
<td>U+001E</td>
<td>RS</td>
<td>信息分隔符二</td>
</tr>
<tr>
<td>\c_</td>
<td>U+001F</td>
<td>US</td>
<td>信息分隔符一</td>
</tr>
</tbody>
</table>
<h1 id="字符组"><a class="markdownIt-Anchor" href="#字符组"></a> 字符组 <code>[]</code></h1>
<p>中括号<code>[]</code>表示字符组，里面可以列出多个字符或字符范围，用来匹配其中任意一个字符。例如<code>[aeiou]</code>可以匹配任意一个元音字母，<code>[0-9]</code>可以匹配任意一个数字字符。还可以用<code>[^...]</code>的形式表示反向字符组，匹配除了括号内列出的字符以外的任意一个字符。</p>
<h2 id="字符组范围-"><a class="markdownIt-Anchor" href="#字符组范围-"></a> 字符组范围 <code>[ - ]</code></h2>
<p>在字符组内部连字符 <code>-</code> 表示一个范围，<strong>只有在字符组内部才是元字符</strong>，因此 <code>-</code> 不需要转义。</p>
<p>如果 <code>-</code> 是 <code>[]</code> 内第一个字符，表明匹配 <code>-</code> 的本意，而不是作为连接符用。</p>
<p>例如匹配数字和 <code>%</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token string">'[0-9%]'</span> a.cfg 
auth <span class="token parameter variable">--enableshadow</span> <span class="token parameter variable">--passalgo</span><span class="token operator">=</span>sha512
lang en_US.UTF-8
%packages
%end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="排除型字符组"><a class="markdownIt-Anchor" href="#排除型字符组"></a> 排除型字符组 <code>[^]</code></h2>
<p><code>[^ ]</code>列出不希望匹配的字符，比如<code>[^x]</code>表示匹配一个不等于 x 的字符。</p>
<p>并不能匹配空字符。</p>
<h1 id="匹配条件"><a class="markdownIt-Anchor" href="#匹配条件"></a> 匹配条件</h1>
<p>正则表达式中的匹配条件指的是匹配某个模式的限定条件。</p>
<h2 id="匹配任意字符"><a class="markdownIt-Anchor" href="#匹配任意字符"></a> 匹配任意字符 <code>.</code></h2>
<p>元字符点号 <code>.</code> 用来匹配除换行符之外任意一个字符，在<strong>字符组内部</strong>比如 <code>[1.3]</code> 中不是元字符。</p>
<h2 id="匹配任意子表达式"><a class="markdownIt-Anchor" href="#匹配任意子表达式"></a> 匹配任意子表达式 <code>|</code></h2>
<p>要表达或的意思用元字符竖线 <code>|</code>，表达式用小括号 <code>()</code> 括起来。</p>
<p>例如匹配出 <code>pwpolicy</code> 为 <code>root</code> 和 <code>user</code> 和 <code>luks</code> 用户的配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'pwpolicy\s(root|user|luks)'</span> a.cfg 
pwpolicy root <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span>
pwpolicy user <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span>
pwpolicy luks <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="行的起始-和结束"><a class="markdownIt-Anchor" href="#行的起始-和结束"></a> 行的起始 <code>^</code> 和结束 <code>$</code></h2>
<p>脱字符号 <code>^</code> 匹配一行的开始处空字符，美元符号 <code>$</code> 匹配一行的结尾处空字符。</p>
<p>单个 <code>^</code> 匹配所有行。</p>
<p>两个字符一起 <code>^$</code> 匹配空行。</p>
<p>例如去除配置文件中的空行和以 <code>#</code> 开头的注释行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">'^$'</span> a.cfg <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">'^#'</span>
auth <span class="token parameter variable">--enableshadow</span> <span class="token parameter variable">--passalgo</span><span class="token operator">=</span>sha512
cdrom
<span class="token punctuation">[</span>root@101c7 ~<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token parameter variable">-v</span> <span class="token string">'^$|^#'</span> anaconda-ks.cfg <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单词分界符-和"><a class="markdownIt-Anchor" href="#单词分界符-和"></a> 单词分界符 <code>&lt;</code> 和 <code>&gt;</code></h2>
<p><code>\&lt;单a</code> 表示匹配以 “单 a” 开头的单词；</p>
<p><code>尾a\&gt;</code> 表示匹配以 “尾 a” 结束的单词；</p>
<p><code>\&lt;单尾\&gt;</code> 表示匹配完整单词 “单尾”。</p>
<p>例如分别搜索出有以 empty 开头或结尾单词所在行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'\&lt;empty'</span> a.cfg 
pwpolicy user <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span>
<span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'empty\>'</span> a.cfg 
pwpolicy root <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span>
pwpolicy luks <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--notempty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="匹配次数"><a class="markdownIt-Anchor" href="#匹配次数"></a> 匹配次数</h1>
<p>正则表达式中的匹配次数指的是匹配某个模式的次数。</p>
<h2 id="可选项元素"><a class="markdownIt-Anchor" href="#可选项元素"></a> 可选项元素 <code>?</code></h2>
<p>用问号 <code>?</code> 表示可选项，把它加在一个字符后面表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件，它只作用于之前紧邻的元素，<strong>匹配 0 到 1 次</strong>。可使用的语法如下：</p>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>??</code></td>
<td>懒惰匹配零次或一次（可选）</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>懒惰匹配一次或多次</td>
</tr>
<tr>
<td><code>*?</code></td>
<td>懒惰匹配零次或多次</td>
</tr>
<tr>
<td><code>&#123;n&#125;?</code></td>
<td>懒惰匹配 n 次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;?</code></td>
<td>懒惰匹配 n 次或多次</td>
</tr>
<tr>
<td><code>&#123;m,n&#125;?</code></td>
<td>懒惰匹配 m 至 n 次（含 n 次）</td>
</tr>
</tbody>
</table>
<p>例如匹配路径<code>\bin</code>或<code>\sbin</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'\/s?bin:'</span> b.cfg 
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="重复单次-和多次"><a class="markdownIt-Anchor" href="#重复单次-和多次"></a> 重复单次 <code>+</code> 和多次 <code>*</code></h2>
<p>加号 <code>+</code> 表示之前紧邻的元素匹配 1 次到多次。</p>
<p>星号 <code>*</code> 表示之前紧邻的元素匹配 0 到任意次数。</p>
<p>疑问号 <code>?</code>，星号 <code>*</code> 和加号 <code>+</code> 统称为量词，因为它们限定了所作用元素的匹配次数。</p>
<p>疑问号 <code>?</code> 能匹配一个空格，星号 <code>*</code> 能匹配任意多个空格，它们永远不会匹配失败。加号 <code>+</code> 匹配不到会报告失败。</p>
<p>语法如下：</p>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?+</code></td>
<td>占有式匹配零次或一次（可选）</td>
</tr>
<tr>
<td><code>++</code></td>
<td>占有式匹配一次或多次</td>
</tr>
<tr>
<td><code>*+</code></td>
<td>占有式匹配零次或多次</td>
</tr>
<tr>
<td><code>&#123;n&#125;+</code></td>
<td>占有式匹配 n 次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;+</code></td>
<td>占有式匹配 n 次或更多次</td>
</tr>
<tr>
<td><code>&#123;m,n&#125;+</code></td>
<td>占有式匹配 m 至 n 次（含 n 次）</td>
</tr>
</tbody>
</table>
<h2 id="指定匹配次数"><a class="markdownIt-Anchor" href="#指定匹配次数"></a> 指定匹配次数 <code>&#123;&#125;</code></h2>
<p>大括号内接数字，用来限制找到的字符数量。例如查找 3 位数字的 UID：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'[0-9]&#123;3&#125;'</span> b.cfg 
games:x:12:100:games:/usr/games:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以通过 <code>&#123;a,b&#125;</code> 来限定范围，例如查找 6 到 8 位数长的号码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'[0-9]&#123;6,8&#125;'</span> b.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以只写一半区间，例如查找 11 位长度以上的号码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'[0-9]&#123;11,&#125;'</span> b.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组 <code>()</code></h1>
<p>分组功能可用功能在各种编程语言下调用形式不同。</p>
<p>例如查找 id 和 gid 都为 89 或 99 的用户：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'((89|99):)\1'</span> b.cfg 
nobody:x:99:99:Nobody:/:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意分组内容一定是用小括号括起来。</p>
<h2 id="非捕获分组"><a class="markdownIt-Anchor" href="#非捕获分组"></a> 非捕获分组 <code>(?:)</code></h2>
<p>在圆括号内以 <code>?:</code> 开头，这个圆括号内的内容不会被捕获。在 <code>grep</code> 中不可用。</p>
<h2 id="反向引用"><a class="markdownIt-Anchor" href="#反向引用"></a> 反向引用 <code>\</code></h2>
<p>也叫捕获分组或向后引用，匹配与表达式先前部分匹配的同样文本。需要用括号 () 包含分组。</p>
<p>例如查找 “boo” 或 “Roo”：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-E</span> <span class="token string">'(b|R)(o)\2'</span> a.cfg 
<span class="token comment"># Run the Setup Agent on first boot</span>
firstboot <span class="token parameter variable">--enable</span>
network  <span class="token parameter variable">--bootproto</span><span class="token operator">=</span>dhcp <span class="token parameter variable">--device</span><span class="token operator">=</span>ens33 <span class="token parameter variable">--onboot</span><span class="token operator">=</span>off <span class="token parameter variable">--ipv6</span><span class="token operator">=</span>auto --no-activate
<span class="token comment"># Root password</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="正前瞻"><a class="markdownIt-Anchor" href="#正前瞻"></a> 正前瞻 <code>(?=)</code></h2>
<p><code>grep</code> 中用得较少，一般用在编程中排除掉正前瞻内容作为匹配结果处理。例如正则表达式 <code>/bed(?=room)/</code> 只能匹配子串 “bedroom”，而子串 “room” 并不作为匹配结果返回，以进行后续处理。</p>
<p>例如匹配 “nochanges --”，并要求后面接的参数为 “emptyok”：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 sdb4m<span class="token punctuation">]</span>$ <span class="token function">grep</span> <span class="token parameter variable">-P</span> <span class="token string">'nochanges\s\-\-(?=emptyok)'</span> a.cfg 
pwpolicy user <span class="token parameter variable">--minlen</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">--minquality</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--notstrict</span> <span class="token parameter variable">--nochanges</span> <span class="token parameter variable">--emptyok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="反前瞻"><a class="markdownIt-Anchor" href="#反前瞻"></a> 反前瞻 <code>(?!)</code></h2>
<p>匹配后面找不到含有给定前瞻模式的内容。</p>
<h2 id="正后顾"><a class="markdownIt-Anchor" href="#正后顾"></a> 正后顾 <code>(?&lt;=)</code></h2>
<p>正后顾会查看左边的内容，这与正前瞻方向相反。</p>
<h2 id="反后顾"><a class="markdownIt-Anchor" href="#反后顾"></a> 反后顾 <code>(?&lt;!)</code></h2>
<p>反后顾会查看某个模式在从左至右的文本流的后面没有出现。</p>
<h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1>
<p>一些简单常用的例子。</p>
<h2 id="匹配-windows-中空行"><a class="markdownIt-Anchor" href="#匹配-windows-中空行"></a> 匹配 Windows 中空行</h2>
<p>Windows 中空行是由回车+换行（CR+LR）组成，如果单个 <code>\r\n</code> 匹配一行中末尾替换成空字符会把下一行内容拼上来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="匹配-unix-中空行"><a class="markdownIt-Anchor" href="#匹配-unix-中空行"></a> 匹配 UNIX 中空行</h2>
<p>Linux 系统中结尾只有 LR 换行符，两个换行符匹配一条空行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">\</span>n<span class="token punctuation">\</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="匹配-html-标签"><a class="markdownIt-Anchor" href="#匹配-html-标签"></a> 匹配 HTML 标签</h2>
<p>匹配开标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>_a-zA-Z*<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>匹配开/闭标签：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>/?_a-zA-Z*<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表示匹配标签内容，排除标签结束符 <code>&gt;</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>^<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="匹配数字千位"><a class="markdownIt-Anchor" href="#匹配数字千位"></a> 匹配数字千位</h2>
<p>即在每三个数字后面添加一个逗号，例如将 1234567 匹配为 1,234,567。这个正则表达式使用了正向肯定零宽断言和正向零宽断言两个技巧。其中 <code>(?&lt;=\d)</code> 表示匹配前面是数字的位置，<code>(?=(\d\d\d)+$)</code> 表示匹配后面是 3 个数字的倍数并且后面没有其他字符的位置。这样，正则表达式会在满足这两个条件的位置上添加逗号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>?<span class="token operator">&lt;=</span><span class="token punctuation">\</span>d<span class="token punctuation">)</span><span class="token punctuation">(</span>?<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">\</span>d<span class="token punctuation">\</span>d<span class="token punctuation">\</span>d<span class="token punctuation">)</span>+$<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
  <entry>
    <title>脚本范例</title>
    <url>/1256157642/</url>
    <content><![CDATA[<h1 id="输出消息"><a class="markdownIt-Anchor" href="#输出消息"></a> 输出消息</h1>
<p>在 <code>echo</code> 命令使用 <code>-n</code> 参数可以让输出不换行:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">fruite</span><span class="token operator">=</span>orange
<span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">110</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"We have <span class="token variable">$&#123;count&#125;</span> <span class="token variable">$&#123;fruite&#125;</span>s"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"??"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="交互式脚本"><a class="markdownIt-Anchor" href="#交互式脚本"></a> 交互式脚本</h1>
<p>使用 <code>read</code> 来读取用户输入保存到变量中:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-p</span> <span class="token string">"Set Username: "</span> newuser
<span class="token builtin class-name">read</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-p</span> <span class="token string">"Set Password: "</span> newpass
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\n">\n</span> Your user:pass is: <span class="token variable">$newuser</span>:<span class="token variable">$newpass</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要想隐藏用户输入使用 <code>-s</code> 选项。如果 <code>read</code> 命令不指定变量，<code>read</code> 会将收到的数据放进特殊的环境变量 <code>REPLY</code> 中。</p>
<p>指定输入超时时间用 <code>-t</code> 参数，计时器过期后，<code>read</code> 命令会返回一个非零退出状态码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> <span class="token parameter variable">-t</span> <span class="token number">5</span> <span class="token parameter variable">-p</span> <span class="token string">"timeout 5s:"</span> myname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以指定 <code>read</code> 命令统计输入的字符数，并和 <code>case</code> 配合检测用户输入的字符，脚本在用户输入后立即执行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-n1</span> <span class="token parameter variable">-p</span> <span class="token string">"Continue [Y/N]?"</span> answer
<span class="token keyword">case</span> <span class="token variable">$answer</span> <span class="token keyword">in</span>
Y<span class="token operator">|</span>y<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token string">"OK, Le't continue"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
N<span class="token operator">|</span>n<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token string">"Bye."</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token string">"Type Wrong!"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>read</code> 也可以用来读取 <code>.csv</code> 文件（逗号分隔值）内容:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">input</span><span class="token operator">=</span>user.csv
<span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">','</span> <span class="token builtin class-name">read</span> <span class="token parameter variable">-r</span> username password<span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"adding user <span class="token variable">$username</span>"</span>
    <span class="token function">useradd</span> <span class="token variable">$username</span> <span class="token parameter variable">-p</span> <span class="token variable">$password</span>
done<span class="token operator">&lt;</span><span class="token variable">$input</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者使用 <code>cat</code> 显示文件内容后再用管道传给 <code>read</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">cat</span> output.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> da_line<span class="token punctuation">;</span><span class="token keyword">do</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$da_line</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="命令替换"><a class="markdownIt-Anchor" href="#命令替换"></a> 命令替换</h1>
<p>备份时将备份时间自动写入到文件名中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 利用date获取时间,格式为190322</span>
<span class="token assign-left variable">data1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y%m%d<span class="token variable">)</span></span>
<span class="token assign-left variable">filename1</span><span class="token operator">=</span><span class="token string">'sqlbackup'</span>
<span class="token comment"># 使用变量命名文件名</span>
<span class="token function">touch</span> <span class="token string">"<span class="token variable">$filename1</span>-<span class="token variable">$data1</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="文件检测"><a class="markdownIt-Anchor" href="#文件检测"></a> 文件检测</h1>
<p>例如根据用户输入检测文件是否存在，不存在返回 ‘not exist’，存在返回文件类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-rp</span> <span class="token string">"Type filename:"</span> file1
<span class="token builtin class-name">test</span> <span class="token parameter variable">-z</span> <span class="token variable">$file1</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"Type error"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token builtin class-name">test</span> <span class="token parameter variable">-e</span> <span class="token variable">$file1</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">"not exist"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token builtin class-name">test</span> <span class="token parameter variable">-f</span> <span class="token variable">$file1</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$file1</span> is file"</span> 
<span class="token builtin class-name">test</span> <span class="token parameter variable">-d</span> <span class="token variable">$file1</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$file1</span> is dir"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="使用中括号判断"><a class="markdownIt-Anchor" href="#使用中括号判断"></a> 使用中括号判断</h1>
<p>使用 <code>[ ]</code> 判断用户输入是 “yes” 还是 “no”：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">read</span> <span class="token parameter variable">-rp</span> <span class="token string">"Type yes or no: "</span> utype
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$utype</span>"</span> <span class="token operator">==</span> <span class="token string">"yes"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'OK'</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$utype</span>"</span> <span class="token operator">==</span> <span class="token string">"no"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'NO'</span>  <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token builtin class-name">echo</span> <span class="token string">'ERROR'</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>判断用户是否为 root：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token environment constant">$UID</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> Non root user.
<span class="token keyword">else</span>
<span class="token builtin class-name">echo</span> root user.
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="参数变量调用"><a class="markdownIt-Anchor" href="#参数变量调用"></a> 参数变量调用</h1>
<p>写一段脚本将特殊变量输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Script name is: <span class="token variable">$0</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Parameter number is: <span class="token variable">$#</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Whole parameter: <span class="token variable">$@</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Frist parameter: <span class="token variable">$1</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@101c7 bin<span class="token punctuation">]</span>$ <span class="token function">bash</span> sh06.sh op1 ca2
Script name is: sh06.sh
Parameter number is: <span class="token number">2</span>
Whole parameter: op1 ca2
Frist parameter: op1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="if-条件判断"><a class="markdownIt-Anchor" href="#if-条件判断"></a> If 条件判断</h1>
<p>使用 <code>if</code> 判断对输入参数进行检测：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">==</span> <span class="token string">"Hello"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">==</span> <span class="token string">"hello"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"no parameters"</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"only hello allowed"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="case-条件判断"><a class="markdownIt-Anchor" href="#case-条件判断"></a> Case 条件判断</h1>
<p>使用 <code>case</code> 判断脚本参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">case</span> <span class="token variable">$1</span> <span class="token keyword">in</span>
    <span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">""</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"no parameters"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"only hello allowed"</span>
        <span class="token builtin class-name">exit</span> <span class="token number">1</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h1>
<p>简单的函数内参数调用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">function</span> <span class="token function-name function">printype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$1</span> is best"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$2</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    printype <span class="token variable">$2</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    printype <span class="token variable">$1</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"no parameters"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="不定循环"><a class="markdownIt-Anchor" href="#不定循环"></a> 不定循环</h1>
<p>使用 <code>while</code> 结构，当输入 <code>y</code> 或 <code>Y</code> 时才停止脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$yn</span>"</span> <span class="token operator">!=</span> <span class="token string">"y"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$yn</span>"</span> <span class="token operator">!=</span> <span class="token string">"Y"</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"Type y or Y to stop:"</span> yn
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">"you stop it!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>until</code> 结构的循环写法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$yn</span>"</span> <span class="token operator">==</span> <span class="token string">"y"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$yn</span>"</span> <span class="token operator">==</span> <span class="token string">"Y"</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"Type y or Y to stop:"</span> yn
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">"you stop it!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="固定循环"><a class="markdownIt-Anchor" href="#固定循环"></a> 固定循环</h1>
<p>使用 <code>for</code> 来遍历 <code>passwd</code> 中的用户名，并执行 <code>id</code> 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">users</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f1</span> /etc/passwd<span class="token variable">)</span></span>
<span class="token keyword">for</span> <span class="token for-or-select variable">username</span> <span class="token keyword">in</span> <span class="token variable">$users</span>
<span class="token keyword">do</span>
    <span class="token function">id</span> <span class="token variable">$username</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用数字定义循环次数，例如计算 101 到 200 之间奇数乘积：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">200</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span>
<span class="token keyword">do</span>
    <span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$s<span class="token operator">*</span>$i<span class="token variable">))</span></span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$s</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>批量建立用户 <code>user100</code> 到 <code>user110</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">110</span><span class="token punctuation">;</span> a<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token assign-left variable">userpass</span><span class="token operator">=</span><span class="token string">'user'</span><span class="token variable">$a</span>
    /usr/sbin/useradd <span class="token parameter variable">-p</span> <span class="token variable">$userpass</span> <span class="token variable">$userpass</span>
<span class="token keyword">done</span>
/usr/bin/tail <span class="token parameter variable">-10</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>3.脚本编程</category>
      </categories>
  </entry>
</search>
